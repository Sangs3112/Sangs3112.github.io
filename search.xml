<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySQL笔记_6</title>
      <link href="/posts/ce24a37f.html"/>
      <url>/posts/ce24a37f.html</url>
      
        <content type="html"><![CDATA[<h1>语句耗时</h1><ol><li>如果<code>select</code>长时间不返回，使用<code>show processlist</code>查看当前语句处于什么状态<ul><li>比如<code>MDL</code>写锁阻塞了别的<code>session</code>的读</li><li>可以查询是什么<code>session</code>阻塞，但是在<code>MySQL</code>启动时需要设置<code>performance_schema = ON</code>，这样会有<code>10%</code>的性能损失</li></ul></li></ol><ul><li><p><code>sys.schema_table_lock_waits</code>，查询这张表可以找到导致阻塞的<code>processid</code>，<code>kill</code>掉即可</p></li><li><p>还有可能被<code>flush</code>阻塞了，一般<code>flush</code>的两个语句是<code>flush table t with read lock</code>锁表<code>t</code>，<code>flush tables with read lock</code>锁所有的表，本身刷脏页的速度很快，但是可能<code>flush</code>命令被别的<code>session</code>阻塞了</p></li><li><p>或者别的线程占用写锁，那么申请<code>lock in share mode</code>的读锁就会被阻塞。通过查找<code>sys.innodb_lock_waits</code>表即可</p></li><li><p>如果在<code>RR</code>场景下，或者在一个事务中，使用<code>select</code>，如果此时别的<code>session</code>有一个<code>update</code>语句，<code>update</code>了一百万次，那么自己的<code>select</code>语句就会特别慢，因为是一致性读，会存在非常大的<code>undolog</code>需要不断查找，而如果使用<code>select in lock share mode</code>，就是当前读，速度就会很快。</p></li></ul><h1>幻读</h1><ol><li><code>RR</code>下，普通查询是快照读，幻读只有在当前读的环境下才会出现，因为快照读不会看到别人提交的数据。并且，如果别人修改了一行，在当前读的两次查询中，第二次查询才读到，那不是幻读。幻读只有是读到别人新插入的行</li></ol><ul><li><p>幻读会破坏加锁的语义，因为先对d=5的行加锁，在别的<code>session</code>中<code>insert</code>了一条d=5，a=1的行，并修改a=1的行将b改成2，这样的话，也就是修改了d=5的行，破坏了最初对d=5的行加锁的语义</p></li><li><p>幻读 + statement格式的<code>binlog</code>会导致数据不一致性，因为<code>binlog</code>是在<code>commit</code>的时候才会记录，</p></li><li><p>即便给所有的行都加上锁，也无法解决幻读的问题，因为原本不存在的行，无法加锁，所以即便给所有的行都加锁，也没有办法阻止插入新的行</p></li><li><p>所以需要加上间隙锁，在值和值的中间加锁，避免插入新的值</p></li><li><p>解决幻读，需要加行锁和间隙锁(<code>gap lock</code>，开区间)</p></li><li><p>行锁 + 间隙锁 = <code>next-key lock</code> (临键锁，左开右闭)</p></li></ul><h2 id="死锁">死锁</h2><ol><li>如果对不存在的一行加锁，比如id=9，不存在<br><code>select * from t where id = 9 for update</code><ul><li>那么本来应该加行锁+间隙锁，但是因为id=9不存在，所以只会加间隙锁</li></ul></li><li>本来<code>select for update</code>是两个排他锁，但是因为不存在这一行，所以两个<code>session</code>都可以对<code>id=9</code>这一行使用<code>select for update</code>，因为都是间隙锁，所以不会冲突</li><li>此时<code>session B</code>判断不存在这一行，尝试添加<code>id=9</code>的记录，但是因为<code>session A</code>中有间隙锁，所以被阻塞</li><li><code>session A</code>也判断不存在这一行，尝试添加<code>id=9</code>的记录，但是因为<code>session B</code>中存在间隙锁，所以被阻塞，导致死锁</li></ol><ul><li>所以<code>RR</code>会导致死锁，因为只有<code>RR</code>才有间隙锁，一般会设置为<code>RC + row</code>格式的<code>binlog</code>，这样可以解决死锁，并且不会出现数据日志不一致问题</li><li>一般在金融等，或者表备份的时候，才是<code>RR</code></li></ul><h1>加锁</h1><ol><li>加锁的基本单位是<code>next-key lock</code>，前开后闭</li><li>查找中访问的对象才会加锁</li><li>索引上等值查询，唯一索引的时候<code>next-key lock</code> 退化为行锁</li><li>等值查询，最右边的值不满足等值查询的时候，退化为间隙锁</li><li>唯一索引上范围查询会找到不满足条件的第一个值</li></ol><p>现在一张表，字段是<code>id，c, d</code>，<code>c</code>上有普通索引，<code>id</code>是主键</p><ul><li>内含数据<code>(0, 0, 0)(5, 5, 5)(10, 10, 10)(15, 15, 15)(20, 20, 20)(25, 25, 25)</code></li></ul><h2 id="举例1-等值查询间隙锁">举例1 - 等值查询间隙锁</h2><table><thead><tr><th style="text-align:center">sessionA</th><th style="text-align:center">session B</th><th style="text-align:center">session C</th></tr></thead><tbody><tr><td style="text-align:center">begin;</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">update t set d = d + 1 where id = 7;</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">insert into t values(8, 8, 8);</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">update t set d = d + 1 where id = 10;</td></tr></tbody></table><ul><li>对于<code>session A</code>表中没有<code>id=7</code>的行，加锁单位是临键锁，前开后闭，所以范围是<code>(5, 10]</code></li><li>id=7是等值查询，找到最后边的值10，不满足等值条件，所以退化为间隙锁，加锁范围就是<code>(5, 10)</code></li><li><code>session B</code>插入id=8就会被阻塞，但是<code>session C</code>插入id=10不会被锁</li></ul><h2 id="举例2-非唯一索引等值查询">举例2 - 非唯一索引等值查询</h2><table><thead><tr><th style="text-align:center">sessionA</th><th style="text-align:center">session B</th><th style="text-align:center">session C</th></tr></thead><tbody><tr><td style="text-align:center">begin;</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">select id from t where c = 5 lock in share mode;</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">update t set d = d + 1 where id = 5;</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">insert into t values(7, 7, 7);</td></tr></tbody></table><ul><li>加临键锁，对<code>(0, 5]</code></li><li>c是普通索引，所以会访问到右边第一个不满足的值为止，也就是查询到10， 所以<code>(5, 10]</code>加临键锁</li><li>c=5是等值查询，最右边一个值10不满足等值条件，退化为间隙锁<code>(5, 10)</code></li><li>访问到的对象才会加锁，覆盖索引不需要访问主键，所以主键索引不需要加锁，因此<code>session B</code>可以完成，<code>session C</code>插入<code>(7, 7, 7)</code>会被阻塞</li><li><code>lock in share mode</code>只会锁覆盖索引，但是<code>for update</code>会判断你要更新，就会给主键索引上满足条件加行锁</li></ul><h2 id="举例3-主键索引范围查询">举例3 - 主键索引范围查询</h2><table><thead><tr><th style="text-align:center">sessionA</th><th style="text-align:center">session B</th><th style="text-align:center">session C</th></tr></thead><tbody><tr><td style="text-align:center">begin;</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">select * from t where id &gt;= 10 and id &lt; 11 for update;</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">insert into t values(8, 8, 8);</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">insert into t values(13, 13, 13);</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">update t set d = d + 1 where id = 15;</td></tr></tbody></table><ul><li>先找到<code>id = 10</code>，<code>next-key lock (5, 10]</code>，但是唯一索引会退化为行锁</li><li>但是范围查找，找到id=15停止，所以会有临键锁<code>(10, 15]</code></li><li>所以B插入<code>(8, 8, 8)</code>可以通过，插入<code>(13, 13, 13)</code>被阻塞；C更新15也被阻塞</li></ul><h2 id="举例4-非唯一索引范围查询">举例4 - 非唯一索引范围查询</h2><table><thead><tr><th style="text-align:center">sessionA</th><th style="text-align:center">session B</th><th style="text-align:center">session C</th></tr></thead><tbody><tr><td style="text-align:center">begin;</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">select * from t where c &gt;= 10 and c &lt; 11 for update;</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">insert into t values(8, 8, 8);</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">update t set d = d + 1 where c = 15;</td></tr></tbody></table><ul><li>查找c = 10的时候，临键锁<code>(5, 10]</code>，不是唯一索引，不会退化为行锁</li><li><code>session A</code>加上了两个临键锁<code>(5, 10]</code>和<code>(10, 15]</code></li><li>B插入<code>(8, 8, 8)</code>阻塞</li></ul><h2 id="举例5-唯一索引范围查询bug">举例5 - 唯一索引范围查询bug</h2><table><thead><tr><th style="text-align:center">sessionA</th><th style="text-align:center">session B</th><th style="text-align:center">session C</th></tr></thead><tbody><tr><td style="text-align:center">begin;</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">select * from t where id &gt; 10 and id &lt;= 15 for update;</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">update t set d = d + 1 where id = 20;</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">insert into t values(16, 16, 16);</td></tr></tbody></table><ul><li>A是范围查询，索引id加到<code>(10, 15]</code>临键锁，id是唯一索引，所以判断到id=15结束</li><li>但是会访问到第一个不满足条件的值为止，所以会找到id=20，范围查询，所以会加上<code>(15, 20]</code>的临键锁</li><li>因此B更新20会阻塞，C插入16也会阻塞</li></ul><h2 id="举例6-非唯一索引存在等值">举例6 - 非唯一索引存在等值</h2><p>比如同时有两行c=10，分别是<code>(10, 10, 10)</code>，和<code>(30, 10, 30)</code></p><ul><li>非唯一索引上包含主键值，所以不会重复</li></ul><table><thead><tr><th style="text-align:center">sessionA</th><th style="text-align:center">session B</th><th style="text-align:center">session C</th></tr></thead><tbody><tr><td style="text-align:center">begin;</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">delete from t where c = 10;</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">insert into t values(12, 12, 12);</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">update t set d = d + 1 where c = 15;</td></tr></tbody></table><ul><li>A遍历找到第一个c=10的记录，所以临键锁加在<code>(5 5, 10 10]</code>上</li><li>A向右查找，碰到第一个不满足条件的行，也就是<code>15 15</code>停止，等值查询，退化为<code>10 10</code>到<code>15 15</code>的行锁</li><li>所以最后是<code>(5 5, 10 10]</code>临键锁，<code>(10 10, 15 15)</code>行锁，因此B插入12会被阻止，C修改15会通过</li></ul><h2 id="举例7-limit加锁">举例7 - limit加锁</h2><table><thead><tr><th style="text-align:center">sessionA</th><th style="text-align:center">session B</th></tr></thead><tbody><tr><td style="text-align:center">begin;</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">delete from t where c = 10 limit 2;</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">insert into t values(12, 12, 12);</td></tr></tbody></table><ul><li>因为有<code>limit 2</code>，所以遍历到<code>10 30</code>后，就已经满足两条了，循环结束</li><li>A加锁范围就是<code>(5 5, 10 10]</code>临键锁<code>(10 10, 10 30]</code>临键锁</li><li>B插入12通过</li><li>所以删除的时候可以加<code>limit</code>，限制删除的条数，操作更安全。<ul><li>但是唯一索引上删除不需要，因为唯一索引本身就只加行锁</li><li>可能更适合普通索引，但是数据是唯一的情况</li></ul></li></ul><h2 id="举例8-死锁">举例8 - 死锁</h2><table><thead><tr><th style="text-align:center">sessionA</th><th style="text-align:center">session B</th></tr></thead><tbody><tr><td style="text-align:center">begin;</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">select id from t where c = 10 lock in share mode;</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">update t set d = d + 1 where c = 10;</td></tr><tr><td style="text-align:center">insert into t values (8, 8, 8)</td><td style="text-align:center"></td></tr></tbody></table><ul><li>A在c上加了<code>(5, 10]</code>临键锁和<code>(10, 15)</code>间隙锁</li><li>B要在c上加<code>(5, 10]</code>临键锁，所以等待A释放</li><li>A 想插入8，需要加锁，等待B释放，死锁</li><li>最后B回滚</li><li>B的临键锁没有申请成功，但是B加锁<code>(5, 10]</code>先加间隙锁，加锁成功，再加c=10的行锁，阻塞，两段执行</li></ul><h2 id="总结">总结</h2><ul><li>RR才有间隙锁，并且两阶段提交，事务<code>commit</code>了，锁释放</li><li>RC没有间隙锁，并且语句执行完就会释放不满足条件的行的行锁</li><li>RC在外键也会有间隙锁</li></ul><h1>优化</h1><ul><li><code>show variables like '%connections%;查看max_connections</code>，也就是最大连接数，超过最大连接数的就会被阻止，最大连接数不是越大越好。</li></ul><ol><li>处理掉占用连接但是没有工作的线程<ul><li><code>show variables like 'wait_timeout';</code>查看超时时间，超过时间以后就会断开连接</li><li>可以使用<code>kill connection + id</code>，但是这样客户端不会马上知道，只有在发起下一个请求以后才会报错，就变成了<code>MySQL</code>一直都没有恢复，但是再次 调用接口就可以访问了</li></ul></li><li>减少连接消耗<ul><li>用<code>–skip-grant-tables</code>跳过权限验证，但是<strong>风险极高，不建议使用</strong>，找回密码可以用</li><li><strong>8.0版本</strong>如果使用跳过权限验证，会同时<code>--skip-networking</code>打开这个，保证数据库只有本地访问</li></ul></li><li>性能问题导致短链接增加<ul><li>慢查询<ul><li>索引没设计好<ul><li><strong>5.6版本后</strong>可以使用<code>Online DDL</code>创建索引，<code>alert table</code>即可</li><li>如果一主一备，在从库处理，<code>set sql_log_bin=off</code>，不写<code>binlog</code>，加索引</li><li>主备切换</li><li>再在从库<code>set sql_log_bin=off</code>，加索引</li></ul></li><li>语句有问题<ul><li>使用存储过程<code>query_rewrite</code>重写某一个语句</li></ul></li><li>选错索引<ul><li>使用<code>query_rewrite</code>加上索引即可，或者语句加索引</li></ul></li><li>可以在上线前处理好，上线前将<code>slow log</code>打开，<code>long_query_time=0</code>记录查询语句</li><li>测试表模拟线上数据，回归测试</li><li>留意<code>row_examined</code>数据</li><li>全量回归测试可以使用开源工具<code>pt-query-digest</code></li></ul></li><li><code>QPS</code>暴增<ul><li>如果是全新业务有<code>bug</code>，下掉业务，数据库端去除白名单</li><li>新功能是单独数据库用户，删除用户，断开现有连接</li><li>如果和现有业务部署在一起，查询重写功能重写语句，压力最大的<code>SQL</code>直接<code>select 1</code>返回<ul><li>但是会有误伤，如果别的业务也用了这个SQL，或者这个语句还有别的用处，都会导致其他业务失败</li></ul></li></ul></li><li>更新语句</li></ul></li></ol><h1>数据更新</h1><ul><li><p><code>binlog</code>在事务执行时写入<code>binlog cache</code>，事务提交时写入<code>binlog</code>，清空<code>cache</code></p></li><li><p><code>binlog_cache_size</code>控制<code>cache</code>大小，超过大小的暂时写入磁盘</p></li><li><p>多个线程有自己的<code>binlog cache</code>，但是共用一个<code>binlog</code></p></li><li><p><code>write</code>是写入<code>cache</code>，速度快，<code>fsync</code>是写<code>binlog</code>文件，<code>sync_binlog</code>参数控制时机</p><ul><li><code>sync_binlog = 0</code>，每次提交只<code>write</code>，不<code>fsync</code></li><li><code>sync_binlog = 1</code>每次提交都会<code>fsync</code></li><li><code>sync_binlog = N</code>(<code>N &gt; 1</code>)，每次都<code>write</code>，累计<code>N</code>个事务再<code>fsync</code></li><li>IO非常大的话，可以适当调大这个值，<code>100 - 1000</code>，但是如果重启了，就会丢失N条<code>binlog</code>，如果容错率很低，不能设置为1</li></ul></li><li><p><code>redo log</code>三种状态，分别是<code>redo log buffer</code>，<code>write</code>到<code>page cache</code>，没有持久化和<code>fsync</code>到磁盘，<code>innodb_flush_log_at_trx_commit</code>控制</p><ul><li><code>= 0</code> 表示每次都只保存再<code>buffer</code>中</li><li><code>= 1</code> 表示每次提交都持久化到磁盘</li><li><code>= 2</code> 表示每次提交都<code>write</code>到<code>page cache</code></li><li><code>InnoDB</code>后台线程每隔1s都会将<code>redo log buffer</code>中的内容<code>write</code>到<code>pagecache</code>再<code>fsync</code>到磁盘，所有的线程共用一个<code>redo log buffer</code>，与<code>binlog</code>不同，所以没有提交的事务的<code>redo log</code>，也有可能被持久化到磁盘</li><li>同样，如果<code>redo log buffer</code>占用<code>innodb_log_buffer_size</code>即将到达一半，就会触发主动写盘，但是只<code>write</code>，没有<code>fysnc</code></li><li>如果并行事务，并且<code>innodb_flush_log_at_trx_commit=1</code>，那么别的事务提交的时候，会把自己没有提交的<code>redo log</code> 持久化到磁盘</li><li>如果=1，那么<code>prepare</code>阶段就会持久化一次，所以只需要每隔1s的刷盘，崩溃恢复的逻辑，只需要<code>binlog</code>写入磁盘，<code>redo log prepare write</code>了，就不需要<code>fsync</code>了</li><li>如果<code>sync_binlog=1， innodb_flush_log_at_trx_commit=1</code>，那么事务提交前，现需要等两次刷盘，一次是<code>redo log</code>的<code>prepare</code>，一次是<code>binlog</code></li><li>也就是如果<code>MySQL``TPS</code>两万，就会有四万次写磁盘，所以使用了组提交的方法减少写盘。</li></ul></li><li><p>日志逻辑序列号是<code>LSN</code>，单调递增，对应<code>redo log</code>的写入点，写入长度为<code>len</code>，那么<code>LSN + len</code>，可以避免多次重复提交<code>redo log</code></p><ul><li>比如三个事务同时在<code>redo log buffer</code>中，事务1写盘的时候，会带上事务23写盘，这样<code>LSN</code>之前的事务都完成了写盘，只需要看<code>LSN</code>后的事务即可</li><li><code>binlog</code>也是有组提交，但是效果不如<code>redo log</code>，因为<code>redo log</code>时间较短，所以<code>binlog</code>等不到那么多</li></ul></li></ul><ol><li>设置<code>binlog_group_commit_sync_delay</code>和<code>binlog_group_commit_sync_no_delay_count</code>，满足一个即可，减少<code>binlog</code>的写盘次数，故意等待时间，跟<code>sync_binlog</code>不同，<code>sync</code>是没有写盘就<code>commit</code>事务，但是这两个参数是直到写盘了，才<code>commit</code>事务，会增加响应时间，但是不会像<code>sync</code>一样丢数据<ul><li><code>innodb_flush_log_at_trx_commit</code>不建议为0，这样<code>redo log</code>只会在内存中，宕机了会丢数据</li><li><code>innodb_flush_log_at_trx_commit</code>设置成2，性能差不多，只有在主机关机才会丢数据，如果服务宕机，重启以后数据还在</li></ul></li></ol><ul><li><p>binlog不能中断，必须连续写，所以每个线程一个<code>binlog cache</code>，不然主从不一致；<code>redo log</code>甚至可以跟着别的线程一块写，所以都是一个<code>redo log buffer</code></p></li><li><p>所以可以<code>sync_binlog=1,innodb_flush_log_at_trx_commit=2</code>,这样<code>redo log</code>如果丢失了，就通过<code>binlog</code>恢复就可以</p></li><li><p>一般设置非双一，就是<code>innodb_flush_log_at_trx_commit=2</code>、<code>sync_binlog=1000</code></p><ul><li>业务高峰期，会有预案主库改写为非双1</li><li>从库延迟，为了让从库赶上主库，减少<code>binlog</code>生成频率，赶上了可以改回来</li><li>用备份恢复主库的副本，也就是使用<code>binlog</code>的时候</li><li>批量导入数据也可以修改，不然<code>binlog=row</code>产生内容太多</li></ul></li><li><p>主从首先保证了最终一致性，只要主库正确提交，就有<code>binlog</code>，那么从库正常就会重放<code>binlog</code></p></li><li><p>主从延迟就是从库执行完的时间点-主库执行完的时间点</p></li><li><p>从库上执行<code>show slave status</code>，可以看到<code>seconds_behind_master</code>，表示延迟了多少</p></li><li><p>主从延迟最主要是从库消费<code>relay log</code>的速度比主库生成<code>binlog</code>的速度更慢</p></li><li><p>主从延迟来源</p><ul><li>从库性能比主库机器性能差(但是现在一般不会)</li><li>从库压力大，CPU资源占用较多，导致重放<code>relay log</code>速度变慢<ul><li>一主多从，让多个从库分担压力</li><li><code>binlog</code>输出到外部，比如<code>Hadoop</code>，让外部提供查询能力</li></ul></li><li>大事务，比如一个事务再主库上执行了十分钟，就延迟了十分钟</li><li>大表上<code>DDL</code></li></ul></li></ul><h2 id="主从复制">主从复制</h2><ol><li>5.6版本之前，支持单线程，但是会导致应用日志较慢，造成延迟</li><li>多线程就是拆<code>sql thread</code>为多个线程<br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/MySQL/45_sqlthread.png" alt="45_sqlthread"><ul><li>比如<code>coordinator</code>就是原来的<code>sql thread</code>，但是不更新了，只是负责读中转日志，并分发日志，<code>work</code>线程才更新日志，<code>worker</code>线程个数根据<code>slave_parallel_workers</code>决定，一般32核设置8-16即可，</li><li><code>coordinator</code>分发规则：<ul><li>不能更新覆盖，同一行的两个事务必须在同一个<code>worker</code>中</li><li>不能拆分事务，同一个事务必须在同一个<code>worker</code>中</li></ul></li></ul></li><li>按表分发策略<ul><li>如果两个事务更新不同的表，就可以分发到不同的<code>worker</code>中</li><li>如果事务跨表，需要将两张表一起考虑</li><li>每个<code>worker</code>中对应一张<code>hash</code>表，保存当前<code>worker</code>中正在执行的事务里面涉及的表，值是多少个事务在更新这个表</li><li>如果<code>coordinator</code>收到事务T，判断其中修改的表<ul><li>没有<code>worker</code>中包含这些表，那就分给最空闲的<code>worker</code></li><li>如果跟多于一个<code>worker</code>冲突，就等待</li><li>如果只跟一个<code>worker</code>冲突，那就分给这个<code>worker</code></li></ul></li><li>所以如果热点表，就变成了单线程，如果负载均衡，就很好解决问题</li></ul></li><li>按行分发策略<ul><li>需要<code>binlog = row</code></li><li>必须有主键，不能有外键</li><li>但是对于大事务，耗费内存，耗费CPU资源更大</li></ul></li><li>5.6版本，按库分发并行</li><li>5.7版本<code>slave-parallel-type</code>控制并行策略，配置为<code>DATABASE</code>就是按库并行，配置<code>LOGICAL_CLOCK</code><ul><li>同处于<code>prepare</code>的事务，备库可以并行</li><li>处于<code>prepare</code>和<code>commit</code>的事务可以并行</li></ul></li></ol><p>一主多从基本架构<br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/MySQL/45_ms.png" alt="45_ms"></p><ol><li>主库负责写入和一部分读，从库负责读<br>切换主库的时候需要找同步位点，5.6版本使用<code>GTID</code>，全局事务ID，在事务提交时生成<br>两个部分，格式为<code>server_uuid:gno</code><ul><li><code>server_uuid</code>是实例启动产生的，全局唯一</li><li><code>gno</code>是整数，初始值为1，每次提交事务的时候分配给这个事务，就加1</li><li>启动<code>GTID</code>在启动时加上参数<code>gtid_mode=on</code> 和 <code>enforce_gtid_consistency=on</code>即可<br>使用基于<code>GTID</code>的主备切换，就不需要指定位点，因为位点是不精确的。所以建议使用基于<code>GTID</code>的主从复制</li></ul></li></ol><h3 id="主从延迟怎么解决">主从延迟怎么解决</h3><ol><li><p>强制走主库方案；</p><ul><li>比如交易平台，卖家发布商品以后，马上返回主页面，看商品是否发布成功，这个就强制走主库，因为需要拿到最新的结果</li><li>如果是买家，晚几秒看到商品也可以接受，就走从库</li></ul></li><li><p><code>sleep</code>方案</p><ul><li><code>sleep(1)</code>大部分同步1s内能搞定，但是不太稳妥</li></ul></li><li><p>判断主备无延迟方案</p><ol><li><code>show slave status中的seconds_behind_master</code>是否等于0<ul><li>单位是秒，如果精度不够，可以使用位点和<code>GTID</code></li></ul></li><li><code>Master_Log_File</code>和<code>Read_Master_Log_Pos</code>表示读到主库的最新位点<br><code>Relay_Master_Log_File</code>和<code>Exec_Master_Log_Pos</code>表示备库执行的最新位点<br>如果<code>Master_Log_File=Relay_Master_Log_File&amp;&amp;Read_Master_Log_Pos=Exec_Master_Log_Pos</code>表示日志同步完成</li><li><code>GTID</code>中<br><code>Auto_Position=1</code>表示主备使用了<code>GTID</code>协议<br><code>Retrieved_Gtid_Set</code>是备库收到的所有日志<code>GTID</code>集合<br><code>Executed_Gtid_Set</code>是备库已经执行完的<code>GTID</code>集合<br>如果两个集合相同，则日志同步完成</li><li>但是上面的方法是判断备库收到的<code>binlog</code>已经执行完了，但是实际上可能主库有<code>binlog</code>，但是备库还没有收到，这时需要使用半同步复制</li><li>业务高峰期，主库位点和<code>GTID</code>更新很快，位点判断就会一直不成立，那么从库就一直都无法响应</li></ol></li><li><p>配合<code>semi-sync</code>方案</p><ul><li>牺牲一定可用性，保持一致性</li><li>但是因为半同步只要一个从库同步就返回<code>ack</code>，实际上请求可能打到别的没有同步的从库上</li><li>所以半同步配合位点方案，会有问题<ul><li>一主多从，会有过期读的问题</li><li>如果一直有延迟，就一直无法<code>select</code>，但是实际上不需要等待到完全没有延迟，而是只要一个事务完成以后，<code>select</code>到哪个事务即可，不需要等待其他事务也同步完</li></ul></li></ul></li><li><p>等主库位点方案</p><ul><li><code>select master_pos_wait(file, pos[, timeout]);</code><ul><li><code>file pos</code>是主库上的文件名和位置</li><li>从库上执行</li><li><code>timeout</code>可选，表示超时</li><li>返回一个正整数<code>M</code>，表示命令开始执行，到应用完<code>file</code>和<code>pos</code>表示的<code>binlog</code>位置，一共执行了多少个事务</li><li>如果备库挂了，那就返回<code>NULL</code></li><li>如果超时，返回<code>-1</code></li><li>如果执行时，已经执行过这个位置了，返回0</li></ul></li><li>具体流程<ul><li>一个事务执行完，马上在主库上执行<code>show master status</code>得到主库执行到的<code>File</code>和<code>Pos</code>(不需要完全精确)</li><li>选一个从库查询</li><li>从库上执行<code>select master_pos_wait(File, Pos, 1);</code></li><li>如果返回&gt;=0，则再这个从库上执行查询语句</li><li>否则就去主库查询</li></ul></li><li>所以如果不允许过期读的情况出现，那么就超时放弃，或者转到主库查询，并做限流</li></ul></li><li><p>等 <code>GTID</code> 方案</p><ul><li><code>WAIT_FOR_EXECUTED_GTID_SET(gtid_set[, timeout])</code>，超时时间默认为0，如果为0，表示一直等待<ul><li>语句作用：等待，直到这个库执行的事务包含传入的<code>gtid_set</code>，返回0</li><li>超时返回1</li></ul></li><li>5.7版本后，不需要主动执行<code>show master status</code>，而是更新以后返回事务的<code>GTID</code>，减少一次查询<ul><li><code>session_track_gtids = OWN_GTID</code></li><li>通过API从<code>mysql_session_track_get_first</code>解析<code>GTID</code>即可</li></ul></li><li>具体流程<ul><li>事务完成，接受到事务的<code>GTID，gtid1</code></li><li>选一个从库查询，执行<code>WAIT_FOR_EXECUTED_GTID_SET(gtid1, 1)</code></li><li>返回0就在这个从库查询</li><li>否则去主库查询</li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 主从延迟解决 </tag>
            
            <tag> 幻读 </tag>
            
            <tag> 死锁 </tag>
            
            <tag> 加锁判断 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL笔记_7</title>
      <link href="/posts/b92393e9.html"/>
      <url>/posts/b92393e9.html</url>
      
        <content type="html"><![CDATA[<h1>主备</h1><ol><li>主备切换流程<br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/MySQL/45_ms.png" alt="45_ms"><br>状态1，客户端读写都只访问节点A，B是从库，同步A的更新，保证AB数据相同<br>需要切换的时候，就变成状态2，客户端只访问节点B</li></ol><ul><li>状态1不会操作B，但是建议将B设置为<code>read only</code><ul><li>防止他人误操作B</li><li>防止切换逻辑出现双写的问题</li><li>判断访问节点的角色</li><li><code>read only</code>对超级管理员无效，所以可以同步更新的线程有超级权限</li></ul></li></ul><ol start="2"><li><p><code>binlog statement</code></p><ul><li><code>statement</code>就是记录<code>SQL</code>语言，甚至会把注释也都记录进去</li><li><code>statement</code>的格式下，<code>delete</code>带有<code>limit</code>，就是<code>unsafe</code>的，会导致主从不一致</li><li>删除条件的两个都有索引，如果主从版本不一，可能选择的索引不一致，所以顺序不同，导致<code>delete</code>的东西不同，本质上就是主从库可能<code>delete</code>的时候用到的索引不同，因为有<code>limit</code>存在，比如只删一条数据，就会导致数据不一致。</li></ul></li><li><p><code>binlog row</code></p><ul><li><code>row</code>里面多了<code>Table_map</code>和<code>Delete_rows</code></li><li><code>Table_map</code>用于说明接下来操作哪个库哪个表</li><li><code>Delete_rows</code>用于定义删除行为</li><li>实际上，<code>row</code>虽然会占用空间，但是有助于恢复数据，比如误删，可以根据<code>binlog</code>看到，直接插入即可；误增误改都可以这么处理</li></ul></li><li><p><code>binlog mixed</code></p><ul><li>如果有大量的删，那么<code>row</code>就会记录大量的内容，导致磁盘IO变多，占用空间变多</li><li><code>statement</code>就不会，只会有一条语句，但是在某些情况下，会导致不一致</li><li>所以<code>mixed</code>判断，如果不会导致不一致就用<code>statement</code>，如果可能会不一致，就切换到<code>row</code></li><li>这个格式用的不多</li></ul></li></ol><h2 id="双M">双M</h2><p><img src="https://gitee.com/sang3112/blog_imgs/raw/master/MySQL/45_2m.png" alt="45_2m"></p><ul><li>建议设置<code>log_slave_updates=ON</code>，从库执行完<code>relay log</code>以后也生成<code>binlog</code></li><li>A更新事务，<code>binlog</code>记录A的<code>server id</code></li><li>B接收到<code>binlog</code>，更新，并记录<code>server id</code>也就是A的<code>server id</code></li><li>再传回A，A判断<code>server id</code>等于自身，所以就不会处理日志</li></ul><h1>并发连接和并发查询</h1><ul><li>线程等待锁的时候，并发线程计数减一</li><li>因为等待锁的时候不吃cpu资源</li><li><code>innodb_thread_concurrency</code>设置最大并发线程数</li></ul><h1>检测MySQL</h1><ul><li><p>再<code>mysql</code>库中创建一个<code>health_check</code>表，只放一行数据，定期执行<br><code>mysql&gt; select * from mysql.health_check; </code></p></li><li><p>可以检测因为并发线程过多导致的数据库不可用的问题</p><ul><li><code>select 1</code>不行，因为不涉及<code>InnoDB</code>引擎，就算超出限制也会返回</li><li>但是这样的话，如果<code>binlog</code>磁盘占满了，也会阻塞<code>commit</code>事务，但是不会阻塞返回，所以这种方法无法判断是否存在磁盘满的情况</li></ul></li><li><p>更新判断：放一个<code>timestamp</code>字段，表示最后一次执行检测的时间：<code>mysql&gt; update mysql.health_check set t_modified=now();</code></p><ul><li>对主从库都需要执行更新检测</li><li>为了主备更新不冲突，再<code>mysql.health_check</code>上存入多行数据，用两个库的serverid作为主键</li><li>但是可能IO已经100%了，此时正好执行到<code>update</code>语句，那么就无法判断这种情况，不能及时切换</li><li>可以通过检测<code>performance_schema</code>里面<code>redolog</code>和<code>binlog</code>的写入时间判断是否存在问题，但是性能损耗10%</li></ul></li></ul><h1>误删数据</h1><ul><li><code>delete</code>误删某一行，那么就用<code>binlog</code>恢复即可，需要<code>binlog=row</code>，<code>binlog_row_image=FULL</code></li><li>可以将<code>sql_safe_updates=ON</code>预防，如果<code>delete</code>或者<code>update</code>没有写<code>where</code>条件，或者<code>where</code>条件没有索引，就会报错</li><li>如果需要删全表，则使用<code>truncate table</code> 或者 <code>drop table</code></li><li>但是如果<code>drop</code>或者<code>truncate</code>，无法使用<code>binlog</code>恢复，只能全量备份+增量恢复</li><li>如果对于核心库，可以使用延迟备份，减慢<code>binlog</code>到从库执行的时间，避免被删</li></ul><h1>kill</h1><ul><li>两个<code>kill</code>命令，<code>kill query + id</code> 和 <code>kill connection + id</code></li><li>发送<code>kill</code>命令以后，<code>session</code>运行状态改为<code>THD::KILL_QUERY</code>，并给<code>session</code>发送一个信号</li><li><code>kill</code>无效<ul><li>线程没有执行到判断线程状态的逻辑</li><li>终止逻辑耗时较长<ol><li>大事务被<code>kill</code>，需要回滚</li><li>大事务回滚包含较大的临时文件，压力过大，耗时长</li><li><code>DDL</code>最后阶段</li></ol></li><li><code>ctrl+c</code>命令是服务器开启一个新的线程发送<code>kill query</code>命令</li></ul></li></ul><h1>全表扫描</h1><ol><li>如果扫描一张大表，就获取一行数据，存储到<code>net_buffer</code>中，内存大小由<code>net_buffer_length</code>控制，默认<code>16K</code></li><li>重复获取行，直到<code>net_buffer</code>写满，发送</li><li>发送成功清空<code>net_buffer</code>，重复</li><li>发送返回<code>EAGAIN</code>或者<code>WSAEWOULDBLOCK</code>，表示本地网络栈写满，进入等待，直到网络栈重新可写，再继续等待</li></ol><ul><li>所以如果客户端接收的慢，事务执行时间就会变长<ul><li>可以使用<code>mysql_store_result</code>，将收到的内容存入客户端内存，加快接收速度</li><li>但是如果是大查询，就会占用大量内存，就需要使用<code>mysql_use_result</code></li></ul></li></ul><p><code>innodb_buffer_pool_size</code>一般设置为可用物理内存的60%-80%，线上服务的内存命中率需要达到99%，可以通过<code>show engine innodb status</code>查看<code>Buffer pool hit rate</code></p><ul><li><code>InnoDB</code>淘汰数据页用的<code>LRU</code>的改进<ul><li>因为如果对一个不常用的表使用全表扫描，这时候就会将别的业务正在使用的内存给顶掉，导致别的业务缓存失效</li><li>所以<code>InnoDB</code>按照<code>5:3</code>的比例将<code>LRU</code>分为了<code>young</code>和<code>old</code>区，<br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/MySQL/45_youngold.png" alt="45_youndold"></li><li>如图，状态1，访问P3，P3在<code>young</code>区，按照<code>LRU</code>，移到链表头部，变成状态2</li><li>此时，要插入新的数据页，淘汰<code>Pm</code>，但是新的数据页Px插入<code>LRU_old</code>处</li><li>处于<code>old</code>区的数据页，每次被访问都要做下面的判断：<ul><li>如果数据页存在超过1s，就移动到链表头</li><li>少于1s，位置不变，<code>innodb_old_blocks_time=1000</code>，表示1s</li><li>这样扫描大表也用到了<code>buffer pool</code>，但是对于<code>young</code>区没有影响</li></ul></li></ul></li></ul><h1>join</h1><ul><li><code>join</code>应该将小表作为驱动表，大表作为被驱动表，因为<code>InnoDB</code>只会用被驱动表上的索引，对于驱动表，也就是<code>join</code>前面的表，用的是全表扫描。如果驱动表是行数N，被驱动表M被驱动表上索引查询，所以如果回表，就需要在普通索引和主键索引上都查询一次，那么时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">2log_2(M)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mclose">)</span></span></span></span>,驱动表上查询<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>行，所以总共是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>+</mo><mn>2</mn><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N+2log_2(M)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mclose">)</span></span></span></span>，这就是<code>NLJ</code></li><li>这是仅限于可以使用被驱动表的索引，如果被驱动表没有索引，就会使用<code>BNL</code><ul><li>将驱动表的数据取出放到<code>join_buffer</code>中，</li><li>将被驱动表的每一行跟<code>join_buffer</code>中的数据对比，满足条件放到结果集中</li><li>总时间复杂度就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>M</mi></mrow><annotation encoding="application/x-tex">NM</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">NM</span></span></span></span></li><li>这样的话，时间复杂度就是两个表的全表扫描<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>+</mo><mi>M</mi><mo>+</mo><mi>N</mi><mi>M</mi></mrow><annotation encoding="application/x-tex">N + M + NM</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">NM</span></span></span></span></li><li>如果驱动表较大，无法放到<code>join_buffer</code>中，就会分段放，<code>join_buffer_size</code>默认<code>256k</code><ul><li>就会将驱动表放一部分行，直到<code>join_buffer</code>放满为止，然后将被驱动表取出比对，再清空<code>join_buffer</code>，放驱动表的下一部分数据，直到比对结束</li><li>假设N行驱动表分<code>K</code>段，<code>N</code>越大，<code>K</code>越大，所以<code>K</code>表示为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo>×</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">\lambda \times N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">λ</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo>∈</mo><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\lambda \in (0, 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">λ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li><li>扫描行数就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>+</mo><mi>λ</mi><mo>×</mo><mi>N</mi><mo>×</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">N + \lambda \times N \times M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">λ</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span></li><li>判断<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>∗</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">N*M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>次</li><li>所以应该让小表当驱动表</li></ul></li></ul></li><li>如果<code>join</code>很慢，就把<code>join_buffer_size</code>改大一些</li><li>尽量让<code>join</code>走<code>NLJ</code>，并且警惕<code>explain</code>检查字段是否出现<code>Block Nested Loop</code></li><li>在决定哪个表做驱动表的时候，应该是两个表按照各自的条件过滤，过滤完成之后，计算参与<code>join</code>的各个字段的总数据量，数据量小的那个表，就是“小表”，应该作为驱动表。</li><li><code>join</code>比强行拆分单表查询性能更好</li></ul><h2 id="Multi-Range-Read-MRR">Multi-Range Read(MRR)</h2><ul><li>如果一张表有主键id索引，普通索引a，通过a索引扫描，有时候需要回表查询主键</li><li>此时a虽然是在索引上顺序查询的，但是因为需要回表，所以在主键id索引上就是乱序查的。但是大都数数据都是通过主键自增顺序插入得到的，所以可以认为按照主键递增顺序查询的话对磁盘接近顺序读，性能会更好</li><li>所以MRR就是先根据索引a找到数据，放到<code>read_rnd_buffer</code>中，(随机读缓冲区)，将缓冲区中的数据按照id递增排序，然后依次在主键中查找。大小由<code>read_rnd_buffer_size</code>控制，如果<code>buffer</code>放满了就会先执行排序，然后查找id返回结果，清空<code>buffer</code>再进行下一步</li><li>如果想要使用<code>MRR</code>，<code>set optimizer_switch=&quot;mrr_cost_based=off&quot;</code>，因为优化器不会判断时使用<code>MRR</code>，所以设置为<code>off</code>，固定使用<code>MRR</code></li></ul><h2 id="Batched-Key-Access-BKA">Batched Key Access(BKA)</h2><ul><li><p>当使用<code>join</code>的时候，驱动表一行一行到被驱动表比对，用不上<code>MRR</code></p></li><li><p>现在将驱动表的内容拿出来，放到<code>join_buffer</code>中，原本<code>join_buffer</code>在<code>BNL</code>里才有暂存驱动表的数据，在<code>NLJ</code>没有用，现在<code>NLJ</code>也会用到</p></li><li><p>然后通过<code>join_buffer</code>跟被驱动表比对</p></li><li><p><code>set optimizer_switch='mrr=on,mrr_cost_based=off,batched_key_access=on';</code>通过这条语句开启<code>MRR</code>和<code>BKA</code>，因为<code>BKA</code>基于<code>MRR</code></p></li><li><p>如果<code>join</code>使用<code>BNL</code>，多次扫描一个冷表，语句执行超过1s，再次扫描冷表就会将数据页放到LRU头部</p></li><li><p>对应的情况就是冷表的数据量小于<code>buffer pool</code>的<code>3/8</code>，能够完全放到<code>old</code>区中。</p></li><li><p>如果冷表很大，业务正常访问的数据页，就没有机会进入<code>young</code>区，这是因为正常访问的数据页要进入<code>young</code>区的话，需要隔1s再被访问到，但是冷表很大，<code>old</code>区在1s内就淘汰了正常数据页，就会导致<code>buffer pool</code>没有这个数据</p></li><li><p>所以大表<code>JOIN</code>不仅会影响IO，IO在<code>join</code>结束也就恢复了，还会影响<code>buffer</code>，需要后面慢慢恢复</p></li></ul><h2 id="BNL对系统的影响">BNL对系统的影响</h2><ol><li>多次扫描被驱动表，影响IO</li><li><code>join</code>条件需要执行<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>×</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">M \times N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>次对比，大表占用非常多资源</li><li>导致<code>buffer pool</code>热数据被淘汰，影响内存利用率</li></ol><ul><li><p>可以尝试给被驱动表添加索引</p></li><li><p>如果不适合加索引，比如次数比较少，添加索引不划算。可以建临时表，给临时表加索引，再<code>join</code>即可，优化很好</p></li><li><p>或者自己在业务端实现<code>hash join</code>，会比临时表优化的还好，<code>select * from t1</code>驱动表t1所有数据存入<code>hash</code>结构，比如set之类，<code>select * from t2 where b&gt;=1 and b&lt;=2000</code>获取被驱动表的<code>2000</code>条数据，然后一条一条在业务端跟<code>hash</code>表内容比对即可。临时表需要比较<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi>k</mi><mo>×</mo><mn>2</mn><mi>k</mi></mrow><annotation encoding="application/x-tex">1k \times 2k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>次，但是<code>hash join</code>只需要比较<code>2k</code>次</p></li><li><p>临时表可以用各种引擎，但是内存表只用<code>memory</code>引擎，一般由mysql自动创建销毁</p></li><li><p>临时表建表语法时<code>create temporary table ...</code></p></li><li><p>一个临时表只能被创建它的<code>session</code>访问，其他<code>session</code>不可见</p></li><li><p>临时表可以与普通表重名</p></li><li><p>如果有同名的，那么<code>show create</code>和增删改查访问临时表</p></li><li><p><code>show tables</code>不显示临时表</p></li><li><p>所以临时表不需要担心重名问题，可以用来给<code>join</code>使用，而且不需要担心数据删除问题</p></li><li><p>分库分表跨库查询就会使用临时表</p></li><li><p>创建临时表的时候，<code>InnoDB</code>创建一个<code>frm</code>文件保存表结构定义，前缀是<code>#sql&#123;进程 id&#125;_&#123;线程 id&#125;_ 序列号</code><br>5.6版本之前，会在临时文件目录下创建一个相同前缀.ibd存放数据文件，5.7版本后有专门的临时表空间存放临时数据，因为前缀不同，所以可以创建同名临时表</p></li><li><p>但是普通表是库名+表名得到的，同一个库创建两个同名表就会报错</p></li><li><p>当<code>session</code>结束的时候，就会执行<code>drop temporary table + 表名</code></p></li><li><p>如果<code>binlog</code>不是<code>row</code>，就会记录临时表的操作，不然会报错，提示临时表不存在。但是<code>row</code>格式只会记录数据，所以不会有对临时表的操作，不会发现临时表不存在这种问题，就不会记录临时表</p></li></ul><h2 id="内存临时表">内存临时表</h2><ol><li><code>union</code>的<code>explain</code>会显示<code>using temporary</code>，表示使用临时表，将<code>union</code>前的结果存在临时表中，然后利用主键唯一性剔除第二个查询中的相同的结果</li></ol><ul><li>如果是<code>union all</code>，就没有去重了，所以也不需要临时表了</li></ul><ol start="2"><li><code>group by</code></li></ol><ul><li><p>创建内存临时表，表上两个字段m和c，主键是m</p></li><li><p>扫描t1上的索引a，取id，并%10记x</p><ul><li>临时表没有x的行，那么插入x,1</li><li>如果有x的行，那么对应的c+1</li><li><code>group by</code>处理完以后默认会对字段m按照自然顺序排序，如果不想排序提高效率，就可以直接加上<code>order by null</code><br><code>tmp_table_size</code>是内存临时表的大小设置参数，默认<code>16M</code>，超过大小会转为磁盘临时表</li></ul></li><li><p>不管是内存临时表还是磁盘临时表，<code>group by</code>都需要构建一个带唯一索引的表，执行代价高</p></li><li><p>5.7版本支持<code>generated column</code>机制，用来实现数据关联更新<code>alter table t1 add column z int generated always as(id % 100), add index(z);</code></p></li><li><p>这样索引z上的数据就是<code>group by</code>有序的数据了<code>group by id %100</code>就可以改写为<code>select z, count(*) as c from t1 group by z;</code>此时不再需要临时表，也不需要排序，直接返回即可</p></li><li><p><code>group by</code>语句使用<code>SQL_BIG_RESULT</code>提示，可以告诉<code>sql</code>数据量很大，直接使用磁盘临时表，然后优化器还会将原本的B+树直接改为数组存储 ，两次优化<br><code>select SQL_BIG_RESULT id%100 as m, count(*) as c from t1 group by m;</code></p></li><li><p>初始化<code>sort_buffer</code>，放入整型字段m</p></li><li><p>扫描t1.a，取id%100放入<code>sort_buffer</code></p></li><li><p>对<code>sort_buffer</code>中字段m排序</p></li><li><p>排完序就是有序数组</p></li><li><p>这样就不会使用临时表</p></li></ul><p><code>InnoDB</code>把数据放在主键索引上，其他索引保存主键id就是索引组织表<code>IOT</code></p><ul><li><p>总是有序</p></li><li><p>有空洞时，插入新数据只能放在固定位置，从而保证有序</p></li><li><p>数据位置改变，只需要修改主键索引</p></li><li><p>主键索引查一次，普通索引查两次</p></li><li><p>变长数据<br><code>Memory</code>数据单独存放，索引上保存数据位置，就是堆组织表<code>HOT</code></p></li><li><p>按照写入顺序</p></li><li><p>有空洞时找到空位就可以插入新数据</p></li><li><p>数据位置改变，需要修改所有索引</p></li><li><p>所有索引地位相同</p></li><li><p>不支持变长，定义<code>varchar</code>，也是 按照<code>char(N)</code></p></li><li><p>内存表锁表，并且丢失会有风险，一般不会用</p><ul><li>但是内存临时表不一样，因为不会被其他<code>session</code>访问，所以没有并发性问题</li><li>本来重启就是要删除的，所以丢失没关系</li><li>备库临时表也不会影响主库</li><li>支持<code>hash</code>索引</li></ul></li><li><p><code>MyISAM</code>主键自增值在数据文件中</p></li><li><p><code>InnoDB</code>主键自增值在内存中，8.0版本实现持久化</p><ul><li>5.7版本前没有持久化，保存在内存，重启后就找表的最大值，最大值+1作为自增值</li><li>如果id=10，则<code>AUTO_INCREMENT=11</code>，删除id=10，还是11，如果删除以后重启，AUTO=10</li><li>8.0版本变更记录在<code>redo log</code>中，重启依靠<code>redo log</code>恢复之前的值</li></ul></li><li><p>插入一行数据，指定为自增，判断id=0，null，或者没有指定，就把表的自增值赋值给他</p></li><li><p>如果id指定了值，就使用指定值；如果指定值小于自增值，则自增值不变；</p><ul><li>如果指定值大于等于自增值，就修改自增值，就是<code>auto_increment_offset</code>开始，<code>auto_increment_increment</code>为步长叠加，找到第一个大于指定值作为新的自增值。两个参数默认都是1</li></ul></li><li><p>如果插入数据，自增主键，但是插入数据失败，数据重复了，那么数据无法插入成功，并且主键自增值也没有改回去（唯一键冲突会导致主键自增不连续）</p></li><li><p>事务回滚也会导致自增主键不连续，为了性能，因为申请id很快，但是回滚id可能会导致主键冲突，没有必要</p></li><li><p>批量<code>insert ... select， replace ...select, load data</code>的场景下设置<code>innodb_autoinc_lock_mode=2</code>可以提升并发性，并且不会出现数据一致性问题</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 主备切换 </tag>
            
            <tag> InnoDB和Memory </tag>
            
            <tag> join优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go笔记_0</title>
      <link href="/posts/f86b96e2.html"/>
      <url>/posts/f86b96e2.html</url>
      
        <content type="html"><![CDATA[<h1><code>GOROOT</code> VS <code>GOPATH</code> VS <code>GOBIN</code> VS <code>GOPROXY</code></h1><ul><li><code>GOROOT</code>: Go语言安装路径</li><li><code>GOPATH</code>: 若干工作区目录的路径。是我们自己定义的工作空间  <div class="note info flat"><ul><li><code>GO1.8</code>版本之后，开发包安装完成后会自动设置一个<code>GOPATH</code>目录，</li><li><code>GO1.14</code>版本之后，推荐使用<code>Go Module</code>模式，不一定非要将代码写在<code>GOPATH</code>目录下，也不需要自己配置<code>GOPATH</code></li></ul></div></li><li><code>GOBIN</code>: GO程序生成的可执行文件的路径</li><li><code>GOPROXY</code>: 默认为<code>GOPROXY=https://proxy.golang.org,direct</code>，修改为<code>GOPROXY=https://goproxy.cn,direct</code></li></ul><h1>跨平台编译</h1><h2 id="Windows-编译-LINUX或者OSX">Windows 编译 LINUX或者OSX</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SET CGO_ENABLED=0   // 禁用CGO</span><br><span class="line">SET GOOS=linux      // 目标平台, [windows, linux, darwin]</span><br><span class="line">SET GOARCH=amd64    // 目标处理器架构</span><br><span class="line">go build</span><br></pre></td></tr></table></figure><h2 id="LINUX-或者-OSX-编译其他环境">LINUX 或者 OSX 编译其他环境</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGO_ENABLED=0 GOOS=linux|darwin|windows GOARCH=amd64 go build</span><br></pre></td></tr></table></figure><div class="note info flat"><ul><li>只有Windows 需要在cmd窗口中运行<code>SET</code>命令</li></ul></div><h1>编写测试</h1><div class="note info flat"><ol><li>有一个程序名为<code>xxx.go</code>，则其测试程序应该名为<code>xxx_test.go</code></li><li>测试函数的命名以<code>Test</code>开始，例如<code>Testxxx()</code></li><li>测试函数只能有一个参数<code>t *testing.T</code>，参数<code>t</code>是测试的<code>hook</code>，测试失败时可以执行<code>t.Fail()</code>等操作</li></ol></div><h2 id="举例">举例</h2><ul><li>有一个<code>main</code>函数，打印<code>Hello world</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Hello</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Hello world&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">fmt.Println(Hello())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>则对应的测试代码应该为</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello_test.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestHello</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">got := Hello()</span><br><span class="line">want := <span class="string">&quot;Hello world&quot;</span></span><br><span class="line"><span class="keyword">if</span> got != want&#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;got &#x27;%q&#x27; want &#x27;%q&#x27;&quot;</span>, got, want)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在终端直接执行<code>go test</code>命令即可进行测试，如果文件名错误，会报错:<code>?       gogo    [no test files]</code></li></ul><h2 id="重构-t-Helper">重构 <code>t.Helper()</code></h2><p>现在有这两个文件<code>hello.go, hellotest.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> helloPrefix = <span class="string">&quot;Hello &quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Hello</span><span class="params">(name <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> helloPrefix + name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">fmt.Println(Hello(<span class="string">&quot;world&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestHello</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">assertCorrectMessage := <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T, got, want <span class="type">string</span>)</span></span>&#123;</span><br><span class="line">t.Helper()</span><br><span class="line"><span class="keyword">if</span> got != want&#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;got &#x27;%q&#x27; want &#x27;%q&#x27;&quot;</span>, got, want)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 成功</span></span><br><span class="line">t.Run(<span class="string">&quot;saying hello to people&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">got := Hello(<span class="string">&quot;chris&quot;</span>)</span><br><span class="line">want := <span class="string">&quot;Hello chris&quot;</span></span><br><span class="line">assertCorrectMessage(t, got, want)</span><br><span class="line">&#125;)</span><br><span class="line">    <span class="comment">// 失败</span></span><br><span class="line">t.Run(<span class="string">&quot;say hello world when an empty string is supplied&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">got := Hello(<span class="string">&quot;&quot;</span>)</span><br><span class="line">want := <span class="string">&quot;Hello world&quot;</span></span><br><span class="line">assertCorrectMessage(t, got, want)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>将断言单独作为一个函数，由两个子测试进行调用。</li><li>第一个子测试能通过，第二个子测试失败</li><li><code>t.Helper()</code>告诉测试套件这个函数是一个辅助函数，这样测试失败时报告的行号将在函数调用中，而不是在辅助函数内部。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不添加t.Helper()的输出</span></span><br><span class="line">--- FAIL: TestHello (0.00s)</span><br><span class="line">    --- FAIL: TestHello/say_hello_world_when_an_empty_string_is_supplied (0.00s)</span><br><span class="line">        hello_test.go:15: got &#x27;&quot;Hello &quot;&#x27; want &#x27;&quot;Hello world&quot;&#x27; # 断言函数处的行号，但是具体不知道是哪个测试用例出错</span><br><span class="line">FAIL</span><br><span class="line">exit status 1</span><br><span class="line">FAIL    gogo    0.001s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加t.Helper()的输出</span></span><br><span class="line">--- FAIL: TestHello (0.00s)</span><br><span class="line">    --- FAIL: TestHello/say_hello_world_when_an_empty_string_is_supplied (0.00s)</span><br><span class="line">        hello_test.go:28: got &#x27;&quot;Hello &quot;&#x27; want &#x27;&quot;Hello world&quot;&#x27; # 具体测试用例内部的行号</span><br><span class="line">FAIL</span><br><span class="line">exit status 1</span><br><span class="line">FAIL    gogo    0.001s</span><br></pre></td></tr></table></figure><h2 id="命名返回值">命名返回值</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Hello</span><span class="params">(name <span class="type">string</span>, language <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> name == <span class="string">&quot;&quot;</span>&#123;</span><br><span class="line">        name = <span class="string">&quot;world&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> greetingPrefix(language) + name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greetingPrefix</span><span class="params">(language <span class="type">string</span>)</span></span> (prefix <span class="type">string</span>)&#123;</span><br><span class="line">    <span class="keyword">switch</span> language &#123;</span><br><span class="line">        <span class="keyword">case</span> french:</span><br><span class="line">            prefix = frenchHelloPrefix</span><br><span class="line">        <span class="keyword">case</span> spanish:</span><br><span class="line">            prefix = spanishHelloPrefix</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            prefix = englishHelloPrefix</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在函数签名中，使用了命名返回值<code>prefix string</code><ul><li>会自动创建一个名为<code>prefix</code>的变量，并且分配零值，即如果是<code>int</code>，则<code>prefix=0</code>，如果是<code>string</code>，则<code>prefix=&quot;&quot;</code></li><li>会在<code>Go Doc</code>中显示，代码更加清晰</li><li>只需要直接写<code>return</code>即可，不需要<code>return prefix</code></li></ul></li><li>函数如果是小写字母开头，则是私有函数；如果是大写字母开头，则是公共函数</li></ul><h2 id="示例">示例</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// integer.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Add takes two integers and returns the sum of them</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info flat"><ul><li><code>Add</code>函数有两个相同类型的参数，所以可以直接写成<code>x, y int</code></li><li>添加的函数注释<code>Add takes two integers and returns the sum of them</code>会放在Go Doc中</li></ul></div><ul><li>添加示例函数，示例函数同样会更新在Go Doc中，可以反映出代码的实际功能</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// integer_test.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleAdd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sum := Add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    fmt.Println(sum)</span><br><span class="line">    <span class="comment">// Output: 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info flat"><ul><li><code>// Output: 3</code>实际上是<code>ExampleAdd()</code>这个函数的期望输出，如果写5，表明希望1 + 2 = 5，会返回测试失败</li><li>这个语法不能在别的测试中使用，只有<code>Examplexxx()</code>中可以使用</li><li>使用<code>go test -v</code>可以输出每个测试用例的通过情况，以及整体的通过情况，输出结果如下</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">=== RUN   TestAdd</span><br><span class="line">--- PASS: TestAdd (0.00s)</span><br><span class="line">=== RUN   ExampleAdd</span><br><span class="line">--- PASS: ExampleAdd (0.00s)</span><br><span class="line">PASS</span><br><span class="line">ok      integer 0.001s</span><br></pre></td></tr></table></figure></div><h2 id="基准测试">基准测试</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iter.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Repeat</span><span class="params">(a <span class="type">string</span>)</span></span> <span class="type">string</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> repeat <span class="type">string</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++&#123;</span><br><span class="line">        repeat += a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> repeat</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编写基准测试</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iter_test.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkRepeat</span><span class="params">(b *testing.B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++&#123;</span><br><span class="line">        Repeat(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info flat"><ul><li><code>testing.B</code>可以访问隐性命名<code>b.N</code>，表示这个代码的运行次数，并记录时间</li><li>测试框架会选择<code>b.N</code></li><li>使用<code>go test -bench=.</code>来运行基准测试，如果在<code>Windows</code>中则使用<code>go test -bench=&quot;.&quot;</code></li><li>如果直接使用<code>go test [-v]</code>不会运行基准测试</li><li>使用<code>go test -cover</code>查看覆盖率</li></ul></div><h1>数组 VS 切片</h1><ul><li><code>numbers := [5]int&#123;1,2,3,4,5&#125;</code></li><li><code>numbers := [...]int&#123;1,2,3,4,5&#125;</code></li><li>遍历数组的两个方式</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, number := <span class="keyword">range</span> numbers&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// range返回索引和值，使用空白标志符来忽略索引</span></span><br></pre></td></tr></table></figure><div class="note info flat"><ul><li>数组传参，比如需要传入<code>numbers</code>，参数类型应该为<code>numbers [5]int</code></li><li>此时如果传入一个<code>[4]int</code>传入函数，不能通过编译，因为会判定为不同的类型</li><li>所以导致数组没什么用，一般用切片<code>slice</code>，尺寸不固定</li><li>切片就是在声明的时候不指定长度，也就是<code>mySlice := []int{1,2,3}</code>，而不是<code>mySlice := [3]int{1,2,3}</code></li><li>参数是可变数量的切片时，应该写<code>numbers ... []int</code></li><li>不能对切片使用等于号，简单的方法是使用<code>reflect.DeepEqual</code>，用于判断两个变量是否相等</li><li>但是<code>reflect.DeepEqual</code>不是类型安全的，甚至可以比较<code>slice</code>和<code>string</code>。</li><li>使用<code>make</code>创建切片可以指定容量和长度，创建的新切片中所有元素均为<strong>0</strong></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go笔记_1</title>
      <link href="/posts/8f6ca674.html"/>
      <url>/posts/8f6ca674.html</url>
      
        <content type="html"><![CDATA[<h1>方法</h1><div class="note info flat"><ul><li>Go语言中只有不同的<code>package</code>中可以有相同函数名的函数，尽管参数不同，但是如果函数名相同就不能出现在相同的包中(函数重载Go语言没有)</li><li>方法需要通过一个特定的实例调用，比如<code>t.Errorf()</code>，这里的<code>Errorf</code>就是一个方法，通过实例<code>t</code>调用</li><li>函数可以随便调用，没有限制</li></ul></div><h1>接口</h1><ul><li>接口让函数接受不同类型的参数并创造类型安全并且高解耦的代码</li><li>Go语言中 interface resolution 是隐式的。如果传入的类型匹配接口需要的，则编译正确。</li><li>函数实现因此不需要关心参数是什么类型的，只需要声明一个接口，辅助函数就可以从具体类型解耦而只关心本身需要做的工作</li></ul><h1>表格驱动测试</h1><ul><li>如果需要测试一个接口的不同实现，或者传入的数据有很多不同的测试需求，则可以使用表格驱动测试</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestArea</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">areaTests := []<span class="keyword">struct</span>&#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">shape Shape</span><br><span class="line">want <span class="type">float64</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">&#123;name: <span class="string">&quot;Rec&quot;</span>, shape: Rec&#123;Width: <span class="number">12</span>, Height: <span class="number">6</span>&#125;, want: <span class="number">72.0</span>&#125;,</span><br><span class="line">&#123;name: <span class="string">&quot;Circle&quot;</span>, shape: Circle&#123;<span class="number">10</span>&#125;, want: <span class="number">314.15926</span>&#125;,</span><br><span class="line">&#123;name: <span class="string">&quot;Tri&quot;</span>, shape: Tri&#123;<span class="number">12</span>, <span class="number">6</span>&#125;, want: <span class="number">361.0</span>&#125;, </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, tt := <span class="keyword">range</span> areaTests&#123;</span><br><span class="line">got := tt.shape.Area()</span><br><span class="line">want := tt.want</span><br><span class="line"><span class="keyword">if</span> got != want&#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;%#v got &#x27;%.2f&#x27;, want &#x27;%.2f&#x27;&quot;</span>, tt.shape, got, want)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info flat"><ul><li>创建了一个匿名结构体，里面有shape和want，放在一个[]struct切片中</li><li>然后使用两个测试用例填充这个切片</li><li>Go中调用一个函数或者方法的时候，参数会被复制</li><li>使用指针解决这个问题，指向某个值，然后修改</li></ul></div><h1>map</h1><ul><li>Map是引用类型的，拥有对底层数据结构的引用</li><li>因此，Map可以是nil指，如果使用一个nil的map，那么会得到一个nil指针异常，导致程序终止</li><li>永远不要初始化一个空的map变量，比如:<code>var m map[string]string</code></li><li>可以用如下两种方式初始化空的map:</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dict = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;&#125;</span><br><span class="line">dict = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br></pre></td></tr></table></figure><ul><li>上述两种方法绝对不会出现nil指针异常</li></ul><h1>依赖注入</h1><ul><li><code>fmt.Fprintf</code>接受一个<code>Writer</code>参数，将字符串传递过去。</li><li><code>fmt.Printf</code>是标准的默认输出</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// di.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Greet</span><span class="params">(writer io.Writer, name <span class="type">string</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// fmt.Printf(&quot;Hello, %s&quot;, name)</span></span><br><span class="line">fmt.Fprintf(writer, <span class="string">&quot;Hello, %s&quot;</span>, name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Greet(os.Stdout, <span class="string">&quot;Elodie&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// di_test.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bytes&quot;</span></span><br><span class="line"><span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGreet</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">buffer := bytes.Buffer&#123;&#125; <span class="comment">// 注入依赖</span></span><br><span class="line">Greet(&amp;buffer, <span class="string">&quot;Chris&quot;</span>)</span><br><span class="line">got := buffer.String()</span><br><span class="line">want := <span class="string">&quot;Hello, Chris&quot;</span></span><br><span class="line"><span class="keyword">if</span> got != want &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;got %s want %s&quot;</span>, got, want)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info flat"><ul><li>Go中可以使用反引号创建字符串，允许将字符串中的东西放在新的一行，比如<br>`<br>3<br>1<br>2<br>`</li></ul></div><ul><li><p>Go中不会阻塞的操作在成为goroutine的单独进程中运行。使用go关键字声明</p></li><li><p><code>go test -race</code>可以发现<code>goroutine</code>中的竞争条件，比如可能多个进程同时写一个<code>map</code>，但是一次执行并不会触发这种现象。</p></li><li><p>可以通过<code>channels</code>协调<code>goroutine</code>解决数据竞争问题。</p></li><li><p>比如原本需要将多个进程的数据写入<code>map</code>中，现在可以使用<code>channel &lt;- data</code>，将数据发送到<code>channel</code>中，然后再使用<code>for</code>循环，将数据保存保存在新的map中，这样不会产生数据竞争的问题。<code>result := &lt;- channel</code></p></li><li><p>在函数调用之前加上<code>defer</code>前缀会在包含他的函数结束时调用它。</p><ul><li>有时候需要清理资源，比如在函数结束时关闭一个文件，或者关闭一个服务器，但是要把它放在创建服务器语句附近，以便函数内后面的代码仍然可以使用这个服务器，就可以使用<code>defer</code>，等到函数执行完再调用</li></ul></li></ul><h1>进程同步</h1><ul><li><code>select</code>可以轻易实现进程同步</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Racer</span> <span class="params">(a, b <span class="type">string</span>)</span></span> (winner <span class="type">string</span>, err <span class="type">error</span>)&#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;- ping(a):</span><br><span class="line"><span class="keyword">return</span> a, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> &lt;- ping(b):</span><br><span class="line"><span class="keyword">return</span> b, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> M- time.After(<span class="number">10</span> *time.Second):</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span>, fmt.Errorf(<span class="string">&quot;timed out waiting for %s and %s&quot;</span>, a, b)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ping</span><span class="params">(url <span class="type">string</span>)</span></span> <span class="keyword">chan</span> <span class="type">bool</span>&#123;</span><br><span class="line">ch := <span class="built_in">make</span> (<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">http.Get(url)</span><br><span class="line">ch &lt;- <span class="literal">true</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果是<code>v := &lt;- ch</code>等待值发送给<code>channel</code>，则这是一个阻塞调用，因为需要等待值返回</li><li><code>select</code>允许多个<code>channel</code>等待，第一个发送值的<code>channel</code>胜出。</li><li>使用<code>select</code>时，<code>time.After</code>是一个很好用的函数，因为<code>channel</code>可能永远不会返回一个值，那就有可能不会返回，因此使用<code>time.After</code>设置超时时间</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">t.Run(<span class="string">&quot;returns an error if a server doesn&#x27;t respond within 10s&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    serverA := makeDelayedServer(<span class="number">11</span> * time.Second)</span><br><span class="line">    serverB := makeDelayedServer(<span class="number">12</span> * time.Second)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> serverA.Close()</span><br><span class="line">    <span class="keyword">defer</span> serverB.Close()</span><br><span class="line"></span><br><span class="line">    _, err := Racer(serverA.URL, serverB.URL)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        t.Error(<span class="string">&quot;expected an error but didn&#x27;t get one&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1>反射</h1><blockquote><p>编写函数 <code>walk(x interface&#123;&#125;, fn func(string))</code>，参数为结构体x，并对 x 中的所有字符串字段调用 fn 函数</p></blockquote><ul><li>反射提供了程序检查自身结构体的能力。</li><li>允许使用类型<code>interface&#123;&#125;</code>，代表任意类型。但是这样市区了对类型安全的检查，编译器不会再检查类型</li><li>除非真的需要，否则不要使用反射</li><li>如果想要实现多态，可以考虑围绕接口实现。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记_13</title>
      <link href="/posts/9dced3f3.html"/>
      <url>/posts/9dced3f3.html</url>
      
        <content type="html"><![CDATA[<h1>并发</h1><h2 id="创建线程">创建线程</h2><ol><li>将线程任务放在一个类的<code>run()</code>中, 这个类需要实现<code>Runnable</code>接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Runnable</code>是个函数式接口, 所以可以使用<code>lambda</code>表达式创建实例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">    task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>从这个<code>Runnable</code>构造一个<code>Thread</code>对象 <code>Thread t = new Thread(r);</code></li><li>启动线程 <code>t.start();</code></li></ol><div class="note info flat"><ul><li>还可以通过建立<code>Thread</code>类的子类定义线程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span> <span class="params">()</span> &#123;</span><br><span class="line">        task;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>然后构造这个子类的对象并调用<code>start()</code>, 但是现在一般不用这个方法, 如果有多个任务, 每个任务都要创建一个线程的开销的太大, 一般使用线程池</li><li>不要调用<code>Thread</code>类或者<code>Runnable</code>对象的<code>run()</code>, 直接调用<code>run()</code>会在同一个线程中执行这个任务, 而不会启动新的线程</li><li>应该调用<code>Thread.start()</code>创建一个新的线程执行<code>run()</code></li></ul></div><h2 id="线程的状态">线程的状态</h2><blockquote><p>使用<code>getState()</code>可以确定当前的状态</p></blockquote><ol><li><code>New</code> 新建</li><li><code>Runnable</code> 可运行</li><li><code>Blocked</code> 阻塞</li><li><code>Waiting</code> 等待</li><li><code>Time waiting</code> 计时等待</li><li><code>Terminated</code> 终止</li></ol><h3 id="New"><code>New</code></h3><ul><li>使用<code>new</code>新建一个线程, 比如<code>new Thread(r)</code>, 线程还没有开始运行</li></ul><h3 id="Runnable"><code>Runnable</code></h3><ul><li>调用<code>start()</code>后, 线程就是<code>Runnable</code>状态, 可以是正在运行, 也可以没有在运行</li></ul><h3 id="Blocked-Waiting-Time-waiting"><code>Blocked</code> &amp; <code>Waiting</code> &amp; <code>Time waiting</code></h3><ul><li>处于阻塞或等待状态时, 线程不活动, 不执行任何代码, 消耗最少的资源<ul><li>当一个线程试图获取一个内部的对象锁, 不是<code>java.util.concurrent.Lock</code>, 而这个锁目前被其他线程占有, 该线程就会阻塞; 当其他线程都释放了这个锁, 并且调度器允许该线程持有锁时, 该线程转换为非阻塞状态</li><li>当线程等待另一个线程通知调度器出现某个条件时, 线程进入等待状态, 阻塞状态和等待状态没有太大的区别. 调用<code>Object.wait(), Thread.join()</code>, 或者等待<code>java.util.concurrent</code>中的<code>Lock, Condition</code>时会进入等待状态</li><li>有几个方法有超时参数, 调用这些方法会让线程进入计时等待状态, 这个状态将会一直保持到计时器满, 或者接收到适当通知. 带有超时参数的方法有<code>Thread.sleep()</code>和计时版的<code>Object.wait(), Thread.join(), Lock.tryLock(), Condition.await()</code></li></ul></li></ul><h3 id="Terminated"><code>Terminated</code></h3><ul><li>由于<code>run()</code>正常退出, 线程自然终止</li><li>因为一个没有捕获的异常终止<code>run()</code>, 线程意外终止</li><li><code>stop()</code>会抛出一个<code>ThreadDeath</code>错误对象, 终止线程, 但是现在已经废弃不用</li></ul><h2 id="线程的属性">线程的属性</h2><h3 id="中断线程">中断线程</h3><ul><li>当线程执行了最后一条语句, 或者抛出了一个没有捕获的异常, 线程就会终止</li><li><code>stop()</code>可以强制停止, 但是已经废弃, 现在没有方法可以强制停止一个线程</li><li>可以使用<code>interrupt()</code>请求终止一个线程, 对一个线程调用<code>interrupt()</code>, 设置线程为中断状态, 每个线程都会不时检测这个<code>boolean</code>标志, 判断线程是否被中断了<ul><li>使用<code>Thread.currentThread().isInterrupted()</code>判断当前线程是否处于中断状态</li><li>如果线程被阻塞, 就无法查看中断状态, 需要引入<code>InterruptedException</code></li><li>在一个被<code>sleep(), wait()</code>阻塞的线程上调用<code>interrupt()</code>, 那个阻塞调用将被<code>InterruptedException</code>中断</li><li>如果在线程循环中调用了<code>sleep()</code>, 就没有必要使用<code>isInterrupted()</code>检测了, 因为如果设置了中断状态, <code>sleep()</code>也只会清除中断装填并直接抛出<code>InterruptedException</code>, 所以还要循环调用了<code>sleep()</code>, 可以直接<code>try-catch``InterruptedException</code></li></ul></li></ul><div class="note info flat"><ul><li><code>interrupted()</code>是一个静态方法, 检查当前线程是否被中断, 调用该方法会清除该线程中断状态</li><li><code>isInterrupted()</code>是一个实例方法, 检查是否有线程被中断, 不会清除线程中断状态</li></ul></div><ul><li>如果<code>catch(InterruptedException e)</code>没有什么需要做的, 可以<code>Thread.currentThread().interrupt()</code>设置中断状态, 或者直接不<code>try-catch</code>, 而是<code>throws InterruptedException</code></li></ul><h3 id="守护线程">守护线程</h3><ul><li><code>t.setDaemon(true)</code>将一个线程转换为守护线程, 唯一的作用是为其他线程提供服务</li><li>比如计时器线程, 或者清空过时缓存项的线程, 如果只剩下守护线程, <code>JVM</code>就会退出, 因为只有守护线程就没有必要运行程序了</li></ul><h3 id="线程名">线程名</h3><ul><li><code>t.setName(&quot;Name&quot;);</code>可以为任何线程设置一个名字</li></ul><h3 id="未捕获异常的处理器">未捕获异常的处理器</h3><ul><li>线程的<code>run()</code>不能抛出任何检查型异常, 如果有非检查型异常则会导致线程终止, 最终线程死亡</li><li>对于可以传播的异常, 也没有<code>catch</code>子句, 因为在线程死亡之前, 异常会传递到一个用于处理未捕获异常的处理器</li><li>这个处理器必须属于实现了<code>Thread.UncaughtExceptionHelper</code>接口的类, 接口只有一个方法<code>void uncaughtException(Thread t, Throwable e);</code></li><li>可以调用<code>setUncaughtExceptionHandler()</code>为任何线程设置处理器, 也可以使用静态方法<code>Thread.setDefaultUncaughtExceptionHandler()</code>为所有线程安装一个默认处理器</li><li>如果没有安装默认处理器, 则为<code>null</code>, 如果没有为单个线程安装处理器, 则处理器就是该线程的<code>ThreadGroup</code>对象</li><li>建议不要在自己的程序中使用线程组</li><li><code>ThreadGroup</code>类实现了<code>Thread.UncaughtExceptionhandler</code>接口, <code>uncaughtException()</code>执行以下操作<ul><li>如果该线程组有父线程组, 调用父线程组的<code>uncaughtExcpeiton()</code></li><li>否则, 如果<code>Thread.getDefaultUncaughtExceptionHandler()</code>返回一个非<code>null</code>的处理器, 则调用该处理器</li><li>否则, 如果<code>Throwable</code>是<code>ThreadDeath</code>的一个实例, 则什么都不做</li><li>否则, 将线程的名字以及<code>Throwable</code>的栈轨迹输出到<code>System.err</code></li></ul></li></ul><h3 id="线程优先级">线程优先级</h3><ul><li>每个线程都有一个优先级, 默认一个线程会继承构造他的线程的优先级</li><li>可以使用<code>setPriority()</code>设置优先级, <code>MIN_PRIORITY = 1</code>, <code>MAX_PRIORITY = 10</code>, <code>NORM_PRIORITY = 5</code></li><li>调度器选择新的线程时优先选择优先级高的线程, 优先级高度依赖于系统</li><li>早期优先级可能很有用, 现在不要使用线程优先级</li></ul><h2 id="同步">同步</h2><ul><li><code>javap -c -p xxx</code>可以反编译<code>xxx.class</code>, 查看虚拟机字节码</li><li>两种机制可以防止并发访问一个代码块, <code>synchronized</code>关键字和<code>Java 5</code>引入的<code>ReentrantLock</code>类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">myLock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    myLock.unLock();</span><br><span class="line">    <span class="comment">// 一定需要将unLock()放在finally中, 不然抛出异常退出将永远阻塞</span></span><br><span class="line">    <span class="comment">// 使用锁时不能使用try-with-resources</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>如果两个线程尝试访问同一个对象, 可以保证串行化访问; 如果两个线程访问不同的对象, 每个线程都会得到不同的锁对象, 两个线程都不会阻塞</p><ul><li>这个锁称为重入锁, 因为线程可以反复获得已经拥有的锁, 锁持有一个计数器跟踪对<code>lock</code>方法的嵌套调用</li><li><code>ReentrantLock(boolean fail)</code>可以构造一个采用公平策略的锁, 但是公平锁比常规锁慢的多, 而且就算使用公平锁, 也不能保证就可以公平处理</li></ul></li><li><p>线程进入临界区以后发现需要满足某个条件才能继续执行, 可以使用条件对象(条件变量)管理那些已经获得锁但是不能有效工作的线程</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">    bankLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (accounts[from] &lt; amout) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        bankLock.unLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果from账户中没有钱, 则while会一直循环, 一直持有锁, 别的线程无法充钱</span></span><br><span class="line"><span class="comment">// 可以使用newCondition()获得一个条件对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Condition sufficientFunds;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bank</span><span class="params">()</span> &#123;</span><br><span class="line">        sufficientFunds = bankLock.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果transfer()发现没有钱, 会调用sufficientFunds.await(), 当前线程暂停, 放弃锁, 其他线程可以执行</span></span><br><span class="line"><span class="comment">// 一旦一个线程调用了await(), 就进入了这个条件的等待集</span></span><br><span class="line"><span class="comment">// 锁可用时, 这个线程也不会变成可运行状态, 而是仍然保持非活动状态, 直到另一个线程在同一个条件上调用signalAll()</span></span><br></pre></td></tr></table></figure><ul><li><code>signalAll()</code>会重新激活所有满足条件的线程, 从等待集中移出, 再次变为可运行状态</li><li><code>await()</code>一般放在一个循环中<code>while(!(OK is proceed)) condition.await()</code></li><li>最终都需要有一个其他线程调用<code>signalAll()</code>, 因为当一个线程调用<code>await()</code>时, 没有办法自行激活<ul><li>如果没有别的线程调用<code>signalAll()</code>, 将永远阻塞, 导致死锁</li><li>只要一个对象状态有变化, 并且可能有利于正在等待的线程, 就可以调用<code>signalAll()</code></li><li><code>signal()</code>可以随机选择等待集的一个线程, 解除其阻塞状态, 比解除所有线程阻塞状态更加高效</li><li>但是如果随机解除阻塞状态的线程发现自己仍然无法运行, 就会再次阻塞, 此时没有其他线程调用<code>signal()</code>以后就会导致死锁</li></ul></li></ul><h3 id="synchronized"><code>synchronized</code></h3><ul><li><p>锁用来保护代码段, 一次只允许一个线程执行被保护的代码段</p></li><li><p>锁可以用来管理试图进入被保护的代码段的线程</p></li><li><p>一个锁可以有一个或者多个关联的条件对象</p></li><li><p>每个条件对象管理那些已经进入被保护代码段, 但是还不能执行的线程</p></li><li><p>如果一个方法声明时有<code>synchronized</code>关键字, 则对象的锁将会保护整个方法, 所以如果需要调用这个方法, 则线程必须获得内部对象锁</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    method body</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.intrinsicLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        method body</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.intrinsicLock.unLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>内部对象锁只有一个关联条件, <code>wait()</code>将一个线程添加到等待集, <code>notifyAll(), notify()</code>可以解除等待集线程阻塞</p></li><li><p>内部锁和条件存在一些限制</p><ul><li>不能中断一个正在尝试获得锁的线程</li><li>不能指定尝试获得锁的线程超时时间</li><li>没有锁只有一个条件对象, 比较低效</li></ul></li></ul><h3 id="同步块">同步块</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(obj) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 就获得了obj的锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bank</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span>[] accounts;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">            accounts[from] -= amount;</span><br><span class="line">            accounts[to] += amount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 但是如果是</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="string">&quot;lock&quot;</span>;</span><br><span class="line"><span class="keyword">synchronized</span> (lock) &#123;...&#125;</span><br><span class="line"><span class="comment">// 这里如果两个线程使用将会锁同一个对象, 因为字符串字面量会共享, 最终导致死锁</span></span><br><span class="line"><span class="comment">// 同时需要避免基本包装类型作为锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">lock</span> <span class="operator">=</span> Integer.valueOf(<span class="number">42</span>);</span><br><span class="line"><span class="comment">// 如果同一个数使用两次, 将会导致共享锁</span></span><br><span class="line"><span class="comment">// 如果需要修改一个静态字段, 会从特定的类上获得锁, 而不是从getClass()返回值上获得</span></span><br><span class="line"><span class="keyword">synchronized</span>(MyClass.class) &#123;...&#125; <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">synchronized</span>(getClass()) &#123;...&#125; <span class="comment">// Error</span></span><br><span class="line"><span class="comment">// 如果从一个子类调用这个方法, getClass()会返回一个不同的class对象, 不能保证互斥了</span></span><br></pre></td></tr></table></figure><h3 id="监视器">监视器</h3><ul><li>监视器是指包含私有字段的类</li><li>监视器类的每个对象都有一个关联的锁</li><li>所有方法由这个锁锁定, 如果客户端调用<code>obj.method()</code>, 调用开始时就会自动获得<code>obj</code>对象的锁, 并且在返回时自动释放这个锁<ul><li>因为所有的字段都是私有的, 这样就可以保证一个线程处理字段时, 其他线程都无法访问</li></ul></li><li>锁可以有任意多个关联的条件</li></ul><h3 id="volatile"><code>volatile</code></h3><ul><li>如果写一个对象, 这个对象接下来可能被另一个线程读取; 或者读一个对象, 这个对象可能已经被另一个线程写入, 就必须使用同步</li><li><code>volatile</code>关键字为实例字段的同步访问提供了一种免锁机制</li><li>如果声明一个字段时<code>volatile</code>, 那编译器或虚拟机就会考虑这个字段可能被另一个线程并发更新</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> done;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span> &#123;<span class="keyword">return</span> done;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setDone</span><span class="params">()</span> &#123;done = <span class="literal">true</span>;&#125;</span><br><span class="line"><span class="comment">// 如果另一个线程已经对该对象加锁, isDone()和setDone()就会被阻塞</span></span><br><span class="line"><span class="comment">// 可以声明为volatile</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> done;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span> &#123;<span class="keyword">return</span> done;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDone</span><span class="params">()</span> &#123;done = <span class="literal">true</span>;&#125;</span><br><span class="line"><span class="comment">// 但是volatile不能保证原子性</span></span><br></pre></td></tr></table></figure><h3 id="final变量"><code>final</code>变量</h3><ul><li><code>final var accounts = new HashMap&lt;String, Double&gt;()</code>声明为<code>final</code>以后, 其他线程会在构造器完成构造以后才能看到这个<code>accounts</code></li><li>如果不使用<code>final</code>, 不能保证其他线程看到的是<code>accounts</code>更新以后的值, 可能都只是<code>null</code>, 而不是信构造的<code>HashMap</code></li></ul><h3 id="原子性">原子性</h3><ul><li>假设对共享变量除了赋值以外不做其他操作, 可以使用<code>volatile</code></li><li><code>java.util.concurrent.atomic</code>包中包含很多原子操作, 使用了机器指令, 没使用锁<ul><li><code>AtomicInteger</code>类中包含<code>incrementAndGet, decrementAndGet</code>以原子方式对一个整数完成自增自减</li></ul></li><li>如果有大量的线程要访问相同的原子值, 性能会大幅度下降, 因为乐观更新需要叫多次重试<ul><li><code>LongAdder</code>和<code>LongAccumulator</code>类解决了这个问题</li></ul></li></ul><h3 id="stop-和-suspend"><code>stop()</code> 和 <code>suspend()</code></h3><ul><li><code>stop()</code>方法就不安全, 会终止所有未完成的方法, 包括<code>run()</code><ul><li>一个线程终止时, 会立即释放被它锁定的对象的锁, 导致对象处于不一致状态</li></ul></li><li><code>suspend()</code>不会破坏对象, 但是如果用来挂起一个持有锁的线程, 在这个线程恢复运行之前这个锁不可用<ul><li>如果调用<code>suspend()</code>的线程试图获得同一个锁, 那么就会导致死锁问题</li></ul></li></ul><h3 id="按需初始化">按需初始化</h3><ul><li><code>JVM</code>会在第一次使用类时初始化一个静态初始化器, 并且只会执行一次</li><li><code>JVM</code>利用一个锁来确保这一点, 但是需要确保构造器不会抛出任何异常</li></ul><h3 id="线程局部变量">线程局部变量</h3><ul><li><p>如果一个类中设置静态变量</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">final</span> <span class="type">SimpleDateFormat</span> <span class="variable">dataFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-mm-dd&quot;</span>);</span><br><span class="line"><span class="comment">// 如果此时两个线程都执行如下操作</span></span><br><span class="line"><span class="type">String</span> <span class="variable">dataStamp</span> <span class="operator">=</span> dataFormat.format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"><span class="comment">// 则dataFormat的内部结构可能会被破坏</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; dataFormat = ThreadLocal.withInitial() -&gt; <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-mm-dd&quot;</span>);</span><br><span class="line"><span class="comment">// 如果需要格式化方法, 可以调用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">dataStamp</span> <span class="operator">=</span> dataFormat.get().format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br></pre></td></tr></table></figure></li><li><p><code>java.util.Random</code>是线程安全的, 但是如果多个线程需要等待一个共享随机数生成器, 就很低效</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">random</span> <span class="operator">=</span> ThreadLocalRandom.current().nextInt(upperBound);</span><br><span class="line"><span class="comment">// ThreadLocalRandom.current()会返回当前线程的一个随机数实例</span></span><br></pre></td></tr></table></figure></li><li><p>如果需要共享一个数据库连接</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Connection&gt; connection = ThreadLocal.withInitial(() -&gt; <span class="literal">null</span>);</span><br><span class="line"><span class="comment">// 任务开始时可以初始化这个连接</span></span><br><span class="line">connection.set(connect(url, username, password));</span><br><span class="line"><span class="comment">// 任务调用某些方法, 所有方法都在一个线程, 其中一个方法需要这个连接</span></span><br><span class="line"><span class="type">var</span> <span class="variable">result</span> <span class="operator">=</span> connection.get().executeQuery(query);</span><br></pre></td></tr></table></figure></li><li><p>上述都要求只有一个任务使用线程, 如果是一个线程池执行任务, 可能不想共享相同线程的其他任务提供数据库连接, 就不能使用上述方法</p></li></ul><h2 id="线程安全的集合">线程安全的集合</h2><ul><li>有的并发散列表映射较大, 使用<code>size()</code>返回<code>int</code>类型, 如果超过了20亿则无法正常返回, 可以使用<code>mappingCount()</code>方法返回<code>long</code>类型数据</li><li>集合返回弱一致性迭代器, 表示迭代器不一定能够反映出构造之后所做的全部更改, 但是他们不会将同一个值返回两次, 也不会抛出<code>ConcurrentModificationException</code></li><li><code>java.util</code>包中的集合, 如果集合在迭代器构造之后发生改变, 将会抛出一个``ConcurrentModificationException`</li><li><code>ConcurrentHashMap</code>不允许有<code>null</code>, 如果传入<code>compute, merge</code>的函数返回<code>null</code>, 就会从映射中删除现有的条目</li></ul><h3 id="并发散列映射的批操作">并发散列映射的批操作</h3><ul><li><p>批操作会遍历映射映射, 处理遍历过程中找到的元素, 不会冻结映射的当前快照</p><ul><li>搜索<code>search</code>: 为每个键或值应用一个函数, 直到函数生成一个非<code>null</code>的结果, 然后函数终止, 返回这个结果</li><li>规约<code>reduce</code>: 组合所有的键值, 这里要使用所提供的一个累加函数</li><li><code>forEach</code>为所有键值应用一个函数</li></ul></li><li><p>所有操作都需要指定一个参数化阈值, 如果希望批操作在一个线程中运行, 可以使用<code>Long.MAX_VALUE</code>, 如果希望用尽可能多的线程运行批操作, 可以使用阈值1</p></li><li><p>希望找到出现次数超过1000次的单词:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> map.search(threshold, (k, v) -&gt; v &gt; <span class="number">1000</span> ? k : <span class="literal">null</span>);</span><br><span class="line"><span class="comment">// res最终是第一个匹配的单词, 如果所有单词都不匹配, 则res是null</span></span><br></pre></td></tr></table></figure></li><li><p><code>forEach</code>有两种形式, 第一种是为每个条目应用一个消费者函数</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.forEach(threshold, (k, v) -&gt; System.out.println(k + <span class="string">&quot;-&gt;&quot;</span> + v));</span><br></pre></td></tr></table></figure></li><li><p>第二种形式接受一个额外的转换器, 先应用转换器, 再传递到消费者函数</p></li><li><p>比如只打印很大的条目:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map.forEach(threshold, </span><br><span class="line">    (k, v) -&gt; v &gt; <span class="number">1000</span> ? k + <span class="string">&quot;-&gt;&quot;</span> + v : <span class="literal">null</span>,</span><br><span class="line">    System.out::prinln);</span><br></pre></td></tr></table></figure></li><li><p><code>reduce</code>操作用一个累加函数组合输入, 比如计算所有值的总和</p><ul><li><code>Long sum = map.reduceValues(threshold, Long::sum);</code></li></ul></li><li><p>同样可以使用一个转换器函数, 比如计算最长的键的长度</p><ul><li><code>Integer mLen = map.reduceKeys(threshold, String::length, Integer::max);</code></li></ul></li><li><p><code>CopyOnWriteArrayList</code>和<code>CopyOnWriteArraySet</code>是线程安全的集合, 所有更改器会建立底层数组的副本</p><ul><li>如果迭代访问集合的线程数超过更改集合的线程数, 这个更改就很有用</li><li>构造一个迭代器, 包含对当前数组的引用, 如果这个数组后来被更改了, 迭代器仍然会引用原来的数组, 尽管集合的数组已经被替换了, 所以迭代器可以访问一致, 但是过时的视图, 并不存在同步开销</li></ul></li></ul><h3 id="并行数组算法">并行数组算法</h3><ul><li><p><code>Arrays</code>提供了大量的并行化操作, 比如<code>Arrays.parallelSort()</code>可以对一个基本类型或对象数组排序</p><ul><li>对对象数组排序, 可以提供一个<code>Comparator</code>数组 <code>Arrays.parallelSort(words, Comparator.comparing(String::length));</code></li></ul></li><li><p>任何集合类都可以使用同步包装器变成线程安全的</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;E&gt; synchArrayList = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;E&gt;());</span><br><span class="line">Map&lt;K, V&gt; synchHashMap = Collections.synchronizedMap(New HashMap&lt;K, V&gt;());</span><br></pre></td></tr></table></figure><ul><li>得到的集合方法会使用一个锁加以保护</li><li>如果希望迭代访问一个集合, 同时另一个线程仍然可能修改这个集合, 就要使用客户端锁定</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(synchHashMap) &#123;</span><br><span class="line">    Iterator&lt;K&gt; iter = synchHashMap.keySet().iterator();</span><br><span class="line">    <span class="keyword">while</span>(iter.hasNext()) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="任务和线程池">任务和线程池</h2><ul><li>如果程序中使用了大量生命周期很短的线程, 不能将每个任务映射到一个单独的线程, 而是应该使用一个线程池</li></ul><h3 id="Callable-Future"><code>Callable</code>, <code>Future</code></h3><ul><li><code>Runnable</code>封装了一个异步运行任务, 可以想象成一个没有参数和返回值的异步方法</li><li><code>Callable</code>与<code>Runnable</code>相似, 只是有返回值, <code>Callable</code>是一个参数化接口, 只有一个方法<code>call</code>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line">    V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>Future</code>可以保存异步计算的结果, 可以启动一个计算, 将<code>Future</code>对象交给某个方法, 然后忘掉他</li><li>计算得到结果的时候, <code>Future</code>对象的所有者就会得到这个结果</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Future接口具有下面的方法</span></span><br><span class="line">V <span class="title function_">get</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// get()调用会阻塞, 直到计算完成</span></span><br><span class="line">V <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span>;</span><br><span class="line"><span class="comment">// 同样会阻塞, 不过如果超时了就会抛出一个TimeoutException</span></span><br><span class="line"><span class="comment">// 如果运行该计算的线程被中断, 两个方法都会抛出InterruptedException, 如果计算完成, 则get()立即返回</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 如果计算还在进行, 则isDone()返回false</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterrupt)</span>;</span><br><span class="line"><span class="comment">// cancel()取消计算, 如果计算还没有开始, 则永远不会开始了</span></span><br></pre></td></tr></table></figure><ul><li><p>取消一个任务涉及两个步骤, 找到并中断底层线程, <code>call()</code>方法中必须感知到中断, 并放弃工作</p></li><li><p>可以使用<code>FutureTask</code>执行<code>Callable</code>, 实现了<code>Future</code>和<code>Runnable</code>接口</p></li><li><p>也可以将一个<code>Callable</code>传递到执行器来执行</p></li><li><p><code>newCachedThreadPool()</code>构造一个线程池, 立即执行各种任务, 如果有空线程可以使用, 就使用空线程, 如果没有就创建</p></li><li><p><code>newFixedThreadPool()</code> 构造一个大小固定的线程池, 如果提交任务数大于空线程数, 没有得到服务的任务就放到队列中</p></li><li><p><code>newSingleThreadPool()</code> 退化的大小为1的线程池, 顺序执行所提交的任务</p></li><li><p>上述三个方法返回一个实现了<code>ExecutorService</code>接口的<code>ThreadPoolExecutor</code>类的对象</p></li><li><p>如果线程生存期很短, 或者大量时间都在阻塞, 可以使用一个缓存线程池</p></li><li><p>为了得到最优的运行速度, 并发线程数等于处理器内核个数, 这种情况应该使用固定线程池, 这样并发线程总数会有一个上限</p></li><li><p>单线程执行器对性能测试有帮助, 可以临时使用一个单线程池替换固定线程池, 测试不并发的情况下性能降低的量</p></li><li><p>使用线程池时所做的工作:</p><ul><li>调用<code>Executors</code>类的静态方法<code>newCachedTreadPool</code>或<code>newFixedThreadPool</code></li><li>调用<code>submit</code>提交<code>Runnable</code>或<code>Callable</code>对象</li><li>保留返回的<code>Future</code>对象, 以便得到结果或者取消任务</li><li>不想再提交任务时可以调用<code>shutdown</code></li></ul></li><li><p><code>invokeAny</code>提交一个<code>Callable</code>对象集合中的所有对象, 并返回某一个已经完成任务的结果, 不知道会返回哪个, 一般都是速度最快的</p></li><li><p>对于搜索问题, 可以使用这个方法</p></li><li><p><code>invokeAll</code>提交一个<code>Callable</code>对象集合中的所有对象, 方法阻塞, 直到所有任务都完成了, 并返回一个<code>Future</code>对象列表, 包含所有答案</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Callable&lt;T&gt;&gt; tasks = ...;</span><br><span class="line">List&lt;Future&lt;T&gt;&gt; res = executor.invokeAll(tasks);</span><br><span class="line"><span class="keyword">for</span> (Future&lt;T&gt; r: res) &#123;</span><br><span class="line">processFuture(r.get());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// get()方法会阻塞, 直到获得了一个结果</span></span><br></pre></td></tr></table></figure></li><li><p>可以使用<code>ExecutorCompletionService</code>管理, 将任务提交到这个完成服务中, 服务会管理一个<code>Future</code>对象的阻塞队列\</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExecutorCompletionService</span>&lt;T&gt;(executor);</span><br><span class="line"><span class="keyword">for</span> (Callable&lt;T&gt; task: tasks) service.submit(task);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tasks.size(); i ++) &#123;</span><br><span class="line">processFuture(service.task().get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>有的应用使用大量线程, 但是大部分是空闲的</p><ul><li>比如服务器为每个连接使用一个线程;</li><li>或者处理器内核使用一个线程执行计算密集型任务, 比如图像或者视频处理</li><li><code>Java 7</code>引入了<code>fork-join</code>框架支持后一类应用</li><li>比如一个任务可以分解为两个子任务分别计算, 需要扩展<code>Recursive&lt;T&gt;</code>的类, 或者扩展<code>RecursiveAction</code>的类</li><li>前者生成一个<code>T</code>结果, 后者不生成结果, 再覆盖<code>compute()</code>生成并调用子任务, 合并结果</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> <span class="keyword">extends</span> <span class="title class_">Recuresive</span>&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (to - from &lt; THRESHOLD) &#123;</span><br><span class="line">...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>后台中, <code>fork-join</code>框架使用了工作密取的启发式方法平衡可用线程的工作负载, 每个工作线程都有任务的一个双端队列<ul><li>一个工作线程将子任务压入双端队列的队头, 只有一个线程可以访问队头, 所以不需要加锁</li><li>一个工作线程空闲时, 会从另一个双端队列的队尾密取一个任务, 由于大的子任务都在队尾, 这种密取很少见</li><li><code>fork-join</code>是对非阻塞任务进行负载优化的, 对于阻塞任务就失效了, 需要使用<code>ForkJoinPool.ManagedBlocker</code>接口解决这个问题</li></ul></li></ul><h2 id="异步计算">异步计算</h2><h3 id="可完成Future">可完成<code>Future</code></h3><ul><li>如果有一个<code>Future</code>对象, 需要调用<code>get()</code>获得值, 方法会阻塞, 直到值可以使用</li><li><code>CompletableFuture</code>类实现了<code>Future</code>接口, 可以注册一个回调, 一旦结果可用, 就会在某个线程中利用该结果调用这个回调</li><li>采用这种方法, 一旦结果可用就可以对结果进行处理, 而不需要阻塞</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title function_">readPage</span><span class="params">(Url url)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UncheckedIOException</span>(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;, executor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果省略executor, 任务会在ForkJoinPool.commonPool()返回的执行器上运行</span></span><br><span class="line"><span class="comment">// supplyAsync()第一个参数是Supplier&lt;T&gt;, 而不是Callable&lt;T&gt;, 这两个接口都描述了无参并且返回类型为T的函数</span></span><br><span class="line"><span class="comment">// Supplier&lt;T&gt;允许抛出检查型异常, 但是Callable&lt;T&gt;不允许</span></span><br></pre></td></tr></table></figure><h2 id="进程">进程</h2><ul><li>有时候需要执行另一个程序, 可以使用<code>ProcessBuilder, Process</code>类<ul><li><code>Process</code>类在单一操作系统进程中执行一个命令</li><li><code>ProcessBuilder</code>类允许配置<code>Process</code>对象, 可以取代<code>Runtime.exec</code>调用</li></ul></li></ul><h3 id="创建进程">创建进程</h3><ul><li>指定需要执行的命令, 或者传入一个<code>List&lt;String&gt;</code><br><code>var builder = new ProcessBuilder(&quot;gcc&quot;, &quot;myapp.c&quot;);</code></li><li>可以使用<code>directory</code>改变工作目录<br><code>builder = builder.directory(path.toFile());</code></li><li>然后需要指定处理进程的标准输入, 输出, 错误流, 默认情况分别是一个管道  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OutputStream</span> <span class="variable">processIn</span> <span class="operator">=</span> p.getOutputStream();</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">processOut</span> <span class="operator">=</span> p.getInputStream();</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">processErr</span> <span class="operator">=</span> p.getErrorStream();</span><br></pre></td></tr></table></figure></li><li>如果希望使用管道将一个进程的输出作为另一个进程的输入, 可以使用<code>Java 9</code>提供的<code>startpipeline()</code></li></ul><h3 id="进程句柄">进程句柄</h3><ul><li>可以用四种方法得到一个<code>ProcessHandler</code></li></ul><ol><li>给定一个<code>Process</code>对象<code>p</code>, <code>p.toHandler()</code>会生成他的<code>ProcessHandler</code></li><li>给定一个<code>Long</code>类型的进程<code>ID</code>, <code>ProcessHandler.of(ID)</code>可以生成这个进程的句柄</li><li><code>Process.current()</code>是运行这个<code>JVM</code>的进程句柄</li><li><code>ProcessHandler.allProcesses()</code>可以生成对当前进程可见的所有操作系统进程的<code>Stream&lt;ProcessHandler&gt;</code></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java核心技术(卷一) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记_12</title>
      <link href="/posts/eac9e365.html"/>
      <url>/posts/eac9e365.html</url>
      
        <content type="html"><![CDATA[<h1>集合</h1><h2 id="Collection接口"><code>Collection</code>接口</h2><ul><li>集合类的基本接口是<code>Collection</code>接口, 有两个基本方法  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Collection</span>&lt;E&gt; &#123;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E element)</span>;</span><br><span class="line">Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">E <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> E&gt; action)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果到达末尾依然调用next(), 会抛出NoSuchElementException</span></span><br><span class="line"><span class="comment">// remove()会删除上一次调用next()返回的元素</span></span><br><span class="line"><span class="comment">// remove()和next()有依赖性, 如果不先调用next(), 会抛出IllegalStateException</span></span><br><span class="line"><span class="comment">// 如果需要删除两个元素</span></span><br><span class="line">it.next();</span><br><span class="line">it.remove();</span><br><span class="line">it.next();</span><br><span class="line">it.remove();</span><br></pre></td></tr></table></figure></li></ul><h3 id="LinkedList"><code>LinkedList</code></h3><ul><li>对于<code>LinkedList</code>, 还存在一个<code>previous()</code>, 支持从后往前遍历</li><li>如果调用了<code>previous()</code>, 则<code>remove</code>或<code>set</code>将修改右边的元素</li><li>如果有两个迭代器, 一个修改元素, 另一个在遍历元素, 就会产生错误, 抛出<code>ConcurrentModificationException</code><ul><li>这里的修改只有增加或删除<code>add(), remove()</code>, <code>set()</code>不会引发错误</li></ul></li><li><code>LinkedList</code>的<code>get()</code>方法不是随机访问, 因为是链表格式, 只是做了一点优化, 如果索引大于<code>n / 2</code>, 则从后往前调用<code>previous()</code>访问</li></ul><h3 id="ArrayList"><code>ArrayList</code></h3><ul><li>支持动态数组, 并且不是同步的</li><li><code>Vector</code>也是动态数组, 但是是同步的, 如果只有一个线程访问<code>Vector</code>, 会在同步操作上花费大量时间, 此时用<code>ArrayList</code>会比较好</li></ul><h3 id="散列表">散列表</h3><ul><li><code>Java</code>中散列表使用<code>LinkedList</code>实现, 每个列表称为一个桶</li><li>先计算一个对象的散列码, 然后与桶的个数取余, 得到的就是存储桶的索引</li><li><code>Java 8</code>中, 桶满了会从链表转换为平衡二叉树</li><li>散列表的键要尽可能属于实现了<code>Comparable</code>接口的类, 这样可以避免散列码分布不均的问题</li><li>桶的个数一般设计为预计元素个数的<code>75%~150%</code>, 默认桶个数是16个</li><li>默认装填因子是0.75, 也就是当哈希表中已经转满了75%就会触发再散列</li></ul><h3 id="TreeSet"><code>TreeSet</code></h3><ul><li><code>TreeSet</code>是一个有序集合, 使用红黑树实现</li><li>插入元素比普通散列表慢, 但是查找一个元素只需要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">log_2(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>因为是有序的, 所以其中的元素必须实现了<code>Comparable</code>接口</li></ul><h2 id="Map"><code>Map</code></h2><ul><li>同样分为<code>HashMap</code>, <code>TreeMap</code></li></ul><h3 id="更新">更新</h3><ul><li><code>counts.put(word, counts.get(word) + 1)</code>, 可能<code>word</code>本身不存在, 会抛出<code>NullPointerException</code></li><li><code>counts.put(word, counts.getOrDefault(word, 0) + 1);</code></li><li><code>counts.putIfAbsent(word, 0)</code>, 表示如果<code>word</code>不存在, 则赋值为0, 然后调用<code>put</code>即可正常更新, 避免<code>null</code></li><li>也可以使用<code>merge</code>简化操作, <code>counts.merge(word, 1, Integer::sum)</code><ul><li>如果<code>word</code>不存在, 就设置为1</li><li>如果存在, 就使用<code>Integer::sum</code>设置为<code>word</code>与1的求和</li></ul></li></ul><h2 id="视图">视图</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; keys = map.keySet();</span><br><span class="line"><span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, E&gt; entry : map.entrySet()) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">k</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line"><span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> entry: map.entrySet) &#123;</span><br><span class="line">..</span><br><span class="line">&#125;</span><br><span class="line">map.forEach((k, v) -&gt; &#123;</span><br><span class="line">...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>可以在视图上调用<code>remove()</code>删除散列表的元素, 但是不能添加元素</li><li><code>keySet</code>方法返回了一个<code>Set</code>接口的类对象</li></ul><h2 id="WeakHashMap"><code>WeakHashMap</code></h2><ul><li>如果一个<code>HashMap</code>中删除了元素, 但是因为<code>HashMap</code>还在使用, 所以<code>GC</code>不会释放这个元素的空间</li><li>因此使用<code>WeakHashMap</code>可以释放删除元素的空间, 使用弱引用保存键</li></ul><h2 id="LinkedHashSet-与-LinkedHashMap"><code>LinkedHashSet</code> 与 <code>LinkedHashMap</code></h2><ul><li>会记住插入元素的顺序, 在元素加入哈希表后, 会添加到<code>LinkedList</code>双向链表中</li></ul><h2 id="EnumSet"><code>EnumSet</code></h2><ul><li>使用位序列实现, 如果对应的值出现了, 则在相应的位置设为1</li><li>没有公共构造器, 要使用静态工厂方法构造  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Weekday</span> &#123;MONDAY, TUESDAY, ...&#125;;</span><br><span class="line">EnumSet&lt;Weekday&gt; always = EnumSet.allOf(Weekday.class);</span><br><span class="line">EnumSet&lt;Weekday&gt; never = EnumSet.noneOf(Weekday.class);</span><br></pre></td></tr></table></figure></li></ul><h2 id="标识散列映射">标识散列映射</h2><ul><li><code>IdentityHashMap</code>, 键的散列值不是通过<code>hashCode()</code>计算得到, 而是使用<code>System.indentityHashCode()</code>计算</li><li><code>Object.hashCode()</code>计算散列码就使用这个方法, 比较两个对象, <code>IdentityHashMap</code>使用<code>==</code>, 而不是<code>equals</code></li></ul><h2 id="小集合">小集合</h2><ul><li><p><code>Java 9</code>引入了一些静态方法, 可以生成给定元素的集合或列表, 以及给定的键值对</p><ul><li><code>List&lt;String&gt; names = List.of(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;);</code></li><li><code>Set&lt;Integer&gt; nums = Set.of(1, 2, 3);</code></li><li><code>Map&lt;String, Integer&gt; m = Map.of(&quot;1&quot;, 1, &quot;2&quot;, 2, &quot;3&quot;, 3);</code></li></ul></li><li><p><code>List, Set</code>有11个<code>of</code>方法, 还有一个参数可变的<code>of</code>方法, 这样是为了提高效率</p></li><li><p><code>Map</code>没有这个参数可变的版本, 因为参数类型会交替为键类型和值类型</p><ul><li>不过有一个<code>ofEntries</code>, 可以接受任意多个<code>Map.Entry&lt;K, V&gt;</code>对象<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Stirng, Integer&gt; socres = ofEntries(</span><br><span class="line">entry(<span class="string">&quot;1&quot;</span>, <span class="number">1</span>),</span><br><span class="line">entry(<span class="string">&quot;2&quot;</span>, <span class="number">2</span>),</span><br><span class="line">entry(<span class="string">&quot;3&quot;</span>, <span class="number">3</span>));</span><br></pre></td></tr></table></figure></li></ul></li><li><p>集合对象是不可修改的, 会导致<code>UnsupportedOperationException</code></p></li><li><p>如果需要一个可修改的集合, 可以把这个不可修改的集合传递到构造器中 <code>var names = new ArrayList&lt;&gt;(List.of(&quot;1&quot;, &quot;2&quot;));</code></p></li><li><p><code>Collections.nCopies(n, anObject)</code>会返回一个实现了<code>List</code>接口的不可变对象</p><ul><li><code>List&lt;String&gt; settings = Collections.nCopies(100, &quot;DEFAULT&quot;);</code></li><li>这样构造包含了100个<code>&quot;DEFAULT&quot;</code>的<code>List</code>, 存储开销很小, 对象只会存储一次</li></ul></li><li><p><code>Array.asList</code>会返回一个可以更改, 但是大小不可改变的列表, 即可以调用<code>set()</code>, 但是不能使用<code>add(), remove()</code></p></li></ul><h3 id="不可修改的副本和视图">不可修改的副本和视图</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; names = ...</span><br><span class="line">Set&lt;String&gt; nameSet = Set.copyOf(names);</span><br><span class="line">List&lt;String&gt; nameList = List.copyOf(names);</span><br><span class="line"><span class="comment">// 每个copyOf()方法会建立集合的一个副本, 修改了原集合这个副本不会受到影响</span></span><br><span class="line"><span class="comment">// 如果原集合正好不可修改, 则copyOf会直接返回原集合</span></span><br></pre></td></tr></table></figure><h2 id="同步视图">同步视图</h2><ul><li><p>如果多个线程访问集合, 一个在修改, 另一个在查看, 结果会发生错误</p></li><li><p><code>synchronizedMap()</code>可以将任何一个映射转换成有同步访问方法的<code>Map</code></p><ul><li><code>var map = Collections.synchronizedMap(new HashMap&lt;String, Integer&gt;());</code></li><li>这样, <code>get(), put()</code>方法就是同步的, 只有一个执行完了才会调用另一个</li></ul></li><li><p>对链表排序可以使用归并排序, 但是<code>Java</code>中是先将链表中的数据复制到数组中, 然后在数组中排序完以后再复制回链表</p></li><li><p><code>Collections.sort()</code>可以对<code>List</code>数据进行排序</p></li><li><p><code>Collections.binarySearch</code>可以对实现了<code>List</code>的接口的列表去进行二分搜索</p><ul><li>如果集合没有采用<code>Comparable</code>接口的<code>compareTo</code>方法进行排序, 则还需要提供一个比较器对象</li><li>如果为<code>binarySearch()</code>提供一个链表, 则会退化为线性查找</li><li><code>binarySearch()</code>返回值<code>ret</code>如果小于零, 则<code>-ret - 1</code>的位置就是这个元素应该插入的位置</li></ul></li></ul><h2 id="批操作">批操作</h2><ul><li><p><code>coll1.removeAll(coll2)</code>, 在<code>coll1</code>中删除所有<code>coll2</code>包含的元素 (补)</p></li><li><p><code>coll1.retainAll(coll2)</code>, 在<code>coll1</code>中删除所有<code>coll2</code>中没有包含的元素 (交)</p></li><li><p>数组转集合</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] names = ...;</span><br><span class="line">List&lt;String&gt; staff = List.of(names);</span><br></pre></td></tr></table></figure></li><li><p>集合转数组</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object[] names = staff.toArray();</span><br><span class="line"><span class="comment">// 得到一个Object[]数组, 无法进行类型转换</span></span><br><span class="line">String[] names = (String[]) staff.toArray(); <span class="comment">// Error</span></span><br><span class="line"><span class="comment">// 需要向toArray传入一个数组构造器表达式</span></span><br><span class="line">String[] names = staff.toArray(String[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="遗留">遗留</h2><ul><li><p><code>Hashtable</code>类和<code>HashMap</code>类作用相同, 但是<code>HashTable</code>是同步的, 不需要兼容性应该使用<code>HashMap</code>, 需要并发应该使用<code>ConcurrentHashMap</code></p></li><li><p><code>Enumeration</code>有两个方法<code>hasMoreElements(), nextElements()</code>, 可以使用<code>Collections.list</code>将元素收集到一个<code>ArrayList</code></p></li><li><p>属性映射的特性</p><ul><li>键值都是字符串</li><li>映射可以保存到文件并从文件加载</li><li>有一个二级表存放默认值</li></ul></li><li><p>实现属性映射的<code>Java</code>平台类名为<code>Properties</code>, 对于配置项很有用</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">settings</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">settings.setProperty(<span class="string">&quot;1&quot;</span>, <span class="number">1</span>);</span><br><span class="line">settings.setProperty(<span class="string">&quot;filename&quot;</span>, <span class="string">&quot;/home);</span></span><br></pre></td></tr></table></figure></li><li><p>使用<code>store()</code>将属性映射表保存到一个文件中, 比如<code>program.properties</code></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;program.properties&quot;</span>, StandardCharsets.UTF_8);</span><br><span class="line">settings.store(out, <span class="string">&quot;Program Properties&quot;</span>);</span><br><span class="line"><span class="type">var</span> <span class="variable">in</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;program.properties&quot;</span>, StandardCharsets.UTF_8);</span><br><span class="line">settings.load(in);</span><br><span class="line"><span class="type">String</span> <span class="variable">userDir</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.home&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p><code>Properties</code>因为历史原因实现了<code>Map&lt;&gt;</code>, 因此可以使用<code>get(), put()</code>, 但是<code>get()</code>返回类型是<code>Object</code>, <code>put()</code>允许插入任意对象</p><ul><li>所以最好使用处理字符串的<code>getProperty(), setProperty()</code></li></ul></li><li><p>栈, <code>Stack</code>, 扩展的<code>Vector</code>, 但是可以使用<code>insert(), remove()</code>添加删除任意的位置</p></li><li><p>位集, <code>BitSet</code>, 如果需要存储一个位序列, 比如标志, 可以使用位集</p><ul><li>因为位集将位包装在字节里, 所以使用位集比使用<code>Boolean, ArrayList</code>高效</li><li><code>bitSet.get(i)</code>会返回第<code>i</code>位的结果, <code>true, false</code></li><li><code>bitSet.set(i)</code>将第<code>i</code>位的结果设置为<code>true</code></li><li><code>bitSet.clear(i)</code>将第<code>i</code>位的结果设置为<code>false</code></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java核心技术(卷一) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记_10</title>
      <link href="/posts/4c78249.html"/>
      <url>/posts/4c78249.html</url>
      
        <content type="html"><![CDATA[<h1>异常</h1><ul><li>所有的异常都是由<code>Throwable</code>继承而来, 下一层有两个分支, <code>Error</code>和<code>Exception</code><ul><li><code>Error</code>类描述了<code>Java</code>运行时系统的内部错误和资源耗尽问题, 一般不要抛出这个类型</li><li><code>Exception</code>层次分为两个分支, <code>RuntimeException</code>和其他异常<ul><li>编程错误导致的是<code>RuntimeException</code></li><li>由于<code>IO</code>错误导致的是其他异常</li><li>继承自<code>RuntimeException</code>异常包括: 错误的强制类型转换; 数组越界; 访问<code>null</code>指针</li><li>不继承自<code>RuntimeException</code>异常包括: 打开不存在的文件; 越过文件末尾读取数据; 根据给定字符串查找<code>Class</code>, 但是这个类并不存在</li></ul></li><li>所有派生于<code>Error</code>和<code>RuntimeException</code>的异常是非检查型异常, 其他异常都是检查型异常</li></ul></li></ul><h2 id="抛出异常的情况">抛出异常的情况</h2><ol><li>调用了某个会抛出异常的方法, 比如<code>FileInputStream</code>构造器</li><li>检测到一个错误, 使用<code>throw</code>语句抛出异常</li><li>程序出现错误, 比如<code>a[-1]</code>抛出一个非检查型异常</li><li><code>JVM</code>内部错误</li></ol><ul><li>一个方法必须声明所有可能抛出的检查型异常, 也可以捕获一个异常, 这样也不需要抛出了</li><li>如果子类覆盖了超类的一个方法, 子类抛出的异常不能比超类的更通用, 如果超类没有抛出异常, 则子类也不能抛出异常</li></ul><h2 id="创建异常">创建异常</h2><ul><li>定义一个派生于<code>Exception</code>或者他子类的一个类, 包含两个构造器, 一个是无参构造器, 另一个是包含详细信息的构造器  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileFormatException</span> <span class="keyword">extends</span> <span class="title class_">IOException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileFormatException</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileFormatException</span><span class="params">(String gripe)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(gripe);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="捕获异常">捕获异常</h2><ul><li>如果<code>try</code>语句块中任何代码抛出了<code>catch</code>指定的一个异常类<ol><li>跳过<code>try</code>语句块剩余执行内容</li><li>执行<code>catch</code>语句块代码</li></ol></li><li>如果没有抛出异常, 则直接跳过<code>catch</code>部分</li><li>如果抛出了异常, 但是不在<code>catch</code>中, 则方法会直接退出</li><li>一般是捕获知道如何处理的异常, 抛出不知道如何处理的异常</li><li>一个<code>try</code>语句块可能抛出多种不同的异常, 每个异常需要一个<code>catch</code>语句块<ul><li>如果两个异常的捕获动作一样的话, 可以使用<code>catch(Exception e1 | Exception e2)</code>合并</li><li>捕获多个变量时, 异常变量银行了<code>final</code></li></ul></li></ul><h2 id="再次抛出">再次抛出</h2><ul><li>有时候只想记录一个异常, 再次抛出  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    logger.log(level, message, e);</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果这段代码存在于 public void update() throws SQLException中</span></span><br><span class="line"><span class="comment">// 在Java 7之前会报错, 因为 throw e可能抛出其他类型的异常, 而不是SQLException</span></span><br><span class="line"><span class="comment">// 现在改变了, 编译器会跟踪到e来自try代码块, try代码块中仅有的检查型异常是SQLException实例, 并且</span></span><br><span class="line"><span class="comment">// e在catch块中没有改变, 那么外围方法声明为throws SQLException就是合法的</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="finally子句"><code>finally</code>子句</h2><ul><li><p>代码抛出异常, 剩下的代码就不会运行, 如果这时候已经获取到了一些资源, 在退出之前需要释放.</p><ul><li>可以先捕获所有异常, 然后释放资源, 再重新抛出异常</li><li>也可以使用<code>finally</code>子句, 无论是否抛出异常, <code>finally</code>子句部分一定都会执行</li><li><code>Java 7</code>之后可以使用<code>try-with-resources</code>, 这个更常用</li></ul></li><li><p><code>try</code>语句可以只有<code>finally</code>, 没有<code>catch</code></p></li><li><p><code>finally</code>语句中不要放<code>throw, continue, break, return</code>这种改变程序执行顺序的语句</p></li></ul><h2 id="try-with-resources"><code>try-with-resources</code></h2><ul><li><code>AutoCloseable</code>接口有一个方法 <code>void close() throwa Exception</code></li><li><code>Closeable</code>接口是<code>AutoCloseable</code>接口的子接口, 同样只包含<code>close()</code>, 但是抛出的是<code>IOException</code></li><li><code>try-with-resources</code>语句的最简单形式是:  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Resources</span> <span class="variable">res</span> <span class="operator">=</span> ...) &#123;</span><br><span class="line">    work with res</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里try块退出时, 会自动调用res.close()</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">var</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(Path.of(<span class="string">&quot;1.txt&quot;</span>), StandardCharsets.UTF_8);</span><br><span class="line">    <span class="type">var</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="string">&quot;2.txt&quot;</span>, StandardCharsets.UTF_8)) &#123;</span><br><span class="line">    <span class="keyword">while</span> (in.hasNext()) &#123;</span><br><span class="line">        out.println(in.next().toUpperCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上述代码不论是如何退出的, 都一定会自动关闭in和out</span></span><br></pre></td></tr></table></figure></li><li>如果是<code>try-catch-finally</code>语句, 在<code>try</code>中抛出了异常, 然后<code>finally</code>调用<code>in.close()</code>又抛出了异常就会产生问题<ul><li>此时使用<code>try-with-resources</code>就可以解决这个问题</li><li>原来的异常会重新抛出, <code>close()</code>产生的异常会被抑制, 自动捕获, 由<code>addSuppressed()</code> 添加到原来的异常方法中</li><li>可以调用<code>getSuppressed()</code>, 会生成一个数组, 包含其中从<code>close()</code>方法中抛出的被抑制的异常</li></ul></li><li><code>try-with-resources</code>语句本身可以有<code>catch, finally</code>语句, 这些子句会在关闭资源以后才执行</li></ul><h2 id="栈轨迹">栈轨迹</h2><ul><li>栈轨迹是程序执行中某个特定点所有挂起的方法调用的一个列表</li><li><code>Throwable</code>类的<code>printStackTrace()</code>可以打印  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Throwable</span>();</span><br><span class="line"><span class="type">var</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringWriter</span>();</span><br><span class="line">t.printStackTrace(<span class="keyword">new</span> <span class="title class_">PrintWriter</span>(out));</span><br><span class="line"><span class="type">String</span> <span class="variable">des</span> <span class="operator">=</span> out.toString();</span><br><span class="line"><span class="comment">// Java 9之前, Throwable.printStackTrace()会生成一个StackTraceElement[]</span></span><br><span class="line"><span class="comment">// 数组中包含了和StackWalker.StackFrame类似的信息, 效率较低</span></span><br><span class="line"><span class="comment">// 因为会得到整个栈, 但是调用者只需要几个栈帧, 并且只允许访问挂起方法的类名, 不能访问类对象</span></span><br></pre></td></tr></table></figure></li><li>还可以使用<code>StackWalker</code>类, 生成一个<code>StackWalker.StackFrame</code>实例流, 其中每个实例表示一个栈帧  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StackWalker</span> <span class="variable">walker</span> <span class="operator">=</span> StackWalker.getInstance();</span><br><span class="line">walker.forEach(frame -&gt; ananlyze frame)</span><br></pre></td></tr></table></figure></li></ul><div class="note info flat"><ul><li>栈轨迹一般显示在<code>System.err</code>上, 如果想要记录栈轨迹, 可以捕获到字符串中</li><li>也可以记录到文件中, 不过如果是错误的话, 就会发送到<code>System.err</code>中, 所以就不能使用下面的代码<ul><li><code>java MyApp &gt; errors.txt</code>, 而是应该使用 <code>java MyApp 2&gt; errors.txt</code></li><li>如果需要在同一个文件中同时保存<code>System.out, System.err</code>可以使用如下代码</li><li><code>java MyApp 1&gt; errors.txt 2&gt;&amp;1</code></li></ul></li><li>可以使用静态方法<code>Thread.setDefaultUncaughtExceptionHandler</code>改变没有捕获异常的处理器</li><li>启动<code>JVM</code>可以使用<code>-verbose</code>看到类加载器加载过程</li><li><code>Xlint</code>选项可以告诉编译器找出常见的代码问题, 比如<code>javac -Xlint sourceFiles</code></li><li><code>JDK</code>提供了<code>jconsole</code>可以显示<code>JVM</code>性能统计结果</li></ul></div><h2 id="使用异常技巧">使用异常技巧</h2><ol><li>异常不能代替简单测试, 使用捕获异常会导致程序耗时大大增加, 因此只在异常情况下使用异常</li><li>不要过分细化异常, 否则一个异常一个<code>catch</code>会导致代码量激增</li><li>合理使用异常层次<ul><li>不要只抛出<code>RuntimeException</code>, 应该需要寻找一个合适的子类, 或者创建自己的异常类</li><li>不要只捕获<code>Throwable</code>异常, 否则代码会很难读懂</li><li>考虑检查型异常和非检查型异常, 检查型异常本质上开销较大</li></ul></li><li>不要压制异常, 可以使用</li><li>使用标准方法报告<code>null</code>指针和越界异常</li><li>不要向用户展示最终的栈轨迹</li></ol><h1>断言</h1><ul><li>断言允许在测试期间在代码中插入一些检查, 在生产代码中自动删除这些  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> condition;</span><br><span class="line"><span class="keyword">assert</span> condition : expression;</span><br><span class="line"><span class="comment">// 两个写法都会计算condition, 如果为false, 会抛出AssertionError异常</span></span><br><span class="line"><span class="comment">// 第二个语句会将expression传入到AssertionError构造器中, 转换为一个消息字符串</span></span><br></pre></td></tr></table></figure></li><li>默认情况下禁用断言, 运行是使用<code>java -enableassertions MyApp</code> 或者<code>java -ea MyApp</code>启用</li><li>不需要重新编译启用断言, 因为断言是类加载器的功能, 禁用断言的时候类加载器会自动删去断言的代码, 不会降低速度</li><li>可以在特定的类或整个包中打开断言<code>java -ea:MyClass -ea:com.mycompany.mylib MyApp</code><ul><li>这样会在<code>MyClass</code>类, <code>com.mycompany.mylib</code>包及其子包中的所有类打开断言</li><li>同样可以使用<code>-da</code> 或者<code>-disableassertions</code>禁用断言</li><li><code>-ea</code>和<code>-da</code>不能应用于没有类加载器的系统类, 需要使用<code>-esa</code>或者<code>enablesystemassertions</code>开启系统类断言</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java核心技术(卷一) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记_11</title>
      <link href="/posts/73c0b2df.html"/>
      <url>/posts/73c0b2df.html</url>
      
        <content type="html"><![CDATA[<h1>泛型</h1><ul><li>没有泛型类的时候, 泛型程序用继承实现, <code>ArrayList</code>类只维护一个<code>Object</code>引用数组, 这样就会每次都需要进行强制类型转换</li><li>现在是使用尖括号<code>&lt;String&gt;</code></li><li><code>Java</code>类库使用<code>E</code>表示集合类型, <code>K,V</code>表示键值对, <code>T,U</code>等表示任意类型</li></ul><h2 id="泛型类">泛型类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    T first;</span><br><span class="line">    T second;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">()</span> &#123; </span><br><span class="line">        first = <span class="literal">null</span>;</span><br><span class="line">        second = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(T first, T second)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">        <span class="built_in">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getSecond</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFirst</span><span class="params">(T newV)</span> &#123;</span><br><span class="line">        first = newV;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSecond</span><span class="params">(T newV)</span> &#123;</span><br><span class="line">        second = newV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型方法">泛型方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">getMiddle</span><span class="params">(T...a)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a[a.length / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型代码和虚拟机">泛型代码和虚拟机</h2><ul><li><p>无论何时定义一个泛型类, 都会自动提供一个相应的原始类型, 就是去掉类型参数以后的泛型类型名</p></li><li><p>类型变量会被擦除, 替换为其限定类型, 如果没有限定类型就是<code>Object</code></p></li><li><p>泛型方法的类型擦除会存在一些问题:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> <span class="keyword">extends</span> <span class="title class_">Pair</span>&lt;LocalDate&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSecond</span><span class="params">(LocalDate second)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (second.compareTo(getFirst()) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">super</span>.setSecond(second);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 日期区间是一对LocalDate对象, 覆盖这个方法保证第二个值永远不小于第一个值, 类擦除以后就是</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> <span class="keyword">extends</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSecond</span><span class="params">(LocalDate second)</span> &#123;...&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 但是还有另一个从Pair继承的setSecond方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSecond</span><span class="params">(Object second)</span> &#123;&#125;</span><br><span class="line"><span class="comment">// 这两个方法参数不同, 所以是不同的方法, 但是他们不应该不同</span></span><br><span class="line"><span class="comment">// 此时类型擦除和多态就产生了冲突, 编译器就会在D类中生成一个桥方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSecond</span><span class="params">(Object second)</span> &#123;setSecond((LocalDate) second);&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同样, 在编译器中, 如果是getSecond(), 会同时存在两个</span></span><br><span class="line"><span class="keyword">public</span> LocalDate <span class="title function_">getSecond</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getSecond</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 这两个方法只有返回类型不同, 不能这么编写代码</span></span><br><span class="line"><span class="comment">// 但是虚拟机会根据参数类型和返回类型共同指定一个方法, 所以虚拟机可以正确处理这两个方法</span></span><br><span class="line"><span class="comment">// 所以编译器可以为只有返回类型不同的两个方法生成字节码文件</span></span><br><span class="line"><span class="comment">// 只是自己编写这样的代码不合法</span></span><br></pre></td></tr></table></figure></li></ul><div class="note info flat"><ul><li>虚拟机中没有泛型, 只有普通的类和方法</li><li>所有的类型参数都会替换为他们的限定类型</li><li>会合成桥方法来保持多态</li><li>会插入强制类型转换来保持类型安全性</li></ul></div><h2 id="限制">限制</h2><ol><li>不能使用基本类型实例化类型参数<ul><li>不能使用<code>Pair&lt;double&gt;</code>, 因为在类型擦除后的<code>Object</code>类中不能存储基本类型, 只能存储<code>Double</code></li></ul></li><li>运行时类型查询只适用于原始类型 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a <span class="keyword">instanceof</span> Pair&lt;String&gt;) <span class="comment">// Error 实际上只会检测a是否是Pair的任意一个类型实例</span></span><br><span class="line"><span class="keyword">if</span> (a <span class="keyword">instanceof</span> Pair&lt;T&gt;) <span class="comment">// Error</span></span><br><span class="line">Pair&lt;String&gt; p = (Pair&lt;String&gt;) a; <span class="comment">// Warn</span></span><br><span class="line"></span><br><span class="line">Pair&lt;String&gt; stringp = ...;</span><br><span class="line">Pair&lt;E&gt; ep = ...;</span><br><span class="line"><span class="keyword">if</span> (stringp.getClass() == ep.getClass()) &#123;&#125;</span><br><span class="line"><span class="comment">// 这里一定相等, 因为两个getClass()返回值都是Pair.Class</span></span><br></pre></td></tr></table></figure></li><li>不能创建参数化类型的数组 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">table</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;String&gt;[<span class="number">10</span>]; <span class="comment">// Error</span></span><br><span class="line"><span class="comment">// 因为类型擦除以后, table的类型是Object[], 存储不正确的元素会抛出ArrayStoreException</span></span><br><span class="line"><span class="comment">// 只是不允许创建, 但是声明依旧合法 即Pair&lt;String&gt;[]变量是合法的</span></span><br><span class="line"><span class="comment">// 但是new Pair&lt;String&gt;[10]初始化会抛出异常</span></span><br><span class="line"><span class="comment">// 可以声明通配符类型数组, 然后进行强制类型转换</span></span><br><span class="line"><span class="type">var</span> <span class="variable">table</span> <span class="operator">=</span> (Pair&lt;String&gt;[]) <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;?&gt;[<span class="number">10</span>];</span><br><span class="line"><span class="comment">// 结果不安全, 比如table[0]存储一个Pair&lt;E&gt;, 然后table[0].getFirst()调用一个String方法, 就会抛出ClassCastException</span></span><br><span class="line"><span class="comment">// 可以直接使用ArrayList: ArrayList&lt;Pair&lt;String&gt;&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="Varargs警告"><code>Varargs</code>警告</h2><ul><li>如果向可变参数的方法传递一个泛型类型实例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;T&gt; coll, T... ts)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (T t : ts) &#123;</span><br><span class="line">        coll.add(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ts是一个数组, 包含所有提供的实参</span></span><br><span class="line">Collection&lt;Pair&lt;String&gt;&gt; table = ...</span><br><span class="line">Pair&lt;String&gt; p1 = ...</span><br><span class="line">Pair&lt;String&gt; p2 = ...</span><br><span class="line">addAll(table, p1, p2);</span><br><span class="line"><span class="comment">// 此时JVM必须创建一个Pair&lt;String&gt;类型数组, 违反规则</span></span><br><span class="line"><span class="comment">// 但是有所放松, 只会给出警告</span></span><br><span class="line"><span class="comment">// 使用@SuppressWarnings(&quot;unchecked&quot;) 去掉警告</span></span><br><span class="line"><span class="comment">// 或者Java 7还可以使用@SafeVarargs注解addAll方法</span></span><br></pre></td></tr></table></figure><div class="note info flat"><ul><li><code>@SafeVarargs</code>注解只能用于<code>static, final</code>或<code>private</code>的构造器或方法中, 其他方法都可能被覆盖, 会使这注解失去作用</li></ul></div><h2 id="不能实例化类型变量">不能实例化类型变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T second;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">()</span> &#123;</span><br><span class="line">        first = <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">        second = <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这个无参构造函数是不合法的, 因为类型擦除以后会变成new Object()</span></span><br><span class="line"><span class="comment">// Java 8之后, 可以使用构造器表达式解决这个问题</span></span><br><span class="line">Pair&lt;String&gt; p = Pair.makePair(String::<span class="keyword">new</span>);</span><br><span class="line"><span class="comment">// makePair()接收一个Supplier&lt;T&gt;, 一个函数式接口, 表示一个无参并且返回类型为T的函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Pair&lt;T&gt; <span class="title function_">makePair</span><span class="params">(Supplier&lt;T&gt; constr)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(constr.get, constr.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传统解决方法是调用反射Constructor.newInstance()构造泛型对象</span></span><br><span class="line">first = T.class.getConstructor().newInstance(); <span class="comment">// Error</span></span><br><span class="line"><span class="comment">// 因为T.class不合法, 会类型擦除为Object.class, 所以应该用如下方法:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Pair&lt;T&gt; <span class="title function_">makePair</span><span class="params">(Class&lt;T&gt; cl)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(cl.getConstructor.newInstance(), cl.getConstructor().newInstance());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Pair&lt;String&gt; p = Pair.makePair(String.class);</span><br><span class="line"><span class="comment">// Class 类本身是泛型的, String.class 是Class&lt;String&gt;的唯一实例, 所以makePair()可以推断pair的类型</span></span><br></pre></td></tr></table></figure><h2 id="不能构造泛型数组">不能构造泛型数组</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&gt; T[] minmax(T... a) &#123;</span><br><span class="line">    T[] mm = <span class="keyword">new</span> <span class="title class_">T</span>[<span class="number">2</span>]; <span class="comment">// Error</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类型擦除, 所以总会构造一个Comparable[2]数组</span></span><br><span class="line"><span class="comment">// 如果数组只会作为类的私有实例字段, 可以将这个数组元素类型声明为擦除以后的类型, 再强制类型转换, 比如ArrayList</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] elements;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> </span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (E) elements[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> n, E e)</span> &#123;</span><br><span class="line">        elements[n] = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是minmax返回一个T[], 就无法使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&gt; minmax(T... a) &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Comparable</span>[<span class="number">2</span>];</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> (T[]) result; <span class="comment">// Warnings</span></span><br><span class="line">&#125; </span><br><span class="line">String[] names = A.minmax(<span class="string">&quot;T&quot;</span>, <span class="string">&quot;A&quot;</span>, <span class="string">&quot;N&quot;</span>);</span><br><span class="line"><span class="comment">// 编译器不会有警告, 但是Comparable[]转换为String[]会出现ClassCastException</span></span><br><span class="line"><span class="comment">// 所以最好提供一个构造器表达式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&gt; T[] minmax(IntFunction&lt;T[]&gt; constr, T... a) &#123;</span><br><span class="line">    T[] result = constr.apply(<span class="number">2</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">String[] names = A.minmax(String::<span class="keyword">new</span>, <span class="string">&quot;T&quot;</span>, <span class="string">&quot;A&quot;</span>, <span class="string">&quot;N&quot;</span>);</span><br><span class="line"><span class="comment">// 或者利用反射</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&gt; T[] minmax(T... a) &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">result</span> <span class="operator">=</span> (T[]) Array.newInstance(a.getClass().getComponentType(), <span class="number">2</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型类的静态上下文中类型变量无效">泛型类的静态上下文中类型变量无效</h2><ul><li>不能在静态方法或字段中引用类型变量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">S</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T si; <span class="comment">// Error</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T <span class="title function_">getSi</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (si == <span class="literal">null</span>) construct <span class="keyword">new</span> <span class="title class_">instanceof</span> T;</span><br><span class="line">        <span class="keyword">return</span> si;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类型擦除以后, 只剩下S类, 只包含一个si字段, 所以非法</span></span><br></pre></td></tr></table></figure><h2 id="不能抛出或捕获泛型类的实例">不能抛出或捕获泛型类的实例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不能扩展Exception</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Problem</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;...&#125; <span class="comment">// Error </span></span><br><span class="line"><span class="comment">// catch 子句不能使用类型变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt; <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">(Class&lt;T&gt; t)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">catch</span> (T e) &#123; <span class="comment">// Error</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 但是在异常规范中允许使用类型变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt; <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">(T t)</span> <span class="keyword">throws</span> T &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable realCause) &#123;</span><br><span class="line">        t.initCause(realCause);</span><br><span class="line">        <span class="keyword">throw</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可以取消对检查型异常的检查">可以取消对检查型异常的检查</h2><ul><li>正常必须对所有检查型异常提供一个处理器, 但是可以利用泛型取消这个检查</li><li>只需要使用泛型类, 类型擦除和<code>@SuppressWarnings(&quot;unchecked&quot;)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt; <span class="keyword">void</span> <span class="title function_">throwAs</span><span class="params">(Throwable t)</span> <span class="keyword">throws</span> T &#123;</span><br><span class="line">    <span class="keyword">throw</span> (T) t;</span><br><span class="line">&#125;</span><br><span class="line">Task.&lt;RuntimeException&gt;throwAs(e);</span><br><span class="line"><span class="comment">// 编译器就会认为e是一个非检查型异常</span></span><br><span class="line"><span class="comment">// 下面的代码会将所有的异常都转换为非检查型异常</span></span><br><span class="line"><span class="keyword">try</span> &#123;...&#125; </span><br><span class="line"><span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    Task.&lt;RuntimeException&gt;throwAs(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="擦除以后可能会存在冲突">擦除以后可能会存在冲突</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> first.equals(value) &amp;&amp; second.equals(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实际上Pair有两个equals方法, boolean equals(String); boolean equals(Object);</span></span><br><span class="line"><span class="comment">// 只能重新命名这个方法</span></span><br></pre></td></tr></table></figure><ul><li>假如两个接口类型是同一个接口的不同参数化, 一个类或者类型变量就不能同时作为这两个接口类型的子类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">E</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;E&gt; &#123;...&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">M</span> <span class="keyword">extends</span> <span class="title class_">E</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;M&gt; &#123;...&#125; <span class="comment">// Error</span></span><br><span class="line"><span class="comment">// 如果上述代码可行, 则M就会同时实现Comparable&lt;E&gt; 和Comparable&lt;M&gt;</span></span><br></pre></td></tr></table></figure><h2 id="泛型继承规则">泛型继承规则</h2><ul><li>如果<code>M</code>是<code>E</code>的子类, <code>Pair&lt;M&gt;</code>不会是<code>Pair&lt;E&gt;</code>的子类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;E&gt; b = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;M&gt;(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 非法</span></span><br></pre></td></tr></table></figure><ul><li>可以将参数化类型转换为一个原始类型</li></ul><h2 id="通配符类型">通配符类型</h2><ul><li><p><code>Pair&lt;? extends E&gt;</code>允许类型参数变化, 表示任何<code>Pair</code>类型, 只要是<code>E</code>的子类</p></li><li><p><code>Pair&lt;M&gt;</code>是<code>Pair&lt;? extends E&gt;</code>的子类型</p></li><li><p>可以使用<code>? super M</code>指定一个超类型限定, 限制为<code>M</code>的所有超类型</p></li><li><p>带超类限定的通配符允许写入一个泛型对象, 带子类限定的通配符允许读取一个泛型对象</p></li><li><p><code>Comparable</code>接口本身就是一个泛型类型</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(T other)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类型变量指示了other参数的类型, String类实现了Comparable&lt;String&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(String other)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;? <span class="built_in">super</span> T&gt;&gt; pair&lt;T&gt; <span class="title function_">minmax</span><span class="params">(T[] a)</span></span><br></pre></td></tr></table></figure></li><li><p>无限定通配符<code>Pair&lt;?&gt;</code></p></li><li><p><code>Pair&lt;?&gt;</code>和<code>Pair</code>本质区别在于可以使用任意的<code>Object</code>对象调用原始<code>Pair</code>类的<code>setFirst()</code></p></li><li><p>测试一个<code>Pair</code>是否包含<code>Null</code>引用, 不需要具体的类型</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">hasNulls</span><span class="params">(Pair&lt;?&gt; p)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> p.getFirst() == <span class="literal">null</span> || p.getSecond() == <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将hasNulls转换为泛型方法, 可以避免使用通配符类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">boolean</span> <span class="title function_">hasNulls</span><span class="params">(Pair&lt;T&gt; p)</span>;</span><br><span class="line"><span class="comment">// 带有通配符版本的可读性更强</span></span><br></pre></td></tr></table></figure></li><li><p>交换<code>Pair</code>元素</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(Pair&lt;?&gt; p)</span>;</span><br><span class="line"><span class="comment">// 通配符不是一个类型变量, 所以不能作为类型编码</span></span><br><span class="line">? t = p.getFirst(); <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">swapHelper</span><span class="params">(Pair&lt;T&gt; p)</span> &#123;</span><br><span class="line">    <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> p.getFirst();</span><br><span class="line">    p.setFirst(p.getSecond());</span><br><span class="line">    p.setSecond(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// swapHelper是一个泛型方法, 但是swap不是, 它有一个固定的Pair&lt;?&gt;类型参数</span></span><br><span class="line"><span class="comment">// 可以由swap调用swapHelper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(Pair&lt;?&gt; p)</span> &#123;swapHelper(p);&#125;</span><br><span class="line"><span class="comment">// 此时swapHelper()参数T捕获通配符, 并不知道通配符指示什么类型, 但是是一个明确的类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">minmaxB</span><span class="params">(M[] a, Pair&lt;? <span class="built_in">super</span> M&gt; res)</span> &#123;</span><br><span class="line">    minmaxB(a, res);</span><br><span class="line">    PairAlg.swapHelper(res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 只有在编译器能够保证通配符表示单个确定的类型时才不会报错</span></span><br><span class="line"><span class="comment">// ArrayList&lt;Pair&lt;T&gt;&gt;绝对不能捕获ArrayList&lt;Pair&lt;?&gt;&gt;中的通配符, 因为ArrayList可能包含两个Pair&lt;?&gt;, 而且指向了不同的类型</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="反射和泛型">反射和泛型</h2><h3 id="泛型Class类">泛型<code>Class</code>类</h3><ul><li><code>Class</code>类是泛型类, <code>String.class</code>实际上是<code>Class&lt;String&gt;</code>类的对象</li><li>类型参数非常有用, 允许<code>Class&lt;T&gt;</code>的方法有更加特定的返回类型  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">T <span class="title function_">newInstance</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 返回这个类的实例, 由无参构造器获得, 返回类型声明为T, 避免强制类型转换</span></span><br><span class="line">T <span class="title function_">cast</span><span class="params">(Object obj)</span>;</span><br><span class="line"><span class="comment">// 返回特定的对象, 给定对象的额实际类型是T的一个子类型, 会声明为T, 否则会抛出一个BadCastException</span></span><br><span class="line">T[] getEnumConstants();</span><br><span class="line"><span class="comment">// 如果这个类不是一个Enum或者T类型枚举值的一个数组, 就会返回null</span></span><br><span class="line">Class&lt;? <span class="built_in">super</span> T&gt; getSuperclass();</span><br><span class="line"><span class="comment">// 返回这个类的超类, 如果T不是一个类, 或者T是Object, 则返回null</span></span><br><span class="line">Constructor&lt;T&gt; <span class="title function_">getConstructor</span><span class="params">(Class... parameterTypes)</span>;</span><br><span class="line">Constructor&lt;T&gt; <span class="title function_">getDeclaredConstructor</span><span class="params">(Class... parameterTypes)</span>;</span><br><span class="line"><span class="comment">// 获得公共构造器, 或者有给定参数类型的构造器</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="使用Class-T-参数进行类型匹配">使用<code>Class&lt;T&gt;</code>参数进行类型匹配</h3><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Pair&lt;T&gt; <span class="title function_">makePair</span><span class="params">(Class&lt;T&gt; c)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(c.newInstance(), c.newInstance());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用makePair(E.class), E.class是一个Class&lt;E&gt;类型的对象</span></span><br><span class="line"><span class="comment">// makePair()的类型参数T 与E匹配, 编译器可以推断出这个方法返回一个Pair&lt;E&gt;</span></span><br></pre></td></tr></table></figure></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java核心技术(卷一) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记_9</title>
      <link href="/posts/1d15a4a2.html"/>
      <url>/posts/1d15a4a2.html</url>
      
        <content type="html"><![CDATA[<h1>内部类</h1><h2 id="使用内部类的原因">使用内部类的原因</h2><ol><li>对同一个包中的其他类隐藏</li><li>访问定义这些方法的作用域的数据, 包括原本的私有数据</li></ol><div class="note info flat"><ul><li>内部类对象会有一个隐式引用, 指向实例化这个对象的外部类对象, 可以访问外部对象的全部状态</li><li>但是<code>Java</code>中静态内部类没有这个指针, 所以<code>Java</code>静态内部类等于<code>CPP</code>中的嵌套类</li><li>可以使用<code>OuterClass.this</code>表示外部类的引用, 比如 <code>T.this.b</code></li><li>可以使用<code>outerObject.new InnerClass()</code>编写内部类的构造器, 比如<code>A listen = this.new B();</code></li><li>在外部类的作用域之外, 可以使用<code>OutClass.InnerClass</code>引用</li></ul></div><ul><li>内部类声明的所有静态字段都必须是<code>final</code>, 初始化为一个编译时常量</li><li>内部类不能有<code>static</code>方法</li><li>使用<code>$</code>和<code>javap -private ClassName</code>可以将内部类文件转换为常规类文件</li></ul><h2 id="局部类">局部类</h2><ul><li>可以在一个方法中声明局部类, 这个类不能用<code>public</code>或者<code>private</code>访问修饰符, 对外部完全隐藏, 除了这个方法外都不知道这个局部类的存在</li><li>局部类不仅可以访问外部类的字段, 还可以访问局部变量, 不过这些局部变量都需要是只能赋值一次就不会改变的事实最终变量</li></ul><h2 id="匿名内部类">匿名内部类</h2><ul><li>如果只想要创建类的一个对象, 不需要为类指定名字  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(<span class="type">int</span> interval, <span class="type">boolean</span> flag)</span> &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">listener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActionListener</span>() &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent event)</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (flag) Toolkit.getDefaultToolkit().flag();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建了一个新的对象listener, 这个类实现了ActionListener接口</span></span><br><span class="line"><span class="comment">// 接口实现了actionPerformed方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以是接口, 也可以是一个类</span></span><br><span class="line"><span class="comment">// 因为匿名内部类没有名字, 所以没有构造器</span></span><br></pre></td></tr></table></figure></li><li>对比构造类对象和构造匿名内部类  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"><span class="type">var</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;2&quot;</span>) &#123;...&#125;;</span><br><span class="line"><span class="comment">// a 是类Person的一个对象</span></span><br><span class="line"><span class="comment">// b 是匿名内部类的一个对象, 这个匿名内部类是Person的子类</span></span><br><span class="line"><span class="comment">// 如果构造类的时候小括号后面跟上了大括号, 那么就是一个匿名内部类</span></span><br><span class="line"><span class="type">var</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>() &#123;<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;c&quot;</span>;&#125;</span><br><span class="line">System.out.println(c.name);</span><br><span class="line"><span class="comment">// 如果声明c的类型为Object, c.name就无法编译了, 因为Object是不可指示的</span></span><br></pre></td></tr></table></figure></li></ul><div class="note info flat"><ul><li>如果在一个方法中, 想要打印类名<br><code>System.out.println(getClass())</code></li><li>普通方法可以调用<code>this</code>, 但是静态方法没有<code>this</code></li><li>如果想要打印静态方法的类名, 可以使用匿名内部类<br><code>System.out.println(new Object(){}.getClass().getEnclosingClass())</code></li><li>这里的<code>getEnclosingClass()</code>是得到这个静态方法的外围类</li></ul></div><h2 id="静态内部类">静态内部类</h2><ul><li>如果生成内部类只是为了隐藏这个类, 并不想生成这个内部类的引用, 可以使用<code>static</code>修饰</li><li>比如要计算一个数组的最大值和最小值<ul><li>可以遍历数组两遍</li><li>也可以定义一个类, 其中包含两个私有字段, 分别记录最大值和最小值</li><li>但是这个类的类名可能会重复, 所以可以定义内部类隐藏类名</li><li>可以将内部类声明为<code>static</code>的, 避免包含其他类的引用</li><li>如果内部类是在一个静态方法中构造的, 则这个内部类必须要声明为静态内部类</li></ul></li></ul><h1>代理</h1><ul><li>代理可以在运行时创建一组给定接口的新类</li><li>只有在编译时无法确定需要实现哪个接口的时候才需要使用代理</li><li>代理类可以在运行时创建一个全新的类, 能够实现指定的接口</li><li>一个代理类包含指定接口需要实现的方法, 以及<code>Object</code>类中的所有方法, 比如<code>toString(), equals()</code></li><li>必须提供一个调用处理器, 调用处理器是实现了<code>InvocaitonHandler</code>接口的类对象, 这个接口只有一个方法, <code>Object invoke()</code></li><li>只要调用代理方法, 就会调用这个<code>invoke</code>方法</li></ul><h2 id="创建代理对象">创建代理对象</h2><ul><li><p>需要使用<code>Proxy</code>类的<code>newProxyInstance()</code>, 包含三个参数</p><ol><li>类加载器</li><li><code>Class</code>对象数组</li><li>一个调用处理器</li></ol></li><li><p>使用目的:</p><ol><li>方法调用 路由到远程服务器</li><li>用户界面事件关联运行中的程序动作</li><li>调试跟踪方法调用</li></ol></li><li><p>定义一个<code>TraceHandler</code>包装器类存储一个包装的对象, <code>invoke()</code>打印所调用方法的名字和参数, 然后调用这个方法, 提供包装的对象作为隐式参数</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TraceHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">new</span> <span class="title class_">TraceHandler</span>(Object t) &#123;</span><br><span class="line">        target = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method m, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// print</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> m.invoke(target, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Object</span> <span class="variable">val</span> <span class="operator">=</span> ...;</span><br><span class="line"><span class="type">var</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TraceHandler</span>(val);</span><br><span class="line"><span class="type">var</span> <span class="variable">interfaces</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;Comparable.class&#125;;</span><br><span class="line"><span class="type">Object</span> <span class="variable">proxy</span> <span class="operator">=</span> Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;Comparable.class&#125;, handler);</span><br></pre></td></tr></table></figure></li></ul><h2 id="特性">特性</h2><ol><li>代理类是程序运行过程中动态创建的, 一旦创建就是常规的类</li><li>所有的代理类都扩展<code>Proxy</code>类, 一个代理类只有一个实例字段, 也就是调用处理器, 在<code>Proxy</code>超类中定义<ul><li>完成代理对象任务所需要的任何额外的数据都需要存储在调用处理器中</li></ul></li><li>所有的代理类都需要覆盖<code>Object</code>类的<code>toString(), equals(), hashCode()</code>, 这些方法只是在调用处理器上调用<code>invoke()</code><ul><li><code>Object</code>类中的其他方法, <code>clone(), getClass()</code>没有重新定义</li></ul></li><li>没有定义代理类的名字, 虚拟机中的<code>Proxy</code>类会生成<code>$Proxy</code>开头的类名</li><li>一个特定的类加载器和一组接口, 只能有一个代理类, 同样可以使用<code>Class proxyClass = Proxy.getProxyClass(null, interface)</code>得到这个类</li><li>代理类一定是<code>public, final</code>的, 如果代理类实现的所有接口都是<code>public</code>的, 那么这个代理类就不属于任何包, 否则一定属于某一个包</li><li>可以通过调用<code>Proxy.isProxyClass()</code>检测一个特定的<code>Class</code>对象是否表示一个代理类</li></ol><ul><li>调用一个目标代理的默认方法会触发调用处理器, 使用<code>InvocationHandler</code>接口的静态方法<code>invokeDefault</code>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> (proxy, method, args) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (method.isDefault()) &#123;</span><br><span class="line">        <span class="keyword">return</span> InvocationHandler.invokeDefault(proxy, method, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java核心技术(卷一) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记_7</title>
      <link href="/posts/faad89a5.html"/>
      <url>/posts/faad89a5.html</url>
      
        <content type="html"><![CDATA[<h1>继承</h1><blockquote><p>基本思想: 基于已有的类创建新的类, 复用已有类的方法, 可以增加一些新的方法和字段</p></blockquote><ul><li>反射是程序在运行期间更多地了解类以及属性的能力</li></ul><div class="note info flat"><p><code>CPP</code>中使用<code>:</code>表示继承, 除了公共继承以外, 还存在私有继承和保护继承<br><code>Java</code>中<code>extends</code>关键字表示继承, 所有继承都是<strong>公共继承</strong></p></div><ul><li><code>extends</code>表示正在构造的类(子类, 派生类)派生于一个已经存在的类(超类, 基类, 父类)<ul><li>子类比超类拥有更多的功能</li><li>“声明为私有的类成员不会被这个类的子类继承”, 这里其实是子类不能直接访问这些私有成员, 但是子类的每个实例对象中依然会包含超类中的私有字段</li></ul></li><li>记录不能被扩展, 记录也不能继承别的类</li><li>如果希望使用超类中的方法, 就使用<code>super</code>关键字, <code>super</code>只是用于指示编译器调用超类方法的特殊关键字<ul><li>同时可以使用<code>super()</code>来调用超类中对应的构造器</li><li>不管是<code>this</code>还是<code>super</code>, <strong>在调用其他构造器的时候</strong>, 都必须放在第一行, 否则会报错</li></ul></li></ul><div class="note info flat"><ul><li>一个对象可以指示多种实际类型, 比如一个类的超类以及他的子类都在一个数组中, 使用<code>foreach</code>循环的时候, 循环变量可以同时指示多个不同的类, 那么这就是多态</li><li>运行的时候可以自动的选择适合的方法, 就是动态绑定</li><li><code>CPP</code>中, 如果希望实现动态绑定, 可以将成员函数设置为<code>virtual</code></li><li><code>Java</code>中默认会执行动态绑定, 如果不希望方法是虚拟的, 可以使用<code>final</code>关键字</li><li><code>CPP</code>中, 一个类可以有多个超类</li><li><code>Java</code>中不支持多重继承, 但是可以使用接口实现多重继承的功能</li></ul></div><h2 id="对象方法调用过程">对象方法调用过程</h2><blockquote><p>假设需要<code>x.f(args)</code>, <code>x</code>是类<code>C</code>的一个对象, 具体调用过程如下:</p></blockquote><ol><li>编译器查看对象的声明类型和方法名, 可能存在多个名为<code>f</code>的方法, 他们具有不同的参数类型, 编译器会一一列举出<code>C</code>中的所有名为<code>f</code>的方法, 以及<code>C</code>的超类中所有名为<code>f</code>的<strong>非私有方法</strong></li><li>重载解析: 编译器确定方法调用中提供的参数类型, 如果所有名为<code>f</code>的方法中存在一个与所提供的参数类型完全匹配的方法, 就直接使用这个方法<ul><li>如果找不到匹配的方法, 或者找到了多个匹配的方法, 编译器就会抛出异常</li><li>方法的名字与参数类型会组成签名, 如果子类的签名和超类的重复了, 子类的方法会覆盖超类的方法</li><li>尽管返回类型不是签名的一部分, 但是在覆盖的时候, 需要保证子类的返回类型是超类返回类型的子类型</li></ul></li><li>如果是<code>private</code>, <code>static</code>, <code>final</code>方法 或者 构造器方法, 编译器就可以准确知道调用哪个方法, 这称为静态绑定. 如果调用方法依赖于隐式参数的实际类型, 就是动态绑定. 所以只要不是上述四种方法, 就是动态绑定</li><li>程序使用动态绑定时, 虚拟机必须调用与<code>x</code>引用对象实际类型对应的方法, 比如<code>x</code>的实际类型是<code>D</code>, <code>D</code>是<code>C</code>的子类, 如果<code>D</code>定义了方法<code>f(String)</code>, 那么就会调用这个方法, 否则就会在<code>D</code>的超类中寻找这个方法<ul><li>如果每一次调用方法都需要执行一次搜索的话, 时间消耗非常大, 所以虚拟机预先为每个类计算了一个方法表, 列出了所有方法的签名和需要调用的方法</li><li>虚拟机加载一个类以后就可以构建这个方法表</li></ul></li></ol><div class="note info flat"><ul><li>覆盖一个方法的时候, 子类方法的可见性不能低于超类方法的可见性</li><li>如果超类方法是<code>public</code>, 子类也必须要是<code>public</code>方法, 如果漏了, 就会报错</li></ul></div><h2 id="final方法"><code>final</code>方法</h2><ul><li>使用<code>final</code>修饰一个类, 就可以阻止定义这个类的子类  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">E</span> <span class="keyword">extends</span> <span class="title class_">M</span> &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li><code>final</code>类的方法自动变为<code>final</code>方法</li><li><code>final</code>类的字段<strong>不会自动</strong>变为<code>final</code>字段</li></ul></li><li>如果将类中的某个方法设定为<code>final</code>, 则该类的所有子类都不能覆盖这个方法  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>final</code>字段表示以后都不会改变的字段</li><li>枚举和记录总是<code>final</code>的, 因为他们不允许被扩展</li></ul><h2 id="对象引用的强制类型转换">对象引用的强制类型转换</h2><ul><li>现在有<code>M</code>类是<code>E</code>的子类  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">E</span>[<span class="number">3</span>];</span><br><span class="line">s[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">M</span>();</span><br><span class="line">s[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">E</span>();</span><br><span class="line">s[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">E</span>();</span><br><span class="line"><span class="type">M</span> <span class="variable">b</span> <span class="operator">=</span> (M) s[<span class="number">0</span>]; <span class="comment">// 强制类型转换</span></span><br><span class="line"><span class="type">M</span> <span class="variable">c</span> <span class="operator">=</span> (M) s[<span class="number">1</span>]; <span class="comment">// 抛出异常 ClassCastException</span></span><br></pre></td></tr></table></figure></li><li>为了避免抛出异常, 可以使用<code>instanceof</code>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s[i] <span class="keyword">instanceof</span> M) &#123;</span><br><span class="line">    b = (M) s[i];</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><ul><li><code>Java 16</code>中有更加简单的写法, 可以直接在<code>instanceof</code>语句中声明子类变量<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s[i] <span class="keyword">instanceof</span> M b) &#123;</span><br><span class="line">    b.setB();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><div class="note info flat"><ul><li>只能在继承层次内使用强制类型转换</li><li>将超类转换为子类之前, 需要使用<code>instanceof</code>检查类型</li><li>如果<code>x</code>是<code>null</code>, <code>x instanceof C</code>不会抛出异常, 返回<code>false</code></li><li>一般情况下最好少用强制类型转换和<code>instanceof</code></li></ul></div><h2 id="protected"><code>protected</code></h2><ul><li>将超类中的某个字段声明为<code>protected</code>, 子类就可以进行访问</li><li>受保护的字段只能由同一个包中的类进行访问, 如果子类在不同的包中, 就不能访问了</li><li>相比之下, <code>protected</code>方法更有意义, 表示可以相信子类能够正确的使用这个方法</li><li>所以<code>Java</code>中的<code>protected</code>允许所有子类, 以及同一个包中的所有其他类访问, 不如<code>CPP</code>中的安全</li></ul><h1><code>Object</code></h1><blockquote><p><code>Object</code>类是<code>Java</code>中所有类的超类</p></blockquote><h2 id="写equals方法">写<code>equals</code>方法</h2><ol><li>显式参数命名为<code>otherObject</code></li><li>检测<code>this</code>与<code>otherObject</code>是否相同</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span> == otherObject) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>检测<code>otherObject</code>是否为<code>null</code>, 如果为<code>null</code>, 则返回<code>false</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (otherObject == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>比较<code>this</code>与<code>otherObject</code>的类<br>如果<code>equals</code>的语义可以在子类中改变, 就使用<code>getClass</code>检测</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (getClass() != otherObject.getClass()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">ClassName</span> <span class="variable">other</span> <span class="operator">=</span> (ClassName) otherObject;</span><br><span class="line"><span class="comment">// 这个判断对于匿名子类会失败</span></span><br></pre></td></tr></table></figure><p>如果所有的子类都有相同的相等性语义, 就可以使用<code>instanceof</code>检测</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(otherObject <span class="keyword">instanceof</span> ClassName other)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>使用相等性概念来比较字段, 使用<code>==</code>比较基本类型字段, 使用<code>Objects.equals</code>比较对象字段, 如果所有的字段都匹配, 返回<code>true</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> field1 == other.field1 &amp;&amp; Objects.equals(field2, other.field2) &amp;&amp; ... ;</span><br></pre></td></tr></table></figure><ul><li>对于数组类型, 使用<code>Arrays.equals()</code>方法检查相应的数组元素, 如果是多维数组, 可以使用<code>Arrays.deepEquals()</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(E other)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> other != <span class="literal">null</span> </span><br><span class="line">            &amp;&amp; getClass() == other.getClass() </span><br><span class="line">            &amp;&amp; Objects.equals(name, other.name) </span><br><span class="line">            &amp;&amp; salary == other.salary </span><br><span class="line">            &amp;&amp; Objects.equals(hireDay, other.hireDay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里有错误, 因为参数类型是E, 没有覆盖Object类的equals方法, 而是定义了一个新的方法</span></span><br><span class="line"><span class="comment">// 为了避免这个错误, 可以使用@Override public boolean equals(Object other)</span></span><br><span class="line"><span class="comment">// 此时编译器就会给出报错信息, 因为当前方法没有覆盖Object中的任何方法</span></span><br></pre></td></tr></table></figure><h2 id="hashCode"><code>hashCode</code></h2><blockquote><p><code>hashCode</code>方法定义在<code>Object</code>类中, 所以每个对象都有一个默认的散列码, 由对象的存储地址得出</p></blockquote><ul><li>自定义<code>hashCode</code>方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">7</span> * name.hashCode() </span><br><span class="line">            + <span class="number">11</span> * Double.valueOf(s).hashCode() </span><br><span class="line">            + <span class="number">13</span> * hireDay.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以使用Objects.hashCode(), 这是null安全的, 如果参数为null, 会直接返回0</span></span><br><span class="line"><span class="comment">// 可以使用静态方法Double.hashCode()避免创建一个Double对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">7</span> * Objects.hashCode(name) </span><br><span class="line">            + <span class="number">11</span> * Double.hashCode(s) </span><br><span class="line">            + <span class="number">13</span> * Objects.hashCode(hireDay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果有多个内容需要hash, 可以直接调用Objects.hash()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, s, hireDay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果有数组类型, 可以使用静态<code>Arrays.hashCode()</code>计算一个散列码, 这个散列码由数组元素的散列码组成</li><li>记录类型会自动提供一个<code>hashCode()</code>, 由字段值的散列码得到一个散列码</li></ul><h2 id="toString"><code>toString()</code></h2><ul><li>使用<code>getClass().getName()</code>获得类名的字符串</li><li>每一个子类都应该实现自己的<code>toString()</code>, 如果超类中实现了, 可以直接使用<code>super.toString()</code></li><li>只要一个对象与一个字符串通过<code>+</code>连接, 编译器就会自动调用<code>toString()</code>方法获得这个字符串的描述</li><li>如果<code>x</code>是任意一个对象, 使用<code>System.out.println(x)</code>也会自动调用<code>x.toString()</code></li><li><code>Objects</code>定义了<code>toString()</code>, 会打印对象的类名和散列码</li></ul><h1><code>ArrayList</code></h1><blockquote><p><code>ArrayList</code>是一个有类型参数的泛型类</p></blockquote><ul><li>使用<code>var</code>可以避免重复写类型 <code>var staff = new ArrayList&lt;E&gt;();</code><ul><li>如果使用了<code>var</code>, 就需要声明类型; 如果不使用<code>var</code>, 可以使用菱形语法 <code>ArrayList&lt;E&gt; staff = new Arraylist&lt;&gt;();</code></li></ul></li><li>使用<code>add</code>添加元素, 如果满了会自动扩容</li><li>如果可以估计大小, 可以在添加元素之前使用<code>staff.ensureCapacity(nums)</code>来设置分配的空间<ul><li>也可以使用<code>var staff = new ArrayList&lt;E&gt;(nums)</code>将初始容量传递给构造器</li></ul></li><li>如果数组的大小保持恒定不会发生变化了, 可以使用<code>staff.trimToSize()</code>将内存块的大小调整为当前所需空间, <code>GC</code>回收多余的空间</li></ul><h1>对象包装器</h1><ul><li>有时候需要将<code>int</code>转换为对象, 所有基本类型都有一个与之对应的类</li><li><code>Integer, Long, Float, Double, Short, Byte, Character, Boolean</code> 前六个派生于公共超类<code>Number</code><ul><li>包装类不可变, 一旦构造了包装器, 就不能更改其中的值</li><li>包装器类还是<code>final</code>, 所以不能派生子类</li><li>尖括号中的类型参数不能是基本数据类型, 必须要是包装器类型</li><li>因为每一个值都包装在对象中, 所以<code>ArrayList&lt;integer&gt;</code> 效率低于<code>int[]</code></li></ul></li><li>当使用<code>list.add(3)</code>的时候, 会自动转换为<code>list.add(Integer.valueOf(3))</code>, 这就是自动装箱</li><li>同样的, 当我们使用<code>int n = list.get(i)</code>的时候, 实际上是将<code>Integer</code>对象赋值给<code>int</code>类型, 这是自动拆箱, 等价于<code>list.get(i).intValue()</code></li><li><code>Integer n = 3; n ++;</code>这里面实际上先自动拆箱, 然后<code>+1</code>, 再自动装箱</li><li>不要使用包装器类构造器, 可以使用<code>Integer.valueOf(i)</code>, 也可以依赖自动装箱:<code>Integer a = i</code>, 不要使用<code>new Integer(i)</code>, 这个将会被删除</li><li>包装器类引用可以为<code>null</code>, 所以会触发<code>NPE</code></li><li>如果表达式中混用了<code>Integer, Double</code>, 则<code>Integer</code>会自动拆箱, 提升为<code>double</code>, 再自动装箱为<code>Double</code></li><li>自动装箱和拆箱是编译器做的工作, 不是虚拟机</li></ul><h1>可变参数个数方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> PrintStream <span class="title function_">printf</span><span class="params">(String fmt, Object... args)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> format(fmt, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这里的<code>...</code>表示接受任意数量的对象, 是一个<code>Object</code>数组, 保存着除了<code>fmt</code>之外的其他参数</li><li>如果调用者给了其他类型或者基本类型的值, 就会自动装箱为对象, 现在就只需要<code>fmt</code>中扫描到第<code>i</code>个格式说明, 与<code>args[i]</code>值匹配</li></ul><h1>抽象类</h1><ul><li>如果一个类中存在抽象方法, 类本身必须声明为抽象的; 抽象类<strong>可以没有</strong>抽象方法; 抽象类可以有具体字段和方法  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">P</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">getD</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>抽象类的子类可以保留抽象类中的部分或所有抽象方法, 那么子类依然是抽象的; 也可以全部实现, 则子类不是抽象的</li><li>抽象类不能被实例化, 但是可以存在抽象类的变量, 只是只能引用其非抽象子类  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">P</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">S</span>();</span><br></pre></td></tr></table></figure></li><li>接口是抽象类的泛化</li></ul><h1>密封类</h1><ul><li>比如有一个抽象类<code>JSONValue</code>, 还有两个<code>final</code>子类, 分别是<code>JSONNumber, JSONArray</code></li><li>两个子类是<code>final</code>的, 所以无法被派生了, 但是不能阻止别人派生<code>JSONValue</code></li><li>可以将<code>JSONValue</code>声明为密封类  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">JSONValue</span></span><br><span class="line">    <span class="keyword">permits</span> JSONArray, JSONNumber, JSONString, JSONBoolean, JSONObject, JSONNull &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 这样使用sealed声明为密封类, 可以保证JSONValue只有六个定义好的子类, 无法派生别的子类了</span></span><br></pre></td></tr></table></figure></li><li>一个密封类的子类必须是可以访问的, 不能是嵌套在别的类中的私有类, 也不能位于另一个包中</li><li>密封类允许的公共子类, 必须要在同一个包中, 如果使用了模块, 还必须要在同一个模块中</li><li>声明密封类可以不加<code>permits</code>, 但是这样的话所有子类都必须要在同一个文件中声明, 这样的话, 子类就不是公共的了</li><li>密封类的子类必须声明为<code>sealed, final, non-sealed</code>中的一种，最后一种允许继续派生</li></ul><h1>反射</h1><h2 id="Class类"><code>Class</code>类</h2><ul><li><code>Java</code>始终为所有对象维护一个运行时类型标识, 跟踪每个对象所属的类</li><li>可以用<code>Class</code>类访问这些信息, <code>Object.getClass()</code>返回一个<code>Class</code>对象的实例<ul><li>最常用的方法就是<code>getName()</code>, 返回一个对象类型的名称, 包名也作为类名的一部分</li></ul></li><li>也可以直接使用<code>类名.class</code>的方法访问这个类</li><li>虚拟机为每个类型管理一个唯一的<code>Class</code>对象, 所以可以使用<code>==</code>比较  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (e.getClass() == E.class) &#123;&#125;</span><br><span class="line"><span class="comment">// 如果e是一个E的实例, 则为true, 如果是M的实例, 其中M是E的子类, 则为false</span></span><br><span class="line"><span class="comment">// 如果是 e instanceof E的话, 那么当e是M的实例时, 依然会返回true</span></span><br></pre></td></tr></table></figure></li><li>如果有一个<code>Class</code>类型的对象, 可以用他构造实例  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">className</span> <span class="operator">=</span> <span class="string">&quot;java.uril.Random&quot;</span>;</span><br><span class="line"><span class="type">Class</span> <span class="variable">cl</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> cl.getConstructor().newInstance();</span><br><span class="line"><span class="comment">// 如果这个类没有无参构造器, 则会抛出异常InvocationTargetException</span></span><br></pre></td></tr></table></figure></li><li><code>Class.forName()</code>会抛出一个检查型异常, 没有办法保证指定名字的类一定存在, 所以需要在函数后面加上<code>throws ReflectOperationException</code></li></ul><h2 id="异常">异常</h2><ul><li>分两种: 非检查型异常和检查型异常<ul><li>检查型异常: 编译器会检查你是否知道这个异常, 并做后准备处理</li><li>非检查型异常: 比如数组越界, null引用访问, 编译器不期望你为这些异常提供处理方法</li></ul></li></ul><h2 id="应用">应用</h2><ol><li><p>资源文件加载</p><ul><li>获得拥有资源的类的<code>Class</code>对象, 比如<code>ResourcesTest.class</code></li><li>调用部分可以接受描述资源位置<code>URL</code>的方法, 比如<code>URL url = cl.getResource(&quot;about.txt&quot;);</code></li><li>否则, 使用<code>getResourceStream()</code>得到输入流读取文件</li></ul></li><li><p>国际化</p><ul><li>与语言相关的字符串都放在资源文件中, 每个语言对应一个文件</li></ul></li></ol><h2 id="利用反射分析类">利用反射分析类</h2><ul><li><code>java.util.reflect</code>包中有三个类: <code>Field, Method, Constructor</code>, 分别用于描述类的字段, 方法和构造器<ul><li>三个类都有一个方法, 名为<code>getName()</code></li><li><code>Field.getType()</code>可以返回字段类型的一个对象, 对象的类型同样是<code>Class</code></li><li><code>Method, Constructor</code>有报告类型参数的方法, <code>Method</code>有报告返回类型的方法, 三者都有<code>getModifiers()</code> 返回一个整数, 用不同的<code>0/1</code>位描述修饰符, 比如<code>public, static</code></li><li>可以使用<code>Modifier</code>类的静态方法分析<code>getModifiers()</code>返回的整数, 需要做的就是在返回的整数基础上, 调用<code>Modifier</code>类中适当的方法</li><li>可以用<code>Modifier.toString()</code>打印修饰符</li></ul></li><li><code>Class</code>中的<code>getFields(), getMethods(), getConstructors()</code>分别返回这个类支持的公共字段, 方法和构造器</li><li><code>Class</code>中的<code>getDeclaredFields(), getDeclaredMethods(), getDeclaredConstructors()</code>返回这个类声明的全部字段, 方法和构造器, 包括私有成员， 包成员, <code>protected</code>成员, 有包访问权限的成员, 但是不会包括超类的成员</li></ul><h2 id="利用反射分析对象">利用反射分析对象</h2><ul><li>利用反射可以查看在编译时还不知道的对象字段</li><li>利用<code>Field</code>中的<code>get</code>, 比如<code>f</code>是一个<code>Field</code>类型的对象, <code>obj</code>是包含<code>f</code>字段的类的对象, 则<code>f.get(obj)</code>将会返回一个对象, 值为<code>obj</code>的当前字段值  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">E</span>();</span><br><span class="line"><span class="type">Class</span> <span class="variable">cl</span> <span class="operator">=</span> h.getClass();</span><br><span class="line"><span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> cl.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">v</span> <span class="operator">=</span> f.get(h);</span><br></pre></td></tr></table></figure></li><li>同样可使用<code>f.set(obj, val)</code>设置值, 但是如果<code>name</code>是一个私有字段, 则不能使用<code>get, set</code>, 会抛出<code>IllageAccessException</code></li><li>只能对可以访问的字段使用<code>get, set</code>, <code>Java</code>允许查看一个对象中的字段, 但是无法访问</li><li>不过可以调用<code>f.setAccessible(true)</code>覆盖<code>Java</code>的访问控制</li><li><code>setAccessible()</code>是<code>Field, Method, Constructor</code>的公共超类<code>AccessibleObject</code>中的方法</li></ul><h2 id="通用toString">通用<code>toString()</code></h2><ul><li>使用<code>getDeclaredFields</code>获得实例字段, 使用<code>setAccessible()</code>将字段设置为可以访问的, 再对每个字段调用<code>toString()</code></li><li>不过如果引用循环会导致无限递归, <code>ObjectAnalyzer</code>会跟踪已经访问过的对象</li></ul><h2 id="使用反射编写泛型数组">使用反射编写泛型数组</h2><ul><li><code>java.util.reflect</code>中的<code>Array</code>类, <code>Arrays.copyOf()</code>就使用了这个类, 这个方法可以用来扩展一个数组  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">goodCopyOf</span><span class="params">(Object a, <span class="type">int</span> newLength)</span> &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">cl</span> <span class="operator">=</span> a.getClass();</span><br><span class="line">    <span class="keyword">if</span> (!cl.isArray()) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">componentType</span> <span class="operator">=</span> cl.getComponentType();</span><br><span class="line">    <span class="comment">// 如果对象是一个数组类型, 返回对应元素的Class, 否则返回null</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> Array.getLength(a);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">newArray</span> <span class="operator">=</span> Array.newInstance(componentType, newLength);</span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, newArray, <span class="number">0</span>, Math.min(length, newLength));</span><br><span class="line">    <span class="keyword">return</span> newArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>这个<code>goodCopyOf</code>可以扩展任意数组, 参数声明为<code>Object</code>类型, 而不是<code>Object[]</code>, 因为<code>int[]</code>可以转换为一个<code>Object</code>, 而不是转换成对象数组</li><li>如果是<code>Object[]</code>的话, 在强制类型转换回去的时候会抛出异常: <code>ClassCastException</code></li></ul><h2 id="使用反射调用任意的方法">使用反射调用任意的方法</h2><ul><li>可以使用<code>Field.get()</code>查看一个方法的字段, 使用<code>Method.invoke()</code>调用包装在当前<code>Method</code>中的方法  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Object <span class="title function_">invoke</span><span class="params">(Object obj, Object... args)</span>;</span><br><span class="line"><span class="comment">// 第一个参数是隐式参数, 其他参数是显式参数</span></span><br><span class="line"><span class="comment">// 如果是静态方法, 则第一个参数会被忽略为null</span></span><br><span class="line"><span class="comment">// 比如m1表示E类中的getName()</span></span><br><span class="line"><span class="type">String</span> <span class="variable">n</span> <span class="operator">=</span> (String) m1.invoke(h);</span><br><span class="line"><span class="comment">// 如果返回的是基本数据类型, invoke会返回其包装类型, 需要强制类型转换后使用自动拆箱</span></span><br><span class="line"><span class="comment">// 比如m2表示E类中的getSalary()</span></span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> (Double) m2.invoke(h);</span><br><span class="line"><span class="comment">// 使用getMethod()可以得到一个类中的方法</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">m1</span> <span class="operator">=</span> E.class.getMethod(<span class="string">&quot;getName&quot;</span>);</span><br><span class="line"><span class="type">Method</span> <span class="variable">m2</span> <span class="operator">=</span> E.class.getMethod(<span class="string">&quot;getSalary&quot;</span>, <span class="type">double</span>.class);</span><br><span class="line"><span class="comment">// 可以获得构造器方法</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">cl</span> <span class="operator">=</span> Random.class;</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">cons</span> <span class="operator">=</span> cl.getConstructor(<span class="type">long</span>.class);</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> cons.newInstance(<span class="number">42L</span>);</span><br></pre></td></tr></table></figure></li><li><code>Method, Construtor</code>类扩展了<code>Executable</code>类, 并且<code>Executable</code>是<code>sealed</code>的, 只允许<code>Method, Constructor</code>作为子类</li><li>比如调用<code>Math.sqrt()</code>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">dx</span> <span class="operator">=</span> (to - from) / (n - <span class="number">1</span>);</span><br><span class="line">Math.class.getMethod(<span class="string">&quot;sqrt&quot;</span>, <span class="type">double</span>.class);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> from; x &lt;= to; x += dx) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> <span class="variable">y</span> <span class="operator">=</span> (Double) f.invoke(<span class="literal">null</span>, x);</span><br><span class="line">    <span class="comment">// 因为Math.sqrt是一个静态方法, 所以invoke的第一个参数为null</span></span><br><span class="line">    System.out.printf(<span class="string">&quot;%10.4f | %10.4f%n&quot;</span>, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>反射能完成所有操作, 但是很不方便, <code>invoke</code>参数错误还会抛出异常. 同时<code>invoke</code>返回类型一定是<code>Object</code>的, 所以必须来回强制类型转换</li><li>编译器就丧失了检查代码的机会, 反射获得方法指针的代码比直接调用慢的多</li><li>所以一般只有绝对必要的时候才会引入<code>Method</code>对象, 更好的方法是使用<code>lambda</code>表达式</li><li>不要使用回调函数的<code>Method</code>对象, 要是用回掉的接口, 这样执行速度更快, 也更好维护</li></ul><h1>继承设计技巧</h1><ol><li>公共字段和方法放在超类中</li><li>不要使用<code>protected</code></li><li>使用继承实现<code>is-a</code>关系</li><li>除非所有继承的方法都有意义, 否则不要使用继承</li><li>覆盖方法不要改变预期的行为</li><li>不要滥用反射</li><li>使用多态, 不要使用类型信息 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x is of type <span class="number">1</span>) </span><br><span class="line">    action1(x)</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    action2(x)</span><br><span class="line"><span class="comment">// 这种形式的代码都可以用多态实现</span></span><br><span class="line"><span class="comment">// 如果action1() action2()表示通用的概念, 可以定义为这两个类型的公共超类或接口中的方法, 然后可以调用</span></span><br><span class="line"><span class="comment">// x.action(), 利用多态的动态分配机制执行正确的动作</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java核心技术(卷一) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记_8</title>
      <link href="/posts/6a129434.html"/>
      <url>/posts/6a129434.html</url>
      
        <content type="html"><![CDATA[<h1>接口</h1><blockquote><p>接口用来描述类应该做什么, 不指定具体如何做, 一个类可以实现多个接口</p></blockquote><ul><li>接口可以定义常量, 但是绝不能有实例字段</li><li><code>Java 8</code>之前, 接口中的方法都是抽象方法</li></ul><div class="note info flat"><ul><li>定义接口的方法不必指定为<code>public</code>, 因为接口方法自动为<code>public</code></li><li>接口中的字段都是<code>public static final</code>的, 也不需要手动指定</li><li>但是实现接口时, 必须明确写<code>public</code>, 否则编译器会默认认为这个方法的访问属性是包可访问, 就会报错</li></ul></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">E</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;E&gt; &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(E oth)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Double.compare(salary, oth.salary);</span><br><span class="line">    <span class="comment">// 如果x &lt; y 返回 负数</span></span><br><span class="line">    <span class="comment">// 如果x = y 返回 0</span></span><br><span class="line">    <span class="comment">// 如果x &gt; y 返回正数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info flat"><ul><li><code>Comparable</code>接口文档建议<code>compareTo</code>方法与<code>equals</code>方法兼容, 即<code>x.equals(y)</code>时, <code>x.compareTo(y) == 0</code></li><li>大部分都是兼容的, 除了<code>BigDecimal</code><ul><li><code>x = new BigDecimal(&quot;1.0&quot;)</code>和<code>y = new BigDecimal(&quot;1.00&quot;);</code>因为精度不同, 所以<code>x.compareTo(y) == 0</code>但是<code>x.equals(y) == false;</code></li><li>理论上应该不返回<code>0</code>, 但是不知道谁大谁小</li></ul></li></ul></div><ul><li>语言标准规定 <code>x.compareTo(y) == -y.compareTo(x)</code>, 同样如果前者抛出异常, 后者也必须抛出异常</li><li>如果<code>M</code>继承自<code>E</code>, <code>E</code>实现了<code>Comparable&lt;E&gt;</code>, 而没有实现<code>Comparable&lt;M&gt;</code></li><li>如果要在<code>M</code>中重写, 就要做好准备比较<code>M</code>和<code>E</code>, 不能简单的将<code>E</code>转换为<code>M</code></li><li>比如<code>x</code>是<code>M</code>, <code>y</code>是<code>E</code>, 调用<code>y.compareTo(x)</code>不会抛出异常, 调用<code>x.compareTo(y)</code>就会抛出一个<code>ClassCastException</code></li><li>可以在每个<code>compareTo</code>之前都进行检测: <code>if (getClass != oth.getClass()) throw new ClassCastException</code></li></ul><h2 id="接口属性">接口属性</h2><ul><li>接口不是类, 不能使用<code>new Comparable()</code></li><li>但是可以使用接口变量, 必须引用一个实现了这个接口的对象<code>Comparable x = new E()</code></li><li>可以使用<code>instanceof</code>检查某个对象是否实现了一个接口</li><li>可以使用<code>extends</code>扩展接口, 一个类只能有一个超类, 但是可以实现多个接口</li></ul><div class="note info flat"><ul><li>记录和枚举类不能扩展其他类, 因为他们隐式扩展了<code>Record</code>和<code>Enum</code>类, 但是他们可以实现接口</li><li>接口也可以是密封的<code>sealed</code>, 直接子类型, 必须声明在<code>permits</code>中, 或者在一个文件中</li></ul></div><h2 id="默认方法">默认方法</h2><ul><li><p>可以为接口提供一个<code>default</code>方法, 表示方法的默认实现</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(T oth)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>大部分情况没什么用, 因为每个实现的接口都会覆盖这个方法</p></li><li><p>不过有时候也能有用, 比如<code>Iterator</code>接口, 声明了一个<code>remove()</code></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportOperationException</span>(<span class="string">&quot;remove&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>默认方法也可以调用其他方法</p></li><li><p>默认方法可以实现接口演化, 实现代码兼容. 比如以前有一个类<code>class B implements Collection</code>, 后来<code>Java</code>版本更新, <code>Collection</code>接口中添加了新的方法, 如果不用<code>default</code>修饰新的方法就会导致原来的类<code>B</code>无法编译</p></li><li><p>如果在一个接口中定义了一个方法, 在超类或者另一个接口中定义了同样的方法, <code>Java</code>有自己的规则:</p><ol><li>超类优先: 如果超类定义了一个具体方法, 同名且有相同参数类型的默认方法会被忽略</li><li>接口冲突: 如果一个接口提供了一个默认方法, 另一个接口提供了一个同名并且参数类型相同的方法, 不论是否为默认方法, 就需要覆盖这个方法来解决冲突 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Name</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;<span class="keyword">return</span> getClass().getName() + <span class="string">&quot;_&quot;</span> + hashCode();&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果有一个类同时实现了这两个接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Person</span>, Name &#123;&#125;</span><br><span class="line"><span class="comment">// 编译器会报错, 需要在Student类中提供一个getName(), 可以选择两个冲突方法中的一个</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Person</span>, Name &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Person.<span class="built_in">super</span>.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 就算如果Name类中没有定义默认的getName()方法, 编译器还是会报错, 要求程序员解决二义性问题</span></span><br><span class="line"><span class="comment">// 如果两个类都没有提供默认的getName()方法, 就不会有冲突</span></span><br></pre></td></tr></table></figure><ul><li>另一种情况是类扩展了超类, 同时实现了一个接口, 超类和接口继承了相同的方法</li></ul> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Name</span> &#123;&#125;</span><br><span class="line"><span class="comment">// 这种情况下只会考虑超类的方法, 接口所有的默认方法都会被忽略</span></span><br><span class="line"><span class="comment">// 类优先的规则可以确保和Java 7的兼容性</span></span><br><span class="line"><span class="comment">// 如果为一个接口添加默认方法, 对于有默认方法之前的版本代码不会有影响</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><div class="note info flat"><ul><li>绝对不能为<code>Object</code>某个方法定义默认方法, 比如<code>toString(), equals()</code></li><li>因为类优先的规则, 这样的方法绝对无法超越<code>Object.toString()</code>或<code>Objects.equals()</code></li></ul></div><h2 id="Comparator接口"><code>Comparator</code>接口</h2><ul><li><p>如果调用<code>Arrays.sort()</code>对字符串进行排序的话, 会按照字典序</p></li><li><p>现在如果想要按照字符串的长度进行排序, 就不能修改<code>String.compareTo()</code></p></li><li><p>可以使用<code>Arrays.sort()</code>方法的第二个版本, 接受一个数组和一个比较器作为参数, 比较器是实现了<code>Comparator</code>接口的类的实例</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">compare</span><span class="params">(T first, T second)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 比如需要按照长度比较字符串, 可以以如下方法实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LengthComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String first, String second)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> first.length() - second.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 完成比较需要建立一个实例</span></span><br><span class="line"><span class="type">var</span> <span class="variable">comp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LengthComparator</span>();</span><br><span class="line"><span class="keyword">if</span> (comp.compare(words[i], words[j]) &gt; <span class="number">0</span>) &#123;&#125;</span><br><span class="line"><span class="comment">// 如果需要对一个数组进行排序, 可以调用 Arrays.sort()</span></span><br><span class="line">String[] f = &#123;&#125;;</span><br><span class="line">Arrays.sort(f, <span class="keyword">new</span> <span class="title class_">LengthComparator</span>);</span><br></pre></td></tr></table></figure></li><li><p>静态<code>comparing</code>方法接受一个键提取器函数, 将类型<code>T</code>映射为一个可比较的类型, 比如<code>String</code></p><ul><li>要比较的对象引用这个函数, 然后对返回的键完成比较, 比如假设有一个<code>Person</code>数组, 可以按照名字进行排序</li><li><code>Arrays.sort(people, Comparator.comparing(Person::getName));</code></li><li>可以把比较器和<code>thenComparing()</code>串起来, 处理比较相同的结果</li><li><code>Arrays.sort(people, Comparator.comparing(Person::getLastName).thenComparing(Person::getFirstName));</code></li><li>可以给<code>comparing</code>和<code>thenComparing</code>提取的键指定一个比较器, 完成对人名长度的排序</li><li><code>Arrays.sort(people, Comparator.comparing(Person::getName, (s, t) -&gt; Integer.compare(s.length(), t.length())));</code></li><li><code>Arrays.sort(people, Comparator.comparingInt(p -&gt; p.getName().length()));</code></li></ul></li><li><p>如果键函数可能返回<code>null</code>, 就需要用到<code>nullsFirst</code>和<code>nullsLast</code>适配器, 可以修改比较器, 遇到<code>null</code>的时候不会抛出异常, 而是标记当前值小于或大于正常值</p><ul><li><code>Comparator.comparing(Person::getMiddleName(), Comparator.nullsFirst(...));</code></li><li><code>nullsFirst</code>方法需要一个比较器, 就是两个字符串的比较器</li><li><code>naturalOrder</code>方法可以为任何实现了<code>Comparable</code>的类建立一个比较器</li><li><code>Arrays.sort(people, comparing(Person::getMiddleName, nullsFirst(naturalOrder()));</code></li><li>静态<code>reverseOrder</code>方法可以提供逆序, 等同于<code>naturalOrder().reversed()</code></li></ul></li></ul><h2 id="Cloneable接口"><code>Cloneable</code>接口</h2><ul><li><code>clone</code>是<code>Object</code>的<code>protected</code>方法, 不能直接调用这个方法, 子类只能调用受保护的<code>clone()</code>来克隆他自己的对象, 如果其中包含了一些其他对象, 就没有办法<code>clone</code>了</li><li>默认的克隆操作是一个浅拷贝, 没有克隆对象中引用的其他对象</li><li>如果原对象和浅克隆对象共享的子对象是不可变的, 那么这种共享就是安全的, 比如<code>String</code><ul><li>或者在对象生命周期中, 子对象一直保持不变，没有更改器方法改变它, 也没有方法生成他的引用, 这种情况下就是安全的</li></ul></li><li>但是大多数情况下, 子对象都是可变的, 必须重新定义<code>clone</code>方法, 需要确定<ol><li>默认的<code>clone</code>方法能满足要求</li><li>可以在可变子对象上调用<code>clone</code>弥补默认的<code>clone</code></li><li>不能使用<code>clone</code></li></ol><ul><li>如果指定第一项或者第二项, 需要实现<code>Cloneable</code>接口, 重新定义<code>clone</code>方法, 同时指定<code>public</code></li></ul></li></ul><div class="note info flat"><ul><li><code>Cloneable</code>接口是<code>Java</code>中少数的标记接口, 记号接口</li><li>用途是确保一个类实现一个特定的方法或一组方法, 标记接口不包含任何方法, 唯一的作用就是允许在类型查询中使用<code>instabceof</code></li><li>自己写代码<strong>不要</strong>使用标记接口</li></ul></div><ul><li>即使默认的<code>clone()</code>可以满足要求, 还是需要实现<code>Clonebale</code>接口, 将<code>clone</code>重新定义为<code>public</code>, 调用<code>super.clone()</code>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">E</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportException &#123;</span><br><span class="line">        <span class="type">E</span> <span class="variable">cloned</span> <span class="operator">=</span> (E) <span class="built_in">super</span>.clone();</span><br><span class="line">        cloned.Day = (Date) Day.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><div class="note info flat"><ul><li>需要注意子类的克隆, 一旦为<code>E</code>定义了<code>clone()</code>, 别人就可以使用他克隆子类<code>M</code></li><li>所以最好避免使用<code>clone()</code>, 使用另一个方法达到同样的目的</li></ul></div><h1><code>lambda</code>表达式</h1><blockquote><p><code>lambda</code>表达式是一个可传递的代码块, 可以在以后执行一次或多次</p></blockquote><ul><li>以上面的排序为例, <code>first.length() - secode.length()</code> 其中<code>first, second</code>都是字符串  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lambda表达式写法</span></span><br><span class="line">(String first, String second) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (first.length() &lt; second.length()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (first.length() &gt; second.length()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 即使lambda表达式没有参数, 仍然需要提供空括号</span></span><br><span class="line">() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果可以推导出lambda表达式的类型, 就可以忽略类型</span></span><br><span class="line">Comparator&lt;String&gt; comp = (first, second) -&gt; &#123;</span><br><span class="line">    first.length() - second.length();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果只有一个参数, 并且参数类型还可以推导出来, 那么还可以省略小括号</span></span><br><span class="line"><span class="type">ActionListener</span> <span class="variable">listener</span> <span class="operator">=</span> event -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;1111&quot;</span> + Instant.ofEpochMilli(event.getWhen()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不需要指定lambda表达式的返回类型, 因为返回类型一定会根据上下文推导得到</span></span><br><span class="line"><span class="comment">// 可以使用var指示一个推导的类型, 不常用, 一般为了关联注解</span></span><br><span class="line">(<span class="meta">@NonNull</span> <span class="keyword">var</span> first, <span class="meta">@NonNull</span> <span class="keyword">var</span> second) -&gt; first.length() - second.length();</span><br></pre></td></tr></table></figure></li></ul><div class="note info flat"><ul><li>如果一个<code>lambda</code>表达式只有部分分支有返回值, 是不合法的</li></ul></div><h2 id="函数式接口">函数式接口</h2><ul><li>对于只有一个抽象方法的接口, 需要这种接口的对象时, 就可以提供一个<code>lambda</code>表达式, 称为函数式接口  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比如Arrays.sort()第二个参数需要一个Comparator实例</span></span><br><span class="line"><span class="comment">// 只有一个抽象方法的接口, 就可以改成lambda表达式</span></span><br><span class="line">Arrays.sort(words, (first, second) -&gt; first.length() - second.length());</span><br><span class="line"><span class="comment">// 可以把lambda表达式看作一个函数, 而不是一个对象, 同时lambda表达式可以传递到函数式接口</span></span><br><span class="line"><span class="comment">// 不能把lambda表达式赋值给类型为Object的变量, Object不是一个函数式接口</span></span><br><span class="line"><span class="comment">// ArrayList通过lambda表达式删除一个数组列表中所有的null</span></span><br><span class="line">list.removeIf(e -&gt; e == <span class="literal">null</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="方法引用">方法引用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>(<span class="number">1000</span>, event -&gt; System.out.println(event));</span><br><span class="line"><span class="comment">// 方法引用可以直接将println传入timer中</span></span><br><span class="line"><span class="type">var</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>(<span class="number">1000</span>, System.out::println);</span><br><span class="line"><span class="comment">// 这里System.out::println是一个方法引用</span></span><br><span class="line"><span class="comment">// 指示编译器生成一个函数式接口实例, 覆盖这个接口的抽象方法来调用给定的方法</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> System.out::println;</span><br><span class="line"><span class="comment">// 这里的Runnable函数式接口有一个无参数的抽象方法 void run()</span></span><br><span class="line"><span class="comment">// 这里调用task.run() 就会自动选择无参数的println() 打印一个空行</span></span><br><span class="line"><span class="comment">// 如果想要对字符串进行排序, 忽略大小写</span></span><br><span class="line">Arrays.sort(words, String::compareToIgnoreCase);</span><br></pre></td></tr></table></figure><ul><li>使用<code>::</code>操作符分割方法名和对象或者类名, 有三种情况:<ol><li><code>object::instanceMethod</code><ul><li>方法引用等价于一个<code>lambda</code>表达式, 参数传递到方法, 对于<code>System.out::println</code>, 对象是<code>System.out</code>, 方法等价于<code>x -&gt; System.out.println(x)</code></li></ul></li><li><code>Class::instanceMethod</code><ul><li>第一个参数会成为隐式参数, 比如<code>String::compareToIgnoreCase</code>等同于<code>(x, y) -&gt; x.compareToIgnoreCase(y)</code></li></ul></li><li><code>Class::staticMethod</code><ul><li>所有参数都传递到静态方法, <code>Math::pow</code>等价于<code>(x, y) -&gt; Math.pow(x, y)</code></li></ul></li></ol></li></ul><div class="note info flat"><ul><li>只有当<code>lambda</code>表达式的体只调用一个方法而不做其他操作的时候, 才能将其转换为方法引用</li><li><code>s -&gt; s.length() == 0</code>里面只有一个方法调用, 但是还有一个比较, 所以不能使用方法引用</li><li>方法引用不会独立存在, 总是会转换为函数式接口的实例</li><li>如果要删除数组中所有为空的值, 可以使用 <code>list.removeIf(Objects::isNull)</code></li><li>包含对象的方法引用与等价的<code>lambda</code>表达式的区别, 比如<code>separator::equals</code>, 如果<code>separator</code>为<code>null</code>, 构造<code>separator::equals</code>时就会立即抛出<code>NullPointerException</code>异常, <code>lambda</code>表达式<code>x -&gt; separator.equals(x)</code>只会在调用时才会抛出<code>NPE</code></li></ul></div><ul><li>可以在方法引用中使用<code>this</code>参数, 比如<code>this::equals</code> 等同于<code>x -&gt; this.equals(x)</code></li><li>同样使用<code>super</code>也是可以的</li></ul><h2 id="构造器引用">构造器引用</h2><blockquote><p>和方法引用类似, 只不过方法名为<code>new</code>, 比如<code>Person::new</code>是<code>Person</code>的构造器引用, 使用哪一个构造器取决于上下文</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; names = ...;</span><br><span class="line">Stream&lt;Person&gt; stream = names.stream().map(Person::<span class="keyword">new</span>);</span><br><span class="line">List&lt;Person&gt; people = stream.toList();</span><br><span class="line"><span class="comment">// 这里将字符串列表转换为一个Person数组</span></span><br><span class="line"><span class="comment">// map为各个列表元素调用Person(String)构造器</span></span><br></pre></td></tr></table></figure><ul><li><code>int[]::new</code>有一个数组的长度作为参数, 是一个构造器引用</li><li><code>Java</code>中无法构造泛型类型<code>T</code>的数组, 数组构造器可以克服这个限制</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object[] people = stream.toArray();</span><br><span class="line"><span class="comment">// toArray()可以返回一个Object类型数组, 但是如果希望得到一个Person数组, 就需要构造器引用</span></span><br><span class="line">Person[] people = stream.toArray(Person[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure><h2 id="变量作用域">变量作用域</h2><ul><li>一个<code>lambda</code>表达式有三个部分<ol><li>一个代码块</li><li>参数</li><li>自由变量: 指非参数, 并且不在代码中定义的变量</li></ol></li><li><code>lambda</code>会将自由变量的值复制到<code>lambda</code>表达式的数据结构实例对象中</li></ul><div class="note info flat"><ul><li><code>lambda</code>表达式中只能引用不会改变的值, 比如引用<code>int</code>就是不合法的</li><li>如果在<code>lambda</code>表达式中更改变量, 并发执行多个动作的时候就不安全</li><li>就算<code>lambda</code>表达式内部没有修改变量, 但是这个变量也有可能在外部改变, 这也是不合法的</li><li><code>lambda</code>表达式捕获的变量必须是<strong>事实最终变量</strong>, 指的是这个变量初始化以后不会赋新值, 比如<code>String</code></li><li><code>lambda</code>表达式中不能声明和局部变量同名的参数或变量</li></ul></div><ul><li>在<code>lambda</code>表达式中使用<code>this</code>参数的时候, 是指创建这个<code>lambda</code>表达式的方法的<code>this</code>参数  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> event -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="built_in">this</span>.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里的this.toString()调用的是A对象的toString(), 而不是B实例方法</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="处理lambda表达式">处理<code>lambda</code>表达式</h2><blockquote><p><code>lambda</code>表达式的重点是延迟执行</p></blockquote><ul><li>延迟执行的原因<ol><li>单线程</li><li>多次运行代码</li><li>在算法的适当位置运行, 比如排序的比较操作</li><li>发生某种情况的时候运行, 比如点击按钮, 数据到达</li><li>只有必要时才运行代码</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repeat(<span class="number">10</span>, () -&gt; System.out.println(<span class="string">&quot;1&quot;</span>));</span><br></pre></td></tr></table></figure><ul><li>如果设计自己的函数式接口, 里面只有一个抽象方法, 可以使用<code>@FunctionalInterface</code>注解来标记接口<ul><li>这样如果添加了一个新的抽象方法, 可以检查出来并报错</li><li>同时<code>javadoc</code>会标记这个接口是一个函数式接口</li><li>不是必须使用这个注解</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java核心技术(卷一) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker笔记_0</title>
      <link href="/posts/81d2299d.html"/>
      <url>/posts/81d2299d.html</url>
      
        <content type="html"><![CDATA[<h1><code>Docker</code> 下载安装</h1><blockquote><p>众所周知, 来自中国的程序员往往具有更好的网络相关基础 :(</p><p>因为多次尝试在<code>Ubuntu</code>上安装<code>Docker</code>以及<code>Docker Compose</code>, 中间踩了无数坑, 为此在这里做一个记录总结</p><p>如果有条件, 直接<code>clash</code>, 按照官网的流程, 大抵是可行的 (虽然我尝试了一下还是存在不少问题…)</p><p>哪怕直接<code>sudo apt install docker</code> 也是完全不行的, 软件源中的<code>docker</code>是究极老版本, 几乎用不了</p></blockquote><ol><li>卸载 <code>Docker</code> (有可能叫<code>docker-engine</code> <code>docker.io</code>)</li></ol><blockquote><p><code>Ubuntu</code>大概率会自带老版本的<code>Docker</code>, 很多语法还有命令都不一样了, 所以需要先卸载了</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt remove docker docker-engine docker.io containerd runc</span><br></pre></td></tr></table></figure><ol start="2"><li>更新软件包</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade</span><br></pre></td></tr></table></figure><ol start="3"><li>安装一些依赖</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ca-certificates curl gnupg lsb-release</span><br></pre></td></tr></table></figure><ol start="4"><li>添加<code>Docker</code>官方<code>GPG</code>密钥</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure><ol start="5"><li>添加<code>Docker</code>软件源</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository &quot;deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot;</span><br></pre></td></tr></table></figure><ol start="6"><li>安装<code>Docker</code></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure><ol start="7"><li>配置用户组</li></ol><blockquote><p>如果不配置的话, 运行<code>Docker</code>的时候会一直提示没有<code>root</code>权限</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure><ul><li>配置完以后需要重新登录才能刷新</li></ul><h1><code>Docker Compose</code> 下载安装</h1><ol><li><p>使用<code>docker version</code>查看<code>Docker</code>版本</p></li><li><p>接着按照<a href="https://docs.docker.com/compose/install/">这个链接</a>里面步骤操作即可.</p><ul><li>因为现在我三台<code>Linux</code>服务器已经安装过了, 不想再卸载重新搞了, 以后下一台机器搞的时候再加上截图以及具体步骤</li></ul></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">github: https://github.com/docker/compose/releases/tag/v2.20.2</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">国内下载地址：https://gitee.com/smilezgy/compose/releases/tag/v2.20.2</span></span><br><span class="line">sudo curl -SL \</span><br><span class="line">https://github.com/docker/compose/releases/download/v2.20.2/docker-compose-linux-x86_64 \</span><br><span class="line">-o /usr/local/bin/docker-compose</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者手动下载, 上传到服务器后执行如下指令(use)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在 docker-compose-linux-x86_64 文件同一目录下执行</span></span><br><span class="line">sudo cp docker-compose-linux-x86_64 /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><ol start="3"><li>添加执行权限</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><h1>使用<code>Docker</code>以及<code>Docker Compose</code></h1><blockquote><p>安装好只是第一步. 2024-06 之后<code>Docker</code>国内的绝大部分镜像站都停了</p><p>比如<code>Docker</code>中国, 网易云, 七牛云, 腾讯云, 百度云, 各个大学</p></blockquote><ul><li>可以在<a href="https://gist.github.com/y0ngb1n/7e8f16af3242c7815e7ca2f0833d3ea6">这个链接</a>中找到停止服务的镜像以及还能用的镜像</li></ul><h2 id="2024-10为止还能使用的镜像站">2024-10为止还能使用的镜像站</h2><blockquote><p>不知道还会撑多久 :(</p></blockquote><table><thead><tr><th>镜像站</th><th>链接</th></tr></thead><tbody><tr><td>1Panel</td><td><a href="https://docker.1panel.live">https://docker.1panel.live</a></td></tr><tr><td>耗子面板</td><td><a href="https://hub.rat.dev">https://hub.rat.dev</a></td></tr><tr><td>不知名</td><td><a href="https://docker.zlzlme.cloudns.ph/">https://docker.zlzlme.cloudns.ph/</a></td></tr></tbody></table><h2 id="Docker换源"><code>Docker</code>换源</h2><blockquote><p>如果不换源, 那么<code>docker pull</code>就会失败</p></blockquote><ol><li>编辑<code>/etc/docker/daemon.json</code></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/docker/daemon.json</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">daemon.json</span></span><br><span class="line">&#123;</span><br><span class="line">    &quot;registry-mirrors&quot;: [</span><br><span class="line">        &quot;https://docker.1panel.live&quot;,</span><br><span class="line">        &quot;https://hub.rat.dev&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>重启<code>Docker</code>服务</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><ol start="3"><li>检查是否配置成功</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker info</span><br></pre></td></tr></table></figure><ul><li>如果配置成功了, 镜像信息会显示在最后</li></ul>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Docker Compose </tag>
            
            <tag> Docker安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记_6</title>
      <link href="/posts/8daab933.html"/>
      <url>/posts/8daab933.html</url>
      
        <content type="html"><![CDATA[<h1>面向对象编程(<code>OOP</code>)</h1><ul><li><code>Java</code>中对象变量只是包含了一个引用，没有实际包含一个变量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">startTime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="comment">// 这里的startTime只是一个指向Date实例的引用</span></span><br><span class="line"><span class="comment">// 不能看作是CPP中的引用，应该看作CPP中的对象指针，也就是Date* startTime</span></span><br></pre></td></tr></table></figure><ul><li>所有的<code>Java</code>对象都存储在堆中，当一个对象包含了另一个对象的时候，实际上只是包含了另一个对象在堆中的指针</li><li>所以如果需要得到一个对象的副本，不能简单的用<code>=</code>，而是应该用<code>clone()</code>方法</li></ul><h2 id="更改器方法和访问器方法">更改器方法和访问器方法</h2><ul><li>更改器方法: 调用方法以后，对应实例的状态会改变</li><li>访问器方法: 调用方法以后，只访问对象，不会修改他。比如(<code>get()</code>)<ul><li>访问器方法<strong>不要返回</strong>可变对象引用<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">E</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Date hireDay;</span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getHireDay</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> hireDay;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里的hireDay就是一个Date类的对象引用，而Date类本身存在更改器方法setTime</span></span><br><span class="line"><span class="comment">// 所以hireDay是可变的，破坏了封装性</span></span><br><span class="line"><span class="comment">// 如果需要返回一个可变对象引用，需要先clone</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">R</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getHireDay</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (Date) hireDay.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><div class="note info flat"><p><code>CPP</code>中带有<code>const</code>后缀的方法是访问器方法，没有<code>const</code>后缀的方法是更改器方法<br><code>Java</code>中没有这种明显的标识</p></div><ul><li>构造器没有返回值，总是和<code>new</code>一起使用</li><li>所有的方法中都不要使用和实例字段同名的方法，可以同名，但是最好不要出现，除了后面讲到的<code>record</code></li><li>实例字段不要设置成<code>public</code>，这样会破坏封装，要保证数据私有</li><li>在构造类的实例时，推荐使用<code>var</code>来声明这个对象的类型，这样就不用重复写类了</li><li>不要对数值类型写<code>var</code>，<code>var</code>只能用于局部字段，对于参数和实例字段不能使用<code>var</code></li></ul><h2 id="null"><code>null</code></h2><ul><li>对象变量包含一个引用，或者是<code>null</code></li><li>如果对<code>null</code>值变量调用方法会产生<code>NullPointException</code></li><li>初始类型不会是<code>null</code>，尤其需要注意<code>String</code>类型的<code>null</code>，可以检测到以后将其转换为另一个值  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (n == <span class="literal">null</span>) &#123;</span><br><span class="line">    name = <span class="string">&quot;unknown&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    name = n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 也有更简单的方法</span></span><br><span class="line">name = Objects.requireNonNullElse(n, <span class="string">&quot;unknown&quot;</span>);</span><br><span class="line"><span class="comment">// 或者可以直接拒绝null</span></span><br><span class="line">name = Objects.requireNonNull(n, <span class="string">&quot;The name can not be null&quot;</span>);</span><br><span class="line"><span class="comment">// 这样可以直接定位到哪里有空值，如果等程序自动触发NPE的话，可能不是空值存在的地方</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="静态字段">静态字段</h2><h3 id="静态变量">静态变量</h3><ul><li>一个对象定义为<code>static</code>，那么这个字段并不出现在每个类的对象中。每个静态字段只有一个副本</li><li>所以静态字段属于类，但是不属于单个类</li><li>比如对员工分配唯一的标识码  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">E</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">nextId</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">E</span><span class="params">()</span> &#123;</span><br><span class="line">        id = nextId;</span><br><span class="line">        nextId ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这样所有员工共享一个nextId，但是每个员工有自己的id</span></span><br><span class="line"><span class="comment">// 就算没有员工对象，这个nextId也是存在的</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="静态常量">静态常量</h3><ul><li>静态常量相比于静态变量更加常用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Math</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.14</span>...;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">System</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">PrintStream</span> <span class="variable">out</span> <span class="operator">=</span> ...;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 分别使用Math.PI和System.out可以访问</span></span><br><span class="line"><span class="comment">// 如果省略了static，那么PI就需要通过一个MATH的实例来访问</span></span><br></pre></td></tr></table></figure><ul><li>最好不要有公共字段，因为公共字段谁都可以访问，但是如果是final的公共常量就不要紧</li><li>因为<code>out</code>是由<code>final</code>修饰的，所以<code>out</code>本身是不允许重新赋值的。</li><li>但是<code>System</code>中有一个<code>setOut</code>方法，这是因为<code>setOut</code>方法不是<code>Java</code>实现的，是一个原生方法，可以跳过访问控制机制</li></ul><h2 id="静态方法">静态方法</h2><ul><li>静态方法是不操作对象的方法，比如<code>Math.pow(x, a)</code>，不需要使用<code>Math</code>对象，没有隐式参数</li><li>所以上面的<code>E</code>类，静态方法不能访问<code>id</code>字段，因为不操作对象。但是可以访问静态字段</li><li>同样可以使用对象实例调用静态方法，但是没有意义，因为静态方法与对象无关，所以最好直接用类名调用静态方法</li></ul><div class="note info flat"><p>以下两种情况可以使用静态方法:</p><ol><li>方法不需要访问对象状态，所有的参数可以直接通过显示参数提供，比如<code>Math.pow(x, a)</code></li><li>方法只需要访问静态字段</li></ol></div><ul><li><code>main</code>方法就是一个静态方法，可以在每个类都创建一个静态方法，用于演示。</li><li>不演示的时候直接调用<code>Application.main</code>则不会执行内部其他类的<code>main</code>函数</li></ul><h3 id="静态工厂方法">静态工厂方法</h3><div class="note info flat"><p>为什么不用构造器要用静态工厂方法：</p><ol><li>无法为构造器命名，因为构造器的命名总是要与类名相同，但是如果需要得到两个不同的名字，就无法实现了</li><li>构造器无法改变构造对象的类型，静态工厂方法可以返回指定的类型，比如某个类的子类</li></ol></div><h2 id="构造器">构造器</h2><ul><li><p>可以在一个构造器中调用另一个构造器</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">E</span> <span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 调用了E(String, double)的构造方法，这样只需要写一次公共的构造函数</span></span><br><span class="line">        <span class="built_in">this</span> (<span class="string">&quot;123&quot;</span> + nextId, s);</span><br><span class="line">        nextId ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>自动定义的设置所有实例字段的构造器是标准构造器</p></li><li><p>自定义构造器的第一个语句必须调用另一个构造器，最终调用标准构造器</p></li></ul><h1>记录</h1><blockquote><p><code>Java 14</code>引入，<strong>状态不可变</strong>，公共可读。一个记录的实例字段称为组件</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">record</span> <span class="title class_">Point</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> &#123;&#125;;</span><br><span class="line"><span class="comment">// 这个Point就是一个记录，不再需要写class中的很多内容</span></span><br><span class="line"><span class="comment">// 具有一个构造器 Point(double x, double y)</span></span><br><span class="line"><span class="comment">// 具有两个访问器 public double x(); public double y()</span></span><br><span class="line"><span class="comment">// 方法和实例字段可以同名</span></span><br><span class="line"><span class="type">var</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">System.out.Println(p.x() + <span class="string">&quot; &quot;</span> + p.y());</span><br></pre></td></tr></table></figure><ul><li>每个记录都有自动定义的三个方法: <code>toString</code> <code>equals</code> <code>hashCode</code></li><li>记录可以自己定义静态字段和方法，但是不能新增<strong>实例字段</strong>，实例字段应该全部都作为参数</li></ul><h1>包</h1><blockquote><p>包名为了确保类名的唯一性，一般是域名的逆序.项目名.类名</p></blockquote><ul><li>一个类可以使用所属包中的所有类，以及其他包中的公共类</li><li>如果包名写错了，但是他不依赖其他包，就可以顺利编译通过，执行的时候会失败，因为虚拟机无法根据包名找到类</li></ul><h2 id="jar"><code>jar</code></h2><ul><li>使用<code>jar cvf jarFileName file1 file2 ... </code>创建新的<code>jar</code>文件 <code>u</code>选项可以更新<code>jar</code>包</li><li>每个<code>jar</code>都包含一个清单文件<code>manifest</code>用于描述归档文件的特殊性<ul><li>清单文件<code>MANIFEST.MF</code>位于<code>jar</code>文件的<code>META-INF</code>子目录中</li><li>清单文件中包含多个条目，分组成多个节。第一节称为主节，作用于整个<code>JAR</code>文件</li><li>节与节之间使用空行分割，除主节外，随后的每一节中的条目可以指定命名实体的属性，比如单个文件，包或者<code>url</code>，都需要以<code>Name</code>条目开始</li><li>如果需要编辑清单文件，可以将需要添加到清单文件的行放到文本文件中，使用<code>jar cfm jarFileName manifestFileName</code></li><li>如果需要更新清单文件，可以将增加的部分放到文本文件中，使用<code>jar ufm xxx.jar manifest-additions.mf</code></li><li>清单文件的最后一行需要以换行符作为结束，否则无法正确读取</li></ul></li><li>可以使用<code>jar cvfe xxx.jar xxxxxClass</code>来指定程序的入口点<ul><li>或者可以在清单文件中添加主类<code>Main-Class: xxxxxClass</code></li><li>这样就可以使用<code>java -jar xxx.jar</code>来启动程序<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hello.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.Println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 比如上述Hello.java文件，使用javac Hello.java可以编译为Hello.class文件，运行java Hello应该可以直接输出Hello</span></span><br><span class="line"><span class="comment">// 此时如果使用jar cvf Hello.jar Hello.java Hello.class的话，将会生成Hello.jar</span></span><br><span class="line"><span class="comment">// 运行java -jar Hello.jar文件，会报错，提示没有主清单属性</span></span><br><span class="line"><span class="comment">// 第一种解决办法: 重新生成一个jar包，生成的时候指定入口程序</span></span><br><span class="line"><span class="comment">// jar -cvfe Hello.jar Hello Hello.java Hello.class</span></span><br><span class="line"><span class="comment">// 第一个Hello.jar是生成的jar包，第二个Hello是主入口程序为Hello这个类，第三个和第四个是jar包中需要包含的文件</span></span><br><span class="line"><span class="comment">// 第二种解决办法: 修改MANIFEST.mf文件</span></span><br><span class="line"><span class="comment">// 创建一个MANIFEST-ADD.mf文件，添加Main-Class: Hello</span></span><br><span class="line"><span class="comment">// 这里一定需要换行，然后保存文件后，运行 jar -ufm Hello.jar MANIFEST-ADD.mf即可</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="多版本jar">多版本<code>jar</code></h3><blockquote><p><code>JAVA 9</code>引入了多版本<code>jar</code>，将特定于版本的类文件放在了<code>META-INF/versions</code>中</p></blockquote><ul><li>如果要增加不同版本(比如java 9)的类文件，可以使用<code>jar -uf xxx.jar --release 9 xxx.class</code></li><li>如果要从头构建一个多版本<code>jar</code>，可以使用<code>-C</code>，每个对应的版本切换到一个不同的类文件目录<br><code>jar cf xxx.jar -C bin/8 . --release 9 -C bin/9 xxx.class</code></li><li>不同版本的编译，需要使用<code>--release</code>和<code>-d</code>指定输出目录</li><li>多版本<code>jar</code>唯一的作用是让你的程序可以使用不同版本的<code>jdk</code></li></ul><h1>注释</h1><h2 id="类注释">类注释</h2><ul><li>放在 <code>import</code> 之后, <code>class</code> 之前</li><li>使用<code>\**  *\</code></li></ul><h2 id="方法注释">方法注释</h2><ul><li>可以对方法的作用，方法的参数，返回值，异常添加注释，使用<code>@param, @return, @throws</code></li></ul><h2 id="字段注释">字段注释</h2><ul><li>只需要对公共字段，静态常量进行注释</li></ul><h2 id="包注释">包注释</h2><ul><li>需要单独写一个文件，比如<code>package-info.java</code>，里面是文档注释</li><li>或者可以写一个<code>package.html</code>，里面抽取标记<code>&lt;body&gt;...&lt;/body&gt;</code>的所有文本</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java核心技术(卷一) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记_5</title>
      <link href="/posts/14a3e889.html"/>
      <url>/posts/14a3e889.html</url>
      
        <content type="html"><![CDATA[<h1>概述和环境</h1><h2 id="源码文件">源码文件</h2><ol><li>确保安装了<code>JDK</code>，并且配置了环境变量</li><li><code>jdk/lib</code>目录中可以找到<code>src.zip</code>，这个压缩包包含了<strong>所有的公共类库</strong>的源码</li><li>使用<code>jar xvf jdk/lib/src.zip</code>可以将<code>src.zip</code>解压缩到<strong>当前目录</strong>下</li><li>如果是别的源码，比如编译器，原生方法，虚拟机，私有辅助类，需要从<code>openjdk</code>那边拿到</li></ol><h2 id="控制台运行Java">控制台运行Java</h2><ol><li>一个包含<code>Main</code>函数的<code>Java</code>类，使用<code>javac xxx.java</code>可以将<code>.java</code>文件编译为<code>.class</code>文件</li><li>然后再使用<code>java xxx</code>，不需要加<code>.class</code>后缀即可直接运行这个编译后的文件</li></ol><h2 id="JShell"><code>JShell</code></h2><ul><li><code>Java 9</code>引入了另一种使用<code>Java</code>的方法，就是&quot;读取-评估-打印循环&quot; (<code>Read-Evaluate-Print Loop</code>, <code>REPL</code>)</li><li>输入一个<strong>表达式</strong>，<code>JShell</code>会评估输入，打印结果，并等待下一个输入。直接在控制台输入<code>jshell</code>即可开始使用<ul><li>输入<code>&quot;java&quot;.length()</code>就会返回字符个数<code>$1 ==&gt; 4</code></li><li>然后再输入<code>4 * $1 + 1</code>，会返回<code>$2 ==&gt; 17</code></li><li>并不需要手动输入<code>System.out.println()</code>也可以直接返回结果，并自动存储变量</li><li>也可以手动指定变量名，例如<code>int ans = 42</code>，会返回结果<code>ans ==&gt; 42</code></li></ul></li></ul><h1><code>Java</code>规范</h1><ol><li>类名需要驼峰：首字母大写，后面每个单词的首字母均大写</li><li>文件名必须和文件内的公共类相同</li><li><code>main</code>函数一定需要在<code>public</code>类中，虚拟机从<code>main</code>函数开始执行，<code>main</code>方法总是静态的</li><li><code>main</code>函数返回值为<code>0</code>，如果需要以其他的返回值返回，需要使用<code>System.exit(nums)</code></li><li>变量的声明尽可能靠近使用变量的地方</li><li><code>Java 10</code>开始，对于局部变量，可以使用<code>var</code>关键字声明，这样可以从变量的初始值推断出他的类型<ul><li><code>var d = 12; // d is an int</code></li><li><code>var s = &quot;12&quot;; // s is a String</code></li></ul></li><li><code>Java</code>中不区分变量的声明和定义</li></ol><h1>类型</h1><ul><li><code>Java</code>具有8种基本类型，其中4种整型，2种浮点类型，1种字符类型<code>char</code>(用于表示<code>Unicode</code>编码)，1种<code>boolean</code>类型</li><li>同时<code>Java</code>具有一个表示任意精度的算数包，大数<code>big number</code>是一个<code>Java</code>对象，而不是基本<code>Java</code>类型了</li></ul><h2 id="整型">整型</h2><ul><li><code>Java</code>的<code>int</code>无论在什么环境下都是<code>4 Bytes</code>，可以表示<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">2 \times 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span></li><li>可以给数字加上下划线，在编译时会自动去除，方便源码阅读: <code>12_000_000_000</code></li><li><code>Java</code>中没有无符号类型，如果确实需要无符号数，比如<code>short</code>表示范围需要在<code>0~255</code>之间的话，进行计算的时候可以使用<code>Byte.toUnsignedInt(b)</code>来得到一个无符号整数</li></ul><h2 id="浮点型">浮点型</h2><ul><li>一般都使用<code>8 Bytes</code>的<code>double</code>类型，<strong>而不是</strong><code>4 Bytes</code>的<code>float</code>类型。</li><li>可以使用十六进制表示浮点数字面量，例如<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.125</mn><mo>=</mo><msup><mn>2</mn><mrow><mo>−</mo><mn>3</mn></mrow></msup></mrow><annotation encoding="application/x-tex">0.125 = 2^{-3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.125</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span></span>可以写成<code>0x1.0p-3</code>。<ul><li>这里<code>0x</code>表示十六进制，<code>p</code>表示指数。不是<code>e</code>是因为<code>e</code>在十六进制中了，<code>-3</code>表示十进制的<code>-3</code>次方，基数为<code>2</code></li></ul></li><li>浮点数溢出的三种情况：正溢出，负溢出和<code>NaN</code>，如果正数/0就是正溢出，反之负溢出；如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mi mathvariant="normal">/</mi><mn>0</mn></mrow><annotation encoding="application/x-tex">0/0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0/0</span></span></span></span>就是<code>NaN</code></li><li><code>Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NaN</code>表示三个特殊的值，基本不用</li><li><code>if (x == Double.NaN)</code>永远为假，因为<code>NaN</code>是永远不会和其他值相同，(<code>Double.NaN</code>也不会和<code>Double.NaN</code>相同)<ul><li>如果需要判断<code>x</code>是否为<code>NaN</code>，可以使用<code>if (Double.isNaN(x))</code></li></ul></li><li>如果需要精确表示浮点数的话，需要使用<code>BigDecimal</code>类</li><li>整数除<code>0</code>产生异常，浮点数除<code>0</code>得到结果<code>NaN</code></li></ul><h2 id="字符类型">字符类型</h2><ul><li><code>char</code>类型可以表示十六进制值，范围从<code>\u0000~\uFFFF</code></li><li>需要注意注释中尽量不要出现Unicode字符，例如 <code>// \u000A is a newline.</code>，这句话会产生一个语法错误，因为读程序时会将<code>\u000A</code>转换为一个换行符<ul><li><code>// look inside c:\user</code>这里也是会报错的，因为<code>\u</code>后面没有跟着4位十六进制数</li></ul></li><li>原本<code>Unicode</code>字符不超过<code>65536</code>个，所以<code>Java</code>设置了<code>char</code>类型只有16位</li><li>后来字符放不下了，<code>Java</code>设置码点来解决问题，指一个编码表中某个字符对应的代码值</li><li>码点采用十六进制编写，加上前缀<code>U+</code>，比如<code>U+0041</code>就是<code>A</code>的码点</li><li><code>Unicode</code>的码点可以分为17个代码平面，第一个代码平面被称为基本多语言平面，包括了码点范围是<code>U+0000~U+FFFF</code></li><li>其余16个平面的码点范围是<code>U+10000~U+10FFFF</code></li><li>不要在<code>Java</code>代码中使用<code>char</code>类型，一般将字符串作为抽象数据类型处理</li></ul><h2 id="布尔类型">布尔类型</h2><ul><li><code>Java</code>的整型和布尔值<strong>不能</strong>相互转换</li></ul><h2 id="常量">常量</h2><ul><li>使用<code>final</code>关键字定义的，只能被赋值一次，不能再更改，一般用全大写命名</li><li>可能需要创建一个常量在类中的多个方法中使用，称为<strong>类常量</strong>，可以使用<code>static final</code>设置一个类常量</li><li><code>const</code>是<code>Java</code>保留的一个关键字，但是目前并没有使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">100</span>; </span><br><span class="line">    <span class="comment">// b可以被类A中的所有方法访问，因为使用static final修饰</span></span><br><span class="line">    <span class="comment">// 同时因为 b 是 public 的，所以也可以被其他类使用A.b访问</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// a只能被main函数访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="枚举类型">枚举类型</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Size</span> &#123;SMALL, MEDIUM, LARGE, EXTRA_LARGE&#125;;</span><br><span class="line"><span class="type">Size</span> <span class="variable">s</span> <span class="operator">=</span> Size.SMALL; <span class="comment">// s只能存储枚举中的值，或者是null</span></span><br></pre></td></tr></table></figure><h2 id="循环移位">循环移位</h2><ul><li><code>&gt;&gt;</code>表示左移，使用符号位填充；<code>&gt;&gt;&gt;</code>表示左移，永远使用<code>0</code>填充</li><li><code>&lt;&lt;</code>表示右移；不存在<code>&lt;&lt;&lt;</code></li><li>所有移位的右操作数都需要对<strong>32</strong>取模，如果左操作数是<code>Long</code>类型，则右操作数需要对<strong>64</strong>取模  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="number">1</span> &lt;&lt; <span class="number">35</span>; <span class="comment">// 与 1 &lt;&lt; 3等价，结果为8</span></span><br><span class="line">i &lt;&lt; <span class="number">35</span>; <span class="comment">// 与 1 &lt;&lt; 3等价，结果为8</span></span><br><span class="line">j &lt;&lt; <span class="number">35</span>; <span class="comment">// 与 1 &lt;&lt; 35等价，结果为34359738368</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="字符串">字符串</h2><ul><li><p><code>Java</code>中字符串就是<code>Unicode</code>序列，比如<code>&quot;Java\u2122&quot;</code>由五个<code>Unicode</code>字符组成。</p></li><li><p><code>Java</code>没有内置的字符串类型，标准<code>Java</code>类库中提供了一个预定义类</p></li><li><p>任何<code>Java</code>对象都可以转换为字符串，所以<code>&quot;PG&quot; + 12 = &quot;PG12&quot;</code></p></li><li><p>如果多个字符串使用界定符分割的话，可以使用静态<code>join</code>方法</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">all</span> <span class="operator">=</span> String.join(<span class="string">&quot;/&quot;</span>, <span class="string">&quot;S&quot;</span>, <span class="string">&quot;M&quot;</span>, <span class="string">&quot;I&quot;</span>); <span class="comment">// all = &quot;S/M/I&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><code>Java 11</code>中提供了<code>repeat</code>方法</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">rep</span> <span class="operator">=</span> <span class="string">&quot;J&quot;</span>.repeat(<span class="number">3</span>); <span class="comment">// rep = &quot;JJJ&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><code>Java</code>中字符串不可变，如果需要修改一个字符串的一部分，需要先使用<code>substring</code>提取字符串不需要修改的部分，然后加上其他修改后的结果字符串。</p><ul><li>字符串不可变每次都需要生成新的字符串，会降低效率，但是编译器底层可以实现字符串共享。</li><li>开发者认为字符串共享带来的收益比修改字符串带来的收益明显，因为往往需要比对字符串是否相同，修改频率较少</li><li>只会共享字符串字面量，由<code>+</code>或者<code>substring</code>得到的字符串无法共享</li><li>因此比较两个字符串相等的时候务必使用<code>&quot;A&quot;.equals(&quot;A&quot;)</code>，如果使用<code>==</code>，则会比较两个字符串是否相等</li><li>如果要检查字符串不是空串也不是<code>null</code>的话，需要先检查<code>null</code>: <code>if (s != null &amp;&amp; s.length() != 0)</code>，否则如果字符串为<code>null</code>的话，调用这个字符串的<code>length()</code>函数会报错</li></ul></li><li><p><code>Java</code>中最常用的<code>Unicode</code>由一个代码单元表示，但是辅助字符需要两个代码单元，所以如果使用<code>charAt</code>，会返回指定索引的代码单元</p><ul><li>如果正好某个索引需要两个代码单元，但是使用<code>charAt</code>指定了前一个单元，就会出现问题。因此，<code>charAt</code>一般不要用</li><li>为了测试，需要提前设置<code>cmd</code>窗口内编码格式为<code>Unicode</code>，在<code>cmd</code>内输入<code>chcp 65001</code>将当前窗口的编码格式切换为<code>Unicode</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;123\uD835\uDD46&quot;</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;当前字符串是：&quot;</span> + s);</span><br><span class="line">    System.out.println(<span class="string">&quot;s.length() = &quot;</span> + s.length());</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;使用s.charAt()打印每一个元素：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i ++) &#123;</span><br><span class="line">        System.out.print(s.charAt(i) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line"></span><br><span class="line">    System.out.print(<span class="string">&quot;s的实际长度(码点个数)为：&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">trueLen</span> <span class="operator">=</span> s.codePointCount(<span class="number">0</span>, s.length());</span><br><span class="line">    System.out.println(trueLen);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;使用s.codePointAt()打印每一个元素：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; trueLen; i ++) &#123;</span><br><span class="line">        System.out.print(s.codePointAt(s.offsetByCodePoints(<span class="number">0</span>, i)) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上面代码的输出结果为：<br><img src="https://gitee.com/sang3112/blog_imgs/raw/4c5ed5605556dc05064ff326aca418d72b731cfe/Java/codepoint.png" alt="codepoint"></li></ul></li></ul></li><li><p>如果需要拼接多个较短的字符串，可以使用<code>StringBuilder</code></p><ul><li><code>StringBuffer</code>效率不如<code>StringBuilder</code>，不过<code>StringBuffer</code>可以支持多线程添加删除字符</li><li>如果所有操作都在单线程，则使用<code>StringBuilder</code></li></ul></li><li><p><code>Java 15</code>中存在文本块，以三个引号开头结尾，可以更加方便的写换行，例如</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Hello</span></span><br><span class="line"><span class="string">World</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;Hello\nWorld\n&quot;</span>;</span><br><span class="line"><span class="comment">// a == b</span></span><br><span class="line"><span class="comment">// 文本块最适合放SQL语句或者HTML语句，但是如果所有的反斜线都需要转义</span></span><br><span class="line"><span class="comment">// 如果不转义就会变成不换行</span></span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Hello\</span></span><br><span class="line"><span class="string">World</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> <span class="string">&quot;HelloWorld\n&quot;</span>;</span><br><span class="line"><span class="comment">// c == d</span></span><br></pre></td></tr></table></figure></li></ul><h1>输入输出</h1><ul><li>如果是密码相关的内容，建议不要使用<code>println</code>，可以使用<code>Console.readPassword</code>方法</li><li><code>printf(&quot;%+f&quot;, d)</code>可以打印<code>d</code>的正负号</li><li><code>printf(%,f, d)</code>可以对<code>d</code>增加三个数一组的分割符</li><li><code>printf(&quot;%1$d,%1$x&quot;, d)</code>分别以十进制和十六进制打印第一个参数<code>d</code></li><li><code>printf(&quot;%d%&lt;x&quot;, d)</code>分别以十进制和十六进制打印<strong>同一个数</strong></li><li>使用<code>String.format</code>方法可以格式化字符串，不打印输出  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> String.format(<span class="string">&quot;Hello, %s. Next year, you&#x27;ll be %d&quot;</span>, name, age + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// Java 15版本以后可以使用下面这种更加简单的方法</span></span><br><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello, %s. Next year, you&#x27;ll be %d&quot;</span>.formatted(name, age + <span class="number">1</span>);</span><br></pre></td></tr></table></figure></li><li>写入文件使用  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="string">&quot;tmp.txt&quot;</span>, StandardCharsets.UTF_8);</span><br><span class="line">out.write(<span class="string">&quot;werwr&quot;</span>);</span><br><span class="line">out.flush();</span><br><span class="line"><span class="comment">// 如果tmp.txt不存在，则会自动创建一个</span></span><br><span class="line"><span class="comment">// 写入以后需要使用flush才能保存</span></span><br></pre></td></tr></table></figure></li></ul><h1>控制流程</h1><ul><li><code>Java</code>中两个嵌套的块不能重复定义相同的变量</li><li>在 <code>for</code>循环中不能检测了两个浮点数是否相等，因为误差的存在，可能会导致死循环</li></ul><h2 id="switch-case"><code>switch-case</code></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种</span></span><br><span class="line"><span class="keyword">switch</span> (s) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;yes&quot;</span>, <span class="string">&quot;y&quot;</span> -&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;no&quot;</span>, <span class="string">&quot;n&quot;</span> -&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span> -&gt; &#123;</span><br><span class="line">        ... </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种</span></span><br><span class="line"><span class="keyword">switch</span> (s) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;y&quot;</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;n&quot;</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第二种方法如果不使用break会导致执行多个分支</span></span><br><span class="line"><span class="comment">// 使用javac -Xlint:fallthrough xxx.java编译可以得到这个方面的警告</span></span><br><span class="line"><span class="comment">// 但是如果本身就想执行多个分支，可以在整个函数外加上</span></span><br><span class="line"><span class="comment">// @SuppressWarnings(&quot;fallthrough&quot;)，这样就不会产生警告了</span></span><br></pre></td></tr></table></figure><ul><li>不能混用<code>:</code>和<code>-&gt;</code>，同时<code>-&gt;</code>也<strong>不</strong>存在直通的行为</li><li><code>yield</code>也会终止<code>switch</code>语句，但是还会生成一个值<ul><li><code>switch</code>表达式的关键是生成一个值，或者抛出异常，<strong>不允许</strong>使用<code>return</code>跳出</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">switch</span>(s) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;y&quot;</span> -&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;n&quot;</span> -&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span> -&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">nums</span> <span class="operator">=</span> <span class="keyword">switch</span>(s) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Spring&quot;</span>, <span class="string">&quot;Summer&quot;</span>, <span class="string">&quot;Winter&quot;</span> -&gt; <span class="number">6</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Fall&quot;</span> -&gt; <span class="number">4</span></span><br><span class="line">    <span class="keyword">default</span> -&gt; -<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面表达式优于下面的表达式</span></span><br><span class="line"><span class="keyword">switch</span>(s) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Spring&quot;</span>, <span class="string">&quot;Summer&quot;</span>, <span class="string">&quot;Winter&quot;</span> -&gt; &#123;</span><br><span class="line">        nums = <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Fall&quot;</span> -&gt; &#123;</span><br><span class="line">        nums = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span> -&gt; &#123;</span><br><span class="line">        nums = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 除非是需要直通式，才会使用`break`和`yield`</span></span><br></pre></td></tr></table></figure><h1>大数</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用valueOf()静态方法可以将一个普通的数转换为大数</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">a</span> <span class="operator">=</span> BigInteger.valueOf(<span class="number">123</span>);</span><br><span class="line"><span class="comment">// 对于一个很长的数，使用带有字符串参数的构造器生成</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;1231231231231231231231231&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>对于 <code>BigDecimal</code>类，总应该使用带有字符串参数的构造器生成。尽管有<code>BigDecimal(double)</code>，但是传入的时候会产生浮点数精度误差</li><li><code>Java</code>不能通过编程实现运算符的重载，所以只能使用<code>add(), multiply()</code>等方法实现加减乘除</li><li><code>Java</code>设计者只重载了<code>+</code>来实现字符串拼接</li></ul><h1>数组</h1><ul><li><code>Java</code>中<strong>允许</strong>长度为0的数组存在</li><li>数组创建时，数字数组初始化为0，对象数组初始化为<code>null</code>，<code>boolean</code>数组初始化为<code>false</code></li><li>如果想要打印数组a，可以直接写<code>Arrays.toString(a)</code>，这个返回值包含了数组中所有元素的字符串</li><li>如果想要快速打印一个二维数组，可以使用<code>Arrays.deepToString(a)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">System.out.println(Arrays.toString(a));</span><br></pre></td></tr></table></figure><h2 id="数组拷贝">数组拷贝</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] b = a;</span><br><span class="line"><span class="comment">// b和a引用同一个数组</span></span><br><span class="line"><span class="comment">// 如果需要拷贝一个副本到新的数组，可以使用copyOf</span></span><br><span class="line"><span class="type">int</span>[] c = Arrays.copyOf(a, a.length);</span><br><span class="line"><span class="comment">// 第二个参数是新数组的长度，一般用于扩充新数组</span></span><br><span class="line"><span class="comment">// 如果需要扩充，则数组数组自动填充0，boolean数组自动填充false</span></span><br><span class="line"><span class="comment">// 如果新数组长度更小，则只拷贝前面的部分</span></span><br></pre></td></tr></table></figure><ul><li><code>main</code>函数的参数，是<code>String[] args</code>，接受一个字符串数组，也就是命令行指定的参数</li><li><code>java Message -h hello</code> 这里面<code>args[0]=-h</code> <code>args[1] = hello</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java核心技术(卷一) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式笔记_1</title>
      <link href="/posts/b406aa8c.html"/>
      <url>/posts/b406aa8c.html</url>
      
        <content type="html"><![CDATA[<h1>简单工厂模式</h1><blockquote><p>需要实例化谁,以后可能会添加实例化的对象,就要用一个单独的类来做这个创造实例的过程,就是<strong>工厂</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Operation.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Operation</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">getResult</span><span class="params">(<span class="type">double</span> numberA, <span class="type">double</span> numberB, String operation)</span>&#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span> (operation) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                ans = numberA + numberB;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                ans = numberA - numberB;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                ans = numberA * numberB;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                ans = numberA / numberB;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;not support operation&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info flat"><p>问题:</p><ol><li>如果需要增加函数,就需要添加新的<code>case</code>,有可能会改变原有的函数;</li><li>如果代码只需要调用除法,却需要编译其他的加,减,乘函数<br>解决办法:<br>实现一个运算抽象类,都有一个方法<code>getResult()</code>,用来得到结果.然后加减乘除都写成运算类的子类</li></ol></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Operation.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Operation</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getResult</span><span class="params">(<span class="type">double</span> numberA, <span class="type">double</span> numberB)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0d</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Add</span> <span class="keyword">extends</span> <span class="title class_">Operation</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getResult</span><span class="params">(<span class="type">double</span> numberA, <span class="type">double</span> numberB)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numberA + numberB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sub.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Operation</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getResult</span><span class="params">(<span class="type">double</span> numberA, <span class="type">double</span> numberB)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numberA - numberB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mul.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mul</span> <span class="keyword">extends</span> <span class="title class_">Operation</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getResult</span><span class="params">(<span class="type">double</span> numberA, <span class="type">double</span> numberB)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numberA * numberB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Div.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Div</span> <span class="keyword">extends</span> <span class="title class_">Operation</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getResult</span><span class="params">(<span class="type">double</span> numberA, <span class="type">double</span> numberB)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numberB == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;除数不能为0&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArithmeticException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numberA / numberB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OperationFactory.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperationFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Operation <span class="title function_">createOperation</span><span class="params">(String opertaion)</span>&#123;</span><br><span class="line">        <span class="type">Operation</span> <span class="variable">oper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (opertaion) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                oper = <span class="keyword">new</span> <span class="title class_">Add</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                oper = <span class="keyword">new</span> <span class="title class_">Sub</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                oper = <span class="keyword">new</span> <span class="title class_">Mul</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                oper = <span class="keyword">new</span> <span class="title class_">Div</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;we didnt implement this operation&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> oper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="type">Operation</span> <span class="variable">oper</span> <span class="operator">=</span> OperationFactory.createOperation(flag);</span><br><span class="line"><span class="type">double</span> <span class="variable">ans</span> <span class="operator">=</span> oper.getResult(a, b);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/sang3112/blog_imgs/raw/master/DesignPattern/SFP.png" alt="SFP"></p><div class="note info flat"><p>三个角色:</p><ol><li>抽象类: 定义所有支持算法的公共接口,比如运算抽象类</li><li>具体算法类: 具体的算法,比如加减乘除运算类</li><li>简单工厂类: 用来维护对运算类的应用</li></ol><ul><li>可以将类类比为产品,使用者在不清楚类生产的具体过程的情况下,可以使用不同的产品.</li></ul></div><h1>策略模式</h1><blockquote><p>定义算法家族,分别封装,让他们之间可以相互替换.这样可以保证算法的变化不会影响到客户<br>一系列算法都完成相同的工作,只是实现不同,可以以相同的方式调用所有的算法,减少耦合.<br>只需要在不同的时间应用不同的业务规则,就可以考虑使用策略模式进行处理</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CashSuper.java</span></span><br><span class="line"><span class="comment">// 收费抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CashSuper</span> &#123;</span><br><span class="line">    <span class="comment">// 收费的抽象方法,参数为单价和数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">acceptCash</span><span class="params">(<span class="type">double</span> price, <span class="type">int</span> num)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CashNormal.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CashNormal</span> <span class="keyword">extends</span> <span class="title class_">CashSuper</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">acceptCash</span><span class="params">(<span class="type">double</span> price, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> price * num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CashRebate.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CashRebate</span> <span class="keyword">extends</span> <span class="title class_">CashSuper</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> <span class="variable">moneyRebate</span> <span class="operator">=</span> <span class="number">1d</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CashRebate</span><span class="params">(<span class="type">double</span> moneyRebate)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.moneyRebate = moneyRebate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">acceptCash</span><span class="params">(<span class="type">double</span> price, <span class="type">int</span> num)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price * num * moneyRebate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CashReturn.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CashReturn</span> <span class="keyword">extends</span> <span class="title class_">CashSuper</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> <span class="variable">moneyCondition</span> <span class="operator">=</span> <span class="number">0d</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> <span class="variable">moneyReturn</span> <span class="operator">=</span> <span class="number">0d</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CashReturn</span><span class="params">(<span class="type">double</span> moneyCondition, <span class="type">double</span> moneyReturn)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.moneyCondition = moneyCondition;</span><br><span class="line">        <span class="built_in">this</span>.moneyReturn = moneyReturn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">acceptCash</span><span class="params">(<span class="type">double</span> price, <span class="type">int</span> num)</span>&#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">ans</span> <span class="operator">=</span> price * num;</span><br><span class="line">        <span class="keyword">if</span> (moneyCondition &gt; <span class="number">0</span> &amp;&amp; ans &gt;= moneyCondition)&#123;</span><br><span class="line">            ans -= Math.floor(ans / moneyCondition) * moneyReturn;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CashContext.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CashContext</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> CashSuper cs;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CashContext</span><span class="params">(CashSuper cs)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.cs = cs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getResult</span><span class="params">(<span class="type">double</span> price, <span class="type">int</span> num)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cs.acceptCash(price, num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;输入策略: 1 - 正常收费; 2 - 打八折; 3 - 打七折; 4 - 满300减100&quot;</span>);</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">discount</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;输入产品的单价:&quot;</span>);</span><br><span class="line">        <span class="type">double</span> <span class="variable">price</span> <span class="operator">=</span> in.nextDouble();</span><br><span class="line">        System.out.println(<span class="string">&quot;输入产品的数量:&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">        in.close();</span><br><span class="line">        <span class="type">CashContext</span> <span class="variable">cs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (discount) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                cs = <span class="keyword">new</span> <span class="title class_">CashContext</span>(<span class="keyword">new</span> <span class="title class_">CashNormal</span>());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                cs = <span class="keyword">new</span> <span class="title class_">CashContext</span>(<span class="keyword">new</span> <span class="title class_">CashRebate</span>(<span class="number">0.8d</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                cs = <span class="keyword">new</span> <span class="title class_">CashContext</span>(<span class="keyword">new</span> <span class="title class_">CashRebate</span>(<span class="number">0.7d</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                cs = <span class="keyword">new</span> <span class="title class_">CashContext</span>(<span class="keyword">new</span> <span class="title class_">CashReturn</span>(<span class="number">300d</span>, <span class="number">100d</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;we dont support this strategy&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> <span class="variable">totalPrice</span> <span class="operator">=</span> cs.getResult(price, num);</span><br><span class="line">        System.out.println(totalPrice);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>策略模式,使用<code>CashContext</code>计算不同策略下的收费及结果,但是会发现在<code>Main</code>中进行了判断需要使用哪一个策略</li><li>可以使用工厂模式+策略模式的方法进行调整</li></ul><h2 id="策略-工厂模式">策略 + 工厂模式</h2><blockquote><p>只需要将<code>Main</code>中的<code>switch</code>部分移动到<code>CashContext</code>中即可</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CashContext.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CashContext</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> CashSuper cs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CashContext</span><span class="params">(<span class="type">int</span> discount)</span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (discount) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                cs = <span class="keyword">new</span> <span class="title class_">CashNormal</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                cs = <span class="keyword">new</span> <span class="title class_">CashRebate</span>(<span class="number">0.8d</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                cs = <span class="keyword">new</span> <span class="title class_">CashRebate</span>(<span class="number">0.7d</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                cs = <span class="keyword">new</span> <span class="title class_">CashReturn</span>(<span class="number">300d</span>, <span class="number">100d</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;we dont support this strategy&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getResult</span><span class="params">(<span class="type">double</span> price, <span class="type">int</span> num)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cs.acceptCash(price, num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在导航中,不同的路径规划算法,比如步行,骑行,搭乘公共交通的,开车的.主要导航类的主要工作是渲染路径,不会在意算法生成的路径,因此可以将路径规划算法使用策略模式进行封装,方便交互</p></blockquote><p><img src="https://gitee.com/sang3112/blog_imgs/raw/master/DesignPattern/SP.png" alt="SP"></p><ul><li>策略模式不适合算法极少变化的场景,这样会使得程序整体变得复杂</li><li>同时要求客户知晓策略的不同</li></ul>]]></content>
      
      
      <categories>
          
          <category> DesignPattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DesignPattern </tag>
            
            <tag> 简单工厂模式 </tag>
            
            <tag> 策略模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式笔记_0</title>
      <link href="/posts/c3019a1a.html"/>
      <url>/posts/c3019a1a.html</url>
      
        <content type="html"><![CDATA[<h1>单一职责原则 <code>SRP</code></h1><blockquote><p>一个类应该只有一个更改它的原因,也就是这个类只有一个职责</p></blockquote><ul><li>每个类的职责都有清晰明确的定义</li><li>一个类的修改只对自身有影响,对其他类没有影响</li></ul><h1>开闭原则 <code>OCP</code></h1><blockquote><p>软件实体(类 模块 函数)应该可以扩展,但是不能修改.对于扩展是开放的,对于修改是封闭的.<br>对于要怎讲爱新功能或者需要调整的改动,应该扩展新的代码而不是修改原有的代码.</p></blockquote><ul><li>对程序中频繁变化的部分抽象</li><li>不要刻意的对每一个部分都进行抽象,拒绝不成熟的抽象,这和抽象本身一样重要.</li></ul><h1>依赖倒置原则 <code>DIP</code></h1><blockquote><p>程序不应该依赖细节,细节应该依赖于抽象. 针对接口编程 而不是针对实现编程</p></blockquote><ul><li>使用接口或者抽象类的目的是制定好规范,不涉及任何具体的操作,把细节任务交给实现类去完成</li><li>让程序中所有的依赖关系都终止于抽象类或者接口</li><li>高层模块不应该依赖底层模块,二者都应该依赖抽象</li><li>抽象不应该依赖细节,细节应该依赖抽象</li></ul><h1>里氏替换原则 <code>LSP</code></h1><blockquote><p>一个软件实体如果适用于父类,必定适用于子类,并且察觉不出子类和父类的区别,也就是子类必须能够替换父类</p></blockquote><ul><li>父类一般使用抽象类或者接口</li><li>抽象类定义公共对象和状态;接口定义公共行为</li><li>子类通过继承父类和接口进行扩展</li><li>子类的方法参数类型 返回值类型 异常 都应该跟父类相匹配;子类不应该强加参数条件限制;子类不能修改父类的私有成员</li></ul><h1>迪米特原则 <code>LoD</code></h1><blockquote><p>最小知识原则.如果两个类不必彼此互相通信,那么这两个类就不应该发生直接的相互作用;如果其中一个类需要调用另一个类的某一个方法,则可以通过第三者转发这个调用</p></blockquote><ul><li>类设计上,每一个类都应该尽量降低成员的访问权限,不要让别的类知道字段或行为就不要公开</li><li>类之间不建立联系,而是通过中间类来中转</li></ul>]]></content>
      
      
      <categories>
          
          <category> DesignPattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DesignPattern </tag>
            
            <tag> 设计原则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记_4</title>
      <link href="/posts/63a4d81f.html"/>
      <url>/posts/63a4d81f.html</url>
      
        <content type="html"><![CDATA[<h1>垃圾回收算法(四种)</h1><div class="note info flat"><ul><li>垃圾回收需要找到内存中存活的对象</li><li>还需要释放不再存活的对象，使程序可以再次利用这部分空间</li></ul></div><ol><li>标记-清除算法</li><li>复制算法</li><li>标记-整理算法</li><li>分代GC</li></ol><div class="note info flat"><ul><li><p>垃圾回收会有单独的<code>GC</code>线程来完成，但是不管哪一种<code>GC</code>算法，都会有部分阶段需要停止所有用户线程，称之为<code>Stop The World</code>，简称<code>STW</code>，如果<code>STW</code>的时间过长，则会影响用户使用</p></li><li><p>为什么一定需要<code>STW</code>?</p><ul><li>分析工作必须在能够确保一致性的快照中进行</li><li>一致性指整个分析期间系统被冻结在某个时间点上</li><li>如果分析过程中对象的引用关系还在不断地变化,那么分析的准确性就没有办法保证</li><li>如果不暂停业务线程的话,在垃圾回收期间新创建的对象会被错误的回收,这是因为业务陈晓晨和垃圾回收线程都是并行执行的</li></ul></li><li><p>评价标准:</p><ol><li><strong>吞吐量</strong>：CPU用于执行用户代码的时间与CPU总执行时间的比值，吞吐量=执行用户代码的时间/(执行用户代码的时间+<code>GC</code>时间)，吞吐量越高表示垃圾回收效率越高</li><li><strong>最大暂停时间</strong>：垃圾回收过程中<code>STW</code>时间的最大值，越小越好</li><li><strong>堆使用效率</strong>：不同垃圾回收算法，堆内存使用效率不同。比如标记清除算法，可以完整的使用堆内存，复制算法会将堆内存一分为二，每次只能使用一半内存。从堆使用效率上来说，标记清除算法要优于复制算法</li></ol></li><li><p>三者不可兼得，堆内存越大，最大暂停时间就越大，减少最大暂停时间，就会降低吞吐量</p></li></ul></div><h2 id="标记-清除算法">标记-清除算法</h2><blockquote><p>两个阶段</p><ol><li>标记阶段，将所有存活对象标记，使用可达性算法，从<code>GC Root</code>开始通过引用链遍历出所有的存活对象</li><li>清除阶段，从内存中删除没有被标记，也就是非存活对象</li></ol></blockquote><div class="note info flat"><ul><li>优点：实现简单，只需要在第一阶段维护每个对象的标志位，第二阶段删除即可</li><li>缺点：<ol><li><strong>碎片化问题</strong>：内存是连续的，所以对象被删除之后，内存中可能会出现很多细小的可用内存单元。如果我们需要一个比较大的空间，这些内存单元会无法进行分配</li><li><strong>分配速度比较慢</strong>：因为内存碎片存在，需要维护一个空闲链表，有可能发生每次遍历链表的最后才能获得合适的内存空间</li></ol></li></ul></div><h2 id="复制算法">复制算法</h2><blockquote><p>核心思想</p><ol><li>准备两块空间<code>From</code>和<code>To</code>空间，每次在对象分配阶段，只能使用其中一块空间(<code>From</code>空间)</li><li><code>GC</code>阶段，将<code>From</code>中存活的对象复制到<code>To</code>空间中</li><li>将两块空间的名字互换，也就是<code>From</code>和<code>To</code>互换名字，因为只有<code>From</code>空间存储对象</li></ol></blockquote><div class="note info flat"><ul><li>完整复制算法<ol><li>将堆内存分隔成两块<code>From</code>空间和<code>To</code>空间，对象分配阶段，创建对象</li><li><code>GC</code>阶段开始，将<code>GC Root</code>搬运到<code>To</code>空间</li><li>将<code>GC Root</code>关联的对象，搬运到<code>To</code>空间，<code>From</code>空间剩下的是没有被<code>GC Root</code>关联的对象了</li><li>清理<code>From</code>空间，并把名称互换</li></ol></li><li>优点：<ol><li>吞吐量高，只需要遍历一次存活对象复制到<code>To</code>空间即可，比标记-整理算法少了一次遍历过程。但是性能比标记-清除算法低，因为标记-清除算法不需要进行对象的移动</li><li>不会出现碎片化的问题，复制算法复制后有序排列对象，所以不会出现内存碎片</li></ol></li><li>缺点：每次只能用一半的堆内存，让一半的空间来创建对象使用</li></ul></div><h2 id="标记-整理算法-标记-压缩算法">标记-整理算法(标记-压缩算法)</h2><blockquote><p>对标记-清理算法中容易产生内存碎片的问题的一种解决方案<br>两个阶段</p><ol><li>标记阶段，将所有的存活对象标记，使用可达性分析算法，从<code>GC Root</code>开始通过引用链遍历出所有存活对象</li><li>整理阶段，将存活对象移动到堆的一端，清理掉非存活对象的内存空间</li></ol></blockquote><div class="note info flat"><ul><li>优点：<ol><li>内存使用率高，整个堆内存都可以使用，复制算法只能用半个堆内存</li><li>不会出现碎片化的问题，整理阶段可以将对象往内存的一侧进行移动，剩下的空间都是可以分配对象的有效空间</li></ol></li><li>缺点：整理阶段的效率不高，整理算法有很多，比如<code>Lisp2</code>整理算法需要对整个堆中的对象搜索三次，整体性能不佳。可以通过<code>Two-Finger</code>，表格算法，<code>ImmixGC</code>等高效的整理算法优化这个阶段的性能</li></ul></div><h2 id="分代GC-Generational-GC">分代<code>GC</code>(<code>Generational GC</code>)</h2><blockquote><p>分代垃圾回收将整个内存区域划分为年轻代(<code>Young</code> 区，新生代)和老年代(<code>Old</code> 区)<br>年轻代存放存活时间比较短的对象，老年代存放存活时间比较长的对象<br>年轻代中有<code>Eden</code>区，<code>Survivor</code>区(<code>S0,S1</code>)<br><code>JDK8</code>中，添加<code>-XX:+UserSerialGC</code>参数使用分代回收的垃圾回收器，运行程序，使用<code>Arthas</code>中的<code>memory</code>命令可以查看三个区域的内存情况，分别是<code>eden_space, survivio_space, tenured_gen</code>，就是伊甸园区，幸存者区，老年代</p></blockquote><div class="note info flat"><ul><li><code>-Xmn</code>：设置新生代的大小，也就是伊甸园区和幸存者区的大小</li><li><code>-XX:SurvivorRatio</code>伊甸园区和幸存区的比例，默认为8。新生代1G内存，伊甸园区就是800MB，<code>S0</code>和<code>S1</code>各100MB</li><li><code>-XX:+PrintGCDetails verbose:gc</code>打印GC日志，前者打印信息详细一些，后者简单一些。</li><li>老年代大小就是堆大小与新生代大小的差</li></ul></div><ul><li>使用分代回收时，创建出来的对象首先放入<code>Eden</code>伊甸园区，如果对象在<code>Eden</code>区越来越多，直到<code>Eden</code>区满，新创建的对象无法放入，就会触发年轻代<code>GC</code>，称为<code>Minor GC</code>或者<code>Young GC</code>，<code>Minor GC</code>会把需要<code>Eden</code>中和<code>From</code>需要回收的对象回收，把没有回收的对象放在<code>To</code>区域中<ul><li>所以<code>Minor GC</code>就是一个复制算法，初始<code>S0</code>是<code>From</code>，<code>S1</code>是<code>To</code>，接下来<code>S0</code>变成了<code>To</code>,<code>S1</code>变成了<code>From</code></li><li>当<code>Eden</code>再次满时，此时会回收<code>Eden</code>区和<code>S1From</code>中的对象，，并把<code>Eden, From</code>中的剩余的对象放在<code>S0</code>中</li></ul></li><li>每次<code>Minor GC</code> 都会为对象记录他的年龄，初始值为0，每次GC完都要加1</li><li>年龄到达15以后(15是最大值)，默认值和垃圾回收器有关，对象就会<strong>晋升</strong>到老年代</li><li>老年代空间不足，无法放入新的对象时，先会尝试<code>Minor GC</code>(为了尽量避免对象放入老年代，比如新生代中年龄都是2或者3，只是被占用满了，需要将对象放在老年代中，如果新生代空间没有满，也可以不用放入老年代，所以先进行<code>Minor GC</code>，尽量避免对象放入老年代)，如果还是不足，就会触发<code>Full GC</code>，对整个堆进行垃圾回收<ul><li>如果<code>Full GC</code>没有释放足够的老年代的空间，就会产生<code>OutOfMemory</code>错误</li></ul></li></ul><div class="note info flat"><ul><li>为什么分代<code>GC</code>要把堆分成年轻代和老年代</li></ul><blockquote><p>系统中的大部分对象，都是创建出来以后不再使用可以被回收，比如用户获取订单数据，订单数据返回给用户之后就可以释放了<br>老年代中会存放长期存活的对象，比如<code>Spring</code>中的大部分<code>bean</code>对象，在程序启动之后就不会被回收了<br>在虚拟机的默认设置中，新生代的大小要远小于老年代的大小</p></blockquote><ol><li>可以通过调整新生代和老年代的比例来适应不同类型的应用程序，提高内存的利用率和性能。比如一个用户很多的网站，有很多人需要访问订单数据，那如果新生代较小，则会有很多年龄较小的对象进入老年代，导致<code>gc</code>时间延长，此时可以将新生代的内存区调大一些，直接可以通过<code>Minor GC</code>回收</li><li>新生代和老年代可以使用不同的垃圾回收算法，新生代一般使用复制算法，减少内存碎片；老年代可以使用标记-清除或者标记-整理算法，由程序员自己调整(因为老年代空间比较大，使用了复制算法就只能使用一半空间了，就不合理了)，标记清除算法效率较高，但是会有内存碎片，而标记整理算法没有内存碎片，但是<code>STW</code>较长</li><li>分代设计中允许只回收新生代<code>Minor GC</code>，如果能满足对象分配的要求就不需要堆整个堆进行回收了，<code>STW</code>时间减少(最核心)，尽可能做<code>Minor GC</code>，减少<code>Full GC</code></li></ol></div><h1>垃圾回收器</h1><ul><li>垃圾回收器是垃圾回收算法的具体实现，由于垃圾回收器分为年轻代和老年代，所以出了G1之外的其他垃圾回收器必须成对使用<br><img src="https://gitee.com/sang3112/blog_imgs/raw/6d55251373589f7b63584fece6808ec3cbcdad27/Java/GC.png" alt="GC"></li></ul><blockquote><p>年轻代的<code>Serial</code>以及老年代的<code>Serial Old</code><br>年轻代的<code>ParNew</code>以及老年代的<code>CMS</code><br>年轻代的<code>Parallel Scavenge</code>以及老年代的<code>Parallel Old</code><br>G1可以同时控制年轻代和老年代(<code>JDK9</code>之后主流推荐)<br><code>JDK9</code>废弃了年轻代的<code>Serial</code>以及老年代的<code>CMS</code>；年轻代的<code>ParNew</code>以及老年代的<code>Serial Old</code><br><code>JDK14</code>中废弃了<code>Parallel Scavenge</code>以及老年代的<code>Serial Old</code>(为什么？)</p></blockquote><h2 id="Serial垃圾回收器-年轻代"><code>Serial</code>垃圾回收器-年轻代</h2><blockquote><p><strong>单线程串行</strong>回收年轻代的垃圾回收器<br><img src="https://gitee.com/sang3112/blog_imgs/raw/6d55251373589f7b63584fece6808ec3cbcdad27/Java/Serial.png" alt="Serial"></p></blockquote><ul><li>回收年轻代，使用复制算法</li><li>优点：单CPU处理器下吞吐量出色</li><li>缺点：多CPU下吞吐量不如其他垃圾回收器，堆偏大会让用户线程处于长时间等待(因为回收的时候只有单线程进行<code>GC</code>)</li><li>适合<code>Java</code>编写的客户端程序，或者硬件配置有限的场景</li></ul><h2 id="SerialOld垃圾回收器-老年代"><code>SerialOld</code>垃圾回收器-老年代</h2><blockquote><p><strong>单线程串行回收</strong>，是<code>Serial</code>的老年代版本</p></blockquote><ul><li><code>-XX:+UseSerialGC</code> 新生代、老年代都使用串行回收器</li><li>回收老年代，使用标记-整理算法</li><li>优缺点跟<code>Serial</code>算法相同</li><li>一般配合<code>Serial</code>使用，或者在特殊情况下调用<code>CMS</code>使用，实际使用不多，一般在<code>CPU</code>资源比较匮乏的时候使用</li></ul><h2 id="ParNew垃圾回收器-年轻代"><code>ParNew</code>垃圾回收器-年轻代</h2><blockquote><p>本质上就是对<code>Serial</code>在多线程CPU下的优化，使用多线程进行垃圾回收<br><img src="https://gitee.com/sang3112/blog_imgs/raw/6d55251373589f7b63584fece6808ec3cbcdad27/Java/ParNew.png" alt="ParNew"><br><code>-XX:+UseParNewGC</code>新生代使用<code>ParNew</code>回收器，老年代使用串行回收器</p></blockquote><ul><li>回收年轻代，使用复制算法</li><li>优点：多CPU处理器下停顿时间较短</li><li>缺点：吞吐量和停顿时间不如<code>G1</code>，所以在<code>JDK9</code>之后不建议使用</li><li>适合<code>JDK8</code>以及之前的版本中，与<code>CMS</code>老年代垃圾回收器配合使用</li></ul><h2 id="CMS-Concurrent-Mark-Sweep-垃圾回收器-老年代"><code>CMS(Concurrent Mark Sweep)</code>垃圾回收器-老年代</h2><blockquote><p>关注的是系统的<strong>暂停时间</strong>，允许用户线程和垃圾回收线程在某些步骤中同时执行，减少用户线程的等待<br><code>-XX:+UseConcMarkSweepGC</code><br><img src="https://gitee.com/sang3112/blog_imgs/raw/6d55251373589f7b63584fece6808ec3cbcdad27/Java/CMS.png" alt="CMS"></p></blockquote><ul><li>使用标记-清除算法回收老年代</li><li>优点：系统由于垃圾回收停顿时间较短，所以用户体验好</li><li>缺点：内存碎片问题，退化问题(会退化为<code>Serial Old</code>单线程)，浮动垃圾问题</li><li>适合大型互联网系统中，用户请求数据量大，频率高的场景，比如订单接口，商品接口等</li></ul><div class="note info flat"><p><code>CMS</code>执行步骤</p><ol><li>初始标记，用极短的时间标记出<code>GC Roots</code>能够直接关联到的对象</li><li>并发标记，标记所有的对象，用户线程不需要暂停</li><li>重新标记，由于并发标记阶段有些对象会发生变化，存在错标和漏标的情况，需要重新标记(这也是<code>STW</code>的原因)</li><li>并发清理，清理死亡对象，用户线程不需要暂停(会有浮动垃圾,不能完全垃圾回收)</li></ol><blockquote><p>只有初始标记和重新标记两个阶段用户线程需要暂停，但是这两个线程执行时间较短，是并发执行的，所以<code>STW</code>较短</p></blockquote><ul><li><code>CMS</code>问题<ol><li>使用标记-清除算法，会有大量内存碎片，在<code>Full GC</code>时进行碎片整理，导致用户线程暂停，可以使用<code>-XX:CMSFullGCsBeforeCompation=N</code>(默认为0)调整<code>N</code>次<code>Full GC</code>之后再整理</li><li>无法处理在并发清理过程中产生的<strong>浮动垃圾</strong>，不能做到完全的垃圾回收, 也就是在并发清理阶段，如果用户产生了对象，并且很快就失效了，则不能在并发清理阶段被回收</li><li>如果老年代内存不足无法分配对象，<code>CMS</code>就会退化为<code>Serial Old</code>单线程回收老年代</li></ol></li></ul></div><h2 id="Parallel-Scavenge垃圾回收器-年轻代"><code>Parallel Scavenge</code>垃圾回收器-年轻代</h2><ul><li>是<code>JDK8</code>默认的垃圾回收器，多线程并行回收，关注系统的吞吐量，具备自动调整堆内存大小的特点</li><li>年轻代的复制算法</li><li>优点：吞吐量高，手动可控，为了提高吞吐量，虚拟机会动态调整堆的参数(不需要关注最大堆内存，年轻代的大小了)</li><li>缺点：不能保证单次的停顿时间(可以设置最大单次暂停时间)</li><li>适合后台任务，不需要与用户进行交互，并且容易产生大量的对象，比如大数据的处理，大文件的导出</li></ul><blockquote><p>允许手动设置最大暂停时间和吞吐量，官方建议<strong>不要设置堆内存的最大值</strong>，垃圾回收器会根据最大暂停时间和吞吐量自动调整内存大小<br>最大暂停时间<code>-XX:MaxGCPauseMillis=n</code>设置每次垃圾回收时的最大停顿毫秒数<br>吞吐量<code>-XX:GCTimeRatio=n</code>设置吞吐量为n，也就是用户线程执行时间=n/(n+1)<br>自动调整内存大小<code>-XX:+UseAdaptiveSizePolicy</code>设置可以让垃圾回收器根据吞吐量和最大停顿毫秒数自动调整内存大小<br>实际上，当我们把最大暂停时间减小的时候，垃圾回收器会主动减少堆内存，从而减少最大暂停时间<br><img src="https://gitee.com/sang3112/blog_imgs/raw/6d55251373589f7b63584fece6808ec3cbcdad27/Java/PS.png" alt="PS"></p></blockquote><h2 id="Parallel-Old垃圾回收器-老年代"><code>Parallel Old</code>垃圾回收器-老年代</h2><ul><li>是<code>PS</code>收集器的老年代版本，利用多线程并发收集</li><li><code>-XX:+UseParallelGC</code>或者<code>-XX:+UseParallelOldGC</code>可以使用<code>PS + PO</code>这种组合</li><li>回收老年代的标记-整理算法，(<code>Arthas</code>上面显示<code>MarkSweep</code>也就是标记清除，这是因为老年代垃圾回收器不会单独使用标记清除算法，官方没有将整理放上来，所以显示<code>MarkSweep</code>，包括<code>CMS</code>用的也不是单纯的标记清除算法)</li><li>优点：并发收集，在多核CPU下效率较高</li><li>缺点：暂停时间较长</li><li>适合与<code>PS</code>一起使用</li></ul><h2 id="G1垃圾回收器"><code>G1</code>垃圾回收器</h2><blockquote><p><code>JDK9</code>之后默认使用<code>G1</code>垃圾回收器，<code>PS</code>关注吞吐量，允许用户设置最大暂停时间，但是会减少年轻代的可用空间大小<br><code>CMS</code>关注暂停时间，但是吞吐量方面会有下降<br><code>G1</code>设计目标就是将上述两种垃圾回收器的优点融合：</p><ol><li>支持巨大的堆空间回收，具有较高的吞吐量</li><li>支持多CPU并行垃圾回收</li><li>允许用户设置最大暂停时间<br>所以强烈建议使用<code>G1</code>垃圾回收器</li></ol></blockquote><h3 id="内存结构">内存结构</h3><ul><li><code>G1</code>之前的垃圾回收器，一般内存结构是连续的<br><img src="https://gitee.com/sang3112/blog_imgs/raw/6d55251373589f7b63584fece6808ec3cbcdad27/Java/beforeg1.png" alt="beforeg1"></li><li><code>G1</code>将整个堆划分为多个大小相等的区域，称为区<code>Region</code>，区域不要求连续，分为<code>eden, Survivor, Old</code>区。<code>Region</code>的大小通过堆空间大小/2048计算得到，也可以通过<code>-XX:G1HeapRegionSize=32m</code>指定(<code>region</code>大小为32M)，<code>Region size</code>必须是2的指数幂，取值范围从1M到32M</li></ul><h3 id="垃圾回收方式">垃圾回收方式</h3><ol><li>年轻代回收(<code>Young GC</code>)</li><li>混合回收(<code>Mixed GC</code>)(回收年轻代加上老年代)</li></ol><h3 id="年轻代回收-YoungGC">年轻代回收(<code>YoungGC</code>)</h3><blockquote><p>回收<code>Eden</code>区和<code>Survivor</code>区中不再使用的对象，会导致<code>STW</code>，<code>G1</code>会尽可能的保证暂停时间，可以通过<code>-XX:MaxGCPauseMillis=n</code>(默认为200)设置最大暂停时间的毫秒数</p></blockquote><ol><li>新创建的对象放在<code>Eden</code>区，如果<code>Eden + Survivor</code>超过年轻代区的60%，就会判断年轻代空间不足，无法分配对象的时候会执行<code>Young GC</code></li><li>标记处<code>Eden</code>和<code>Survivor</code>区域中的存活对象</li><li>根据最大暂停时间选择某些区域将存活对象复制到一个新的<code>Survivor</code>区域，并且年龄+1，并清空这些区域(所以使用了复制方法，不会产生内存碎片)</li></ol><blockquote><p>进行<code>Young GC</code>的时候会记录每次垃圾回收的<code>Eden</code>区域和<code>Survivor</code>区域的<strong>平均耗时</strong>，从而作为下次回收时的参考依据，这样就可以根据配置的最大暂停时间计算出本次回收最多能回收多少个<code>Region</code>区域了<br>比如<code>-XX:MaxGCPauseMillis=n</code>(默认为200)，每个<code>Region</code>回收耗时40ms，所以这次最多只能回收4个<code>Region</code></p></blockquote><ol start="4"><li>后面如果再发生<code>Young GC</code>，步骤相同，只是<code>Survivor</code>会搬运到另一个<code>Survivor</code>区</li></ol><blockquote><p>如果一个对象年龄达到阈值(默认是15)，就会被放入老年代</p></blockquote><ol start="5"><li>如果部分对象大小超过<code>Region</code>的一半，那么就会直接放到老年代中，称为<code>Humongous</code>区(巨大的)。</li></ol><blockquote><p>比如堆内存4G，每个<code>Region</code>2M，只要一个对象超过1M，就会被放入<code>Humongous</code>区中，如果对象过大，就会横跨多个<code>Region</code></p></blockquote><ol start="6"><li>多次回收之后，会有很多老年代区，如果达到阈值(<code>-XX:InitiatingHeapOccupancyPercent</code>)占用总堆空间的默认的45%，就会触发<code>Mixed GC</code>，回收所有年轻代和部分老年代对象以及大对象区，采用复制算法完成</li></ol><h3 id="混合回收-Mixed-GC">混合回收(<code>Mixed GC</code>)</h3><blockquote><p>分为初始标记<code>Initial Mark</code>，并发标记<code>Concurrent Mark</code>，最终标记<code>Remark</code>或者<code>Finalize Marking</code>，并发清理(<code>Cleanup</code>)<br><code>G1</code>对老年代的清理会选择存活度最低的区域来进行回收，可以保证回收效率最高，也就是<code>G1</code>的由来(判断哪个区域存活对象最少，就优先清除哪个区域)<br><img src="https://gitee.com/sang3112/blog_imgs/raw/6d55251373589f7b63584fece6808ec3cbcdad27/Java/G1old.png" alt="G1old"></p></blockquote><ul><li>初始标记：标记<code>GC Roots</code>引用的对象为存活，并行执行，暂停用户线程，速度较快</li><li>并发标记：将第一步中标记对象的引用对象标记为存活，和用户线程一起执行(可能会出现错标漏标)</li><li>最终标记：标记一些引用改变漏标的对象，不管新创建、不再关联的对象(但是上一步，有些对象不再使用了，<code>G1</code>不再处理)</li><li>并发复制清理：使用复制算法，将存活对象复制到别的<code>Region</code>中，不会产生内存碎片</li></ul><div class="note info flat"><ul><li>如果清理过程中没有足够的空<code>Region</code>存放转移的对象，就会出现<code>Full GC</code>，单线程执行标记-整理算法，此时会导致用户线程暂停。所以尽量保证堆中有一定的空间</li></ul></div><blockquote><p><code>-XX:+UseG1GC</code>，打开<code>G1</code>的开关，<code>JDK9</code>之后不需要打开<br><code>-XX:MaxGCPauseMillis=n</code>设置最大暂停时间</p></blockquote><ul><li>使用<strong>复制算法</strong>回收年轻代+老年代</li><li>优点：<ol><li>对较大的堆如果超过6G对回收时，延迟也可控</li><li>不会产生内存碎片</li><li>并发标记的<code>SATB</code>算法效率高</li></ol></li><li>缺点：<code>JDK8</code>之前还不够成熟</li></ul><h2 id="总结">总结</h2><ul><li>组合</li></ul><ol><li><code>JDK8</code>以及之前：<code>ParNew + CMS</code>(关注暂停时间); <code>PS + PO</code>(关注吞吐量); <code>G1</code>(<code>JDK8</code>之前不建议使用，较大堆并且关注暂停时间)</li><li><code>JDK9</code>之后，使用<code>G1</code></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 垃圾回收算法 </tag>
            
            <tag> 垃圾回收器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记_3</title>
      <link href="/posts/fdc04dbc.html"/>
      <url>/posts/fdc04dbc.html</url>
      
        <content type="html"><![CDATA[<h1>垃圾回收器</h1><blockquote><p>主要负责在<strong>堆</strong>上进行内存回收</p></blockquote><ul><li>自动垃圾回收可以降低实现难度，降低回收bug的可能性</li><li>但是程序员无法控制内存回收的及时性, 也无法完全避免内存溢出</li></ul><h2 id="应用场景">应用场景</h2><ol><li>解决系统僵死(因为频繁的垃圾回收)</li><li>性能优化</li><li>常见垃圾回收，四种引用等</li></ol><h2 id="方法区回收">方法区回收</h2><blockquote><p>线程不共享的程序计数器和<code>Java</code>虚拟机栈以及本地方法栈，都只需要等待线程销毁自己就销毁了，不需要垃圾回收</p></blockquote><h3 id="方法区回收的条件-三个">方法区回收的条件(三个)</h3><blockquote><p>方法区中的类不再使用，即可被回收</p></blockquote><ol><li>类的<strong>所有实例</strong>都已经被回收了，在堆中不存在任何该类的实例对象以及子类对象 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = loader.loadClass(<span class="string">&quot;类的全限定名&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">o = <span class="literal">null</span>; <span class="comment">// 此时对象o不再使用，就可以让gc自动回收clazz类</span></span><br></pre></td></tr></table></figure></li><li>加载该类的类加载器已经被回收了 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">URLClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URLClassLoader</span>(<span class="keyword">new</span> <span class="title class_">URL</span>[]&#123;<span class="keyword">new</span> <span class="title class_">URL</span>(spec:<span class="string">&quot;路径&quot;</span>)&#125;);</span><br><span class="line">loader = <span class="literal">null</span>; </span><br></pre></td></tr></table></figure></li><li>该类对应的<code>java.lang.Class</code>对象没有任何地方被引用 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = loader.loadClass(<span class="string">&quot;类的全限定名&quot;</span>);</span><br><span class="line">clazz = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>使用<code>System.gc()</code>可以手动触发垃圾回收</p></blockquote><div class="note info flat"><ul><li>开发过程中此类场景出现较少，主要在<code>OSGI, JSP</code>的热部署等场景中</li><li>每个<code>jsp</code>文件对应一个类加载器，一个<code>jsp</code>文件被修改了，直接写在这个<code>jsp</code>类加载器，创建新的类加载器，重新加载<code>jsp</code>文件</li></ul></div><h2 id="堆回收">堆回收</h2><blockquote><p>堆上的对象主要看是否还被<strong>引用</strong>，如果被引用，说明不能回收</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Demo</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">        d = <span class="literal">null</span>; <span class="comment">// 此时没有引用，可以被回收</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceCounting</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        <span class="type">B</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        a1.b = b1;</span><br><span class="line">        b1.a = a1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// A实例要回收，需要消除两个引用关系，分别是栈中a1对对象的引用，以及B对象中b1.a对对象的引用</span></span><br><span class="line">    <span class="comment">// a1 = null;</span></span><br><span class="line">    <span class="comment">// b1.a = null;</span></span><br><span class="line"><span class="comment">// 如果单纯的执行a1 = null; b1 = null; A和B对象也可以被回收，因为方法里面没有办法访问到AB对象了</span></span><br></pre></td></tr></table></figure><div class="note info flat"><ul><li>如果想要查看垃圾回收的信息，可以使用<code>-verbose:gc</code></li></ul></div><h2 id="判断堆上的对象是否被引用-两种方法">判断堆上的对象是否被引用(两种方法)</h2><ol><li><strong>引用计数法</strong>：每个对象维护一个计数器，初始值为0，对象被引用就加1，取消引用就减1<ul><li>缺点:</li></ul><blockquote><p>引用和取消引用需要维护计数器，对性能有一定影响<br>循环引用，比如A引用B，B引用A，就会导致对象无法回收(上面的例子如果用引用计数法，就无法回收了)</p></blockquote></li><li>可达性分析法(<code>Java</code>使用，性能更高，解决了循环引用的问题)<ul><li>可达性分析算法将对象分为两类: 垃圾回收的根对象(<code>GC Root</code>)；普通对象，对象与对象之间存在引用关系</li><li><code>GC Root</code>对象一般不可以被回收，<code>JVM</code>也会维护一个<code>GC Root</code>对象列表</li><li>每次从某个<code>GC Root</code>遍历引用链，如果某个普通对象可以从<code>GC Root</code>到达，说明不可被回收<br><img src="https://gitee.com/sang3112/blog_imgs/raw/6d55251373589f7b63584fece6808ec3cbcdad27/Java/achieve.png" alt="achieve"></li></ul></li></ol><div class="note info flat"><p>什么样的对象可以作为<code>GC Root</code>对象</p><ol><li>线程<code>Thread</code>对象，引用线程栈帧中的方法参数、局部变量等</li><li>系统类加载器加载的<code>java.lang.Class</code>对象，引用类中的静态变量 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceCounting</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">A</span> <span class="variable">a2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// sun.misc.Launcher是一个GC Root对象，可以找到应用程序类加载器，以及扩展类加载器。</span></span><br><span class="line"><span class="comment">// 自定义的ReferenceCounting是由应用程序类加载器加载的，所以可以由GC Root找到</span></span><br><span class="line"><span class="comment">// a2 引用了A，所以GC Root可以找到a2，所以不会回收</span></span><br></pre></td></tr></table></figure></li><li>监视器对象，用来保存同步锁<code>synchronized</code>关键字持有的对象<br><code>synchronized(Reference.class)</code> 只要这个关系建立起来，监视器对象就可以找到<code>ReferenceCounting</code>，就无法回收</li><li>本地方法调用时使用的全局对象(不需要程序员过多关注)</li></ol></div><ul><li>通过<code>Arthas</code>以及<code>eclise MAT(Memory Analyzer)</code>工具可以查看<code>GC Root</code></li><li><code>Arthas</code>使用<code>heapdump &lt;dir/文件名.hprof&gt;</code>命令将堆内存快照保存到本地磁盘中</li><li>使用<code>MAT</code>工具打开堆内存的快照文件</li><li>使用<code>GC Roots</code>功能查看所有的<code>GC Root</code></li></ul><h3 id="对象引用-五种">对象引用(五种)</h3><blockquote><p>强引用，软引用，弱引用，虚引用，终结器引用</p></blockquote><ol><li><p>强引用</p><blockquote><p>可达性算法中的对象引用一般指强引用，就是<code>GC Root</code>对象对普通对象有引用关系，那么普通对象就不会被回收</p></blockquote></li><li><p>软引用</p><blockquote><p>如果一个对象只有软引用关联到它，如果程序内存不足，则会将软引用进行回收<br><code>JDK1.2</code>提供<code>SoftReference</code>实现软引用，经常用于缓存中<br>因此使用软引用应该创建两个对象，一个是<code>SoftReference</code>对象，引用真正使用的对象，而<code>SoftReference</code>本身应该被<code>Gc Root</code>引用，保证可以找到</p></blockquote> <div class="note info flat"><p>软引用的执行过程</p><ol><li>对象使用软引用包装起来，<code>new SoftReference&lt;对象类型&gt;(对象);</code></li><li>内存不足时，<code>JVM</code>进行垃圾回收</li><li>垃圾回收仍然不能解决内存不足的问题，回收软引用中的对象</li><li>如果依然内存不足，会抛出<code>OutOfMemory</code>异常</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">100</span>];</span><br><span class="line">SoftReference&lt;<span class="type">byte</span>[]&gt; softReference = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;<span class="type">byte</span>[]&gt;(bytes);</span><br><span class="line"><span class="comment">// 这段代码将100M的数据放在软引用中</span></span><br></pre></td></tr></table></figure><ul><li><code>Java</code>中的<code>Caffeine</code>可以在创建缓存的过程中将缓存对象设置成<code>softValues()</code>也就是软引用</li></ul></div> <div class="note info flat"><ul><li>软引用中的对象如果内存不足会被回收，<code>SoftReference</code>对象本身也需要被回收，但是<code>SoftReference</code>一旦被回收了，就无法知道其引用的对象是否真的被回收了，所以<code>SoftReference</code>提供了一套<strong>队列机制</strong>来进行判断:<ol><li>软引用创建时，通过构造器传入引用队列(程序员自定义)</li><li>软引用中包含对象被回收时，该软引用对象会被放入引用队列</li><li>通过代码遍历引用队列，将<code>SoftReference</code>的强引用删除</li></ol></li></ul></div><ul><li>软引用可以继承<code>SoftReference</code>类的方式来实现，<code>SoftReference</code>类就是一个软引用对象，通过构造器传入软引用包含的对象，以及引用队列</li><li>使用软引用实现学生数据的缓存，软引用如果被回收了，则要清理<code>HashMap</code>中的<code>key</code><br><img src="https://gitee.com/sang3112/blog_imgs/raw/6d55251373589f7b63584fece6808ec3cbcdad27/Java/stucac.png" alt="stucache"></li></ul> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentCache</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">StudentCache</span> <span class="variable">cache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StudentCache</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; ; ++ i)&#123;</span><br><span class="line">            StudentCache.getInstance().cacheStudent(<span class="keyword">new</span> <span class="title class_">Student</span>(i, String.valueOf(i)))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, StudentRef&gt; StudentRefs; <span class="comment">// 用于Cache内容的存储</span></span><br><span class="line">    <span class="keyword">private</span> ReferenceQueue&lt;Student&gt; q; <span class="comment">// 垃圾Reference队列</span></span><br><span class="line">    <span class="comment">// 继承SoftReference，每个实例都具有一个可识别的标识</span></span><br><span class="line">    <span class="comment">// 并且标识与在HashMap中的key相同</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">StudentRef</span> <span class="keyword">extends</span> <span class="title class_">SoftReference</span>&lt;Student&gt;&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">_key</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">StudentRef</span><span class="params">(Student em, ReferenceQueue&lt;Student&gt; q)</span>&#123;</span><br><span class="line">            <span class="built_in">super</span>(em, q); <span class="comment">// 调用父类的构造方法</span></span><br><span class="line">            _key = em.getId();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造一个缓存器实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">StudentCache</span><span class="params">()</span>&#123;</span><br><span class="line">        StudentRefs = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, StudentRef&gt;();</span><br><span class="line">        q = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;Student&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取得缓存器实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StudentCache <span class="title function_">getInstance</span><span class="params">()</span> &#123;<span class="keyword">return</span> cache;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以软引用的方式对一个Student对象的实例进行引用并保存该引用(放入缓存)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">cacheStudent</span><span class="params">(Student em)</span>&#123;</span><br><span class="line">        cleanCache(); <span class="comment">// 清除垃圾引用</span></span><br><span class="line">        <span class="type">StudentRef</span> <span class="variable">ref</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StudentRef</span>(em, q);</span><br><span class="line">        StudentRefs.put(em.getId(), ref);</span><br><span class="line">        System.out.println(StudentRefs.size());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 依据指定的ID，重新获取相应的Student对象的实例</span></span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">getStudent</span><span class="params">(Integer id)</span>&#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">em</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 缓存中是否有该Student实例的软引用，如果有就从软引用中获得</span></span><br><span class="line">        <span class="keyword">if</span> (StudentRefs.containsKey(id))&#123;</span><br><span class="line">            <span class="type">StudentRef</span> <span class="variable">ref</span> <span class="operator">=</span> StudentRefs.get(id);</span><br><span class="line">            em = ref.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有这个软引用，或者这个软引用得到的实例为空，则重新构建一个实例，保存对这个实例的软引用</span></span><br><span class="line">        <span class="keyword">if</span> (em == <span class="literal">null</span>)&#123;</span><br><span class="line">            em = <span class="keyword">new</span> <span class="title class_">Student</span>(id, String.valueOf(id));</span><br><span class="line">            System.out.println(<span class="string">&quot;Retrieve From StudentInfoCenter. ID = &quot;</span> + id);</span><br><span class="line">            <span class="built_in">this</span>.cacheStudent(em);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> em;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除那些软引用的所有Student对象已经被回收的StudentRef对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">cleanCache</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">StudenRef</span> <span class="variable">ref</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>((ref = (StudentRef)q.poll() != <span class="literal">null</span>))&#123;</span><br><span class="line">            StudentRefs.remove(ref._key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> id, String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;<span class="keyword">return</span> id;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;<span class="built_in">this</span>.id = id;&#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;<span class="keyword">return</span> name;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;<span class="built_in">this</span>.name = name;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>弱引用</p><blockquote><p>关联的对象在垃圾回收时，不管内存够不够，都会被直接回收<br><code>JDK1.2</code>版本之后提供了<code>WeakReference</code>类来实现弱引用，主要用在<code>ThreadLoacl</code>中，弱引用本身也可以使用引用队列回收<br>除了<code>ThreadLocal</code>以外，基本上不会使用这个，<code>Caffeine</code>中也有弱引用的实现，但是一般不用</p></blockquote></li><li><p>虚引用(幽灵引用，幻影引用)</p><blockquote><p>在常规开发中<strong>不会</strong>使用<br>不能通过虚引用对象获取包含的对象，唯一的用途是当对象被垃圾回收器回收时可以接收到对应的通知<br>使用<code>PhantomReference</code>实现了虚引用<br>直接内存为了及时知道直接内存中的对象不再使用，从而回收内存，就会用虚引用实现<code>Cleaner</code>类(解决了直接内存中内存的释放问题)</p></blockquote></li><li><p>终结器引用</p><blockquote><p>在常规开发中不会使用<br>对象需要被回收的时候，终结器引用会关联对象并且放在<code>Finalizer</code>类中的引用队列，由一条<code>FinalizerThread</code>线程从队列中获取对象，然后执行对象的<code>finalize</code>方法(这个方法实际上重写了<code>Object</code>中的方法，作用是回收对象时做一些收尾的工作)，在对象第二次被回收时，该对象才会被真正的回收。这个过程中<code>finalize</code>方法再将自身对象使用强引用关联上，但是不建议这么做，因为这个<code>finalize</code>方法什么时候调用，甚至可能不调用，都是<code>GC</code>决定的，不是程序员决定的。(不管是实现自救，也就是用强引用关联；还是实现清理工作都是不合适的，所以基本不会用)</p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 方法区 堆的垃圾回收 </tag>
            
            <tag> 五种引用关系 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记_2</title>
      <link href="/posts/8ac77d2a.html"/>
      <url>/posts/8ac77d2a.html</url>
      
        <content type="html"><![CDATA[<h1>运行时数据区</h1><h2 id="分类">分类</h2><ol><li>线程不共享：程序计数器、<code>Java</code>虚拟机栈、本地方法栈</li><li>线程共享：方法区、堆区</li></ol><h2 id="程序计数器">程序计数器</h2><blockquote><p><code>Program Counter Register</code>，也叫做<code>PC</code>寄存器，每个线程会通过程序计数器记录当前<strong>要执行</strong>的字节码指令的地址</p></blockquote><h3 id="作用">作用</h3><ol><li>控制程序指令的执行，比如跳转，分支，异常</li><li>多线程情况下<code>JVM</code>通过程序计数器记录CPU切换前执行到哪一句，切换回来后执行并继续解释运行</li></ol><div class="note info flat"><p>程序计数器会产生内存溢出的问题吗</p><ul><li>内存溢出指在使用某一块内存区域时，存放的数据需要占用的内存大小超过了虚拟机能够提供的内存上限</li><li>每个线程只存储一个固定长度的内存地址，<code>PC</code>不会产生内存溢出</li><li><code>PC</code>不用程序员修改</li></ul></div><h2 id="Java虚拟机栈"><code>Java</code>虚拟机栈</h2><blockquote><p>先进后出(<code>FILO</code>)，每个方法调用一个栈帧来保存</p></blockquote><ul><li><code>Java</code>虚拟机栈随着线程的创建而创建，线程销毁则栈回收，由于方法可能会在不同的线程中执行，所以每个线程都有自己的虚拟机栈</li></ul><h3 id="栈帧组成">栈帧组成</h3><blockquote><p>局部变量表，操作数栈，帧数据</p></blockquote><ol><li>局部变量表：方法执行过程中存放所有的局部变量，与字节码局部变量表不太一样</li></ol><blockquote><p>栈帧中的局部变量表是一个数组，每一个位置成为槽<code>slot</code>，<code>long, double</code>占用两个槽，其他类型占用一个槽<br>实例方法中的序号为<code>0</code>的位置存放的是<code>this</code>，指的是当前调用方法的对象，运行时会在内存中存放实例对象的地址<br>方法参数也会保存在局部变量表中，顺序与参数定义顺序一致<br>所以局部变量表保存了实例方法的<code>this</code>对象，方法的参数，方法体中声明的局部变量。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> m)</span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 占用了6个槽，为了节省空间，槽是可以复用的，一旦某个局部变量不再生效，则当前的槽可以再次使用</span></span><br><span class="line"><span class="comment">// ab在代码块中，代码块结束以后，ab就释放了</span></span><br></pre></td></tr></table></figure><ol start="2"><li>操作数栈：存放中间数据的一块区域，如果一条指令将一个值压入操作数栈，则后面的指令可以弹出并使用该值</li></ol><blockquote><p><strong>编译期</strong>就可以确定操作数栈的最大深度，从而在执行时正确分配内存大小</p></blockquote><ol start="3"><li>帧数据：包含动态链接，方法出口，异常表的引用</li></ol><blockquote><p>动态链接保存的是符号引用到运行时常量池中内存地址的映射关系(比如引用其他类)<br>方法出口：方法在正确或异常结束时，栈帧会被弹出，PC应该指向那个<strong>上一个栈帧中的下一条指令的地址</strong>，所以在当前栈帧中，需要存储此方法的出口的地址<br>异常表引用：存放代码中的异常处理信息，包含异常捕获的生效范围以及异常发生以后跳转到的字节码指令位置</p></blockquote><div class="note info flat"><p>栈内存溢出</p><ul><li>如果栈帧过多，占用内存超过栈内存可以分配的最大大小以后就会出现内存溢出</li><li>会报<code>StackOverflowError</code>错误</li><li>比如递归的时候没有设置递归出口，则会内存溢出</li></ul><p>设置栈内存</p><ul><li>通过参数<code>-Xss&lt;值&gt;</code>设置虚拟机栈大小，单位是[字节，必须是1024的倍数，默认] [k或者K] [m或者M] [g或者G]</li><li>也可以用<code>-XX:ThreadStackSize=&lt;大小&gt;</code>，但是比较复杂</li><li><code>HotSpot JVM</code>对栈的大小的最大值和最小值有要求，超过范围会自动调整</li><li>局部变量过多，操作数栈深度过大也会影响栈内存大小</li><li>可以手动指定<code>-Xss256k</code>节省内存</li></ul></div><h2 id="本地方法栈">本地方法栈</h2><blockquote><p><code>Java</code>虚拟机栈存储了<code>Java</code>方法调用时的栈帧，本地方法栈存储的是本地方法的栈帧，用<code>cpp</code>编写的</p></blockquote><ul><li>在<code>Hotspot</code>虚拟机中，<code>Java</code>虚拟机栈和本地方法栈实现上用了同一个栈空间，本地方法栈会在栈内存上生成一个栈帧，临时保存方法参数的同时,方便出现异常时也把本地方法的栈信息打印出来</li></ul><h2 id="堆">堆</h2><blockquote><p>堆内存是最大的内存区域，<strong>创建出来的对象都在堆上</strong><br>栈上的局部变量表中可以存放堆上对象的引用，静态变量也可以存放堆对象的引用，通过静态变量可以实现对象在线程之间共享</p></blockquote><div class="note info flat"><p>堆内存溢出</p><ul><li>堆内存大小有上限，如果一直向堆中放入对象达到上限后，就会抛出<code>OutOfMemory</code>错误</li><li>有三个需要关注的值: <code>used, total, max</code>，在<code>Arthas</code>中可以使用<code>dashbord -i </code> 或者 <code>memory</code>命令查看<ul><li><code>used</code>：当前已经使用的堆内存</li><li><code>total</code>：<code>Java</code>虚拟机已经分配的可用堆内存</li><li><code>max</code>：是可以分配的最大堆内存</li><li><code>total</code>内存不足的时候，<code>Java</code>会扩大<code>total</code>，直到达到<code>max</code>为止</li></ul><blockquote><p>但是，<strong>不是</strong>在<code>total = used = max</code>的时候堆内存溢出，这是因为有垃圾回收器存在的原因</p></blockquote><ul><li>默认情况下，<code>max</code>默认是系统内存的<code>1/4</code>，<code>total</code>默认是系统内存的<code>1/64</code>，实际应用中需要单独设置</li><li><code>-Xmx值 -Xms值</code>，分别表示<code>max</code>和<code>total</code>的大小，<code>max</code>必须大于<code>2MB</code>，<code>total</code>必须大于<code>1MB</code></li><li>但是实际上<code>Arthas</code>堆内存显示的比实际上分配的要小一点，这是因为使用了<code>JMX</code>技术，与垃圾回收器有关，计算的是可以<strong>分配对象的内存，而不是整个内存</strong></li><li>一般设置的时候，将<code>total</code>设置成<code>max</code>相同的大小，减少申请内存和压缩内存的开销。</li></ul></li></ul></div><h2 id="方法区">方法区</h2><blockquote><p>存放基础信息的位置(类的元信息，运行时常量池，字符串常量池)，线程共享，是一个虚拟概念</p></blockquote><ul><li>用来存放每个类的基本信息(元信息)，一般称为<code>InstanceKlass</code>对象，在类的加载阶段完成</li><li>还用来存放了字节码中的运行时常量池，通过<strong>编号查表</strong>的方式找到常量，称为<strong>静态常量池</strong>。常量池<strong>加载</strong>到内存中之后，可以通过内地址快读定位到常量池中的内容，就是<strong>运行时常量池</strong>。</li></ul><h3 id="JDK7以及之前"><code>JDK7</code>以及之前</h3><ul><li>方法区存放在<strong>堆的永久代空间</strong>，堆的大小由虚拟机参数控制</li><li>在<code>Arthas</code>中可以看见<code>ps_perm_gen</code>就是永久代，因为在堆上，所以设置了<code>max</code>，存储空间大小有限制</li></ul><h3 id="JDK8以及之后"><code>JDK8</code>以及之后</h3><ul><li>方法区存放在<strong>元空间</strong>中，位于<strong>操作系统内存</strong>中，独立于<code>JVM</code>内存之外，默认情况下只要不超过操作系统上限，可以一直分配</li><li>在<code>Arthas</code>中可以看见<code>metaspace</code>，就是元空间，<code>max=-1</code>，表示没有上限，只要不超过操作系统的上限即可。</li></ul><div class="note info flat"><p>方法区溢出</p><ul><li><code>JDK7</code>在堆上，十几万个类会出现错误。<code>JDK8</code>运行上百万次，不会出现错误。</li><li><code>JDK7</code>方法区存储在堆区中的永久代空间，可以设置<code>-XX:MaxPermSize=值</code>来控制</li><li><code>JDK8</code>方法区位于元空间中，默认不超过操作系统上限即可，同样可以使用<code>-XX:MaxMetaspaceSize=值</code>设置元空间大小<ul><li>启动程序的时候最好设置元空间的最大大小，没有特殊情况设置成<code>256M</code>，以免占用其他程序的内存，能够容纳三十多万个类的加载</li></ul></li></ul></div><h3 id="字符串常量池">字符串常量池</h3><blockquote><p>存储代码中定义的常量字符串内容，比如<code>&quot;123&quot;</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译成字节码以后，&quot;abc&quot;会加入到静态常量池中</span></span><br><span class="line"><span class="comment">// s1通过new创建，所以&quot;abc&quot;放在堆内存中，由s1保存</span></span><br><span class="line"><span class="comment">// s2没有使用new，所以s2存放的是字符串常量池中的&quot;abc&quot;</span></span><br><span class="line"><span class="comment">// 所以最后打印s1 == s2两个地址不同，返回false</span></span><br></pre></td></tr></table></figure><div class="note info flat"><ul><li>早期的设计中，字符串常量池是运行时常量池的一部分，存储位置相同。后续将字符串常量池和运行时常量池进行拆分</li><li><code>JDK7</code>之前，运行时常量池包含字符串常量池，都在永久代中</li><li><code>JDK7</code>版本的时候，字符串常量池从方法区拿到了堆中，运行时常量池剩下的东西还在永久代中</li><li><code>JDK8</code>之后，没有永久代了，所以运行时常量池在元空间中，而字符串常量池仍然在堆中</li></ul></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;2&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;12&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> a + b;</span><br><span class="line">    System.out.println(c == d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译成字节码以后，字符串常量池中会有&quot;1&quot;, &quot;2&quot;, &quot;12&quot;</span></span><br><span class="line"><span class="comment">// c指向的是字符串常量池中的&quot;12&quot;</span></span><br><span class="line"><span class="comment">// d 中的 + 变成了使用StringBuilder方法进行连接</span></span><br><span class="line"><span class="comment">// d指向的是堆内存中的&quot;12&quot;</span></span><br><span class="line"><span class="comment">// 所以是false</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;2&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;12&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span> + <span class="string">&quot;2&quot;</span>;</span><br><span class="line">    System.out.println(c == d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此时cd都是在字符串常量池中</span></span><br><span class="line"><span class="comment">// 所以返回true</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>().append(<span class="string">&quot;think&quot;</span>).append(<span class="string">&quot;123&quot;</span>).toString();</span><br><span class="line">    System.out.println(s1.intern() == s1);</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>().append(<span class="string">&quot;ja&quot;</span>).append(<span class="string">&quot;va&quot;</span>).toString();</span><br><span class="line">    System.out.println(s2.inter() == s2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// String.intern()是手动将字符串放在字符串常量池中</span></span><br><span class="line"><span class="comment">// 比如多次输入，每次Scanner.next().intern()，如果有两次输入相同的字符串，就可以减少存储的消耗，只需要往字符串常量池中存储一份字符串即可</span></span><br><span class="line"><span class="comment">// JDK6这个版本中，intern()会把第一次遇到的字符串实例复制到永久代字符串常量池中，返回的也是永久代字符串实例的引用。JVM启动时会把java加入到常量池中</span></span><br><span class="line">    <span class="comment">// 所以JDK6中，s1.intern()方法在字符串常量池中，s1在堆上，返回false</span></span><br><span class="line">    <span class="comment">// s2.intern()在字符串常量池中，s2在堆上，所以返回false</span></span><br><span class="line"><span class="comment">// JDK7之后的版本，由于字符串常量池在堆上，所以intern()方法会把第一次遇到的字符串引用放在字符串常量池中</span></span><br><span class="line">     <span class="comment">// s1.intern()返回的就是s1在堆上的引用，也就是地址，所以返回true</span></span><br><span class="line">     <span class="comment">// s2.intern()由于java已经在字符串常量池中有了，所以s2.intern()是字符串常量池中的地址，s2是堆中的地址，因此返回false</span></span><br></pre></td></tr></table></figure><div class="note info flat"><p>静态变量存储在哪里？</p><ul><li><code>JDK6</code>以及之前，静态变量存储在方法区中，也就是永久代中</li><li><code>JDK7</code>以及之后的版本中，静态变量存储在<code>Class</code>对象中，脱离了永久代。</li></ul></div><h2 id="直接内存">直接内存</h2><blockquote><p>不属于<code>Java</code>运行时的内存区域，在<code>JDK1.4</code>中引入了<code>NIO</code>机制，使用了直接内存，比如<code>Netty</code>网络框架</p></blockquote><ul><li><p>直接内存解决两个问题</p><ol><li><code>Java</code>堆中的对象如果不再使用要回收，回收时会影响对象的创建和使用</li><li><code>IO</code>操作比如读文件，需要先把文件读入直接内存(缓冲区)，然后再把数据复制到<code>Java</code>堆中</li></ol></li><li><p>现在直接放入直接内存即可，同时<code>Java</code>堆上维护直接内存的引用，减少了数据复制的开销，写文件也是同样的思路</p></li><li><p>所以现在不需要从直接内存上复制到堆中了，减少回收对象的影响，提升读写文件的效率</p></li><li><p>可以使用<code>ByteBuffer</code>在直接内存上创建数据，在<code>Arthas</code>中的<code>memory</code>可以查看<code>direct</code>部分的相关信息</p><ul><li><code>ByteBuffer directBuffer = ByteBuffer.allocateDirect(size);</code></li></ul></li></ul><div class="note info flat"><p>直接内存存在溢出现象</p><ul><li><code>-XX:MaxDirectMemorySize=值</code>修改直接内存的大小，如果不设置这个参数，则会自动选择最大分配的大小</li><li>如果底层使用了<code>NIO</code>，则需要设置这个参数；如果没有用到直接内存，也可以不设置这个参数</li><li>具体设置的大小需要进行压力测试以后，确定最大内存</li></ul></div><h2 id="总结">总结</h2><ol><li>运行时数据区分为了哪几个部分，每个部分的作用是什么</li></ol><ul><li>程序计数器，<code>Java</code>虚拟机栈，本地方法栈。线程不共享，每个线程有一块独立的区域<ul><li>程序计数器，记录当前要执行的字节码指令的地址，不会出现内存溢出的问题</li><li>Java虚拟机栈和本地方法栈。每个方法的调用会使用一个栈帧来保存数据，会内存溢出，一般因为递归没有出口</li></ul></li><li>方法区，堆。线程共享的<ul><li>堆中存放创建的对象，最容易内存溢出，与垃圾回收有关</li><li>方法区存放类的元信息，以及常量池，会出现内存溢出</li></ul></li></ul><ol start="2"><li>不同<code>JDK</code>版本之间运行时区域的区别是什么</li></ol><ul><li><code>JDK6</code>方法区放在堆里面，称为永久代，字符串常量池放在方法区中</li><li><code>JDK7</code>字符串常量池从方法区中独立，放在了堆上</li><li><code>JDK8</code>字符串常量池依然在堆里面，但是方法区称为元空间，从堆中独立</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 运行时数据区 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记_1</title>
      <link href="/posts/13ce2c90.html"/>
      <url>/posts/13ce2c90.html</url>
      
        <content type="html"><![CDATA[<h1>类加载器</h1><ul><li>类加载器(<code>ClassLoader</code>)是<code>JVM</code>给应用程序实现类和接口字节码数据的技术</li><li>本地接口<code>JNI</code>允许<code>Java</code>调用其他语言编写的方法，在<code>hotspot</code>类加载器中，主要用于调用<code>JVM</code>中使用<code>CPP</code>编写的方法</li></ul><h2 id="应用">应用</h2><ol><li><code>SPI</code>机制</li><li>类的热部署</li><li><code>Tomcat</code>类的隔离</li><li>类的双亲委派机制(怎么打破双亲委派机制)</li><li>自定义类加载器</li><li>使用<code>Arthas</code>不停机解决线上故障</li></ol><h2 id="分类">分类</h2><ol><li><code>Java</code>代码中实现的 or <code>JDK</code>默认提供或者自定义的，所有实现的类加载器都需要继承抽象类<code>ClassLoader</code></li><li><code>JVM</code>底层源码实现的，跟虚拟机实现语言一致，比如<code>Hotspot</code>使用<code>cpp</code>实现。作用是加载运行时的基础类，保证运行中基础类可以被正确的加载，比如<code>java.lang.String</code>，确保可靠性</li></ol><h3 id="JDK8之前"><code>JDK8</code>之前</h3><ul><li><code>JVM</code>底层实现的类加载器，<strong>启动类加载器</strong><code>Bootstrap</code>，加载<code>Java</code>中<strong>最核心</strong>的类，在<code>jre/lib</code>目录下的所有类文件，比如<code>rt.jar, tools.jar, resources.jar</code></li></ul><div class="note info flat"><ul><li>如果打印看到类加载器为<code>null</code>，则就是启动类加载器。因为为了安全性考虑，不允许在代码中获得启动类加载器。</li><li>用户自己如果写了一些底层的<code>jar</code>包可以由启动类加载器加载，有两种方式<ol><li>放在<code>jre/lib</code>目录下(但是不推荐这么做)</li><li>使用<code>-Xbootclasspath/a:&lt;jar包目录&gt;/&lt;jar包名&gt;</code>进行扩展</li></ol></li></ul></div><ul><li><code>Java</code>代码中实现了<strong>扩展类加载器</strong><code>Extension</code>，允许扩展<code>Java</code>中比较通用的类；<strong>应用程序类加载器</strong><code>Application</code>，加载应用使用的类，比如由第三方<code>jar</code>包引入的类。<ul><li>源码都位于<code>sun.misc.Launcher</code>中，是一个静态内部类，继承自<code>URLClassLoader</code>，可以通过目录或指定<code>jar</code>包将字节码文件加载到内存中</li><li><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Java/extends.png" alt="extends"></li><li>扩展类加载器<code>Extension ClassLoader</code>默认加载<code>jre/lib/ext</code>下的类文件<ol><li>所以同样可以将自定义的<code>jar</code>包放在<code>jre/lib/ext</code>目录下(但是不推荐)</li><li>使用<code>-Djava.ext.dirs=&lt;jar包目录&gt;</code>进行扩展，会覆盖原始目录，<code>windows</code>上可以使用分号分隔，<code>macos</code>或者<code>linux</code>上使用冒号分隔，追加上原始目录</li></ol></li><li>应用程序类加载器<code>Application</code>加载<code>classpath</code>下的类文件，项目中的类或者是第三方依赖中的类</li></ul></li><li><code>Arthas</code>中使用<code>classloader</code>命令可以查看<ul><li><code>classloader -l</code>查看所有类加载器的哈希值</li><li><code>classloader -c &lt;hash&gt;</code>其中<code>&lt;hash&gt;</code>表示某一个类加载器的哈希值，就可以把所有加载的<code>jar</code>包都打印出来，</li><li>可以看到扩展类加载器加载的都是扩展类加载器的<code>jar</code>包，但是应用程序类加载器加载了不止<code>maven</code>第三方<code>jar</code>包，还加载了扩展类加载器，以及启动类加载器加载的<code>jar</code>包的内容，这是因为双亲委派机制</li></ul></li></ul><h1>双亲委派机制</h1><blockquote><p>解决了一个类到底由谁来加载的问题</p></blockquote><h2 id="作用">作用</h2><ol><li>保证类加载的安全性，避免恶意代码替换<code>JDK</code>的核心类库，确保核心类库的<strong>完整性</strong>和<strong>安全性</strong></li><li>避免重复加载</li></ol><h2 id="含义">含义</h2><ul><li>一个类加载器接收到加载类的任务时，会自底向上查找是否加载过，再自顶向下加载。自顶向下依次是启动类加载器，扩展类加载器，应用程序类加载器。<ul><li>先自底向上查找一个类是否被加载过<ul><li>如果已经加载过，则这个类的加载任务就结束了</li><li>如果没有加载过，则会自顶向下逐个加载</li></ul></li><li>双亲委派机制就是向上查找和向下加载的过程<ul><li>比如一个定义的类A，先由应用程序类加载器查找，没有加载过则再由扩展类加载器查找，没有加载过则再由启动类加载器进行查找，如果启动类加载器加载过了，则加载过程结束</li><li>比如一个类B，没有被三个类加载器加载，则由启动类加载器加载，查看加载路径，发现不在启动类加载器的加载路径中，则会由扩展类加载器尝试加载，判断路径</li></ul></li><li>所以向上查找的过程避免了重复加载，向下加载的过程起到了加载优先级的作用</li></ul></li></ul><div class="note info flat"><ol><li>如果一个类重复出现在三个类加载器的加载位置处，则由谁来加载？<ul><li>根据双亲委派机制，应该是由启动类加载器加载的，因为他的优先级是最高的</li></ul></li><li><code>String</code>类能否被覆盖，如果自定义了一个<code>java.lang.String</code>类，那么这个类是否会被加载<ul><li>启动类加载器在向上查找阶段已经会发现<code>rt.jar</code>包中的<code>String</code>类已经加载过了，所以不会加载自定义的<code>String</code>类，会返回已经加载过的<code>String</code>类</li></ul></li><li>如何使用代码主动加载一个类(两种方法)<ul><li>使用<code>Class.forName()</code>，使用当前类的类加载器去加载指定的类</li><li>通过<code>getClassLoader()</code>获取到类加载器，通过类加载器的<code>loadClass()</code>方法指定某个类加载器的加载，这种方式更加明确一些，比如:  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取main方法所在类的类加载器，应用程序类加载器</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> D.class.getClassLoader();</span><br><span class="line">System.out.println(cl);</span><br><span class="line"><span class="comment">// 使用应用程序类加载器加载指定的类</span></span><br><span class="line">Class&lt;?&gt; clazz = cl.loadClass(<span class="string">&quot;类名&quot;</span>);</span><br><span class="line">System.out.println(clazz.getClassLoader());</span><br></pre></td></tr></table></figure></li></ul></li></ol><ul><li>每一个类加载器都有一个父类加载器，在代码中都是<code>parent</code>，类型是<code>ClassLoader</code>，比如应用程序类加载器的<code>parent=扩展类加载器</code>，但是扩展类加载器的<code>parent=null</code>，这是因为启动类加载器是无法获得的，所以是<code>null</code><ul><li><code>Arthas</code>使用<code>classloader -t</code>查看父子关系</li></ul></li></ul><ol start="4"><li>如果一个类无法被三个类加载器加载呢？<ul><li>会报<strong>类无法找到</strong>的错误</li></ul></li></ol></div><h2 id="总结-类的双亲委派机制是什么">总结-类的双亲委派机制是什么</h2><ol><li>类加载器加载某个类的时候，会自底向上向父类查找是否加载过，如果加载过就直接返回，如果一直到最顶层的类加载器都没有加载，再由自顶向下进行加载</li><li>应用程序类加载器的父类加载器是扩展类加载器，扩展类加载器的父类加载器是启动类加载器</li><li>双亲委派机制的好处有两点:<ul><li>避免恶意代码替换<code>JDK</code>中核心类库，比如<code>java.lang.String</code>，确保安全性，完整性</li><li>避免重复加载类</li></ul></li></ol><h2 id="打破双亲委派机制">打破双亲委派机制</h2><ol><li>自定义类加载器</li><li>线程上下文类加载器</li><li><code>Osgi</code>框架的类加载器</li></ol><h3 id="场景">场景</h3><ul><li>有两个<code>Web</code>应用，都具有一个名为<code>MyServlet</code>的类，只有名字相同，内容不同。<code>Tomcat</code>想去加载这两个类，这两个类都位于<code>classpath</code>上，应用1的类可以正常加载，但是应用2的类，<code>Tomcat</code>无法加载，因为这个时候<code>MyServlet</code>类已经存在了。这样只能加载一个类</li><li>实际上<code>Tomcat</code>对每个应用都有一个类加载器，这样就不会走双亲委派机制。应用1和应用2都加载自己的类，因此实现了使用自定义类加载器打破双亲委派机制，实现应用类的隔离</li></ul><h3 id="自定义类加载器">自定义类加载器</h3><ul><li><code>ClassLoader</code>中包含了四个核心方法，双亲委派机制的核心代码在<code>loadClass</code>方法中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) </span><br><span class="line"><span class="comment">// 类加载的入口，提供了双亲委派机制，内部会调用findClass</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) </span><br><span class="line"><span class="comment">// 抽象类，加载字节码二进制信息的核心方法，由类加载器子类实现，获取二进制数据调用defineClass</span></span><br><span class="line"><span class="comment">// 比如URLClassLoader会根据文件路径获取类文件中的二进制数据</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass (String name, <span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len) </span><br><span class="line"><span class="comment">// 调用了虚拟机底层的方法，做一些类名的校验，将字节码信息加载到虚拟机内存当中</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">resolveClass</span><span class="params">(Class&lt;?&gt; c)</span> </span><br><span class="line"><span class="comment">// 执行类生命周期的连接阶段</span></span><br></pre></td></tr></table></figure><ul><li>双亲委派机制</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parent == null 说明父类加载器是启动类加载器，直接调用findBootstrapClassOrNull</span></span><br><span class="line"><span class="comment">// 否则调用父类加载器的加载方法</span></span><br><span class="line"><span class="keyword">if</span> (parent != <span class="literal">null</span>)&#123;</span><br><span class="line">    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    c = findBootstrapClassOrNull(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父类加载器不行的话，就自己加载</span></span><br><span class="line"><span class="keyword">if</span> (c == <span class="literal">null</span>) c = findClass(name);</span><br></pre></td></tr></table></figure><ul><li>自定义的类加载器，如果不手动指定父类加载器，则默认指向应用程序类加载器</li><li>两个自定义类加载器，加载相同的限定名的类，是否会冲突？<ul><li>不会冲突，只有<strong>相同的类加载器+相同的类限定名</strong>才会被认为是同一个类，在<code>Arthas</code>中使用<code>sc -d 类名</code>可以查看具体情况</li></ul></li><li>为了实现多种不同的渠道加载字节码的方式，不应该打破双亲委派机制，应该重写<code>findClass</code>方法</li></ul><h3 id="线程上下文类加载器">线程上下文类加载器</h3><blockquote><p>以<code>JDBC</code>为例，使用了<code>DriverManager</code>来管理项目中引入的不同数据库的驱动，比如<code>MySQL</code>驱动，或者<code>Oracle</code>驱动</p></blockquote><ul><li><code>DriverManager</code>类位于<code>rt.jar</code>中，所以由<strong>启动类加载器加载</strong></li><li>但是不同数据库的驱动是在用户的<code>jar</code>包中，由<strong>应用程序类加载器加载</strong>，因此违反了双亲委派机制</li><li>所以在初始化<code>DriverManager</code>时，通过<code>SPI</code>机制加载<code>jar</code>包中的<code>MySQL</code>驱动</li><li><code>SPI</code>利用了线程上下文类加载器(应用程序类加载器)加载类并创建对象<br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Java/spi.png" alt="spi"></li></ul><h2 id="DriverManager如何知道驱动类已经引入"><code>DriverManager</code>如何知道驱动类已经引入</h2><blockquote><p><code>SPI(Service Provider Interface)</code>机制，是<code>JDK</code>内置的服务提供发现机制，类似于<code>Spring</code>的依赖注入</p></blockquote><h3 id="SPI原理"><code>SPI</code>原理</h3><ol><li>在<code>ClassPath</code>路径下的<code>META-INF/services</code>目录中，以接口的全限定名来命名文件，对应的文件里面写了接口的实现</li><li>使用<code>ServiceLoader</code>类加载实现类,<code>ServiceLoader&lt;Driver&gt; lD = ServiceLoader.load(Driver.class);</code>获取<code>Driver</code>对象</li></ol><h3 id="SPI如何获取应用程序类加载器"><code>SPI</code>如何获取应用程序类加载器</h3><blockquote><p>使用了线程上下文中保存的类加载器进行类的加载，一般是应用程序类加载器</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; ServiceLoader&lt;S&gt; <span class="title function_">load</span><span class="params">(Class&lt;S&gt; service)</span>&#123;</span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();  </span><br><span class="line">    <span class="keyword">return</span> ServiceLoader.load(service, cl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li><p>在《深入理解Java虚拟机》一书中认为<code>JDBC</code>打破了双亲委派机制，因为由启动类加载器加载的类，委派应用程序类加载器去加载类的方式打破了双亲委派机制。</p></li><li><p>也有一种说法，认为<code>JDBC</code>没有打破双亲委派机制，因为单独的启动类加载器在<code>DriverManager</code>加载完了之后，通过<strong>初始化阶段</strong>触发了驱动类的加载，依然遵循的是双亲委派机制。因为驱动类加载器自底向上查找后，再自顶向下进行判断，发现启动类加载器和扩展类加载器都无法加载，所以由应用程序类加载器进行加载，这个过程也没有打破双亲委派机制。这两个类加载器都没有重写<code>loadClass</code>方法，打破双亲委派机制的唯一方法就是重写<code>loadClass</code>方法</p></li></ul></blockquote><h3 id="OSGI模块化"><code>OSGI</code>模块化</h3><blockquote><p><code>JDK9</code>之后有另一种模块化方法，因此不再使用了。<code>OSGI</code>也使用了类加载器实现了热部署的功能，即在服务不停止的情况下，动态更新字节码文件到内存中。现在可以使用<code>Arthas</code>实现热部署，本质上还是类加载器</p></blockquote><ul><li><code>Arthas</code>不停机解决线上问题</li></ul><ol><li>出问题服务器上部署一个<code>Arthas</code></li><li><code>jad --source-only &lt;类全限定名&gt; &gt; &lt;dir/文件名.java&gt;</code>： <code>jad</code>命令反编译，用其他编译器，比如<code>vim</code>来修改源代码</li><li><code>mc -c &lt;类加载器的hash&gt; &lt;dir/文件名.java&gt; -d &lt;输出目录&gt;</code>： <code>mc</code>命令用来编译修改过的代码<ul><li>这里的类加载器的<code>hash</code>可以使用<code>sc -d &lt;对应的类名&gt;</code>来查看</li></ul></li><li><code>retransform class</code>文件所在的&lt;目录/xxx.class&gt;：用<code>retransform</code>命令加载新的字节码</li></ol><div class="note info flat"><p>注意事项:</p><ol><li>如果程序重启，则字节码文件会恢复，因为只是通过<code>retransform</code>这个命令将字节码文件放在了内存中。因此要将字节码文件放在<code>jar</code>包中进行更新</li><li>使用<code>retransform</code>不能添加方法或者字段，也不能更新正在执行中的方法</li></ol></div><h1><code>JDK9</code>之后</h1><blockquote><p>引入了<code>module</code>概念</p></blockquote><ol><li>启动类加载器由<code>Java</code>编写了，不再由<code>CPP</code>编写，位于<code>jdk.internal.loader.ClassLoaders</code>类中。<ul><li><code>Java</code>中的<code>BootClassLoader</code>继承自<code>BuiltinClassLoader</code>实现从模块中找到要加载的字节码资源文件</li><li>但是启动类加载器依然无法通过<code>Java</code>代码获取，这是为了保证统一，所以返回的内容依然是<code>null</code></li><li><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Java/891.png" alt="891"></li></ul></li><li>扩展类加载器被替换成了平台类加载器(<code>Platform ClassLoader</code>)<ul><li>平台类加载器遵循模块化方式加载字节码文件，所以继承关系从<code>URLClassLoader</code>变成了<code>BuiltinClassLoader</code>，实现了从模块中加载字节码文件</li><li>平台类加载器的存在更多是为了与老版本兼容，自身没啥特殊的逻辑。如果使用了模块化的思想，平台类加载器基本上就不需要了</li><li><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Java/892.png" alt="892"></li></ul></li></ol><h1>总结</h1><ol><li>类加载器的作用<ul><li>类加载器(<code>CLassLoader</code>)负责在类加载的过程中的字节码获取并加载到内存，通过加载字节码数据放入内存转换成<code>byte[]</code>，接下来调用虚拟机底层方法将<code>byte[]</code>转换成方法区和堆中的数据</li></ul></li><li>有几种类加载器<ul><li>启动类加载器<code>Bootstrap</code> 加载核心类</li><li>扩展类加载器<code>Extension</code> 加载扩展类</li><li>应用程序类加载器<code>Application</code> 加载应用<code>classpath</code>中的类</li><li>自定义类加载器，重写<code>findClass</code>方法</li><li><code>JDK9</code>之后从扩展类加载器变成了平台类加载器<br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Java/cl.png" alt="cl"></li></ul></li><li>什么是双亲委派机制<ul><li>每个<code>Java</code>实现的类加载器中保存了一个成员变量叫做父 类加载器，自底向上查找是否加载过，再自顶向下加载，避免核心类被应用程序重写覆盖的问题，提升安全性</li></ul></li><li>如何打破双亲委派机制<ul><li>重写<code>loadClass</code>方法</li><li><code>JNDI, JDBC, JCE, JBI</code>等框架使用了<code>SPI</code> + 线程上下文类加载器</li><li><code>OSGI</code>实现了一整套类加载逻辑，允许同级类加载器之间互相调用</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 类加载器 </tag>
            
            <tag> 双亲委派机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记_0</title>
      <link href="/posts/64c91c06.html"/>
      <url>/posts/64c91c06.html</url>
      
        <content type="html"><![CDATA[<h1>面向对象的特性</h1><h2 id="封装">封装</h2><ul><li>将数据和行为组合在一个包中，并对使用者隐藏具体的实现细节</li><li>关键在于不能让别的类调用到当前类的实例字段</li></ul><h2 id="继承">继承</h2><ul><li>实现了<code>IS-A</code>的关系，子类可以获得父类<strong>非</strong><code>private</code>的属性和方法</li><li>应该要遵循里氏替换原则</li></ul><div class="note info flat"><ul><li>里氏替换原则：子类必须能够替换掉所有的父类对象，父类引用指向子类对象称为<strong>向上转型</strong></li></ul></div><h3 id="举例">举例</h3><ul><li><code>Cat</code>和<code>Animal</code>就是一种<code>IS-A</code>关系，所以<code>Cat</code>可以继承<code>Animal</code>，并且获得<code>Animal</code>的所有非<code>private</code>的属性和方法</li><li><code>Cat</code>可以当做<code>Animal</code>使用，所以<code>Animal</code>可以引用<code>Cat</code>对象：<code>Animal a = new Cat()</code>，这就是向上转型</li></ul><div class="note info flat"><p>类常见的关系</p><ul><li>依赖 <code>USES-A</code>: 只要一个类需要使用或操作另一个类，就说明前者依赖后者。需要尽可能减少相互依赖的类, (减少耦合)</li><li>聚合 <code>HAS-A</code>: 类A的对象包含类B的对象</li><li>继承 <code>IS-A</code></li></ul></div><h2 id="多态">多态</h2><ul><li>分为编译时多态和运行时多态</li></ul><div class="note info flat"><ul><li>编译时多态：指方法的<strong>重载</strong></li><li>运行时多态：指对象引用的具体类型在运行期间才能确定<ul><li>运行时多态具有三个条件：继承、覆盖(重写)、向上转型</li></ul></li><li>重载指的是多个方法具有相同的方法名，以及不同的参数(或者参数顺序)。编译器查找匹配更适合的方法的过程是重载解析</li><li>所以如果需要完整的描述一个方法，则需要他们的方法名，参数类型，称为方法的签名</li><li>返回类型不是签名的一部分，所以重载不允许存在(方法名相同，参数类型相同，返回值不同的多个函数)</li></ul></div><h1>JVM</h1><h2 id="功能">功能</h2><ol><li>解释运行：<code>javac</code>编译源代码，得到<code>class</code>字节码，<code>JVM</code>将其<strong>实时</strong>解释成机器码，让计算机执行，这是为了实现跨平台</li><li>内存管理：自动为对象方法分配内存，自动垃圾回收不再使用的对象</li><li>即时编译<code>JIT</code>：对热点代码进行优化，提升执行效率</li></ol><h2 id="组成">组成</h2><ol><li>类加载器</li><li>运行时数据区域(<code>JVM</code>管理的内存)</li><li>执行引擎(即编译器，解释器，垃圾回收等)</li><li>本地接口</li></ol><h1>字节码文件</h1><ul><li><code>jclasslib</code>可以打开字节码文件<code>.class</code></li><li><code>javap -v 路径名/类名.class &gt; 输出文件</code>命令同样可以反编译<code>.class</code>文件，并输出到指定文件中</li><li><code>jar -xvf</code>可以解压<code>jar</code>包</li><li><code>Arthas</code>可以使用<code>java -jar arthas-boot.jar</code>命令启动<ul><li><code>dashbord -i &lt;time (ms)&gt; -n &lt;num&gt;</code> 可以查看服务器各项指标，<code>-i</code>后面指定刷新的时间(<code>ms</code>)，<code>-n</code>后面指定刷新的次数</li><li><code>dump -d &lt;dir&gt; 包名.类名</code> 可以将指定类名的字节码文件导出到指定的<code>dir</code>中</li><li><code>jad 包名.类名</code> 可以将字节码反编译成源代码，然后可以确定代码是否可以满足要求。比如可以确定版本</li></ul></li></ul><h2 id="组成-2">组成</h2><ol><li><strong>基本信息</strong>：魔数，版本号，访问标识(<code>public final</code>)，父类和接口</li><li><strong>常量池</strong>：字符串常量，类或接口名、字段名，主要在字节码指令中使用</li><li><strong>字段</strong>：类或者接口声明的字段信息</li><li><strong>方法</strong>：类或者接口声明的方法信息</li><li><strong>属性</strong>：类的属性，比如源码的文件名，内部类的列表</li></ol><div class="note info flat"><ul><li>字节码文件，文件头是<code>0xCAFEBABE</code>，这个就是魔数</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>主版本号</mtext><mo>−</mo><mn>44</mn></mrow><annotation encoding="application/x-tex">主版本号 - 44</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord cjk_fallback">主版本号</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">44</span></span></span></span> 就是1.2版本之后的大版本计算方法，比如52是JDK8，主版本号为61则是JDK17</li><li>常量池作用：避免相同的内容重复定义，节省空间<ul><li>符号引用：字节码指令通过编号引用到常量池的过程</li></ul></li><li>方法：<ul><li><code>iconst_&lt;i&gt;</code> 就是将<code>i</code>放在操作数栈中</li><li><code>istore_&lt;i&gt;</code> 将操作数栈中的数字放到局部变量表的<code>i</code>号位置</li><li><code>iload_&lt;i&gt;</code> 将局部变量表中的数据<strong>复制</strong>一份放到操作数栈中</li><li><code>iadd</code> 将操作数栈顶的两个数字相加，只保留一个数据</li><li><code>iinc &lt;i&gt; by &lt;j&gt;</code> 将局部变量表中的<code>i</code>号位置的元素加<code>j</code>，直接在局部变量表上操作</li><li>局部变量数组表就是一个数组，存放所有的局部变量，并且位置<code>0</code>是<code>args</code>参数</li></ul></li></ul></div><h2 id="i-i-1-VS-i-VS-i-1-VS-i"><code>i = i + 1</code> VS <code>i ++</code> VS <code>i += 1</code> VS <code>++ i</code></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">iconst_0</span><br><span class="line">istore_1</span><br><span class="line">iconst_0</span><br><span class="line">istore_2</span><br><span class="line">iconst_0</span><br><span class="line">istore_3</span><br><span class="line">iconst_0</span><br><span class="line">istore 4</span><br><span class="line">iinc 1 by 1</span><br><span class="line">iinc 2 by 1</span><br><span class="line">iinc 3 by 1</span><br><span class="line">iload 4</span><br><span class="line">iconst_1</span><br><span class="line">iadd</span><br><span class="line">istore 4</span><br><span class="line">return</span><br></pre></td></tr></table></figure><ul><li>除了<code>i = i + 1</code>以外，都只需要一条指令<code>iinc 1 by 1</code>，即可完成自增操作</li><li><code>i = i + 1</code>需要四条指令才能完成，即<code>12~15</code></li></ul><h1>类的生命周期</h1><ol><li>加载</li><li>连接<ol><li>验证</li><li>准备</li><li>解析</li></ol></li><li>初始化</li><li>使用 (<code>new</code>)</li><li>卸载 (<code>GC</code>)</li></ol><h2 id="加载">加载</h2><ol><li><strong>类加载器</strong>根据<strong>类的全限定名</strong>通过不同的渠道以<strong>二进制流</strong>的方式获取字节码信息</li><li>类加载器加载完类以后，会将字节码信息保存到内存的<strong>方法区</strong>中</li><li>生成一个<code>InstanceKlass</code>对象，保存所有类的信息，包含特定功能比如多态的信息(虚方法表)</li><li>在<strong>堆区</strong>中生成一份与方法区数据类似的<code>java.lang.Class</code>对象，为了在Java代码中获取类的信息以及存储静态字段的数据(JDK8之后放在堆区)</li></ol><div class="note info flat"><p>为什么需要分别在<strong>方法区</strong>和<strong>堆区</strong>中同时保留两份代码？</p><ul><li>方法区中的<code>InstanceKlass</code>对象是用<code>cpp</code>编写的，<code>Java</code>不能直接操作，所以要在堆区放一个<code>Java</code>编写的<code>java.lang.Class</code></li><li>堆区的字段少于方法区的字段，因为方法区中有<strong>虚方法表</strong>，开发者不需要用，因此开辟了一块堆区，只包含了方法的内容，开发者只能访问堆区，提升安全性</li></ul></div><ul><li><code>JDK</code>自带<code>hsdb</code>工具可以查看<code>JVM</code>的内存信息，<code>hsdb</code>位于安装目录下的<code>lib/sa-jdi.jar</code>中</li><li><code>java -cp sa-jdi.jar sun.jvm.hotspot.HSDB</code>用于启动<code>hsdb</code>工具，启动后需要输入进程号，可以通过<code>jps</code>命令查找</li></ul><h2 id="连接">连接</h2><h3 id="验证">验证</h3><ol><li>验证内容是否满足<code>JVM</code>规范，比如文件头是否满足<code>CAFEBABE</code>，主次版本号是否满足要求</li><li>验证元信息，比如类必须要有父类，<code>super</code>不能为空</li><li>验证程序语义是否正确，不能跳转到不正确的位置</li><li>符号引用验证，比如是否访问了其他类中的<code>private</code>方法</li></ol><div class="note info flat"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查版本号是否满足要求</span></span><br><span class="line"><span class="comment">// 检查版本号的具体逻辑：</span></span><br><span class="line">    <span class="comment">// 主版本号不能高于运行环境主版本号;</span></span><br><span class="line">    <span class="comment">// 如果主版本号相同，那么副版本号也不能超过</span></span><br><span class="line"><span class="keyword">return</span> (major &gt;= JAVA_MIN_SUPPORTED_VERSION) </span><br><span class="line">    &amp;&amp; (major &lt;= max_version) </span><br><span class="line">    &amp;&amp; ((major != max_version) || (minor &lt;= JAVA_MAX_SUPPORTED_MINOR_VERSION));</span><br><span class="line"><span class="comment">// major 主版本号</span></span><br><span class="line"><span class="comment">// minor 副版本号</span></span><br><span class="line"><span class="comment">// JAVA_MIN_SUPPORTED_VERSION 支持的最低版本号，jdk8是45 表示jdk1.0</span></span><br><span class="line"><span class="comment">// max_version 支持的最高版本号，jdk8是52</span></span><br><span class="line"><span class="comment">// JAVA_MAX_SUPPORTED_MINOR_VERSION 支持的最高副版本号，jdk8未使用，为0</span></span><br></pre></td></tr></table></figure></div><h3 id="准备">准备</h3><ul><li>给<strong>静态变量</strong>分配内存和设置<strong>初始值</strong></li></ul><div class="note info flat"><ul><li>设置初始值是所有的变量都赋值为<code>0</code>，或者<code>null</code>，或者<code>'\u0000'</code></li><li>只有用<code>final</code>修饰的变量，会将其直接赋值为定义的值，因为<code>final</code>的值不会修改了</li></ul></div><h3 id="解析">解析</h3><ul><li>将符号引用替换为直接引用，<strong>就是使用地址替换编号</strong></li></ul><h2 id="初始化">初始化</h2><ul><li><code>public static int v = 1;</code>这句代码在<strong>连接准备</strong>阶段会将<code>v = 0</code>，然后在<strong>初始化</strong>阶段会<code>v = 1</code></li><li>初始化阶段就是执行<strong>静态代码块</strong>中的代码，为<strong>静态变量</strong>赋值，执行字节码文件中<code>clinit</code>部分的字节码指令</li><li><code>putstatic</code> 从操作数栈中获取值，设置<strong>静态变量</strong></li><li><code>clinit</code>方法执行顺序跟<code>Java</code>中的编写顺序一样</li><li>使用<code>-XX:+TraceClassLoading</code>参数可以打印出加载并初始化的类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">D</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        v = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这段代码最终的v=1，因为v是static变量，所以在连接准备阶段v=0</span></span><br><span class="line"><span class="comment">// 经过初始化阶段，v首先经过静态代码块，v=2</span></span><br><span class="line"><span class="comment">// 然后v经过静态设置，v=1</span></span><br></pre></td></tr></table></figure><div class="note info flat"><p><strong>触发</strong>初始化：</p><ol><li>访问一个类的<strong>静态变量</strong>或者<strong>静态方法</strong>，如果变量是<code>final</code>修饰的并且等号右边是<strong>常量</strong>，则不会触发初始化(在准备阶段就已经完成赋值了)</li><li>调用<code>Class.forName(String className)</code>，如果只传入类名，那么会<strong>默认</strong>进行初始化，也可以传入参数指定不初始化</li><li><code>new</code>一个类的对象</li><li>执行<code>main</code>方法的<strong>当前类</strong></li></ol></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Test1</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Test1</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;D&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出DACBCB </span></span><br><span class="line"><span class="comment">// main方法执行之前，首先会执行static静态代码块，因此输出D</span></span><br><span class="line"><span class="comment">// 然后执行main函数，输出A</span></span><br><span class="line"><span class="comment">// 接下来调用构造方法，但是字节码中构造代码块比构造函数先执行，所以输出CB</span></span><br><span class="line"><span class="comment">// 调用了两次构造方法，因此输出CBCB</span></span><br></pre></td></tr></table></figure><div class="note info flat"><p><strong>不触发</strong>初始化：</p><ol><li><strong>没有</strong>静态代码块，并且<strong>没有</strong>静态变量赋值语句</li><li><strong>有</strong>静态变量声明，但是<strong>没有</strong>赋值语句</li><li>静态变量使用<code>final</code>关键字，等号右边是常量，会在<strong>准备阶段</strong>直接进行赋值，则不会有初始化</li></ol></div><ul><li>直接访问父类的静态变量，<strong>不会</strong>触发子类的初始化</li><li>子类的初始化<code>clinit</code>调用之前，会先调用父类的<code>clinit</code>初始化方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">B</span>(); <span class="comment">// 如果有这个new B()，则会初始化B，就会优先初始化父类，</span></span><br><span class="line">        <span class="comment">// 如果没有new B()，则直接调访问父类的静态变量。</span></span><br><span class="line">        System.out.println(B.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        a = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果有new B(), 输出2</span></span><br><span class="line"><span class="comment">// 如果没有new B(), 输出0</span></span><br></pre></td></tr></table></figure><div class="note info flat"><ul><li>访问父类的静态变量不需要初始化子类，初始化子类之前一定会初始化父类</li></ul></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        A[] arr = <span class="keyword">new</span> <span class="title class_">A</span>[<span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AAA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出空</span></span><br><span class="line"><span class="comment">// 数组的创建不会导致数组元素中的类初始化</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(A.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Integer.valueOf(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AAA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AAA 1</span></span><br><span class="line"><span class="comment">// final修饰的变量，如果等号右边需要执行指令才能得出结果，则会执行clinit初始化</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面向对象的特性 </tag>
            
            <tag> JVM </tag>
            
            <tag> 类的生命周期 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes笔记_0</title>
      <link href="/posts/64a0ba43.html"/>
      <url>/posts/64a0ba43.html</url>
      
        <content type="html"><![CDATA[<h1>架构</h1><p>一个<code>Kubernetes</code>集群至少包含一个控制平面，以及一个或多个工作节点</p><h2 id="控制平面">控制平面</h2><p><img src="https://gitee.com/sang3112/blog_imgs/raw/a76c53b22b402ccf7186b9efa53546500f90932e/Kubernetes/controlplane.png" alt="controlplane"></p><ul><li>负责管理工作节点和维护集群状态，所有任务的分配都来自控制平面</li><li>为集群做出去全局决策，比如资源的调度、检测和响应集群事件</li></ul><h3 id="kube-apiserver"><code>kube-apiserver</code></h3><ul><li>如果与<code>Kubernetes</code>集群进行交互，需要通过API</li><li><code>apiserver</code>是<code>Kubernetes</code>控制平面的前端，用于处理内部和外部请求</li></ul><h3 id="kube-scheduler"><code>kube-scheduler</code></h3><ul><li>集群状态是否良好，如果需要创建新的容器，需要将他们放在哪里，由调度程序关注</li><li><code>scheduler</code>调度程序考虑容器集的资源需求，比如<code>CPU</code>或者内存，以及集群的运行状态，然后将容器集安排到适当的计算节点</li></ul><h3 id="kube-controller-manager"><code>kube-controller-manager</code></h3><ul><li>控制器负责实际运行集群，<code>controller-manager</code>控制器管理器将多个控制器功能合并，降低了程序的复杂性</li></ul><div class="note info flat"><p><code>controller-manager</code>包含以下控制器:</p><ol><li>节点控制器(<code>Node Controller</code>): 负责在节点出现故障时进行通知和响应</li><li>任务控制器(<code>Job Controller</code>): 检测代表一次性任务的<code>Job</code>对象，然后创建<code>Pods</code>来运行这些任务直到完成</li><li>端点控制器(<code>Endpoints Controller</code>): 填充端点<code>Endpoints</code>对象，即加入<code>Service</code>和<code>Pod</code></li><li>服务账户和令牌控制器(<code>Service Account &amp; Token Controllers</code>): 为新的命名空间创建默认账户和<code>API</code>访问令牌</li></ol></div><h3 id="etcd"><code>etcd</code></h3><ul><li>键值对数据库，存储配置数据和集群状态信息</li></ul><h3 id="可选组件cloud-controller-manager">可选组件<code>cloud-controller-manager</code></h3><ul><li>云控制管理器，允许将集群了解到云提供商的<code>API</code>之上，将该云平台交互的组件与自己的集群交互组件分离开。如果在自己的环境中运行<code>Kubernetes</code>或者在本地计算机中运行学习环境，则所部署的集群不需要有云控制管理器</li></ul><h3 id="各组件之间的关系">各组件之间的关系</h3><p><img src="https://gitee.com/sang3112/blog_imgs/raw/a76c53b22b402ccf7186b9efa53546500f90932e/Kubernetes/relationship.png" alt="relationship"></p><h2 id="工作节点">工作节点</h2><ul><li>负责执行由控制平面分配的请求任务，运行实际的应用和工作负载</li></ul><h3 id="Node组件"><code>Node</code>组件</h3><p><img src="https://gitee.com/sang3112/blog_imgs/raw/a76c53b22b402ccf7186b9efa53546500f90932e/Kubernetes/node.png" alt="node"></p><ul><li>节点组件会在每个工作节点上运行，负责维护运行的<code>Pod</code>并提供<code>Kubernetes</code>运行环境</li></ul><h1><code>Pod</code></h1><ul><li><code>Pod</code>是包含一个或者多个容器的容器组，是<code>Kubernetes</code>中创建和管理的最小对象</li></ul><h2 id="特点">特点</h2><ol><li>是<code>Kubernetes</code>的最小调度单位(原子单元)，<code>Kubernetes</code>直接管理<code>Pod</code>而不是容器</li><li>同一个<code>Pod</code>中的容器总是会被自动安排到集群中的同一个节点(物理机或者虚拟机上)，并且<strong>一起调度</strong></li><li><code>Pod</code>可以理解为运行特定应用的<strong>逻辑主机</strong>，容器共享存储、网络和配置声明(比如资源限制)</li><li>每个<code>Pod</code>有唯一的<code>IP</code>地址，<code>IP</code>地址分配给<code>Pod</code>，在同一个<code>Pod</code>内，所有容器共享一个<code>IP</code>地址和端口空间，<code>Pod</code>内的容器可以使用<code>localhost</code>相互通信</li></ol><h2 id="创建和管理">创建和管理</h2><ol><li>创建<code>Pod</code>: <code>kubectl run &lt;Pod名称&gt; --imgae=&lt;容器镜像&gt;</code><ul><li>执行一次性任务，退出<code>Pod</code>时自动删除容器: <code>kubectl run &lt;Pod名称&gt; --image=&lt;容器镜像&gt; -it --rm</code></li></ul></li><li>查看容器状态: <code>kubectl get pod</code><ul><li>显示详细<code>Pod</code>信息: <code>kubectl get pod -owide</code></li></ul></li><li>查看<code>Pod</code>运行日志: <code>kubectl logs -f &lt;Pod名称&gt;</code></li><li>查看<code>Pod</code>的一些信息: <code>kubesctl describe pod &lt;Pod名称&gt;</code><ul><li>创建分为四个步骤<ol><li>分配节点 <code>Successfully assigned default/Pod名称 to k8s-worker2</code></li><li>拉取镜像 <code>Container image &quot;容器镜像&quot; already present on machine</code></li><li>创建容器 <code>Created container Pod名称</code></li><li>启动容器 <code>Started container Pod名称</code></li></ol></li></ul></li><li>进入<code>Pod</code>容器: <code>kubectl exec -it Pod名称 -- /bin/bash</code></li><li>删除容器: <code>kubectl delete pod Pod名称</code></li></ol><h1><code>Deployment</code>部署和<code>ReplicaSet</code>副本集</h1><ul><li><code>Deployment</code>是对<code>ReplicaSet</code>和<code>Pod</code>的更高级别的抽象，使<code>Pod</code>拥有多副本，自愈，扩缩容，滚动升级等能力</li><li><code>ReplicaSet</code>副本集是一个<code>Pod</code>的集合，设置运行<code>Pod</code>的数量，确保任何时间都有指定数量的<code>Pod</code>副本在运行。</li></ul><div class="note info flat"><ul><li>通常，我们不直接使用<code>ReplicaSet</code>，而是在<code>Deployment</code>中声明</li></ul></div><ul><li>创建<code>Deployment</code>: <code>kubectl create deployment &lt;部署名称&gt; --imgae=&lt;镜像名称&gt; --replicas=&lt;副本数量&gt;</code><ul><li><code>Deployment</code>通过副本集控制<code>Pod</code>的数量</li><li>如果手动删除一个<code>Pod</code>，副本集会自动生成一个新的<code>Pod</code>，维持副本数量不变。这就是自愈</li></ul></li><li>查看<code>Deployment</code>状态: <code>kubectl get deploy</code></li></ul><h2 id="缩放">缩放</h2><ul><li>查看副本集: <code>kubectl get replicaSet</code><ul><li>查看副本集缩放过程: <code>kubectl get replicaSet --watch</code></li></ul></li></ul><h3 id="手动缩放">手动缩放</h3><ul><li>手动修改<code>Deployment</code>中的副本集数量: <code>kubectl scale deploy &lt;部署名称&gt; --replicas=&lt;新的副本数量&gt;</code></li></ul><h3 id="自动缩放">自动缩放</h3><ul><li><code>kubectl autoscale deployment/&lt;部署名称&gt; --min=&lt;最小副本数&gt; --max=&lt;最大副本数&gt; --cpu-percent=75</code><ul><li><code>--cpu-percent=75</code>是使得自动缩放保持所有的<code>Pod</code>的平均cpu占用维持在75%以下</li></ul></li><li>查看自动缩放: <code>kubectl get hpa</code></li><li>删除自动缩放: <code>kubectl delete hpa &lt;部署名称&gt;</code></li></ul><h2 id="滚动更新">滚动更新</h2><ul><li>滚动更新部署版本: <code>kubectl set image deploy/部署名称 容器名=镜像版本</code></li><li>如果一个<code>Deployment</code>中有三个<code>Pod</code>，运行滚动更新命令时，会创建一个新的副本集。<ul><li>当新的副本集有一个<code>Pod</code>就绪了，就会下线旧副本集中的一个<code>Pod</code>，直到旧副本集中所有的<code>Pod</code>均下线</li></ul></li><li>版本回滚:<ul><li>查看历史版本: <code>kubectl rollout history deploy/部署名称</code></li><li>查看历史版本详情: <code>kubectl rollout history deploy/部署名称 --revision=版本号</code></li><li>回滚到指定的版本: <code>kubectl rollout  undo deploy/部署名称 --to-revision=版本号</code></li></ul></li></ul><h1>Service</h1><ul><li>将一组<code>Pods</code>上的应用程序公开为网路服务的抽象方法</li><li>将一组<code>Pod</code>提供相同的<code>DNS</code>名，并进行负载均衡</li><li><code>Kubernetes</code>为<code>Pod</code>提供分配了<code>IP</code>地址，但是<code>IP</code>地址可能发生变化，集群内的容器可以通过<code>service</code>名称访问服务，不需要担心<code>Pod</code>的<code>IP</code>发生变化</li></ul><div class="note info flat"><p><code>Service</code>定义的抽象:</p><ul><li>逻辑上一组可以互相替换的<code>Pod</code>，通常称为微服务</li><li><code>Service</code>对应的<code>Pod</code>集合通过选择符关联</li><li>在一个<code>Service</code>上运行了三个<code>Nginx</code>副本，副本之间可以相互替换，我们不需要关心它调用了哪一个<code>Nginx</code>，也不需要关注<code>Pod</code>的运行装填，只需要调用这个服务就可以了</li></ul></div><ul><li>将部署公开为服务: <code>kubectl expose deploy/部署名称 --name=服务名称 --port=服务端口 --target-port=对应pod端口</code></li></ul><h2 id="ServiceType"><code>ServiceType</code></h2><h3 id="ClusterIP-默认"><code>ClusterIP</code>(默认)</h3><ul><li>将服务公开在集群内部，<code>Kubernetes</code>会给服务分配一个集群内部的<code>IP</code>，集群内的所有主机都可以通过这个<code>Cluster-IP</code>访问服务。集群内部的<code>Pod</code>可以通过<code>Service</code>名称访问服务。</li></ul><h3 id="NodePort"><code>NodePort</code></h3><ul><li>通过每个节点的主机和静态端口(<code>NodePort</code>)暴露服务，集群外部的主机可以使用节点<code>IP</code>和<code>NodePort</code>访问服务</li></ul><h3 id="ExternalName"><code>ExternalName</code></h3><ul><li>将集群外部的网络引入集群内部</li></ul><h3 id="LoadBalancer"><code>LoadBalancer</code></h3><ul><li>使用云提供商的负载均衡器向外部暴露服务</li></ul><div class="note info flat"><p>使用<code>--type=NodePort</code>即可，本地集群不需要使用<code>LoadBalancer</code></p></div><p><img src="https://gitee.com/sang3112/blog_imgs/raw/a76c53b22b402ccf7186b9efa53546500f90932e/Kubernetes/port.png" alt="port"></p><h1>命名空间</h1><ul><li>一种资源隔离机制，将同一个集群中的资源划分为互相隔离的组。命名空间可以在多个用户之间划分集群资源(通过资源配额)</li><li>比如可以设置开发、测试、生产多个命名空间</li><li>同一个命名空间内资源名称唯一，跨命名空间时没有这个要求</li><li>命名空间作用域仅仅针对带有名字空间的对象，比如<code>Deployment、Service</code>等</li><li>作用域对集群访问对象不适用，比如<code>StorageClass、Node、PersistentVolume</code>等</li><li>查看命名空间: <code>kubectl get namespace</code><ul><li><code>Kubernetes</code>默认创建四个命名空间:</li><li><code>default</code>: 默认命名空间，不可删除，没有指定命名空间的对象都会分配到这里</li><li><code>kube-system</code>: 系统对象(控制平面和<code>Node</code>组件)使用的命名空间</li><li><code>kube-public</code>: 自动创建的公共命名空间，所有用户(包括没有身份验证的用户)都可以读取，将集群中公用的可见和可读的资源放在这个空间中</li><li><code>kube-node-lease</code>: 租约(<code>Lease</code>)对象使用的命名空间。每个节点都有一个关联的<code>Lease</code>对象，<code>Lease</code>是一种轻量级的资源，通过发送心跳，检测集群中的每个节点是否发生故障<ul><li>查看<code>lease</code>对象: <code>kubectl get lease -A</code></li></ul></li></ul></li><li>查看指定命名空间的<code>Pod</code>: <code>kubectl get pod -n=命名空间名称</code></li><li>创建命名空间: <code>kubectl create ns 命名空间名称</code></li><li>运行容器指定命名空间: <code>kubectl run pod名称 --image=镜像名称 -n=命名空间名称</code></li><li>修改默认命名空间的名称(<code>default</code>): <code>kubectl config set-context $(kubectl config current-context) --namespace=新的名称</code></li><li>删除命名空间: <code>kubectl delete ns 命名空间名称</code><ul><li>删除命名空间会删除其中所有内容，如果有些对象无法被删除(对象处于错误状态，或者对象资源被占用)，则命名空间也无法被删除。需要手动删除对象以后才能删除命名空间</li></ul></li></ul><h1>管理对象</h1><h2 id="命令行指令">命令行指令</h2><ul><li>使用<code>kubectl</code>创建和管理<code>Kubernetes</code>对象。简单高效，但是功能有限，不适合复杂场景，不容易追溯操作，用于开发和调试。</li></ul><h2 id="声明式配置">声明式配置</h2><ul><li><code>Kubernetes</code>使用<code>yaml</code>文件描述<code>Kubernetes</code>对象，学习难度大并且配置麻烦，但是操作留痕，适合操作复杂的对象，多用于生产。</li><li>使用命令行指令，无法指定<code>NodePort</code>端口，是随机生成的。但是<code>yaml</code>文件中可以指定<code>NodePort</code></li></ul><h2 id="常用命令缩写">常用命令缩写</h2><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">缩写</th><th style="text-align:center">Kind</th></tr></thead><tbody><tr><td style="text-align:center">namespace</td><td style="text-align:center">ns</td><td style="text-align:center">Namespace</td></tr><tr><td style="text-align:center">nodes</td><td style="text-align:center">no</td><td style="text-align:center">Node</td></tr><tr><td style="text-align:center">pods</td><td style="text-align:center">po</td><td style="text-align:center">Pod</td></tr><tr><td style="text-align:center">services</td><td style="text-align:center">svc</td><td style="text-align:center">Service</td></tr><tr><td style="text-align:center">deployment</td><td style="text-align:center">deploy</td><td style="text-align:center">Deployment</td></tr><tr><td style="text-align:center">replicasets</td><td style="text-align:center">rs</td><td style="text-align:center">ReplicaSet</td></tr><tr><td style="text-align:center">statefulsets</td><td style="text-align:center">sts</td><td style="text-align:center">StatefulSet</td></tr></tbody></table><h2 id="使用yaml文件配置KUbernetes对象">使用<code>yaml</code>文件配置<code>KUbernetes</code>对象</h2><ul><li><code>apiVersion</code>: <code>Kubernetes API</code>版本</li><li><code>kind</code>: 对象类别，比如<code>Pod、Deployment、Service、ReplicaSet</code>等</li><li><code>metadata</code>: 描述对象的元数据，包括一个<code>name</code>字符串，<code>UID</code>(系统自动生成)和可选的<code>namespace</code></li><li><code>spec</code>: 对象的配置</li></ul><div class="note info flat"><p><code>yaml</code>内容在官网都可以找到</p></div><ul><li>使<code>yaml</code>文件生效: <code>kubectl apply -f xxx.yaml</code></li><li>删除<code>yaml</code>文件: <code>kubectl delete -f xxx.yaml</code></li></ul><h2 id="标签">标签</h2><ul><li>附加在对象<code>Pod</code>上的键值对，用于补充对象的描述信息。标签使用户可以以松散的方式管理对象映射，不需要客户端存储这些映射。</li><li>格式<ul><li>键:<ul><li>前缀(可选) / 名称(必须)</li></ul></li><li>有效的名称和值:<ul><li>字符数量小于等于63</li><li>如果不为空，以字母和数字字符开头结尾</li><li>包含破折号-，下划线_，点和字母或者数字</li></ul></li></ul></li><li>查看所有<code>Pod</code>的标签: <code>kubectl get pod --show-labels</code><ul><li>查看指定<code>Pod</code>的标签: <code>kubectl get pod -l &quot;指定的Pod描述&quot;</code></li></ul></li></ul><h2 id="选择器">选择器</h2><ul><li>标签通常配合选择器使用，标签选择器可以识别一组对象，标签不支持唯一性</li><li>标签选择器最常见的用法是为<code>Service</code>选择一组<code>Pod</code>作为后端</li><li>标签选择运算，基于等值的和基于集合的<ul><li>多个条件使用逗号分割，相当于<code>AND</code></li><li>基于等值的直接使用键值对即可</li><li>基于集合的可以使用<code>IN, NOT IN</code></li></ul></li></ul><h1>容器运行时接口(<code>CRI</code>)</h1><ul><li><code>Kubelet</code>运行在每个节点上，用于管理和维护<code>Pod</code>和容器的状态</li><li>容器运行时接口是<code>Kubelet</code>和容器运行时之间通信的主要协议，将<code>Kubelet</code>于容器运行时解耦，实现了<code>CRI</code>接口的容器引擎，都可以所谓<code>Kubernetes</code>的容器运行时。</li><li><code>Docker</code>没有实现<code>CRI</code>接口，<code>Kubernetes</code>使用<code>dockershim</code>来兼容<code>docker</code></li><li><code>crictl</code>是一个兼容<code>CRI</code>的容器运行时命令，跟<code>docker</code>命令一个样，可以用来检查和调试底层的运行时容器<ul><li>比<code>docker</code>命令稍微少一些，比如无法实现导入导出</li><li>因此导入导出使用<code>ctr</code>命令，也只用来导入导出，因为<code>ctr</code>也不是很好用<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker pull alpine:3.15 </span><br><span class="line">docker save apline:3.15 &gt; alpine-3.15.tar # 保存成tar</span><br><span class="line">ctr -n k8s.io images import alpine-3.15.tar --platform linux/amd64 # 导入镜像</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">kubernetes 中所有的镜像都在k8s.io这个命名空间中</span></span><br><span class="line">ctr -n k8s.io images export alpine.tar docker.io/library/alpine:3.15 --platform linux/amd64 # 导出镜像</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1>金丝雀发布(<code>canary deployment</code>)</h1><ul><li>生产环境中小范围部署新的应用代码，一旦应用签署发布，只有少数用户被路由到他，最大限度降低影响。如果没有错误发生，则将新版本逐渐推广到整个基础设施</li><li>默认的金丝雀发布有一定的局限<ul><li>不能根据用户的注册时间、地区等请求中的内容属性进行流量分配</li><li>同一个用户如果多次调用该<code>Service</code>，可能第一次请求到了旧版本的<code>Pod</code>，第二次请求到了新版本的<code>Pod</code></li><li>因为<code>Kubernetes Service</code>只在<code>TCP</code>层面解决负载均衡问题，不对请求响应的消息内容做任何解析和识别，如果更完善的实现金丝雀日发布，可以考虑<code>Istio</code>灰度发布</li></ul></li></ul><h1>搭建<code>MySQL</code></h1><h2 id="创建mysql-pod-yaml">创建<code>mysql-pod.yaml</code></h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mysql-pod</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">mysql</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:5.7</span></span><br><span class="line">    <span class="attr">env:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_ROOT_PASSWORD</span></span><br><span class="line">        <span class="attr">value:</span> <span class="string">&quot;123456&quot;</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/var/lib/mysql</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">data-volume</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">data-volume</span></span><br><span class="line">      <span class="attr">hostPath:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/home/mysql/data</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">Directory</span></span><br></pre></td></tr></table></figure><h2 id="挂载数据卷">挂载数据卷</h2><ul><li><code>hostPath</code>卷: 将主机节点上的文件或目录挂在到<code>Pod</code>中</li></ul><table><thead><tr><th style="text-align:center">type</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">DirectoryOrCreate</td><td style="text-align:center">目录不存在则自动创建</td></tr><tr><td style="text-align:center">Directory</td><td style="text-align:center">挂载已经存在的目录，不存在会报错</td></tr><tr><td style="text-align:center">FileOrCreate</td><td style="text-align:center">文件不存在则自动创建，不会自动创建文件的父目录，必须确保文件路径存在</td></tr><tr><td style="text-align:center">File</td><td style="text-align:center">挂载已经存在的文件，不存在会报错</td></tr><tr><td style="text-align:center">Socket</td><td style="text-align:center">挂在UNIX套接字，比如挂载/var/run/docker.sock 进程</td></tr></tbody></table><h2 id="ConfigMap"><code>ConfigMap</code></h2><ul><li><code>Docker</code>中可以使用绑定挂载的方式将配置文件挂载到容器里，但是在<code>Kubernetes</code>集群中，容器可能被调度到任意的节点中，配置文件需要能在集群的任意节点上访问、分发和更新</li><li><code>ConfigMap</code>用来在etcd中保存非加密的数据，一般用来保存配置文件<ul><li>可以用作环境变量，命令行参数或者存储卷</li><li>将配置信息与容器镜像解耦，便于配置的修改</li><li>在设计上不是用来保存大量数据的</li><li>保存的数据不能超过1MB</li><li>超出这个限制，需要考虑存储卷或者访问文件存储服务</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka笔记_1</title>
      <link href="/posts/afe3e258.html"/>
      <url>/posts/afe3e258.html</url>
      
        <content type="html"><![CDATA[<h1>消费</h1><ul><li><code>watermark</code>水位线以下的数据是消费者可以消费的数据</li></ul><h2 id="消费者组中的消费者和分区之间的分配关系">消费者组中的消费者和分区之间的分配关系</h2><ol><li>同一个消费者组中的消费者都订阅同一个主题，所以消费者组中的多个消费者可以共同消费同一个主题中的所有数据</li><li>为了避免数据被重复消费，所以主题一个分区的数据只能被组中的一个消费者消费，所以两个消费者不能同时消费一个分区的数据。但是一个消费者可以同时消费多个分区的数据。</li></ol><h2 id="消费者分区分配策略-4种">消费者分区分配策略(4种)</h2><div class="note info flat"><ul><li>具体的分配策略实际上是由消费者组中的<code>Leader</code>决定的，<code>Leader</code>就是群主，是第一个加入消费者组的消费者</li><li>消费者加入群组时，发送一个<code>JoinGroup</code>，群主负责给每一个消费者分配一个分区</li></ul></div><h3 id="轮询分配策略-RoundRobinAssignor">轮询分配策略(<code>RoundRobinAssignor</code>)</h3><ul><li>每个消费者组中的消费者都含有一个自动生成的<code>UUID</code>作为<code>memberid</code></li><li>轮询策略会将每个消费者按照<code>memberid</code>进行排序，所有<code>member</code>消费的主题分区根据主题名称进行排序</li><li>将主题分区轮询分配给对应的订阅用户，未订阅当前轮询主题的消费者会跳过<br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Kafka/RRA1.png" alt="RRA1"><br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Kafka/RRA2.png" alt="RRA2"><br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Kafka/RRA3.png" alt="RRA3"><br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Kafka/RRA4.png" alt="RRA4"></li></ul><h3 id="范围分配策略-RangeAssignor">范围分配策略(<code>RangeAssignor</code>)</h3><ul><li>每个<code>Topic</code>的<code>partition</code>数计算出每个消费者应该分配的分区数量，分配原则就是一个主题的分区尽可能平分，如果不能平均分配，则按照顺序向前补齐。</li></ul><div class="note default flat"><ul><li>假设目前有五个分区分给两个消费者，<code>5 / 2 = 2, 5 % 2 = 1</code>。则剩下一个分区补在第一个消费者中，则分配结果为<code>[123][45]</code></li><li>假设目前有五个分区分配给三个消费者，<code>5 / 3 = 1, 5 % 3 = 2</code>，最后分配结果是<code>[12][34][5]</code></li><li>范围分配策略针对单个<code>Topic</code>的情况下比较均衡，如果多个<code>Topic</code>，则<code>member</code>靠前的排序可能比靠后的排序负载多很多，也不够理想</li></ul></div><p><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Kafka/RA1.png" alt="RA1"></p><h3 id="粘性分区-StickyAssignor">粘性分区(<code>StickyAssignor</code>)</h3><ul><li>第一次分配后，每个组成员都保留分配给自己的分区信息。如果消费者加入或者退出，则进行分区再分配时(一般是消费者退出45s以后，才会进行再分配，因为又要考虑可能恢复的情况)，尽可能保证消费者原有分区不变，重新对加入或者退出消费者的分区进行分配。<br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Kafka/SA1.png" alt="SA1"><br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Kafka/SA2.png" alt="SA2"></li></ul><h3 id="优化的粘性分配策略-CooperativeStickyAssignor">优化的粘性分配策略(<code>CooperativeStickyAssignor</code>)</h3><ul><li>前三种分配策略在进行重分配的时候使用的是<code>EAGER</code>协议，让当前的所有消费者放弃当前分区，关闭连接，资源清理，重新加入组和等待分配策略，效率较低</li><li>从2.4版本开始，粘性分配策略的基础上，优化了重分配的过程，使用的是<code>COOPERATIVE</code>协议。粘性分区分配策略分配的会更加均匀和高效一些</li><li><code>COOPERATIVE</code>协议将一次全局重平衡，改成每个小规模的重平衡，直到最终收敛平衡的过程</li></ul><div class="note info flat"><ul><li><code>Kafka</code>消费者默认的分区分配就是<code>RangeAssignor</code>(第一次分区分配)，<code>CooperativeStickyAssinor</code>(后续的分区分配)</li></ul></div><h1>集群的脑裂问题</h1><ul><li>首先<code>ZooKeeper</code>具有三个<code>Broker</code>，其中有一个<code>Controller</code>，由<code>Broker1</code>创建的</li><li>但是此时网络不稳定，<code>Broker1</code>掉线了。<code>ZooKeeper</code>中的<code>Controller</code>临时节点被删除了，同时选举了<code>Broker3</code>作为新的<code>Controller</code>，创建了新的临时节点</li><li>此时<code>Broker1</code>恢复了链接，由于是<code>Broker3</code>创建了<code>Controller</code>。所以<code>Broker3</code>才是真正的管理者</li><li>但是<code>Broker1</code>此时仍然认为自己是管理者，两个<code>Broker</code>都会向<code>Broker2</code>同步消息，<code>Broker2</code>不知道应该同步谁的消息，这就是脑裂问题</li></ul><h2 id="解决">解决</h2><ul><li><code>ZooKeeper</code>引入了<code>epoch</code>纪元，有一个<code>controller_epoch</code>(不是临时节点)，记录的是当前的<code>controller</code>是出现的第几个<code>controller</code>。这样<code>Broker2</code>就可以判断出最新的管理者是谁，从而完成同步消息</li></ul><h1>总结</h1><h2 id="Kafka组件">Kafka组件</h2><ul><li>通信用组件 <code>SocketServer</code>，<code>NetworkClient</code>，生产者中的缓冲区, <code>ZooKeeper</code>等等</li></ul><h2 id="LSO、LEO、HW含义"><code>LSO、LEO、HW</code>含义</h2><ol><li><code>LSO (Log Start Offset, Log Stable Offset)</code><ul><li>第一个是数据文件的起始偏移量</li><li>第二个表示的位移值是用来判断事务型消费者的可见性，就是事务的隔离级别<ul><li>一个是<code>read_committed</code>, 另一个是<code>read_uncommitted</code>，如果没有使用事务，则这个偏移量没有意义</li></ul></li></ul></li><li><code>LEO (Log End Offset)</code> 下一个要写入的数据偏移量，<strong>是不存在的</strong>。水位线靠这个推动增长</li><li><code>HW</code> 高水位线的意思，是<code>Kafka</code>为了数据一致性增加的一种数据隔离方式，消费者只能消费到小于高水位线的数据</li></ol><h2 id="Controller选举如何实现"><code>Controller</code>选举如何实现</h2><ul><li><code>Kafka</code>在4.0版本以后，将会完全抛弃<code>ZooKeeper</code>，现在<code>Controller</code>选举还是依赖<code>ZooKeeper</code>实现的，所有的<code>Broker</code>都会监听<code>ZooKeeper</code>中的一个<code>Controller</code>临时节点。如果没有创建，则<code>Broker</code>会申请创建，创建成功，则该<code>Broker</code>就是集群的<code>Controller</code>。一旦失去和<code>ZooKeeper</code>的通信，临时节点就会消失，就会重新进行选举，并且<code>Controller纪元</code>就会更新</li></ul><h2 id="AR-ISR-OSR的含义"><code>AR ISR OSR</code>的含义</h2><ol><li><code>AR</code> 是分区的所有副本集合</li><li><code>ISR</code> 是正在同步数据的副本列表，列表的第一个就是分区的<code>Leader</code>副本，其他就是<code>Follower</code>副本</li><li><code>OSR</code> 就是没有处于同步数据的副本列表，一旦副本拉去数据满足了特定的条件。则<code>OSR</code>会移除并增加到<code>ISR</code>中。同样如果副本没有拉取数据满足特定的条件，就会从<code>ISR</code>中移除，放到<code>OSR</code>中。这些就是<code>ISR</code>列表的收缩和扩张，权衡数据的可靠性和性能之间的关系</li></ol><h2 id="Producer消息重复或者消息丢失的原因"><code>Producer</code>消息重复或者消息丢失的原因</h2><ul><li>主要就是<code>Kafka</code>为了提高数据可靠性提供的重试机制，数据一旦发送失败了，数据就丢失了</li><li>数据重复，恰恰是因为开启重试机制以后，如果网络阻塞或者不稳定，导致数据需要重新发送，数据就有可能会重复</li><li>幂等性操作要求必须开启<strong>重试功能和</strong><code>ACKS = -1</code>，这样可以确保数据不会丢失<ul><li><code>Kafka</code>提供幂等性操作只能保证同一个生产者会话中同一个分区中的数据不会重复，一旦数据发送过程中，生产者对象重启，幂等性操作失效，此时需要使用事务功能解决跨会话的幂等性操作，但是跨分区的幂等性操作是无法实现的。</li></ul></li></ul><h2 id="Consumer消息重复或消息丢失的原因"><code>Consumer</code>消息重复或消息丢失的原因</h2><ul><li>是消费者提交偏移量的问题，消费者为了防止意外情况下，重启后不知道从哪里开始消费，会每5s自动保存偏移量，但是这种自动保存偏移量的操作是基于时间的，一旦未到达时间，消费者重启了，那么消费者可能重复消费数据</li><li><code>Kafka</code>提供自动保存偏移量的功能的同时，也提供了手动保存偏移量的两种方式，一个同步提交，另一个是异步提交。本质上都是提交一批数据的最后一个偏移的值，但是可能会出现，偏移量已经提交完毕了，但是拉取的数据还没有处理完毕，消费者重启了，此时有些数据就无法消费到，造成了数据丢失</li></ul><h2 id="Kafka数据如何保证有序"><code>Kafka</code>数据如何保证有序</h2><ul><li>有序需要考虑<strong>生产有序，存储有序和消费有序</strong>。</li><li><strong>生产有序</strong> 就是生产者对象需要给数据增加序列号，用于标记数据的顺序，在服务端进行缓存数据的比对，一旦发现数据是乱序的，就需要让生产者客户端进行数据排序，然后重新发送数据，从而保证数据的有序。不过这里缓存的比对，最多只能有5条数据的比对，所以生产者客户端需要配置<strong>在途请求缓冲区的请求队列</strong>数据设置成5，否则数据依然可能乱序。因为服务端的缓存数据是以分区为单位的，所以需要生产者客户端将数据发送到一个分区中，如果数据发送到多个分区中，无法保证顺序，这就是生产有序的意思</li><li><strong>存储有序</strong> <code>Kafka</code>的服务端获取数据以后会将数据顺序写入日志文件，保证了存储有序，也只能保证一个分区的数据有序</li><li><strong>消费有序</strong> <code>Kafka</code>在存储数据时会给数据增加一个访问的偏移量值，消费者只能按照偏移量的方式顺序访问，并且一个分区的数据只能被消费者组中的一个消费者消费，那么按照偏移量方式读取的数据就不会出现乱序的情况，从而实现消费有序</li></ul>]]></content>
      
      
      <categories>
          
          <category> Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
            <tag> 消费者分区分配策略 </tag>
            
            <tag> 集群脑裂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka笔记_0</title>
      <link href="/posts/d8e4d2ce.html"/>
      <url>/posts/d8e4d2ce.html</url>
      
        <content type="html"><![CDATA[<h1>消费模式</h1><h2 id="点对点模式-P2P">点对点模式(<code>P2P</code>)</h2><ul><li>队列中<strong>只有一个消费者</strong>可以消费数据，用后即销毁，因此数据有且只有一次消费。</li><li>适合用于<strong>短信业务</strong>，发送一次，消费一次。  <div class="note info flat"><p>特点:<br>- 每个消息只有一个接收者<br>- 发送和接收之间没有依赖，发送者成功发送消息后，不管接收有没有运行，都可以再次发送消息<br>- 接收者在成功接收后需要向队列应答成功，以便消息队列删除当前消息</p></div><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Kafka/p2p.png" alt="p2p"></li></ul><h2 id="发布订阅模式-PS">发布订阅模式(<code>PS</code>)</h2><ul><li>数据会在队列中存储<strong>7天</strong>，每个订阅都可以消费到相应的数据，可以<strong>重复进行</strong>消费数据。</li><li>大部分都是发布订阅模式。  <div class="note info flat"><p>特点:<br>- 每个消息有多个订阅者<br>- 发布者和订阅者之间有时间上的依赖性。针对某个<code>Topic</code>的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息<br>- 为了消费消息，订阅者需要提前订阅该角色主题，并保持在线运行</p></div><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Kafka/ps.png" alt="ps"></li></ul><h1>基础架构</h1><div class="note info flat"><ul><li><code>Kafka</code><strong>不是主从集群</strong>，因此每一个节点都可以是主节点，如果一个节点宕机了，那么其他的节点可以被选举为主节点</li><li><code>Kafka</code>中每一个节点都称为<code>Broker</code>，每个节点都存在一个<code>Kafka_controller</code>组件</li><li>但是只有一台节点的<code>controller</code>组件是活跃状态，其他都是<code>standby</code>状态</li><li>主节点宕机时，从节点通过<code>ZooKeeper</code>进行集群选举，得到新的主节点</li></ul></div><h1><code>Feed</code>流实现方案</h1><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">拉模式</th><th style="text-align:center">推模式</th><th style="text-align:center">推拉结合</th></tr></thead><tbody><tr><td style="text-align:center">写比例</td><td style="text-align:center">低</td><td style="text-align:center">高</td><td style="text-align:center">中</td></tr><tr><td style="text-align:center">读比例</td><td style="text-align:center">高</td><td style="text-align:center">低</td><td style="text-align:center">中</td></tr><tr><td style="text-align:center">用户读取延迟</td><td style="text-align:center">高</td><td style="text-align:center">低</td><td style="text-align:center">低</td></tr><tr><td style="text-align:center">实现难度</td><td style="text-align:center">复杂</td><td style="text-align:center">简单</td><td style="text-align:center">很复杂</td></tr><tr><td style="text-align:center">使用场景</td><td style="text-align:center">较少使用</td><td style="text-align:center">用户量少，没有大V</td><td style="text-align:center">过千万的用户量，有大V</td></tr></tbody></table><h1>消息队列应用</h1><h2 id="线程与线程之间的数据交互">线程与线程之间的数据交互</h2><div class="note info flat"><ul><li>栈内存是<strong>线程独享</strong>的，堆内存是共享的</li></ul></div><p><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Kafka/threaddata.png" alt="threaddata"></p><h2 id="进程与进程之间的数据交互">进程与进程之间的数据交互</h2><div class="note info flat"><ul><li>进程有自己独立的内存，<strong>无法</strong>通过堆内存共享数据</li></ul></div><p><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Kafka/processdata.png" alt="processdata"></p><h2 id="传统数据交互的问题">传统数据交互的问题</h2><ul><li>如果线程1发送数据的速度是<code>50 条/s</code>，但是线程2处理数据的速度是<code>30 条/s</code>，就会导致<strong>每秒有20条数据</strong>积压在内存中，最后导致内存溢出，服务终止</li><li>如果放在磁盘文件中，磁盘文件也是有上限的，并且速度较慢</li></ul><h2 id="消息中间件">消息中间件</h2><ul><li>进程之间直接进行交互，可以在进程之间添加一个缓冲区，用于解耦合</li><li>发送数据的进程只需要考虑往缓冲区中存放数据，也就是<strong>消息中间件</strong>，从而实现降低系统之间的耦合性</li><li>消息一般包含<strong>消息头，消息属性和消息主体内容</strong><br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Kafka/JMS.png" alt="JMS"></li></ul><h1><code>Kafka</code>基本概念</h1><h2 id="基本命令参数">基本命令参数</h2><div class="note info flat"><ul><li>连接<code>Kafka</code>必须要的参数: <code>--bootstrap-server ip:port(9092)</code> <code>9092</code>是<code>Kafka</code>默认的端口号</li><li><code>Kafka</code>创建新<code>topic</code>需要在后面跟上: <code>--topic 主题名 --create</code></li><li>查看<code>topic</code>: <code>--list</code></li><li>查看某个具体的<code>topic</code>: <code>--topic 主题名 --describe</code></li><li>修改<code>topic</code>: <code>--topic 主题名 --alter --修改的内容</code></li><li>删除<code>topic</code>: <code>--topic 主题名 --delete</code></li></ul></div><h2 id="单节点架构">单节点架构</h2><p><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Kafka/kafka.png" alt="kafka"></p><ul><li>消息称为<code>record</code></li><li><code>App</code>通过调用<code>Kafka</code>的接口实现生产和消费，会将数据保存到<code>.log</code>文件中，增加标记<code>offset</code>，固定顺序</li></ul><h2 id="集群架构">集群架构</h2><p><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Kafka/arch.png" alt="arch"></p><div class="note default flat"><ul><li>中间单个节点容易成为性能瓶颈，如果宕机，则数据无法访问</li><li>两种方式解决: 1. 横向扩展 2. 纵向扩展</li></ul></div><h3 id="横向扩展">横向扩展</h3><ul><li>增加服务节点，搭建集群，降低单点故障带来的问题<br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Kafka/horizontal.png" alt="horizontal">  <div class="note info flat"><ul><li>在<strong>一定程度上缓解</strong>，不是真正完全解决，因为主题在指定的<code>Broker</code>上，所以依然必须要访问某一个特定的<code>Broker</code></li><li>因此真正解决需要将一个<code>topic</code>分成多个部分，所有生产数据可以指向不同的<code>Broker</code>，但是都是同一个<code>topic</code></li></ul></div></li></ul><h3 id="纵向扩展">纵向扩展</h3><ul><li>增加系统的资源配置，更快的网络，更大的硬盘  <div class="note info flat"><ul><li><code>topic</code>是一个整体，但是划分了不同的数据块<ul><li>通过添加不同的编号，即为不同的分区(<code>partition</code>)</li><li>生产者就可以将数据发向不同的<code>partition</code>，消费者可以消费同一个<code>topic</code>不同的<code>partition</code></li></ul></li><li><code>Kafka</code>设置了消费者组<code>Consumer Group</code>，专门用来消费不同<code>partition</code>的消息，这样避免发送多次消费请求</li></ul></div></li><li>为了数据的可靠性，可以将数据进行备份，但是<code>Kafka</code>没有备份的概念，只有<strong>副本</strong>的概念。</li><li>多个副本同时只有一个能进行读写操作，称为<code>Leader</code>副本，其他副本称为<code>Follower</code>副本</li><li><strong>副本个数不应该超过broker数量 - 1</strong></li></ul><p><code>Kafka</code>有一个管理的<code>Broker</code>，称为控制器(<code>Controller</code>)</p><div class="note info flat"><p>如果<code>Controller</code>宕机了，如何解决</p><ol><li>给<code>Controller</code>添加备份</li><li>每一个<code>Broker</code>都可以做备份，如果<code>Controller</code>宕机了，则会使用<code>ZooKeeper</code>选取一个新的<code>Controller</code></li></ol></div><p><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Kafka/jiqun.png" alt="jiqun"></p><div class="note default flat"><p><code>ZooKeeper</code>选举流程</p><ol><li><code>ZooKeeper</code>首先没有任何的节点，启动<code>Broker1</code>，则会产生临时节点<code>Controller</code>，<code>id=1</code></li><li>然后启动<code>Broker2</code>和<code>Broker3</code>后，不能再产生临时节点，就会创建一个监听器，监听节点的变化</li><li><code>Controller</code>失去连接了以后，监听器就会发生作用，选举出新的<code>Controller</code></li></ol></div><h1><code>Broker</code>启动流程</h1><h2 id="Broker1启动流程"><code>Broker1</code>启动流程</h2><ol><li>在<code>ZooKeeper</code>注册<code>Broker</code>节点，创建临时节点<code>ids</code></li><li>监听<code>/controller</code>节点</li><li>注册<code>/controller</code>节点</li><li>注册成功，选举称为<code>Controller</code>，监听临时节点<code>/brokers/ids</code>，从而可以对后面加入的节点进行响应</li></ol><h2 id="Broker2启动流程"><code>Broker2</code>启动流程</h2><ol><li>在<code>ZooKeeper</code>注册<code>Broker</code>节点，在<code>ids</code>里面创建临时节点2</li><li>监听<code>/controller</code>临时节点</li><li>注册<code>/controller</code>临时节点，因为<code>ZooKeeper</code>中已经存在<code>Controller</code>，所以不会注册成功</li><li>通知集群变化</li><li>连接<code>Broker</code>，发送集群的相关数据</li></ol><h2 id="Broker3启动流程"><code>Broker3</code>启动流程:</h2><ol><li>注册<code>Broker</code>节点，在<code>ids</code>里面创建临时节点3</li><li>监听<code>/controller</code>临时节点</li><li>注册<code>/controller</code>临时节点，注册不成功</li><li>通知集群变化</li><li>连接<strong>所有的<code>Broker</code></strong>，发送集群的相关信息</li></ol><h2 id="删除Controller节点-宕机">删除<code>Controller</code>节点(宕机):</h2><ol><li>由监听器通知节点删除</li><li>注册<code>Controller</code>临时节点，只有一个节点能注册成功</li><li>增加<code>ids</code>监听器，删除曾经的<code>Controller</code>监听器</li><li>连接所有的<code>Broker</code>，发送集群的相关数据</li></ol><h2 id="底层实现">底层实现</h2><ol><li><code>Broker</code>和<code>ZooKeeper</code>之间的通信: 节点带有<code>ZooKeeperClient</code>实现通信</li><li><code>Controller</code>和<code>Broker</code>之间的通信: <code>NIO</code>的<code>Channel, Buffer, Selector, SelectionKey</code></li></ol><h1>生产</h1><h2 id="创建主题">创建主题</h2><ul><li>生产消息的时候如果不存在对应的主题，<code>Kafka</code>会自动创建主题(可以通过配置关闭)</li><li>要关注每个<code>Broker</code>中的<code>Leader</code>的数量，平衡分配会更合理一些</li><li><code>Kafka</code>默认的副本分配未必是平均分配，所以只能尽可能的合理分配，也可以自己指定副本的分配方案</li></ul><h2 id="分区计算">分区计算</h2><ol><li>如果发送消息中指定了分区编号，则会直接向分区中发送消息，并且不会检查分区编号是否有问题。如果写了一个不存在的编号，则消息一直阻塞</li><li>自定义分区器实现<code>Partitioner</code>，会检查编号是否小于0，但是过大依然不会检查</li><li>把<code>key</code>做了一个非哈希散列算法<code>murmur2</code>，取余分区数量，得到的结果就是分区编号。所以指定的<code>key</code>主要用来做分区计算的</li></ol><div class="note info flat"><ul><li>为了节省网络资源消耗，设计了<code>RecordAccumulator</code>数据收集器，将多个消息一起发送，而不是简单的一条一条发送</li><li>数据收集器内部都是一些批次对象，如果批次对象的容量足够，则会自动往里面<code>append</code>数据</li><li>如果批次对象的容量不够了，则会将批次对象锁定关闭，不再接收新的数据，开启一个新的批次对象，用于接收数据</li><li>批次对象中有一个<code>16K</code>的阈值，不是不能超过<code>16K</code>，而是超过<code>16K</code>再关闭</li></ul></div><p><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Kafka/produce.png" alt="produce"></p><h2 id="应答处理-三个级别">应答处理(三个级别)</h2><ol><li><code>ACKS = 0</code>: 优先考虑数据传送效率，数据是否真的发送过去是不关心的。假设网络是没有任何问题的，发送完一条数据立马发送下一条</li><li><code>ACKS = 1</code>: 可靠性和发送效率折中，<code>Leader</code>保存数据到磁盘后，就响应发送成功。但是如果<code>Leader</code>宕机了，<code>Follower</code>没有来得及备份，则数据无法访问</li><li><code>ACKS = -1 or ALL</code>: 优先考虑数据的安全性，<code>Leader</code> 和 <code>Follower</code>把数据都保存了，然后才响应发送成功，效率很低</li></ol><ul><li>这里的<code>Follower</code>是<code>ISR</code>中的所有副本，而不是本身的所有副本</li></ul><h2 id="重试机制Retry">重试机制<code>Retry</code></h2><ul><li><code>ACKS = 1</code>: 如果一个数据，从主线程出发到<code>Buffer</code>缓冲区后到<code>Sender</code>线程中，发送到<code>NetworkClient</code>网络客户端，再发送到<code>SocketServer</code>服务器。如果这个时候数据没有到<code>ReplicaManager</code>，<code>Leader</code>宕机，则无法进行副本保存。此时<code>NetworkClient</code>客户端有一份数据，<code>SocketServer</code>有一份数据，但是由于宕机，导致<code>SocketServer</code>的数据丢失，没有保存则不会有响应，此时会有超时时间。如果超时了会进行<code>Retry</code>。<ol><li>将<code>NetworkClient</code>的数据重新传送到<code>Buffer</code>中，再经过<code>Sender</code>线程，再回到<code>NetworkClient</code>进行发送</li><li>默认是不断重试，重试次数是整型的最大值</li></ol></li></ul><h3 id="重试机制的问题-重复和乱序">重试机制的问题(重复和乱序)</h3><ol><li>数据重试机制可能会导致数据重复(超时时间过少导致的)</li><li><code>Buffer</code>有三条数据，被网络客户端发送到<code>Broker</code>中，生产者可同时处理五个请求，所以三个数据可以一起处理。<ul><li>但是如果三条数据中有一条处理失败了，则会重新发送那一条数据，但是此时会导致乱序问题</li></ul></li></ol><h3 id="如何解决重复和乱序-幂等性">如何解决重复和乱序(幂等性)</h3><ul><li>开启幂等性: 配置<code>ENABLE_IDEMPOTENCE_CONFIG</code>(默认不启用)</li></ul><div class="note default flat"><p>开启幂等性要求</p><ul><li><code>ACKS = -1</code></li><li>开启重试机制</li><li>在途请求缓冲区不能超过5(默认就是5)</li></ul></div><ul><li>给数据开启<strong>唯一</strong>的标识，包括两个部分，分别是<strong>生产者ID，数据的顺序号</strong><ul><li><p>不同的<code>partition</code>数据可能有相同的标号，但是同一个<code>partition</code>内序号一定是唯一的</p></li><li><p>所以幂等性只能保证<strong>对同一个</strong><code>partition</code>起作用</p></li><li><p><code>Broker</code>可以保存生产者状态，里面只有五条数据。如果是同一个<code>Producer</code>，同一个<code>partition</code>，就可以对比唯一标识判断数据是否<strong>重复</strong></p></li><li><p><strong>乱序</strong>是判断当前的序号是否连续</p><ul><li>如果6失效了，会尝试将7插入进去，发现前面是5后面是7，不连续，则6和7都会重发</li><li>如果5后面的6正常，则会将1弹出后，再将6传入，保证数据按序输出</li><li>这个队列的大小为五，所以要求在途请求缓冲区不能超过5</li></ul><div class="note default flat"><p>幂等性跨会话问题</p><ul><li>生产者ID是随机生成的，如果生产者重启了，则生产者ID也会发生改变。此时比对序号的操作时会发现比对不成功</li><li>可以通过<strong>事务</strong>解决</li><li>数据唯一标识中添加事务ID，事务是基于幂等性操作，保证一次提交。因此事务可以解决跨会话的幂等性问题，但是<strong>不能解决跨分区</strong>的问题</li></ul></div></li></ul></li></ul><h2 id="数据传输语义">数据传输语义</h2><table><thead><tr><th style="text-align:center">数据传输语义</th><th style="text-align:center">含义</th><th style="text-align:center">场景</th></tr></thead><tbody><tr><td style="text-align:center">at most once</td><td style="text-align:center">最多一次，不管是否能够接收到，数据最多传输一次，可能丢失</td><td style="text-align:center">Socket ACK = 0</td></tr><tr><td style="text-align:center">at least once</td><td style="text-align:center">最少一次，数据不会丢失，如果接收不到，则继续发送直到接收，可能会出现数据重复</td><td style="text-align:center">ACK = 1</td></tr><tr><td style="text-align:center">exactly once</td><td style="text-align:center">精准一次，消息只会传送一次，不会丢也不会重复</td><td style="text-align:center">幂等 + 事务 + ACK = 1</td></tr></tbody></table><h2 id="事务流程">事务流程</h2><p><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Kafka/tx.png" alt="tx"></p><h2 id="文件存储类型">文件存储类型</h2><ul><li>数据写入<code>Leader</code>节点时，<strong>不会</strong>立即将数据写入磁盘文件中，因为这样效率太低了。</li><li><code>Kafka</code>将一个文件切分成一个一个文件段。当大于<code>1G</code>时，就会产生一个新的文件段。</li><li>如果一份数据超过7天，也会生成一个新的文件段</li><li><code>.log</code>就是数据的日志文件，当前文件中起始偏移量</li><li><code>.index</code>偏移量索引文件，将偏移量与文件中的数据的具体位置进行关联，称之为<strong>稀疏索引文件</strong></li><li><code>.timeindex</code>保存时间戳和数据偏移量之间的关系</li></ul>]]></content>
      
      
      <categories>
          
          <category> Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
            <tag> 应答处理机制 </tag>
            
            <tag> 重试机制 </tag>
            
            <tag> 幂等性 </tag>
            
            <tag> 事务流程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis笔记_5</title>
      <link href="/posts/46b5b207.html"/>
      <url>/posts/46b5b207.html</url>
      
        <content type="html"><![CDATA[<h1><code>QuickList</code></h1><div class="note info flat"><ul><li><code>ZipList</code>虽然节省内存，但是申请的是<strong>连续的空间</strong>，如果内存占用较多，内存申请效率很低；<ul><li>这时候需要限制<code>ZipList</code>的长度或者<code>entry</code>大小；</li><li>也可以创建多个<code>ZipList</code>分片存储数据</li><li>但是拆分后比较分散，不方便管理和查找，所以引入了<code>QuickList</code></li></ul></li></ul></div><ul><li><code>QuickList</code>本质上是一个<strong>双端链表</strong>，其中的每一个节点都是<code>ZipList</code><br><img src="https://gitee.com/sang3112/blog_imgs/raw/1ac80c3030f37c5d649c32e7e65c57937283ef7a/Redis/QuickList.png" alt="QuickList"></li><li>为了避免<code>QuickList</code>中每个<code>ZipList</code>的<code>entry</code>过多，可以配置<code>list-max-ziplist-size</code>来进行限制<ul><li>如果为正，表示<code>ZipList</code>的允许的<code>entry</code>最大个数</li><li>如果为负，表示<code>ZipList</code>的最大内存大小，共五种情况<table><thead><tr><th style="text-align:center">情况</th><th style="text-align:center">内存占用</th></tr></thead><tbody><tr><td style="text-align:center">-1</td><td style="text-align:center">&lt;= 4KB</td></tr><tr><td style="text-align:center">-2(默认)</td><td style="text-align:center">&lt;= 8KB</td></tr><tr><td style="text-align:center">-3</td><td style="text-align:center">&lt;= 16KB</td></tr><tr><td style="text-align:center">-4</td><td style="text-align:center">&lt;= 32KB</td></tr><tr><td style="text-align:center">-5</td><td style="text-align:center">&lt;= 64KB</td></tr></tbody></table></li></ul></li><li><code>QuickList</code>同时可以对节点<code>ZipList</code>进行压缩，通过配置<code>list-compress-depth</code>控制。因为链表一般都是<strong>首尾访问较多</strong>，所以<strong>首尾不压缩</strong>。<table><thead><tr><th style="text-align:center">情况</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">不压缩</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">表示<code>QuickList</code>首尾各有一个节点不压缩，中间节点压缩</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">表示<code>QuickList</code>首尾各有两个节点不压缩，中间节点压缩</td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">… 以此类推</td></tr></tbody></table></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span>&#123;</span></span><br><span class="line">    <span class="comment">// 头节点</span></span><br><span class="line">    quickliskNode *head;</span><br><span class="line">    <span class="comment">// 尾节点</span></span><br><span class="line">    quicklistNode *tail;</span><br><span class="line">    <span class="comment">// 所有ziplist的entry数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> count;</span><br><span class="line">    <span class="comment">// ziplists总数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line">    <span class="comment">// ziplist的entry上限，默认为-2</span></span><br><span class="line">    <span class="type">int</span> fill : QL_RILL_BITS;</span><br><span class="line">    <span class="comment">// 首尾不压缩节点数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> compress : QL_COMP_BITS;</span><br><span class="line">    <span class="comment">// 内存重新分配时的书签数量以及数组，一般用不到</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> bookmark_count : QL_BM_BITS;</span><br><span class="line">    quicklistBookmark bookmarks[];</span><br><span class="line">&#125; quicklist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 前一个节点指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="comment">// 后一个</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">// 当前节点</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *zl;</span><br><span class="line">    <span class="comment">// 当前节点的ZipList的entry个数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count : <span class="number">16</span>;</span><br><span class="line">    <span class="comment">// 编码方式: 1, ZipList; 2, lzf压缩模式</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> encoding : <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 数据容器类型(预留): 1, 其他; 2, ZipList</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> container : <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 是否被解压缩: 1, 被解压，需要重新压缩</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> recomress : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> attempted_compress : <span class="number">1</span>; <span class="comment">// 测试用</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> extra : <span class="number">10</span>; <span class="comment">// 预留字段</span></span><br><span class="line">&#125; quicklistNode;</span><br></pre></td></tr></table></figure><div class="note info flat"><p>特点:</p><ol><li>节点为<code>ZipList</code>的双端链表</li><li>解决传统链表内存占用问题</li><li>控制<code>ZipList</code>大小，解决连续内存空间申请效率问题</li><li>中间节点可以压缩，进一步节省内存</li></ol></div><h1><code>SkipList</code></h1><ul><li>是一个链表，但是<ul><li><p>元素<strong>升序</strong>排列</p></li><li><p>包含多级指针，指针跨度不同</p></li><li><p>最多允许<strong>32级</strong>指针</p><p><img src="https://gitee.com/sang3112/blog_imgs/raw/1ac80c3030f37c5d649c32e7e65c57937283ef7a/Redis/skiplist.png" alt="skiplist"></p></li></ul></li></ul><div class="note info flat"><p>特点:</p><ol><li>一个双向链表，每个节点包含<code>score</code>和<code>ele</code>值</li><li>节点按照<code>score</code>值排序，如果相同则按照<code>ele</code>字典排序</li><li>每个节点可以包含多层指针，层数是<code>1~32</code>的随机数</li><li>不同层指针到下一个节点的跨度不同，层级越高，跨度越大</li><li>增删改查的效率与红黑树基本一致，实现更简单</li></ol></div><h1><code>RedisObject</code></h1><ul><li><p><strong>任意</strong>的数据类型的键和值都会被封装成<code>RedisObject</code></p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span>&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> type : <span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> encoding : <span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> lru : LRU_BITS;</span><br><span class="line">    <span class="type">int</span> refcount;</span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><ul><li><p><code>type</code>: 对象类型，分别是<code>string、hash、list、set、zset</code>，占用<code>4bits</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> OBJ_STRING 0</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> OBJ_LIST 1</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> OBJ_SET 2</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> OBJ_ZSET 3</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> OBJ_HASH 4</span></span><br></pre></td></tr></table></figure></li><li><p><code>encoding</code>: 底层11种编码方式，占用<code>4bits</code></p><table><thead><tr><th style="text-align:center">编号</th><th style="text-align:center">编码方式</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">OBJ_ENCODING_RAW</td><td style="text-align:center">raw编码动态字符串</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">OBJ_ENCODING_INT</td><td style="text-align:center">long类型整数字符串</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">OBJ_ENCODING_HT</td><td style="text-align:center">哈希表(字典dict)</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">OBJ_ENCODING_ZIPMAP</td><td style="text-align:center">废弃</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">OBJ_ENCODING_LINKEDLIST</td><td style="text-align:center">双端列表</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">OBJ_ENCODING_ZIPLIST</td><td style="text-align:center">压缩列表</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">OBJ_ENCODING_INTSET</td><td style="text-align:center">整数集合</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">OBJ_ENCODING_SKIPLIST</td><td style="text-align:center">跳表</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">OBJ_ENCODING_EMBSTR</td><td style="text-align:center">embstr动态字符串</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">OBJ_ENCODING_QUICKLIST</td><td style="text-align:center">快速列表</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">OBJ_ENCODING_STREAM</td><td style="text-align:center">stream流</td></tr></tbody></table><ul><li>数据类型对应的编码方式<table><thead><tr><th style="text-align:center">数据类型</th><th style="text-align:center">编码方式</th></tr></thead><tbody><tr><td style="text-align:center">OBJ_STRING</td><td style="text-align:center">int, embstr, raw</td></tr><tr><td style="text-align:center">OBJ_LIST</td><td style="text-align:center">LinkedList和ZipList(3.2版本前)；QuickList(3.2版本后)</td></tr><tr><td style="text-align:center">OBJ_SET</td><td style="text-align:center">intset，HT</td></tr><tr><td style="text-align:center">OBJ_ZSET</td><td style="text-align:center">ZipList, HT, SkipList</td></tr><tr><td style="text-align:center">OBJ_HASH</td><td style="text-align:center">ZipList, HT</td></tr></tbody></table></li></ul></li><li><p><code>lru</code>: 该对象最后一次被访问的时间，占用<code>24bits</code></p></li><li><p><code>refcount</code>: 对象引用计数器，为0表示无人引用，可以被回收</p></li><li><p><code>*ptr</code>: 指针，指向存放实际数据的空间</p></li></ul></li></ul><h1><code>String</code></h1><ul><li>基本编码方式是<code>RAW</code>，基于<code>SDS</code>实现，上限为<code>512MB</code></li><li>如果<code>SDS</code>长度小于<code>44B</code>，则会采用<code>EMBSTR</code>编码，此时<code>objecthead</code>与<code>SDS</code>是一段连续的空间，申请内存只需要调用一次内存分配函数，效率更高</li><li>如果存储的字符串是整数值，并且大小在<code>LONG_MAX</code>范围内，则会采用<code>INT</code>编码，直接将数据保存在<code>RedisObject</code>的<code>ptr</code>指针位置，正好<code>8B</code>，就不需要<code>SDS</code>了</li></ul><p><img src="https://gitee.com/sang3112/blog_imgs/raw/1ac80c3030f37c5d649c32e7e65c57937283ef7a/Redis/string.png" alt="string"></p><h1><code>Zset</code></h1><ul><li><p>底层结构由<code>Dict</code><strong>和</strong><code>SkipList</code>实现，但是内存占用较高</p></li><li><p>所以还有第二种实现方式: 元素数量不多时，哈希表和<code>SkipList</code>优势不明显，更消耗内存，所以此时会用<code>ZipList</code>节省内存，不过需要同时满足</p><ol><li>元素数量小于<code>zset_max_ziplist_entries</code>默认<code>128</code>，如果为<code>0</code>就<strong>禁用ZipList</strong></li><li>每个元素都小于<code>zset_max_ziplist_value</code>字节，默认值<code>64</code></li></ol></li><li><p><code>ZipList</code>本身没排序功能，也没有键值对的概念，需要有<code>ZSet</code>通过编码实现</p><ul><li><code>ZipList</code>是连续内存，因此<code>score</code>和<code>ele</code>是紧挨在一起的两个<code>entry</code>，<code>element</code>在前，<code>score</code>在后</li><li><code>score</code>越小越接近队首，<code>score</code>越大越接近队尾，按照<code>score</code>升序排列</li></ul></li><li><p>两种不同的编码就涉及到编码转换，添加元素的时候会进行判断，如果是<code>ZipList</code>，就会进行判断，是否需要转换为<code>HT+SL</code></p></li></ul><h1><code>Hash</code></h1><ul><li><code>Hash</code>底层跟<code>ZSet</code>基本一致，只是排序有关的<code>SkipList</code>去掉</li><li>默认采用<code>ZipList</code>，用来节省内存。<code>ZipList</code>中相邻两个<code>entry</code>分别保存<code>field</code>和<code>value</code></li><li>数据量较大的时候，<code>Hash</code>会转换为<code>Dict</code>编码，触发条件有两个：<ul><li><code>ZipList</code>中元素数量超过了<code>hash-max-ziplist-entries</code>默认<code>512B</code></li><li><code>ZipList</code>中任意<code>entry</code>大小超过了<code>hash-max-ziplist-value</code>默认<code>64B</code></li></ul></li></ul><h1>用户空间和内核空间</h1><div class="note info flat"><ol><li>寻址空间分为两部分: 内核空间，用户空间</li><li>用户空间只能执行受限的命令(Ring3)，不能直接调用系统资源，必须通过内核提供的接口来访问</li><li>内核空间可以执行特权命令(Ring0)，调用一切系统资源</li></ol></div><h2 id="空间切换">空间切换</h2><p>为了提高IO效率，会在用户空间和内核空间都加入缓冲区</p><ul><li>写数据时，要把用户缓冲数据拷贝到内核缓冲区，然后写入设备</li><li>读数据时，要从设备读取数据到内核缓冲区，然后拷贝到用户缓冲区</li></ul><h1>IO模型(5种)</h1><h2 id="阻塞IO">阻塞IO</h2><ul><li>两个阶段都必须阻塞等待，性能差一些<br><img src="https://gitee.com/sang3112/blog_imgs/raw/1ac80c3030f37c5d649c32e7e65c57937283ef7a/Redis/blockingIO.png" alt="blockingIO"></li></ul><h2 id="非阻塞IO">非阻塞IO</h2><ul><li><code>recvfrom</code>操作会立即返回结果而不是阻塞用户进程，等待数据就绪的时候非阻塞的，实际上拷贝数据的时候还是阻塞的。</li><li>没啥用，没有提升系统性能，反而会提升CPU使用率。<br><img src="https://gitee.com/sang3112/blog_imgs/raw/1ac80c3030f37c5d649c32e7e65c57937283ef7a/Redis/noblockingio.png" alt="noblockingIO"></li></ul><div class="note info flat"><ul><li>阻塞IO和非阻塞IO都需要调用<code>recvfrom</code>来获取数据，差别在于无数据时的处理方案。</li></ul></div><h2 id="IO多路复用"><strong>IO多路复用</strong></h2><ul><li><p>如果客户端处理<code>Socket</code>请求时，单线程情况下，依次处理每一个<code>Socket</code>，如果正在处理的<code>Socket</code>恰好未就绪，数据不可读或不可写，则线程被阻塞，其他客户端<code>Socket</code>就必须等待，性能会很差。</p></li><li><p>文件描述符(<code>FD</code>): 从0开始递增的无符号整数，关联<code>Linux</code>中的一个文件</p></li><li><p>IO多路复用就是用<strong>单线程</strong>，监听多个<code>FD</code>，在某个<code>FD</code>可读可写时得到通知，避免无效等待，充分利用CPU<br><img src="https://gitee.com/sang3112/blog_imgs/raw/1ac80c3030f37c5d649c32e7e65c57937283ef7a/Redis/IOmulti.png" alt="IOmulti"></p></li><li><p>有三种监听<code>FD</code>的方式</p><ol><li><code>select</code></li><li><code>poll</code></li><li><code>epoll</code></li></ol></li><li><p><code>select</code> 和 <code>poll</code>只会通知用户进程有<code>FD</code>就绪，但是不确定是哪个<code>FD</code>，需要用户进程<strong>逐个遍历</strong><code>FD</code>确认</p></li><li><p><code>epoll</code>会在通知用户进程<code>FD</code>就绪的通知，把已经就绪的<code>FD</code>写入用户空间</p></li></ul><h3 id="select"><code>select</code></h3><div class="note info flat"><p>问题:</p><ul><li>每次执行<code>select</code>都需要将整个<code>fd_set</code>从用户空间拷贝到内核空间，<code>select</code>结束还需要再次拷贝，因此涉及<strong>两次切换，两次拷贝</strong></li><li><code>select</code>不知道是哪个<code>FD</code>就绪，需要遍历整个<code>fd_set</code></li><li><code>fd_set</code>监听的<code>FD</code>数量不能超过<code>1024</code></li></ul></div><h3 id="poll"><code>poll</code></h3><p>IO流程:</p><ol><li>创建<code>pollfd</code>数组，向其中添加关注的<code>FD</code>信息，数组大小自定义</li><li>调用<code>poll</code>函数，将<code>pollfd</code>数组拷贝到内核空间，转链表存储，无上限</li><li>内核遍历<code>FD</code>，判断是否就绪</li><li>数据就绪或超时后，拷贝<code>pollfd</code>数组到用户空间，返回就绪<code>FD</code>数量<code>n</code></li><li>用户进程判断<code>n</code>是否大于0</li><li>大于0则遍历<code>pollfd</code>数组，找到就绪的<code>FD</code></li></ol><div class="note info flat"><p><code>poll</code> VS <code>select</code>:</p><ul><li><code>select</code>模式中的<code>fd_set</code>大小固定为1024，<code>pollfd</code>在内核中采用链表，理论上没有上限</li><li>监听的<code>FD</code>越多，每次遍历的消耗的时间也越久，性能反而会下降</li></ul></div><h3 id="epoll"><code>epoll</code></h3><p>对<code>select</code> 和 <code>poll</code>的改进，提供了三个函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">rbr</span>;</span> <span class="comment">// 红黑树，记录所有监听的fd</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdlist</span>;</span><span class="comment">// 链表，记录就绪的FD</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 会在内核创建eventpoll结构体，返回对应的句柄epfd</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将一个FD添加到epoll红黑树中，并设置ep_poll_callback</span></span><br><span class="line"><span class="comment">// callback触发时，就把对应的FD添加到rdlist就绪列表中</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">int</span> epfd, <span class="comment">// epoll实例的句柄</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> op, <span class="comment">// 执行的操作，包括ADD、MOD、DEL</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> fd, <span class="comment">// 监听的FD</span></span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> epoll_event *event <span class="comment">// 监听的事件类型: 读，写，异常等</span></span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3检查rdlist列表是否为空，不为空则返回就绪的FD数量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">int</span> epfd, <span class="comment">// eventpoll实例句柄</span></span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> epoll_event *events, <span class="comment">// 空event数组，接收就绪FD</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> maxevents, <span class="comment">// events数组的最大长度</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> timeout <span class="comment">// 超时时间</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><div class="note info flat"><p>特点:</p><ul><li>基于<code>epoll</code>实例中的<strong>红黑树</strong>保存监听的<code>FD</code>，理论无上限，增删改查效率很高，性能<strong>不会</strong>随监听的<code>FD</code>数量增多而下降</li><li>每个<code>FD</code>只需要执行一次<code>epoll_ctl</code>添加到红黑树，每次<code>epoll_wait</code>无需参数，无需重复拷贝<code>FD</code>到内核</li><li>内核会将就绪的<code>FD</code>直接拷贝到用户空间的指定位置，用户进程无需遍历所有的<code>FD</code>就能知道就绪<code>FD</code>是谁</li></ul></div><h2 id="时间通知机制">时间通知机制</h2><p>有数据可读时，<code>epoll_wait</code>可以得到通知，但是通知模式有两种:</p><ul><li><code>LevelTriggered</code>(默认): <code>LT</code>, 当<code>FD</code>有数据可读，<strong>会重复通知多次</strong>，直到数据处理完成</li><li><code>EdgeTriggered</code>: <code>ET</code>, 当<code>FD</code>有数据可读，<strong>只会通知一次</strong>，不管数据是否处理完成</li></ul><p>基于<code>epoll</code>的<code>web</code>服务基本流程<br><img src="https://gitee.com/sang3112/blog_imgs/raw/1ac80c3030f37c5d649c32e7e65c57937283ef7a/Redis/webservice.png" alt="webservice"></p><h2 id="信号驱动IO">信号驱动IO</h2><ul><li>与内核寄建立<code>SIGIO</code>的信号关联并设置回调，内核有<code>FD</code>就绪，就会发出<code>SIGIO</code>信号通知用户，期间用户可以执行其他业务，无需阻塞等待。比非阻塞IO性能好一些<br><img src="https://gitee.com/sang3112/blog_imgs/raw/1ac80c3030f37c5d649c32e7e65c57937283ef7a/Redis/signalIO.png" alt="signalIO"></li></ul><div class="note info flat"><p>问题:</p><ul><li>如果有大量IO，信号较多<code>SIGIO</code>处理函数不能及时处理，可能导致信号队列溢出</li><li>内核空间与用户空间频繁信号交互性能较低</li></ul></div><h2 id="异步IO">异步IO</h2><ul><li>一二阶段都是非阻塞的，但是因为不阻塞，用户进程调用完异步API以后就可以去做其他的事情，内核等到数据拷贝到用户空间后才会递交信号，通知用户进程。</li><li>但是因为不阻塞，导致用户进程一直接收请求，IO操作较慢，所以必须要做并发访问的限流<br><img src="https://gitee.com/sang3112/blog_imgs/raw/1ac80c3030f37c5d649c32e7e65c57937283ef7a/Redis/syncIO.png" alt="syncIO"></li></ul><div class="note info flat"><ul><li>同步和异步需要看第二阶段是同步还是异步的，<strong>阻塞IO和非阻塞IO都是同步的</strong>，只有异步IO才是异步的</li></ul></div><p><img src="https://gitee.com/sang3112/blog_imgs/raw/1ac80c3030f37c5d649c32e7e65c57937283ef7a/Redis/compare.png" alt="compare"></p><h2 id="Redis网络模型"><code>Redis</code>网络模型</h2><p><code>Redis</code>是单线程还是多线程的</p><div class="note info flat"><ul><li>业务处理部分是单线程的</li><li>如果是整个<code>Redis</code>，则是多线程的<ul><li>引入了多线程异步处理一些耗时较长的任务，比如异步删除<code>BigKey</code>的命令<code>unlink</code></li><li>在核心网络模型中引入了多线程，进一步提高对于多核CPU的利用率</li></ul></li></ul></div><div class="note info flat"><p>选择单线程的原因:</p><ol><li><code>Redis</code>纯内存操作，执行速度非常快，性能瓶颈是网络延迟而不是执行速度，因此多线程不会带来巨大的性能提升</li><li>多线程会导致过多的上下文切换，带来不必要的开销</li><li>引入多线程会面临<strong>线程安全问题</strong>，必然要引入线程锁，实现复杂度更高，性能大打折扣，而且需要考虑老代码的兼容问题</li></ol></div><h1><code>RESP</code>数据类型</h1><ol><li>单行字符串: 首字节是<code>'+'</code>，后面跟上单行字符串，以<code>CRLF(&quot;\r\n&quot;)</code>结尾。但是字符串内不能带有<code>\r\n</code>这种(可以理解成是<strong>二进制不安全</strong>的)</li><li>错误: 首字节是<code>'-'</code>，与单行字符串格式一样，只是字符串是异常信息</li><li>数值: 首字节是<code>':'</code> ，后面跟数字格式的字符串，以<code>CRLF</code>结尾</li><li>多行字符串: 首字节是<code>'$'</code>，表示<strong>二进制安全</strong>的字符串，最大<code>512MB</code>，不用担心字符串内部出现<code>\r\n</code><ul><li>例如: <code>&quot;$5\r\nhello\r\n&quot;</code>，这里的<code>5</code>表示要读五个字符</li><li>如果是<code>0</code>表示空字符串<code>&quot;$0\r\n\r\n&quot;</code></li><li>如果是<code>-1</code>，表示不存在<code>&quot;$-1\r\n&quot;</code></li></ul></li><li>数组: 首字符<code>'*'</code>，后面跟上数组元素个数，再跟上元素，元素类型不限</li></ol><h1>内存回收</h1><h2 id="过期策略">过期策略</h2><ul><li><code>expire</code>对<code>key</code>设置<code>TTL</code>，超时自动释放内存</li></ul><div class="note info flat"><p><code>Redis</code>如何知道一个<code>key</code>是否过期</p><ul><li>Redis的数据库结构体中，有两个<code>dict</code>，一个用来保存<code>key-value</code>，另一个用来记录<code>key-TTL</code></li></ul></div><div class="note info flat"><p>是不是<code>TTL</code>到期就立即删除了</p><ul><li>惰性删除，不是在<code>TTL</code>到期后就立即删除了，而是在访问一个<code>key</code>(增删改查)，检查<code>key</code>的存活时间，如果已经过期了，才执行删除</li><li>周期删除，一个定时任务，周期性抽样部分过期的<code>key</code>，然后执行删除，有两种周期<ol><li><code>Redis</code>会设置一个定时任务<code>serverCron()</code>，会按照<code>server.hz</code>的频率来执行过期<code>key</code>的清理，模式为<code>SLOW</code>。(执行频率低，执行时间长)</li><li>每个事件循环前会调用<code>beforeSleep()</code>函数，执行过期<code>key</code>清理，模式为<code>FAST</code>(执行频率高，执行时间短，几十微秒)<ul><li><code>SLOW</code>模式规则<ul><li>执行频率受到<code>server.hz</code>影响，默认为10，每秒执行10次，每次100ms</li><li>执行清理耗时不超过一次执行周期的25%</li><li>逐个遍历<code>DB</code>，逐个遍历<code>DB</code>中的<code>bucket</code>，抽取20个<code>key</code>判断是否过期</li><li>如果没有达到时间上限25ms并且过期<code>key</code>比例大于10%，再进行一次抽样，否则结束</li></ul></li><li>FAST模式规则<ul><li>执行频率受到<code>beforeSleep()</code>调用频率影响，但是两次<code>FAST</code>模式间隔不超过2ms</li><li>执行清理耗时不超过1ms</li><li>逐个遍历<code>DB</code>，逐个遍历<code>DB</code>中的<code>bucket</code>，抽取20个<code>key</code>判断是否过期</li><li>如果没有达到时间上限1ms并且过期<code>key</code>比例大于10%，再进行一次抽样，否则结束</li></ul></li></ul></li></ol></li></ul></div><h2 id="淘汰策略">淘汰策略</h2><ul><li>当<code>Redis</code>内存使用达到设置的阈值时，<code>Redis</code>主动挑选部分<code>key</code>删除以释放更多内存</li><li>在处理客户端命令方法<code>processCommand()</code>中尝试做内存淘汰</li><li>删除<code>key</code>策略：<ol><li><code>noeviction</code>: 默认，不淘汰任何<code>key</code>，但是内存满时不允许写入新数据</li><li><code>volatile-ttl</code>：设置了<code>TTLkey</code>，比较<code>key</code>的剩余<code>TTL</code>值，<code>TTL</code>越小越先被淘汰</li><li><code>allkeys-random</code>: 对<strong>全体</strong><code>key</code>，随机淘汰，也就是直接从<code>db-&gt;dict</code>中随机挑选</li><li><code>volatile-random</code>: 设置了<code>TTL</code>的<code>key</code>，随机淘汰，也就是从<code>db-&gt;expires</code>中随机挑选</li><li><code>allkeys-lru</code>：最少最近使用，当前时间减去最后一次访问时间，值越大淘汰优先级越高</li><li><code>volatile-lru</code>:对设置了<code>TTL</code>的<code>key</code>，使用<code>LRU</code>算法进行淘汰</li><li><code>allkeys-lfu</code>: 最少频率使用，会统计每个<code>key</code>的访问频率，值越小淘汰优先级越高</li><li><code>volatile-lfu</code>: 对设置了<code>TTL</code>的<code>key</code>，基于<code>LFU</code>算法进行淘汰</li></ol></li></ul><div class="note info flat"><p><code>LRU, LFU</code>记录在<code>RedisObject</code>中，<code>LRU</code>以<strong>秒</strong>为单位记录最近一次访问时间，长度为<code>24bit</code><br><code>LFU</code>的高16位以<strong>分钟</strong>为单位记录最近一次访问时间，低8位记录<strong>逻辑访问次数</strong></p><ul><li>逻辑访问次数，不是每次key访问都计数，而是运算得到<ul><li>生成<code>0~1</code>之间随机数<code>R</code></li><li>计算<code>1 / (旧次数 * lfu_log_factor + 1)</code>记录为<code>P</code>，<code>lfu_log_factor</code>默认为10</li><li>如果<code>R &lt; P</code>,则计数器+ 1，最大不超过255</li><li>访问次数会随时间衰减，距离上一次访问时间间隔<code>lfu_decay_time</code>(分钟，默认1)，计数器-1</li></ul></li></ul></div><p><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Redis/expire.png" alt="expire"></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis笔记_4</title>
      <link href="/posts/31b28291.html"/>
      <url>/posts/31b28291.html</url>
      
        <content type="html"><![CDATA[<h1>简单动态字符串<code>SDS</code></h1><div class="note info flat"><p>传统的C语言字符串存在问题:<br>1. 获取字符串长度需要通过运算<br>2. 非二进制安全，如果中间有一个<code>\0</code>则字符串直接结束了<br>3. 不可修改</p></div><p><code>set name sangs</code>: 这条命令会在底层创建两个<code>SDS</code>，分别是<code>name</code> 和 <code>sangs</code>的<code>SDS</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span>&#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> len;            <span class="comment">// buf已保存的字符串字节数，不包含结束标识</span></span><br><span class="line">    <span class="type">uint8_t</span> alloc;          <span class="comment">// buf申请的总字节数，不包含结束标识，第一次触发时，申请内存一般和len一样</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags;    <span class="comment">// 不同的SDS头类型，用来控制SDS的头大小</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><table>    <tr>        <!-- <td rowspan="">数值</td> -->        <td>len: 4</td><td>alloc: 4</td><td>flags: 1</td><td>n</td><td>a</td><td>m</td><td>e</td><td>\0</td>    </tr></table><div class="note info flat"><ul><li>由于通过<code>len</code>判断需要读取多少位，所以是<strong>二进制安全</strong>的，不会读取到一半终止</li><li>之所以叫动态字符串，是因为具备动态扩容的能力。如果要给<code>SDS</code>追加一段字符串，就会申请<strong>新的内存空间</strong>，即为<strong>内存预分配</strong><ul><li>如果<strong>新字符串长度小于</strong><code>1M</code>，则新空间为扩展后字符串长度的<code>两倍+1</code></li><li>如果<strong>新字符串长度大于</strong><code>1M</code>，则新空间为扩展后字符串长度<code>+1M+1</code></li></ul></li></ul></div><h2 id="举例">举例</h2><table>    <tr>        <td>len: 2</td><td>alloc: 2</td><td>flags: 1</td><td>h</td><td>i</td><td>\0</td>    </tr></table><table>    <tr>        <td>len: 6</td><td>alloc: 12</td><td>flags: 1</td><td>h</td><td>i</td><td>,</td><td>A</td><td>m</td><td>y</td><td>\0</td><td> </td><td> </td><td> </td><td> </td><td> </td><td> </td>    </tr></table><h2 id="优点">优点</h2><ol><li>获取字符串长度的时间复杂度为<code>O(1)</code></li><li>支持动态扩容</li><li>减少内存分配次数</li><li>二进制安全</li></ol><h1><code>IntSet</code></h1><div class="note info flat"><ul><li>是<code>set</code>集合的一种实现方式，基于<strong>整数数组</strong>实现。</li><li>长度可变</li><li><strong>有序</strong></li></ul></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typeder <span class="class"><span class="keyword">struct</span> <span class="title">intset</span>&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding;  <span class="comment">// 编码方式，支持16位，32位，64位整数</span></span><br><span class="line">    <span class="type">uint32_t</span> length;    <span class="comment">// 元素个数</span></span><br><span class="line">    <span class="type">int8_t</span> contents[];  <span class="comment">// 整数数组，保存集合数据，指针，指向数组第一个地址</span></span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure><h2 id="IntSet升级"><code>IntSet</code>升级</h2><p>假设有一个<code>IntSet</code>，元素为<code>5, 10 ,20</code>。则采用的编码为<code>INTSET_ENC_INT16</code>，每个整数占用<code>2B</code>，如果此时添加了一个数字<code>50000</code>，超过了<code>int16_t</code>的范围，则会自动升级编码方式到合适的大小</p><ul><li>升级编码为<code>INTSET_ENC_INT32</code>，每个整数占用<code>4B</code>，并按照新的编码方式以及元素个数扩容数组</li><li><strong>倒序</strong>依次将数组中的元素拷贝到扩容后的正确位置(因为正序拷贝会导致后面的数字被覆盖)</li><li>将待添加的元素放入数组末尾</li><li>将<code>IntSet</code>的<code>encoding</code>属性改为<code>INTSET_ENC_INT32</code>，修改<code>length:4</code></li></ul><h2 id="特点">特点</h2><ol><li><code>Redis</code>确保<code>IntSet</code>元素唯一有序</li><li>具备升级机制，可以节省内存空间</li><li>底层采用<strong>二分查找</strong>方式查询</li></ol><div class="note info flat"><ul><li>因为需要连续的内存空间，所以适合<strong>少量的数据</strong>，且<code>IntSet</code><strong>只能</strong>存储整数</li></ul></div><h1><code>Dict</code></h1><div class="note info flat"><ul><li>三个部分组成:<ol><li>哈希表(<code>DickHashTable</code>)</li><li>哈希节点(<code>DictEntry</code>)</li><li>字典(<code>Dict</code>)</li></ol></li></ul></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span>&#123;</span></span><br><span class="line">    dictEntry **table；     <span class="comment">// Entry指针数组，数组中保存的是指向Entry的指针</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;     <span class="comment">// 哈希表大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask; <span class="comment">// 哈希表大小的掩码，总等于size - 1</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;     <span class="comment">// Entry个数</span></span><br><span class="line">&#125; dictht;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span>&#123;</span></span><br><span class="line">    <span class="type">void</span> *key;  <span class="comment">// 键</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">    &#125; v;        <span class="comment">// 值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dcitEntry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;         <span class="comment">// dict类型，内置不同的hash函数</span></span><br><span class="line">    <span class="type">void</span> *privdata;         <span class="comment">// 私有数据，在做特殊hash运算时使用</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];           <span class="comment">// 一个Dict包含两个哈希表，其中一个是当前数据，另一个一般为空，rehash时使用</span></span><br><span class="line">    <span class="type">long</span> rehashidx;         <span class="comment">// rehash进度，-1表示未进行</span></span><br><span class="line">    <span class="type">int16_t</span> pauserehash;    <span class="comment">// rehash是否暂停，1表示暂停，0表示继续</span></span><br><span class="line">&#125;dict;</span><br></pre></td></tr></table></figure><h2 id="Dict扩容"><code>Dict</code>扩容</h2><div class="note info flat"><p>当我们向<code>Dict</code>添加键值对时，<code>Redis</code>首先根据<code>key</code>计算出<code>hash</code>值<code>h</code>，然后利用<code>h &amp; sizemask</code>来计算元素应该存储得到数组中的哪个索引位置。</p><ul><li>因为<code>sizemask</code>的大小恰好是<code>size - 1</code>，所以<code>h &amp; sizemask</code>这个与运算的结果恰好等于对<code>h</code>求余(其实就是<strong>除留余数法</strong>)</li></ul></div><ul><li>如果有<strong>同义词</strong>，则将新插入的元素接在前面，后面跟上原来的数据(这就是使用<strong>拉链法</strong>解决哈希冲突)</li><li>但是如果元素较多，冲突增多，链表过长，则查询效率会大大降低<ul><li>因此每次新增键值对会检查<strong>负载因子</strong>(使用的位置个数和总空间个数的比值)</li><li>哈希扩容:<ol><li>负载因子 &gt;= 1，并且服务器<strong>没有</strong>执行<code>BGSAVE</code>或者<code>BGREWRITEAOF</code>等后台进程</li><li>负载因子 &gt; 5</li></ol></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> _dictExpandIfNeeded (dict *d)&#123;</span><br><span class="line">    <span class="comment">// 如果正在rehash 返回OK</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) <span class="keyword">return</span> DICT_OK;</span><br><span class="line">    <span class="comment">// 如果哈希表为空，则初始化哈希表默认大小为4</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].size == <span class="number">0</span>) <span class="keyword">return</span> dictExpand(d, DICT_HT_INITIAL_SIZE);</span><br><span class="line">    <span class="comment">// 当负载因子(used / size)达到1以上，并且当前没有进行bgrewrite等子进程操作</span></span><br><span class="line">    <span class="comment">// 或者当负载因子超过5，则进行地图Expand，也就是扩容</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used &gt;= d-&gt;ht[<span class="number">0</span>].size &amp;&amp; </span><br><span class="line">        (dict_can_resize || d-&gt;ht[<span class="number">0</span>].used / d-&gt;ht[<span class="number">0</span>].size &gt; dict_force_resize_ratio))&#123;</span><br><span class="line">            <span class="comment">// 扩容大小为used + 1，底层对扩容大小判断，实际上找的是第一个大于等于used + 1的2^n</span></span><br><span class="line">            <span class="keyword">return</span> dictExpand(d, d-&gt;ht[<span class="number">0</span>].used + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Dict收缩"><code>Dict</code>收缩</h2><div class="note info flat"><ul><li>当负载因子小于<strong>0.1</strong>的时候，就会做哈希表收缩</li></ul></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_hash.c hashTypeDeleted()</span></span><br><span class="line"><span class="keyword">if</span> (dictDelete((dict*)o-&gt;ptr, field) == c_OK)&#123;</span><br><span class="line">    deleted = <span class="number">1</span></span><br><span class="line">    <span class="comment">// 删除成功后，需要检查是否重置Dict大小，如果需要则调用dictResize重置</span></span><br><span class="line">    <span class="keyword">if</span>(htNeedsResize(o-&gt;ptr)) dictResize(o-&gt;ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// server.c </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">htNeedsResize</span><span class="params">(dict *dict)</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> size, used;</span><br><span class="line">    <span class="comment">// 哈希表大小</span></span><br><span class="line">    size = dictSlots(dict);</span><br><span class="line">    <span class="comment">// entry数量</span></span><br><span class="line">    used = dictSize(dict);</span><br><span class="line">    <span class="comment">// size &gt; 4(初始大小)并且负载因此低于0.1</span></span><br><span class="line">    <span class="keyword">return</span> (size&gt;DICT_HT_INITIAL_SIZE &amp;&amp; (used*<span class="number">100</span> / size &lt; HASHTABLE_MIN_FILL));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dictResize</span><span class="params">(dict *d)</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> minimal;</span><br><span class="line">    <span class="comment">// 如果正在做bgsave或者bgrewriteof或者rehash，返回错误</span></span><br><span class="line">    <span class="keyword">if</span>(!dict_can_resize || dictIsRehashing(d)) <span class="keyword">return</span> DICT_ERR;</span><br><span class="line">    <span class="comment">// 获取used，也就是entry个数</span></span><br><span class="line">    minimal = d-&gt;ht[<span class="number">0</span>].used;</span><br><span class="line">    <span class="comment">// 如果used小于4，则重置为4</span></span><br><span class="line">    <span class="keyword">if</span>(minimal &lt; DICT_HT_INITIAL_SIZE) minimal = DICT_HT_INITIAL_SIZE;</span><br><span class="line">    <span class="comment">// 重置大小为minimal，其实是第一个大于等于minimal的2^n</span></span><br><span class="line">    <span class="keyword">return</span> dictExpand(d, minimal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="rehash"><code>rehash</code></h2><div class="note info flat"><p>无论是收缩还是扩容，都会创建新的哈希表，导致哈希表的<code>size</code>和<code>sizemask</code>变化，而<code>key</code>的查询与<code>sizemask</code>有关，因此必须对哈希表中的每一个<code>key</code>重新计算索引，插入新的哈希表，这个过程称为<code>rehash</code></p><ol><li>计算新的哈希表的<code>realeSize</code>，取决于当前做的是扩容还是收缩<ul><li>扩容，则新的<code>size</code>为第一个大于等于<code>dict.ht[0].used + 1</code>的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></li><li>收缩，则新的<code>size</code>为第一个大于等于<code>dict.ht[0].used</code>的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>(不得小于4)</li></ul></li><li>按照新的<code>realeSize</code>申请内存空间，创建<code>dictht</code>，并赋值给<code>dict.ht[1]</code></li><li>设置<code>dict.rehashidx=0</code>表示开始<code>rehash</code></li><li>将<code>dict.ht[0]</code>中的每一个<code>dictEntry</code>都<code>rehash</code>到<code>dict.ht[1]</code></li><li>将<code>dict.ht[1]</code>赋值给<code>dict.ht[0]</code>，给<code>dict.ht[1]</code>初始化为空哈希表，释放原来的<code>dict.ht[0]</code>内存</li></ol></div><h3 id="渐进式rehash">渐进式<code>rehash</code></h3><div class="note info flat"><p>但是这样做，一次完成<code>rehash</code>，则很有可能导致<strong>主线程阻塞</strong>，所以实际上是分多次进行<code>rehash</code>，称为<strong>渐进式</strong><code>rehash</code></p><ol><li>计算新的哈希表的<code>realeSize</code>，取决于当前做的是扩容还是收缩<ul><li>扩容，则新的<code>size</code>为第一个大于等于<code>dict.ht[0].used + 1</code>的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></li><li>收缩，则新的<code>size</code>为第一个大于等于<code>dict.ht[0].used</code>的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>(不得小于4)</li></ul></li><li>按照新的<code>realeSize</code>申请内存空间，创建<code>dictht</code>，并赋值给<code>dict.ht[1]</code></li><li>设置<code>dict.rehashidx=0</code>表示开始<code>rehash</code><br><s>4. 将<code>dict.ht[0]</code>中的每一个<code>dictEntry</code>都<code>rehash</code>到<code>dict.ht[1]</code></s></li><li>每次执行增删改查操作时，检查一下<code>dict.rehashidx</code>是否大于-1，如果是则将<code>dict.ht[0].table[rehashidx]</code>的<code>entry</code>链表<code>rehash</code>到<code>dict.ht[1]</code>，并且将<code>rehashidx ++</code>，直到<code>dict.ht[0]</code>的所有数据都<code>rehash</code>到<code>dict.ht[1]</code></li><li>将<code>dict.ht[1]</code>赋值给<code>dict.ht[0]</code>，给<code>dict.ht[1]</code>初始化为空哈希表，释放原来的<code>dict.ht[0]</code>内存.</li><li>将<code>rehashidx</code>赋值为-1，表示<code>rehash</code>结束</li><li>在<code>rehash</code>过程中，新增操作直接写入<code>ht[1]</code>，查询修改和删除则会在<code>dict.ht[0], dict.ht[1]</code>依次查找并执行，可以确保<code>ht[0]</code>中的数据只减不增，随着<code>rehash</code>最终为空</li></ol></div><h1><code>ZipList</code></h1><div class="note info flat"><ul><li>节省内存</li><li>一种特殊的&quot;双端链表&quot;，实际上<strong>并不是链表</strong>，只是一系列特殊编码的<strong>连续</strong>内存组成的，可以在任意一端进行压入、弹出操作，并且时间复杂度为<code>O(1)</code>的数据结构</li></ul></div><p><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Redis/ziplist.png" alt="ziplist"></p><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">类型</th><th style="text-align:center">长度</th><th style="text-align:center">用途</th></tr></thead><tbody><tr><td style="text-align:center">zlbytes</td><td style="text-align:center">uint32_t</td><td style="text-align:center">4B</td><td style="text-align:center">记录整个压缩列表占用的内存字节数</td></tr><tr><td style="text-align:center">zltail</td><td style="text-align:center">uint32_t</td><td style="text-align:center">4B</td><td style="text-align:center">记录压缩列表表尾节点距离压缩列表的起始地址有多少字节，通过这个偏移量，可以确定尾节点的位置</td></tr><tr><td style="text-align:center">zllen</td><td style="text-align:center">uint16_t</td><td style="text-align:center">2B</td><td style="text-align:center">记录压缩列表包含的节点数量，最大值为UINT16_MAX(65534)，超过这个值会记录为65535，但是节点的真实数量需要遍历整个压缩列表才能计算得出</td></tr><tr><td style="text-align:center">entry</td><td style="text-align:center">列表节点</td><td style="text-align:center">不定</td><td style="text-align:center">压缩列表包含的各个节点，节点长度由节点保存的内容决定</td></tr><tr><td style="text-align:center">zlend</td><td style="text-align:center">uint8_t</td><td style="text-align:center">1B</td><td style="text-align:center">特殊值0xff，用于标记压缩列表的末端</td></tr></tbody></table><h2 id="ZipListEntry"><code>ZipListEntry</code></h2><ul><li>每一个<code>Entry</code>内部又包含了三个部分，分别为  <table>      <tr>          <td>previous_entry_length</td><td>encoding</td><td>content</td>      </tr>  </table></li><li><code>previous_entry_length</code>: 前一个节点的长度，占<code>1 or 5</code>字节<ul><li>如果前一个节点的长度小于254，则采用<code>1B</code>来保存这个长度</li><li>如果前一个字节的长度大于254，则采用<code>5B</code>来保存这个长度，其中第一个字节为<code>0xfe</code>,后面四个字节才是真实长度数据(所以字节的长度不能太大)</li></ul></li><li><code>encoding</code>: 编码属性，记录<code>content</code>的数据类型(字符串还是整数)以及长度，占用1，2，或者5个字节</li><li><code>contents</code>: 负责保存节点的数据，可以是字符串或者整数</li><li>这样可以避免使用两个指针记录前后节点，这样需要消耗16个字节，浪费内存。</li><li>小端存储</li></ul><h2 id="Encoding编码"><code>Encoding</code>编码</h2><h3 id="字符串编码-以00-01-10开头则content为字符串">字符串编码: 以<code>00, 01, 10</code>开头则<code>content</code>为字符串</h3><table><thead><tr><th style="text-align:center">编码</th><th style="text-align:center">编码长度</th><th style="text-align:center">字符串大小</th></tr></thead><tbody><tr><td style="text-align:center">|00pppppp|</td><td style="text-align:center">1B</td><td style="text-align:center">&lt;= 63B</td></tr><tr><td style="text-align:center">|01pppppp|qqqqqqqq|</td><td style="text-align:center">2B</td><td style="text-align:center">&lt;= 16383 B</td></tr><tr><td style="text-align:center">|10000000|qqqqqqqq|rrrrrrrr|ssssssss|tttttttt|</td><td style="text-align:center">5B</td><td style="text-align:center">&lt;= 4294967295B</td></tr></tbody></table><ul><li>例如保存’ab’, ‘bc’:<br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Redis/abbc.png" alt="abbc"></li></ul><h3 id="整数编码-以11开头，则content为整数，并且encoding固定占用一个字节">整数编码: 以<code>11</code>开头，则<code>content</code>为整数，并且<code>encoding</code><strong>固定占用一个字节</strong></h3><table><thead><tr><th style="text-align:center">编码</th><th style="text-align:center">编码长度</th><th style="text-align:center">字符串大小</th></tr></thead><tbody><tr><td style="text-align:center">11000000</td><td style="text-align:center">1</td><td style="text-align:center">int16_t(2B)</td></tr><tr><td style="text-align:center">11010000</td><td style="text-align:center">1</td><td style="text-align:center">int32_t(4B)</td></tr><tr><td style="text-align:center">11100000</td><td style="text-align:center">1</td><td style="text-align:center">int64_t(8B)</td></tr><tr><td style="text-align:center">11110000</td><td style="text-align:center">1</td><td style="text-align:center">24位有符号整数(3B)</td></tr><tr><td style="text-align:center">11111110</td><td style="text-align:center">1</td><td style="text-align:center">8位有符号整数(1B)</td></tr><tr><td style="text-align:center">1111xxxx</td><td style="text-align:center">1</td><td style="text-align:center">直接在xxxx位置保存数值，范围从0001~1101，减一后结果为实际值，实际上保存了(0~12)</td></tr></tbody></table><ul><li>例如保存2, 5:<br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Redis/25.png" alt="25"></li></ul><h2 id="连锁更新问题">连锁更新问题</h2><ul><li>每个<code>entry</code>都包含<code>previous_entry_length</code>来记录上一个节点大小，长度是<code>1 or 5</code>字节<ul><li>假设有<code>N</code>个连续的，长度为<code>250~253</code>字节之间的<code>entry</code>，只需要使用<code>1B</code>即可</li><li>如果在第一个节点插入一个大小为<code>254B</code>的<code>entry</code>，就需要占用<code>5B</code>，此时导致后面的每一个<code>entry</code>大小都恰好达到了<code>254B</code>，导致了每个元素都需要改变<br>最终产生了连续多次空间扩展操作，就是<strong>连锁更新</strong>。新增，删除都有可能导致连锁更新</li></ul></li><li>因为概率很低，所以暂时还没有完全解决。目前有新的<code>listpack</code>可以在一定程度上解决<code>ZipList</code>的连锁更新问题，但是还没有完全引入</li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis笔记_3</title>
      <link href="/posts/afd61732.html"/>
      <url>/posts/afd61732.html</url>
      
        <content type="html"><![CDATA[<h1>传统缓存的问题</h1><p>传统缓存策略是请求到达<code>Tomcat</code>后，先查询<code>Redis</code>，如果未命中则查询数据库:</p><ol><li>请求经过<code>Tomcat</code>处理，性能成为整个系统的瓶颈</li><li><code>Redis</code>缓存失效时，对数据库产生冲击</li></ol><p>多级缓存就是充分利用请求处理每个缓环节，分别添加缓存，减轻<code>Tomcat</code>压力，提升服务性能。</p><h1>缓存分类</h1><ol><li>分布式缓存比如<code>Redis</code>:<ul><li>优点: 存储容量更大，可靠性更好，可以在集群间共享</li><li>缺点: 访问缓存有网络开销</li><li>场景: 缓存数据量较大，可靠性要求较高，需要在集群间共享</li></ul></li><li>进程本地缓存，比如<code>HashMap、GuavaCache</code>:<ul><li>优点: 读取本地内存，没有网络开销，速度更快</li><li>缺点: 存储容量有限，可靠性较低，无法共享</li><li>场景: 性能要求较高，缓存数据量较小</li></ul></li></ol><p><img src="https://gitee.com/sang3112/blog_imgs/raw/98bb67431bb6b9cd36eece37d38e4128f45c9f77/Redis/multicache.jpg" alt="multicache"></p><h1><code>Caffeine</code></h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Cache&lt;String, String&gt; cache = Caffeine.newBuilder().build();</span><br><span class="line">cache.put(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>)</span><br><span class="line"><span class="comment">// 取数据，如果没有则返回NULL，使用较少</span></span><br><span class="line"><span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> cache.getIfPresent(<span class="string">&quot;key&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取数据，如果没有则使用第二个函数，可以查询数据库</span></span><br><span class="line"><span class="type">String</span> <span class="variable">defaultKey</span> <span class="operator">=</span> cache.get(<span class="string">&quot;key&quot;</span>, key-&gt;&#123;</span><br><span class="line">    <span class="comment">// 写查询数据库代码</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="缓存驱逐策略-三种">缓存驱逐策略(三种)</h2><ol><li>基于容量: 设置缓存数量上限<br><code>Cache&lt;String, String&gt; cache = Caffeine.newBuilder().maximumSize(1).build();</code> 设置缓存大小上限为1</li><li>基于时间: 设置缓存的有效时间<br><code>Cache&lt;String, String&gt; cache = Caffeine.newBuilder().expireAfterWrite(Duration.ofSeconds(10)).build();</code> 设置缓存有效期为10秒，从最后一次写入开始计时</li><li>基于引用: 设置缓存为软引用或弱引用，利用<code>GC</code>来回收缓存数据，<strong>性能较差，不建议使用</strong> <div class="note info flat"><ul><li>默认情况下，当一个缓存元素过期时，<code>Caffeine</code><strong>不会</strong>自动立即清理和驱逐，而是在一次读或写操作后，或者在空闲时间完成对失效数据的驱逐。</li></ul></div></li></ol><h2 id="冷启动与缓存预热">冷启动与缓存预热</h2><ul><li>冷启动: 服务刚刚启动时，<code>Redis</code>没有缓存，如果数据都在第一次查询时添加缓存，可能会给数据库带来较大的压力</li><li>缓存预热: 实际开发中，可以利用<strong>大数据统计</strong>用户访问的<strong>热点数据</strong>，项目启动时将这些<strong>热点数据</strong>提前查询并保存到<code>Redis</code>中。如果数据量较少，就直接在启动时将所有的数据都放入<code>Redis</code></li></ul><h2 id="缓存同步策略">缓存同步策略</h2><table><thead><tr><th style="text-align:center">同步策略</th><th style="text-align:center">设置有效期</th><th style="text-align:center">同步双写</th><th style="text-align:center">异步通知</th></tr></thead><tbody><tr><td style="text-align:center">含义</td><td style="text-align:center">给缓存设置有效期，到期自动删除，再次查询时更新</td><td style="text-align:center">修改数据库的同时，直接修改缓存(使用同一个事务实现)</td><td style="text-align:center">修改数据库时发送事件通知，相关服务监听通知后修改缓存数据 (常用) (MQ, Canal)</td></tr><tr><td style="text-align:center">优点</td><td style="text-align:center">简单，方便</td><td style="text-align:center">时效性强，缓存和数据库强一致性</td><td style="text-align:center">低耦合，可以同时通知多个缓存服务</td></tr><tr><td style="text-align:center">缺点</td><td style="text-align:center">时效性差，缓存过期之前可能数据不一致</td><td style="text-align:center">有代码侵入风险，耦合度高</td><td style="text-align:center">时效性一般，可能存在中间不一致状态</td></tr><tr><td style="text-align:center">使用场景</td><td style="text-align:center">更新频率较低，适合时效性要求低的业务</td><td style="text-align:center">对一致性、时效性要求较高的缓存数据</td><td style="text-align:center">时效性要求一般，有多个服务需要同步</td></tr></tbody></table><h3 id="基于MQ实现异步通知">基于<code>MQ</code>实现异步通知</h3><p><img src="https://gitee.com/sang3112/blog_imgs/raw/98bb67431bb6b9cd36eece37d38e4128f45c9f77/Redis/MQ.png" alt="MQ"></p><h3 id="基于Canal实现异步通知">基于<code>Canal</code>实现异步通知</h3><p><img src="https://gitee.com/sang3112/blog_imgs/raw/98bb67431bb6b9cd36eece37d38e4128f45c9f77/Redis/Canal.png" alt="Canal"></p><div class="note info flat"><ul><li>基于<code>Canal</code>，比<code>MQ</code>更好一些，时效性更强，监听效率更高，基于主从同步实现</li><li><code>Canal</code>把自己伪装成<code>MySQL</code>的一个<code>slave</code>，监听<code>master</code>的<code>binlog</code>变化，再把得到的变化信息通知给<code>Canal</code>客户端，完成对其他数据库的同步</li></ul></div><h1><code>Redis</code>设计</h1><h2 id="key设计"><code>key</code>设计</h2><ol><li>遵循基本格式: <code>[业务名称]:[数据名]:[id]</code></li><li>长度不要超过44Bytes</li><li>不包含特殊字符</li></ol><div class="note info flat"><ul><li>比如登录业务，保存用户信息，设计<code>key</code>就是: <code>login:user:10</code></li><li>长度越小占用的空间越少，所以<code>key</code>满足可读性，应该尽可能短</li></ul></div><div class="note info flat"><p>好处:</p><ol><li>可读性强</li><li>避免<code>key</code>冲突</li><li>方便管理</li><li>更节省内存，<code>key</code>是<code>string</code>，底层编码包含<code>int、embstr、raw</code>，其中<code>embstr</code>是一块连续空间，占用空间更少，更加紧凑。但是<code>embstr</code>需要在<code>key</code>小于44B使用</li></ol></div><h2 id="value设计"><code>value</code>设计</h2><div class="note info flat"><ul><li><code>BigKey</code>，通常以<code>Key</code>的大小和<code>Key</code>中成员的数量来总和判定，比如:<ul><li><code>Key</code>本身数据量过大，一个<code>String</code>类型的<code>Key</code>，它的值为5MB</li><li><code>Key</code>中的成员数目过多，一个<code>ZSET</code>类型的<code>Key</code>，它的成员数量为10000个</li><li><code>Key</code>中的成员数据量过大，一个<code>Hash</code>类型的<code>Key</code>，成员数量虽然只有1000个，但是这些<code>Value</code>的总大小为100MB</li></ul></li></ul></div><ul><li><p><code>BigKey</code>危害:</p><ol><li>网络阻塞: 对<code>BigKey</code>读请求，少量的<code>QPS</code>就会导致带宽使用率被占满，导致<code>Redis</code>实例，乃至物理机变慢</li><li>数据倾斜: <code>BigKey</code>所在的<code>Redis</code>实例内存使用率远超其他实例，无法使数据分片的内存资源达到均衡</li><li><code>Redis</code>阻塞: 对元素较多的<code>hash, list, zset</code>等做运算会耗时较久，使主线程阻塞</li><li><code>CPU</code>压力: 对<code>BigKey</code>的数据序列化和反序列化都会导致<code>CPU</code>的使用率飙升，影响<code>Redis</code>实例和本机其他应用</li></ol></li><li><p>如何发现<code>BigKey</code>:</p><ol><li><code>redis-cli --bigkeys</code>: 利用<code>redis-cli</code>提供的<code>--bigkeys</code>，分析所有的key，返回<code>Key</code>整体统计信息与每个数据最大的<code>Big Key</code></li><li><code>scan</code>扫描: 自己编程利用<code>scan</code>扫描<code>Redis</code>中所有的<code>Key</code>，利用<code>strlen, hlen</code>等命令判断长度，不建议使用<code>memory usage</code>，因为这个命令对<code>CPU</code>占用较高</li><li>第三方工具，比如<code>Redis-Rdb-Tools</code>分析<code>RDB</code>快照，全面分析内存使用</li><li>网络监控: 自定义工具，监控进入<code>Redis</code>网络数据，超出预警值主动告警</li></ol></li></ul><div class="note info flat"><ul><li>推荐做法<ol><li>单个<code>key</code>的<code>value</code>小于<code>10KB</code></li><li>对于集合类型的<code>Key</code>，建议元素数量小于1000</li><li>使用<code>unlink</code>异步删除<code>BIGKEY</code></li></ol></li></ul></div><h2 id="恰当的数据类型">恰当的数据类型</h2><p>存储一个<code>User</code>对象，有三种方法:</p><ol><li><p><code>Json</code>字符串</p> <table>     <tr>         <td>user:1</td><td>{"name": "Jack", "age": 21}</td>     </tr> </table><ul><li>优点: 实现简单粗暴</li><li>缺点: 数据耦合不够灵活</li></ul></li><li><p>字段打散</p> <table>     <tr>         <!-- <td rowspan="">数值</td> -->         <td>user:1:name</td><td>Jack</td>     </tr>     <tr>         <td>user:1:age</td><td>21</td>     </tr> </table><ul><li>优点: 可以灵活访问对象任意字段</li><li>缺点: 占用空间大，没有办法做统一控制</li></ul></li><li><p>hash</p> <table>     <tr>         <td rowspan="2">user:1</td>         <td>name</td><td>age</td>     </tr>     <tr>         <td>jack</td><td>21</td>     </tr> </table><ul><li>优点: 底层使用<code>ziplist</code>，占用空间小，可以灵活访问对象的任意字段</li><li>缺点: 代码相对复杂</li></ul></li></ol><div class="note info flat"><ul><li>假如有<code>hash</code>类型的<code>key</code>，其中有100万对<code>field, value</code>，其中<code>field</code>是自增id，这个<code>key</code>有什么问题，如何优化?<ul><li>存在的问题:<ol><li><code>hash</code>的<code>entry</code>数量超过500时，会使用哈希表，而不是<code>ZipList</code>，内存占用较多</li></ol></li><li>优化:<ol><li>可以通过<code>hash-max-ziplist-entries</code>配置<code>entry</code>上限，但是如果<code>entry</code>过多就会导致<code>BigKey</code>问题</li><li>拆分为<code>string</code>类型: 但是<code>string</code>底层没有太多内存优化，内存占用较多；想要批量获取这些数据比较麻烦</li><li>拆分为小的<code>hash</code>，将<code>id/100</code>作为<code>key</code>，将<code>id % 100</code>作为<code>field</code>，这样每一百个元素就是一个<code>hash</code></li></ol></li></ul></li></ul></div><div class="note info flat"><ul><li>推荐做法<ol><li>合理拆分数据，拒绝<code>BigKey</code></li><li>选择合适的数据结构</li><li><code>Hash</code>结构的<code>entry</code>数量不要超过1000</li><li>设置合理的超时时间</li></ol></li></ul></div><h2 id="批处理">批处理</h2><ul><li><p><code>Redis</code>的处理速度非常快，消耗的时间绝大部分都是在网络传输中消耗。</p></li><li><p>所以可以一次性传输多条数据，但是不能传输太多命令，否则这样单次命令占用的带宽过多，会导致网络阻塞</p></li><li><p><code>mset</code>只能处理<code>string</code>类型的，<code>hmset</code>, <code>sadd</code>都只能处理相同的<code>key</code>，所以有缺陷，因此需要实现<code>pipeline</code></p></li><li><p><code>pipeline</code>可以处理复杂类型，但是<code>pipeline</code>的多个命令之间<strong>不具备原子性</strong></p></li><li><p>如果<code>mset</code>或者<code>pipeline</code>这样的批处理需要在一次请求中携带多条命令，并且此时<code>Redis</code>是一个集群，那么批处理的多个<code>key</code>必须在同一个<code>slot</code>中，否则执行失败。</p></li></ul><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">串行命令</th><th style="text-align:center">串行slot</th><th style="text-align:center">并行slot</th><th style="text-align:center">hash_tag</th></tr></thead><tbody><tr><td style="text-align:center">实现思路</td><td style="text-align:center">for循环遍历，依次执行每个命令</td><td style="text-align:center">在客户端计算每个key的slot，将slot一致分为一组，每组都利用pipeline批处理，串行执行各组命令</td><td style="text-align:center">在客户算计算每个key的slot，每组都利用pipeline批处理，并行执行各组命令</td><td style="text-align:center">将所有的key都设置相同的hash_tag，则所有key的slot都一定相同</td></tr><tr><td style="text-align:center">耗时</td><td style="text-align:center">N次网络耗时+N次命令耗时</td><td style="text-align:center">m次网络耗时+N次命令耗时，m = key的slot个数</td><td style="text-align:center">1次网络耗时+N次命令耗时</td><td style="text-align:center">1次网络耗时+N次命令耗时</td></tr><tr><td style="text-align:center">优点</td><td style="text-align:center">实现简单</td><td style="text-align:center">耗时较短</td><td style="text-align:center">耗时非常短</td><td style="text-align:center">耗时非常短、实现简单</td></tr><tr><td style="text-align:center">缺点</td><td style="text-align:center">耗时非常久</td><td style="text-align:center">实现稍复杂，slot越多，耗时越久</td><td style="text-align:center">实现复杂(用的较多)</td><td style="text-align:center">容易出现数据倾斜(所以不怎么用，虽然性能好)</td></tr></tbody></table><h2 id="持久化配置">持久化配置</h2><ul><li>保证数据安全，但是会带来额外的开销</li></ul><div class="note info flat"><ul><li>推荐做法<ol><li><p>用来做缓存的<code>Redis</code>实例尽量不要开启持久化功能，放在一个单独实例里面，就不要开启持久化了</p></li><li><p>建议关闭<code>RDB</code>持久化功能，使用<code>AOF</code>持久化，因为<code>AOF</code>每秒刷盘</p></li><li><p>利用脚本定期在<code>slave</code>节点做<code>RDB</code>，实现数据备份。(也不建议频繁做)</p></li><li><p>设置合理的<code>rewrite</code>阈值，避免频繁的<code>bgrewrite</code></p></li><li><p>配置<code>no-appendfsync-on-rewrite=yes</code>，禁止在<code>rewrite</code>期间做<code>AOF</code>，避免因为<code>AOF</code>引起的阻塞。但是这部分期间，没有做<code>AOF</code>，所以有可能有数据的丢失，这需要看自己是关注可用性还是持久性</p></li><li><p><code>Redis</code>实例的物理机需要留足够的内存，应对<code>fork</code>和<code>rewrite</code></p></li><li><p>单个<code>Redis</code>实例内存上限不要太大，比如4G或8G，可以加快<code>fork</code>的速度，减少主从同步，数据迁移压力</p></li><li><p>不要与CPU密集型应用部署在一起，比如<code>ES</code></p></li><li><p>不要与高硬盘负载应用部署在一起，比如数据库，消息队列</p></li></ol></li></ul></div><h2 id="慢查询">慢查询</h2><ul><li>只要执行时间超时了，不管是是不是查询语句，都是慢查询</li><li><code>slowlog-log-slower-than</code>: 慢查询阈值，单位是微秒，默认是10000，建议配置成1000</li><li>慢查询会放入慢查询日志中，日志长度有上限，可以通过配置指定<code>slowlog-max-len</code>，本质是一个队列的长度，默认是129，建议配置成1000，并且需要及时处理</li><li><code>slowlog len</code>: 查询慢查询日志长度</li><li><code>slowlog get[n]</code>: 读取n条慢查询日志</li><li><code>slowlog reset</code>: 清空慢查询列表</li></ul><h2 id="安全性问题">安全性问题</h2><ol><li><code>Redis</code>一定要设置密码</li><li>禁止线上使用<code>keys , flushall, flushdb, config set</code>命令，可以利用<code>rename-command</code>禁用</li><li><code>bind</code>: 限制网卡，禁止外网网卡访问</li><li>开启防火墙</li><li>不要使用<code>root</code>账户启动<code>Redis</code></li><li>尽量不是默认的端口</li></ol><h2 id="内存配置">内存配置</h2><ul><li><p>内存不足会导致<code>Key</code>频繁被删除，响应时间变长，QPS不稳定，当内存使用率达到90%以上就需要警惕了，并快速定位到内存占用的原因</p><table><thead><tr><th style="text-align:center">内存占用</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">数据内存</td><td style="text-align:center">是Redis最主要的部分，存储Redis键值信息，主要是BigKey问题，内存碎片问题</td></tr><tr><td style="text-align:center">进程内存</td><td style="text-align:center">Redis本身运行肯定占用内存，比如代码，常量池，大约几兆，大多数生产环境中与Redis数据占用的内存相比可以忽略</td></tr><tr><td style="text-align:center">缓冲区内存</td><td style="text-align:center">一般包括客户端缓冲区，AOF缓冲区，复制缓冲区等，客户端缓冲区又包括输入缓冲区和输出缓冲区。这部分内存占用波动较大，不当使用BigKey，可能导致内存溢出</td></tr></tbody></table></li><li><p>复制缓冲区: 主从复制的<code>repl_backlog_buf</code>，如果太小可能导致频繁的全量复制，影响性能，通过<code>repl-backlog-size</code>设置，默认1M</p></li><li><p>AOF缓冲区: AOF刷盘之前的缓冲区，执行<code>rewrite</code>的缓冲区，无法设置容量上限</p></li><li><p>客户端缓冲区: 分为输入缓冲区和输出缓冲区，输入缓冲区最大1G不能设置，输出缓冲区可以设置</p></li></ul><h2 id="集群">集群</h2><h3 id="完整性配置">完整性配置</h3><ul><li><code>Redis</code>配置中，发现任意一个插槽不可用，则整个集群都停止对外服务。</li><li>为了保证高可用性，建议将<code>cluster-require-full-coverage</code>配置为<code>no</code>，默认是<code>yes</code></li></ul><h3 id="带宽问题">带宽问题</h3><ul><li><p>集群节点之间会不断的互相<code>ping</code>来确定集群中其他节点的状态，每次<code>ping</code>携带的信息至少包括</p><ul><li>插槽信息</li><li>集群状态信息</li></ul></li><li><p>集群中节点越多，集群状态信息数据量也就越大，10个节点的相关信息可能达到1kb，此时每次集群互通需要的带宽会非常高</p></li><li><p>解决办法:</p><ol><li>避免大集群，集群节点数不要太多，最好少于1000，如果业务庞大，则需要建立多个集群</li><li>避免在单个物理机中运行太多<code>Redis</code>实例</li><li>配置合适的<code>cluster-node-timeout</code></li></ol></li></ul><h3 id="集群问题">集群问题</h3><ol><li>完整性问题</li><li>带宽问题</li><li>数据倾斜问题</li><li>客户端性能问题</li><li>命令的集群兼容性问题</li><li>lua和事务问题(集群模式下没有办法使用lua和事务)</li></ol><div class="note info flat"><ul><li>满足需求的前提下，能不使用集群就不用集群。因为单体主从<code>Redis</code>已经能达到<strong>万级QPS</strong>，已经能满足大部分需求了</li></ul></div>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis笔记_2</title>
      <link href="/posts/d8d127a4.html"/>
      <url>/posts/d8d127a4.html</url>
      
        <content type="html"><![CDATA[<h1>数据持久化</h1><h2 id="RDB"><code>RDB</code></h2><div class="note info flat"><ul><li><code>Redis Database Backup file</code>(<code>Redis</code>数据备份文件)，也叫做<code>Redis</code>数据快照。把内存中的所有数据都记录到磁盘中，故障重启后，从磁盘读取快照文件，恢复数据。</li><li><code>RDB</code>文件称为快照文件，默认保存当前运行目录</li></ul></div><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis-cli</span><br><span class="line">save # 使用save命令来进行快照保存，由Redis主进程执行RDB，阻塞所有命令</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">所以一般不使用save，Redis在停机退出的时候会自动执行save，再次启动会读取RDB，实现默认的持久化</span></span><br><span class="line">bgsave # 开启子进程执行RDB，避免主进程受到影响</span><br></pre></td></tr></table></figure><ul><li><code>redis.conf</code>配置<code>RDB</code>机制</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">save 900 1 # 表示如果900s内至少有1个key被修改，则执行bgsave</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000 </span><br><span class="line"># 如果是save &quot;&quot; 表示禁用RDB</span><br><span class="line"></span><br><span class="line">rdbcompression yes # 是否压缩，建议不开启，因为压缩也会消耗CPU</span><br><span class="line">dbfilename dump.rdb # RDB文件名称</span><br><span class="line">dir ./ # 文件保存路径目录</span><br></pre></td></tr></table></figure><div class="note info flat"><ul><li><code>RDB</code>的<code>bgsave</code>开始时会<code>fork</code>主进程得到子进程，子进程共享主进程的内存数据。完成<code>fork</code>后读取内存数据并写入<code>RDB</code>文件</li><li>但是<code>fork</code>的过程是阻塞的，主进程此时不能处理别的请求。所以要加快<code>fork</code>过程</li></ul></div><ul><li>主进程操作虚拟内存，虚拟内存根据页表的映射关系到物理内存中真正的数据</li><li><code>fork</code>仅仅是把页表做拷贝，即对映射关系做拷贝，因此子进程可以读取相同的数据，写入行的<code>RDB</code>文件</li><li>为了避免在子进程读的时候主进程写，<code>fork</code>采用的是<code>copy-on-write</code>技术<ul><li>主要是将物理内存标记成<code>read-only</code></li><li>主进程读，则访问共享内存</li><li>主进程写，则拷贝一份数据，对副本执行写操作，写完后页表映射关系修改到副本</li><li>极端情况下就是所有数据都要拷贝一份，内存翻倍。所以一般情况下<code>Redis</code>需要预留内存<br><img src="https://gitee.com/sang3112/blog_imgs/raw/dffcbbcd0438066a55be0c2d47d6caf381416a6f/Redis/copyonwrite.png" alt="copyonwrite"></li></ul></li></ul><div class="note info flat"><ul><li><p><code>RDB</code>方式<code>bgsave</code>的基本流程</p><ul><li><code>fork</code>主进程得到一个子进程，共享内存空间</li><li>子进程读取内存数据并写入新的<code>RDB</code>文件</li><li>用新的<code>RDB</code>文件替换旧的<code>RDB</code>文件</li></ul></li><li><p><code>RDB</code>缺点</p><ul><li><code>RDB</code>执行间隔时间长，两次<code>RDB</code>之间写入数据有丢失风险</li><li><code>fork</code>子进程、压缩、写出<code>RDB</code>文件比较耗时</li></ul></li></ul></div><h2 id="AOF"><code>AOF</code></h2><div class="note info flat"><ul><li><code>Apppend Only File</code>(追加文件)，每一个写命令都会记录在<code>AOF</code>中，可以看作是命令日志文件</li><li>默认关闭</li></ul></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes # 是否开启AOF功能，默认为no</span><br><span class="line">appendfilename &quot;appendonly.aof&quot; # AOF文件名</span><br><span class="line"></span><br><span class="line">appendfsync always # 每次执行一次写命令，立即记录到AOF文件中</span><br><span class="line">appendfsync everysec # 写命令执行完写放入AOF缓存，每隔1s将缓冲区数据写到AOF文件，默认方案</span><br><span class="line">appendfsync no # 写命令执行完先放入AOF缓存，操作系统决定何时将缓冲区内容写回磁盘</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">配置项</th><th style="text-align:center">刷盘时机</th><th style="text-align:center">优点</th><th style="text-align:center">缺点</th></tr></thead><tbody><tr><td style="text-align:center">always</td><td style="text-align:center">同步刷盘</td><td style="text-align:center">可靠性高，几乎不丢数据</td><td style="text-align:center">性能影响大</td></tr><tr><td style="text-align:center">everysec</td><td style="text-align:center">每秒刷盘</td><td style="text-align:center">性能适中</td><td style="text-align:center">最多丢失1s数据</td></tr><tr><td style="text-align:center">no</td><td style="text-align:center">操作系统控制</td><td style="text-align:center">性能最好</td><td style="text-align:center">可靠性较差，可能丢失大量数据</td></tr></tbody></table><div class="note info flat"><ul><li>因为同时记录了命令和数据，所以<code>AOF</code>会比<code>RDB</code>文件大很多，并且会记录同一个<code>key</code>的多次写操作，但是只有最后一次的写才有意义，因此可以执行<code>bgrewriteaof</code>命令，让<code>AOF</code>执行重写，用最少的命令达到原来操作相同的结果</li><li>可以在<code>redis.conf</code>中配置<code>AOF</code>重写机制</li></ul></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto-aof-rewrite-percentage 100 # AOF文件比上次文件增占了多少百分比则触发重写</span><br><span class="line">auto-aof-rewrite-min-size 64mb # AOF文件体积最小多大以上才触发重写</span><br></pre></td></tr></table></figure><h2 id="RDB-VS-AOF"><code>RDB</code> VS <code>AOF</code></h2><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">RDB</th><th style="text-align:center">AOF</th></tr></thead><tbody><tr><td style="text-align:center">持久化方式</td><td style="text-align:center">定时对整个内存快照</td><td style="text-align:center">记录每次执行命令</td></tr><tr><td style="text-align:center">数据完整性</td><td style="text-align:center">不完整，两次备份之间会丢失</td><td style="text-align:center">相对完整，取决于刷盘策略</td></tr><tr><td style="text-align:center">文件大小</td><td style="text-align:center">会有压缩，文件体积小</td><td style="text-align:center">记录命令，文件体积大</td></tr><tr><td style="text-align:center">宕机恢复速度</td><td style="text-align:center">很快</td><td style="text-align:center">慢</td></tr><tr><td style="text-align:center">数据恢复优先级</td><td style="text-align:center">低，因为数据完整性不如AOF</td><td style="text-align:center">高，因为数据完整性更高</td></tr><tr><td style="text-align:center">系统资源占用</td><td style="text-align:center">高，大量CPU和内存消耗</td><td style="text-align:center">低，主要是磁盘IO资源，但是AOF重写会占用大量的CPU和内存资源</td></tr><tr><td style="text-align:center">使用场景</td><td style="text-align:center">可以容忍数分钟的数据丢失，更快启动速度</td><td style="text-align:center">对数据安全性要求较高时常见</td></tr></tbody></table><h1><code>Redis</code>主从集群</h1><ul><li>单节点<code>Redis</code>并发能力有上限，进一步提高<code>Redis</code>的并发能力，就需要搭建主从集群，实现读写分离</li><li>启动三个<code>Redis</code>服务，需要配置三台主从关系<ul><li>临时配置: <code>replicaof &lt;masterip&gt; &lt;masterport&gt;</code></li><li>永久配置: 在<code>redis.conf</code>中添加一行: <code>replicaof &lt;masterip&gt; &lt;masterport&gt;</code></li></ul></li></ul><h2 id="数据同步原理">数据同步原理</h2><ul><li>主从第一次同步是全量同步，<code>slave</code>重启后同步，则执行增量同步</li><li>如何判断是否第一次同步:<ul><li><code>replication ID</code>: 简称<code>replid</code>是数据集的标记，<code>ID</code>一致则说明是同一个数据集，每个<code>master</code>都有唯一的<code>replid</code>,<code>slave</code>则会继承<code>master</code>节点的<code>replid</code></li><li><code>offset</code>偏移量，随着记录在<code>repl_baklog</code>中的数据增多而逐渐增大，<code>slave</code>完成同步时也会记录当前同步的<code>offset</code>，如果<code>slave</code>的<code>offset</code>小于<code>master</code>的<code>offset</code>，则说明<code>slave</code>数据落后于<code>master</code>，需要更新</li><li>基于<code>replid</code>判断主从是否一致，如果不一致则表明是第一次同步</li></ul></li></ul><p><img src="https://gitee.com/sang3112/blog_imgs/raw/dffcbbcd0438066a55be0c2d47d6caf381416a6f/Redis/first.png" alt="first"></p><div class="note info flat"><p>全量同步的流程:</p><ol><li><code>slave</code>节点请求增量同步</li><li><code>master</code>节点判断<code>replid</code>，不一致，则拒绝增量同步</li><li><code>master</code>将完整内存数据生成<code>RDB</code>，发送到<code>slave</code></li><li><code>slave</code>清空本地数据，加载<code>master</code>的<code>RDB</code></li><li><code>master</code>将<code>RDB</code>期间的命令记录在<code>repl_backlog</code>，持续将<code>log</code>中的命令发送给<code>slave</code></li><li><code>slave</code>执行接收到的命令，保持与<code>master</code>之间的同步</li></ol></div><p><img src="https://gitee.com/sang3112/blog_imgs/raw/dffcbbcd0438066a55be0c2d47d6caf381416a6f/Redis/second.png" alt="second"></p><ul><li><code>repl_baklog</code>大小有上限，写满后会覆盖最早的数据，如果<code>slave</code>断开时间过久，导致尚未备份的数据被覆盖，则无法基于<code>log</code>做增量同步，只能再次进行全量同步</li></ul><div class="note info flat"><p>优化主从集群:</p><ol><li>在<code>master</code>中配置<code>repl-diskless-sync yes</code>启用无磁盘复制，避免全量同步时的磁盘IO(一般是用于磁盘比较慢，但是网络较快的场景)</li><li><code>Redis</code>单节点上的内存占用不要太大，减少<code>RDB</code>导致的过多的磁盘IO</li><li>减少全量同步的次数: 提高<code>repl_baklog</code>的大小，发现<code>slave</code>宕机则尽快实现故障恢复，避免全量同步</li><li>限制一个<code>master</code>上的<code>slave</code>数量，如果很多<code>slave</code>则使用主从从的链式结构，减少<code>master</code>压力</li></ol></div><div class="note info flat"><p>增量同步 VS 全量同步</p><ol><li>全量同步: <code>master</code>将完整内存数据生成<code>RDB</code>，发送到<code>slave</code>，后续命令记录在<code>repl_baklog</code>中，逐个发送给<code>slave</code></li><li>增量同步: <code>slave</code>提交自己的<code>offset</code>到<code>master</code>，获取<code>repl_baklog</code>中从<code>offset</code>之后的命令给<code>slave</code></li></ol></div><h2 id="哨兵Sentinel">哨兵<code>Sentinel</code></h2><h3 id="作用">作用</h3><ol><li>监控: <code>Sentinel</code>不断检查<code>master</code>和<code>slave</code>是否按照预期工作</li><li>自动故障恢复: 如果<code>master</code>故障，则<code>Sentinel</code>将<code>slave</code>提升为<code>master</code>，故障实例恢复后也会以新的<code>master</code>为主</li><li>通知: <code>Sentinel</code>充当<code>Redis</code>客户端的服务发现来源，集群发生故障转移时，将最新的信息推送给<code>Redis</code>客户端</li></ol><h3 id="判断Redis是否健康">判断<code>Redis</code>是否健康</h3><p>基于心跳机制监测服务状态，每隔1s向集群的每个实例发送<code>PING</code>命令:</p><ul><li>主观下线<code>sdown</code>: 某个<code>sentinel</code>发现节点实例没有在规定时间内响应，则认为其主观下线</li><li>客观下线<code>odown</code>: 超过指定数量<code>quorum</code>的<code>sentinel</code>都认为该实例主观下线，则其客观下线，<code>quorum</code>最好超过<code>sentinel</code>的一半</li></ul><h3 id="主从切换选择依据">主从切换选择依据</h3><ol><li>判断<code>slave</code>节点与<code>master</code>节点断开时间长短，超过指定值<code>down-after-milliseconds * 10</code>会排除该<code>slave</code>节点</li><li>判断<code>slave</code>节点的<code>slave-prority</code>越小优先级越高，如果为0则永不选举</li><li>如果<code>slave-prority</code>则判断<code>slave</code>的<code>offset</code>值，越大越新，优先级越高</li><li>最后判断<code>slave</code>节点的运行<code>ID</code>大小，越小优先级越高</li></ol><h3 id="故障转移">故障转移</h3><ol><li><code>sentinel</code>给<code>slave1</code>发送<code>slaveof no one</code> ，让节点称为<code>master</code></li><li><code>sentinel</code>给其他<code>slave</code>发送<code>slaveof ip port</code>命令，让这些<code>slave</code>称为新的<code>master</code>从节点，开始从新的<code>master</code>上同步数据</li><li><code>sentinel</code>将故障节点标记为<code>slave</code>，故障节点恢复后悔自动成为新的<code>master</code>的<code>slave</code></li></ol><h1><code>Redis</code>分片集群</h1><div class="note info flat"><p>主从集群的问题:</p><ol><li>海量数据存储</li><li>高并发写</li></ol></div><h2 id="分片集群特征">分片集群特征</h2><ol><li>集群中有多个<code>master</code>，每个<code>master</code>保存不同数据(并发写)</li><li>每个<code>master</code>可以有多个<code>slave</code>(并发读)</li><li><code>master</code>通过<code>PING</code>监测彼此健康状态</li><li>客户端请求可以访问集群的任意节点，最终都会被转发到正确的节点<br><img src="https://gitee.com/sang3112/blog_imgs/raw/dffcbbcd0438066a55be0c2d47d6caf381416a6f/Redis/Clustering.png" alt="cluster"></li></ol><div class="note info flat"><p><code>Redis</code>会把每一个<code>master</code>映射到0~16383共16384个<code>hash slot</code>上，查看集群信息就可以看到<br>数据<code>key</code>不是与节点绑定，而是与插槽绑定。<code>redis</code>会根据<code>key</code>的有效部分计算插槽值，分两种情况</p><ul><li><code>key</code>中包含&quot;{}“，且”{}“中至少包含一个字符，”{}&quot;中的部分是有效部分</li><li><code>key</code>中国不包含&quot;{}&quot;，整个<code>key</code>都是有效部分<br>利用<code>CRC16</code>算法得到一个哈希值，然后对16384取余，得到的结果就是<code>slot</code>值<br>如何将同一类数据固定的保存在同一个<code>Redis</code>实例中:</li><li>这一类数据使用相同的有效部分，比如<code>key</code>都以<code>{typeID}</code>为前缀</li></ul></div><h2 id="故障转移-2">故障转移</h2><p>集群中一个<code>master</code>宕机会发生什么?</p><ol><li>实例与其他实例失去链接</li><li>疑似宕机</li><li>确定下线，自动提升一个<code>slave</code>成为新的<code>master</code></li></ol><h2 id="数据迁移">数据迁移</h2><ul><li>利用<code>cluster failover</code>命令可以手动让集群中的某个<code>master</code>宕机，切换到执行<code>cluster failover</code>命令的这个<code>slave</code>及诶单，实现无感知的数据迁移，具体流程为:<br><img src="https://gitee.com/sang3112/blog_imgs/raw/dffcbbcd0438066a55be0c2d47d6caf381416a6f/Redis/movedate.png" alt="movedata"></li><li>手动的<code>failover</code>支持三种不同的模式:<ul><li>默认的流程，例如1~6</li><li><code>force</code>省略了对<code>offset</code>的一致性校验</li><li><code>takeover</code>直接执行第五步，忽略数据一致性，忽略<code>master</code>状态和其他<code>master</code>意见</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis笔记_1</title>
      <link href="/posts/41d8761e.html"/>
      <url>/posts/41d8761e.html</url>
      
        <content type="html"><![CDATA[<div class="note info flat"><p>全局唯一<code>ID</code>: 经常会需要全局唯一<code>ID</code>，比如订单表的生成。因为</p><ul><li>如果<code>ID</code>自增，则规律性太明显</li><li>并且表中可能存在大量的数据，会受到表单数据量的限制</li></ul></div><div class="note info flat"><p>全局唯一<code>ID</code>生成器特性:</p><ol><li>唯一性</li><li>高可用</li><li>高性能</li><li>递增性</li><li>安全性</li></ol></div><h1>超卖问题</h1><ul><li>原本库存为1，线程1查询后发现库存满足要求。要去扣除库存，但在此之前，线程2，线程3同时查询，发现库存充足。同样满足扣除库存的要求，此时产生了超卖问题</li><li><img src="https://gitee.com/sang3112/blog_imgs/raw/4de21bf55caff74e4e42766859d0389dca4b4b93/Redis/oversell.png" alt="oversell"></li></ul><h2 id="解决方法-加锁">解决方法: 加锁</h2><ol><li><p>乐观锁: 认为线程安全问题不一定发生，因此不加锁，只是在<strong>更新数据时判断有没有其他线程对数据进行了修改</strong></p><ul><li>如果没有修改则认为自己安全，才能更新数据</li><li>如果已经被其他线程修改说明发生了安全问题，此时重试或返回异常</li></ul></li><li><p>悲观锁: 认为线程安全问题一定会发生，因此操作数据之前先获取数据，确保线程串行执行。(性能差)</p><ul><li>比如<code>Synchronized、Lock</code>都是悲观锁</li></ul></li></ol><h3 id="乐观锁">乐观锁</h3><ol><li>版本号法<ul><li>用版本标识数据更新，如果版本<code>version</code>更新了，则表示数据已经被更新了。</li></ul></li><li>CAS法<ul><li>用之前查询到的数据判断是否存在相同的数据，如果不存在，则表示数据已经更新。实际上就是简化了版本字段。</li></ul></li></ol><div class="note info flat"><p>这样存在问题，因为如果有一百个线程，初始情况下<code>stock=100</code>，第一个线程首先执行查询，满足，然后修改数据库<code>stock - 1</code>。在修改数据库之前，其他线程查询<code>stock=100</code>，也满足查询条件，但是实际上查询数据库只有<code>stock=99</code>了，发现被修改了，因此直接错误退出。<br>所以应该使用<code>stock&gt;0</code>而不是等于前一个值</p></div><h1>分布式锁</h1><div class="note info flat"><ul><li>满足分布式系统或集群模式下<strong>多进程可见</strong>并且<strong>互斥的锁</strong></li></ul></div><h2 id="要求">要求</h2><ol><li>多进程可见即所有<code>JVM</code>可见</li><li>互斥</li><li>高可用</li><li>高性能</li><li>安全性</li></ol><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">MySQL</th><th style="text-align:center">Redis</th><th style="text-align:center">Zookeeper</th></tr></thead><tbody><tr><td style="text-align:center">互斥</td><td style="text-align:center">利用MySQL本身互斥锁机制</td><td style="text-align:center">利用SETNX互斥命令</td><td style="text-align:center">利用节点的唯一性和有序性实现互斥</td></tr><tr><td style="text-align:center">高可用</td><td style="text-align:center">好</td><td style="text-align:center">好</td><td style="text-align:center">好</td></tr><tr><td style="text-align:center">高性能</td><td style="text-align:center">一般</td><td style="text-align:center">好</td><td style="text-align:center">一般</td></tr><tr><td style="text-align:center">安全性</td><td style="text-align:center">断开连接，自动释放锁</td><td style="text-align:center">利用锁超市时间，到期释放</td><td style="text-align:center">临时节点，断开连接自动释放</td></tr></tbody></table><h2 id="基于Redis的分布式锁">基于<code>Redis</code>的分布式锁</h2><div class="note info flat"><p>分布式锁需要实现两个方法：获取锁和释放锁</p></div><p><img src="https://gitee.com/sang3112/blog_imgs/raw/4de21bf55caff74e4e42766859d0389dca4b4b93/Redis/distributedlock.png" alt="distributedlock"></p><ol><li>获取锁<ul><li>互斥: 确保只有一个线程能够获取锁<code>setnx lock thread1</code>，<code>expire lock 5</code></li><li>但是上面这种两条语句的方法不是原子的，有可能执行了一条后线程中断</li><li>可以使用<code>set lock thread1 nx ex 5</code>合并成一条语句</li></ul></li><li>释放锁<ul><li>手动释放: <code>del key</code></li><li>超时释放: 获取锁的时候设置超时时间</li></ul></li></ol><h3 id="Redisson分布式锁原理"><code>Redisson</code>分布式锁原理</h3><ol><li>可重入: 利用<code>hash</code>结构记录线程<code>ID</code>和重入次数</li><li>可重试: 利用信号量和<code>pubsub</code>功能实现等待、唤醒，获取锁失败的重试机制</li><li>超时续约: 利用<code>watchDog</code>，每隔一段时间重置超时时间</li></ol><h1><code>Redis</code>消息队列</h1><h2 id="基于List的消息队列的优缺点">基于<code>List</code>的消息队列的优缺点</h2><ul><li>优点:<ol><li>利用<code>Redis</code>存储，不受限与<code>JVM</code>内存上限</li><li>基于<code>Redis</code>持久化机制，保证数据安全性</li><li>满足消息有序性</li></ol></li><li>缺点:<ol><li>无法避免消息丢失</li><li>只支持单消费者</li></ol></li></ul><h2 id="基于PubSub的消息队列">基于<code>PubSub</code>的消息队列</h2><ul><li>发布订阅，一个消费者可以订阅一个或多个<code>channel</code>，生产者向对应的<code>channel</code>发送消息后，所有订阅者可以收到相关信息</li><li><code>subscribe channel [channel]</code>: 订阅一个或多个频道</li><li><code>publish channel msg</code>: 向一个频道发送消息</li><li><code>psubscribe pattern [pattern]</code>: 订阅与pattern格式匹配的所有频道</li><li>优点:<ol><li>采用发布订阅模型，支持多生产，多消费</li></ol></li><li>缺点:<ol><li>不支持持久化</li><li>无法避免消息丢失，不安全</li><li>消息堆积有上限，超出时数据丢失</li></ol></li></ul><h2 id="基于Stream的消息队列">基于<code>Stream</code>的消息队列</h2><ul><li>发送消息: <code>xadd key [NOMKSTREAM] [MAXLEN|MINID [=|~] threadhold [LIMIT count]] *|ID field value [field value ...]</code><ul><li><code>[NOMKSTREAM]</code>: 如果队列不存在，是否自动创建队列，默认是动创建</li><li><code>[MAXLEN|MINID [=|~] threadhold [LIMIT count]]</code>: 设置消息队列的最大消息数量</li><li><code>*|ID</code>: 消息的唯一<code>ID</code>，*代表由<code>Redis</code>自动生成，格式是<code>时间戳-递增数字</code></li><li><code>field value [field value ...]</code>: 发送到队列中的消息，称为<code>Entry</code>，格式就是多个键值对</li></ul></li><li>读取消息: <code>XREAD [COUNT count] [BLOCK milliseconds] STREAMS key[key ...] ID [ID ...]</code><ul><li><code>[COUNT count]</code>: 每次读取消息的最大数量</li><li><code>[BLOCK milliseconds]</code>: 没有消息时，是否阻塞，阻塞时长</li><li><code>STREAM key [key ...]</code>: 要从哪个队列读取消息，<code>key</code>就是队列名</li><li><code>ID [ID ...]</code>: 起始<code>ID</code>，只返回大于该<code>ID</code>的消息。0表示从第一条消息开始，$表示从最新的消息开始</li></ul></li></ul><p>指定<code>$</code>表示读取最新的消息，但是如果一下到来几条消息，依然只会读取最新的消息，导致漏读</p><ul><li>优点:<ol><li>消息可回溯</li><li>一个消息可以被多个消费者读取</li><li>可以阻塞读取</li></ol></li><li>缺点:<ol><li>有消息漏镀的风险</li></ol></li></ul><h3 id="消费者组">消费者组</h3><ul><li><p>将多个消费者划分到一个组中，监听同一个队列</p></li><li><p>特点:</p><ol><li>消息分流: 队列中的消息会分流给组内不同的消费者，不是重复的消费，从而加快消息处理的速度</li><li>消息标识: 消费者组维护一个标识，记录最后一个被处理的消息，哪怕消费者宕机，还会从标识之后读取消息，确保每一个消息都会被消费</li><li>消息确认: 消费者获取消息后，消息处于<code>pending</code>状态，存入<code>pending-list</code>。当处理完成后需要通过<code>XACK</code>来确认消息，标记消息为已处理，才会从<code>pending-list</code>中移除(可以确保所有的消息都能被消费到)</li></ol></li><li><p>创建消费者组: <code>xgroup create key groupName ID [MKSTREAM]</code></p><ul><li><code>key</code>: 队列名称</li><li><code>groupName</code>: 消费者组名称</li><li><code>ID</code>: 起始<code>ID</code>标识，<code>$</code>标识队列中最后一个消息，<code>0</code>标识队列中第一个消息</li><li><code>MKSTREAM</code>: 队列不存在时自动创建队列</li></ul></li><li><p>删除消费者组: <code>xgroup destroy key groupName</code></p></li><li><p>删除消费者组中指定的消费者: <code>xgroup delconsumer key groupname consumername</code></p></li><li><p>给指定的消费者组添加消费者: <code>xgroup createconsumer key groupname consumername</code></p></li><li><p>从消费者组读取消息: <code>xreadgroup GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] ID [ID ...]</code></p><ul><li><code>group</code>: 消费者组名称</li><li><code>consumer</code>: 消费者名称，如果消费者不存在，则会自动创建一个</li><li><code>count</code>: 本次查询的最大数量</li><li><code>BLOCK milliseconds</code>: 当没有消息时最长等待时间</li><li><code>NOACK</code>: 无需手动ACK，获取到消息后自动确认</li><li><code>STREAMS key</code>: 指定队列名称</li><li><code>ID</code>: 获取消息的起始ID<ul><li>‘&gt;’: 从下一个未消费的消息开始</li><li>其他: 根据指定ID从<code>pending-list</code>中获取已经消费但是没有确认的消息，比如0，是从<code>pending-list</code>中的第一个消息开始</li></ul></li></ul></li><li><p>特点:</p><ol><li>消息可回溯</li><li>可以多消费者争抢消息，加快消费速度</li><li>可以阻塞读取</li><li>没有消息漏读风险</li><li>有消息确认机制，保证消息至少被消费一次</li></ol></li></ul><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">List</th><th style="text-align:center">PubSub</th><th style="text-align:center">Stream</th></tr></thead><tbody><tr><td style="text-align:center">消息持久化</td><td style="text-align:center">支持</td><td style="text-align:center">-</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">阻塞读取</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">消息堆积处理</td><td style="text-align:center">受限于内存空间，可以利用多消费者加快处理</td><td style="text-align:center">受限于消费者缓冲区</td><td style="text-align:center">受限于队列长度，可以利用消费者组提高消费速度，减少堆积</td></tr><tr><td style="text-align:center">消息确认机制</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">消息回溯</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">支持</td></tr></tbody></table><h1><code>GEO</code></h1><ul><li><code>GEOADD</code>: 添加一个地理空间信息，包括经度、纬度、值</li><li><code>GEODIST</code>: 计算指定两个点之间的距离并返回</li><li><code>GEOHASH</code>: 将值的坐标转为哈希字符串形式并返回</li><li><code>GEOPOS</code>: 返回指定值的坐标</li><li><code>GEORADIUS</code>: 指定圆心、半径，找到院内包含的所有值，按照圆心之间的距离排序后返回，6.2版本以后废弃</li><li><code>GEOSEARCH</code>: 指定范围内搜索值，按照与指定点之间的距离排序后返回，范围可以是圆形或矩形</li><li><code>GEOSEARCHSTORE</code>: 与<code>GEOSEARCH</code>功能一致，不过可以把结果存储到一个指定的key中</li></ul><h1><code>BitMap</code></h1><ul><li><code>Redis</code>中使用<code>String</code>类型实现<code>BitMap</code>，最大上限512M，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup><mi>b</mi><mi>i</mi><mi>t</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">2^{32} bits</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mord mathnormal">bi</span><span class="mord mathnormal">t</span><span class="mord mathnormal">s</span></span></span></span></li><li><code>SETBIT</code>: 向指定位置<code>offset</code>存入一个0 or 1</li><li><code>BITCOUNT</code>: 统计<code>BitMap</code>中值为1的<code>bit</code>位的数量</li><li><code>BITFIELD</code>: 操作<code>BitMap</code>中bit数组中的指定位置<code>offset</code>的值，实现了查询修改以及自增，一般用来查询</li><li><code>BITFIELD_RO</code>: 获取<code>BitMap</code>中bit数组，并以十进制形式返回</li><li><code>BITOP</code>: 将多个<code>BitMap</code>的结果位运算</li><li><code>BITPOS</code>: 查找bit数组中指定范围内第一个0 or 1出现的位置</li></ul><h1><code>HyperLogLog(HLL)</code></h1><ul><li><p><code>UV</code>: <code>Unique Visitor</code>独立访客量，通过互联网访问，浏览这个网页的自然人。一天内同一个用户多次访问，只记录一次</p></li><li><p><code>PV</code>: <code>Page View</code>页面访问量或点击量，用户没访问网站的一个页面，记录次<code>PV</code>，用来衡量网站的流量</p></li><li><p><code>UV</code>在服务端做会麻烦，因为要判断该用户是否统计过了，所以需要保存用户信息。但是如果每个访问的用户都保存到<code>Redis</code>中，则数据量很大</p></li><li><p><code>HLL</code>是一种概率算法，用于确定非常大的集合的基数，不需要存储其所有的值。基于<code>String</code>实现，单个<code>HLL</code>内存永远小于16K，测量结果是概率性的，误差小于81%。对于<code>UV</code>统计完全可以忽略</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis笔记_0</title>
      <link href="/posts/36df4688.html"/>
      <url>/posts/36df4688.html</url>
      
        <content type="html"><![CDATA[<h1><code>SQL</code> VS <code>NoSQL</code></h1><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">SQL</th><th style="text-align:center">NoSQL</th></tr></thead><tbody><tr><td style="text-align:center">数据结构</td><td style="text-align:center">结构化</td><td style="text-align:center">非结构化</td></tr><tr><td style="text-align:center">数据关联</td><td style="text-align:center">关联的</td><td style="text-align:center">无关联</td></tr><tr><td style="text-align:center">查询方式</td><td style="text-align:center">SQL查询</td><td style="text-align:center">非SQL</td></tr><tr><td style="text-align:center">事务特性</td><td style="text-align:center">ACID</td><td style="text-align:center">BASE</td></tr><tr><td style="text-align:center">存储方式</td><td style="text-align:center">磁盘</td><td style="text-align:center">内存</td></tr><tr><td style="text-align:center">扩展性</td><td style="text-align:center">垂直</td><td style="text-align:center">水平</td></tr><tr><td style="text-align:center">使用场景</td><td style="text-align:center">数据结构固定且对安全性，一致性要求较高</td><td style="text-align:center">数据结构不固定，对一致性安全性要求不高，对性能有一定要求</td></tr></tbody></table><div class="note info flat"><p>特征:</p><ol><li>键值型，值支持多种不同的数据结构，功能丰富</li><li>单线程，每个命令具有原子性。现在多线程仅仅在网络连接请求方面，内部核心命令依然是单线程的</li><li>低延迟，速度快</li><li>支持数据持久化</li><li>支持主从集群，分片集群</li><li>支持多语言</li></ol></div><div class="note info flat"><p>为什么<code>Redis</code>单线程，但是速度快?</p><ol><li>基于内存(最重要的原因)</li><li>IO多路复用</li><li>使用C语言，良好的编码</li></ol></div><h1><code>Redis</code>安装</h1><p>使用<code>Docker</code>安装:</p><ol><li>在<code>docker-data/redis/</code>中执行命令<code>wget http://download.redis.io/redis-stable/redis.conf</code>下载config</li><li>修改权限</li><li>修改配置信息 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bind 127.0.0.1          # 注释掉这行，表示其他机器也可以链接</span><br><span class="line">protected-mode no       # 默认为yes，表示只允许本机的回环连接</span><br><span class="line">daemonize no            # 默认为no，不守护进程，不是docker部署需要改为yes</span><br><span class="line">                        # 如果是Docker部署不需要改为yes，因为docker run -d本身就是后台启动</span><br><span class="line">requirepass xxxxxx      # 密码</span><br><span class="line">appendonly yes          # 持久化</span><br><span class="line">port 6379               # 默认，监听的端口</span><br><span class="line">dir .                   # 默认，表示当前目录即为工作目录</span><br><span class="line">database 16             # 默认，表示数据库数量</span><br><span class="line">maxmemory 512mb         # 表示redis能使用的最大内存</span><br><span class="line"># logfile &quot;redis.log&quot;   # 日志文件，默认为空，表示不记录日志，存储在dir指定的目录中</span><br></pre></td></tr></table></figure></li><li>运行<code>Redis</code>: (网上的方法99%都是有问题的)以<code>redis:7.2.4-alpine3.19</code>为例</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name redis -p 6379:6379 -v /&#123;USER_DIR&#125;/docker-data/redis/redis.conf:/usr/local/etc/redis/redis.conf -v /&#123;USER_DIR&#125;/docker-data/redis:/data -d redis:7.2.4-alpine3.19 redis-server /usr/local/etc/redis/redis.conf --appendonly yes --requirepass xxxxxx</span><br></pre></td></tr></table></figure><h1>数据结构</h1><div class="note info flat"><p>通用命令:</p><ol><li><code>KEYS</code>: 查看所有符合模板的key，不建议在生产环境上使用，查询会阻塞其他线程</li><li><code>DEL</code>: 删除一个 or 多个指定的key</li><li><code>EXISTS</code>: 判断key是否存在</li><li><code>EXPIRE</code>: 给key设置有效期(秒)，到期自动删除</li><li><code>TTL</code>: 查看key的剩余有效期，-1表示永久有效， -2表示过期</li></ol></div><h2 id="基本类型">基本类型</h2><ol><li><p><code>String</code></p><ul><li>字符串底层都是字节数组的形式存储的，最大不能超过512M</li><li>格式又可以分为<code>string, int, float</code></li><li>但是对于<code>int, float</code>，都转为二进制的形式存储</li><li><code>Redis</code>的key允许多个单词形成层级结构，使用<code>:</code>分隔，即<code>项目名:业务名:类型:id</code></li></ul> <div class="note info flat"><p>常用命令:</p><ol><li><code>SET</code>: 添加或修改已经存在的一个<code>String</code>类型键值对</li><li><code>GET</code>: 根据key获取<code>String</code>类型的value</li><li><code>MSET, MGET</code>: 批量添加和批量获取多个<code>String</code>类型键值对</li><li><code>INCR</code>: 对int自增1</li><li><code>INCRBY</code>: 让整型的key自增并指定步长，比如<code>incrby num 2</code>表示让<code>num</code>自增2</li><li><code>INCRBYFLOAT</code>: 让float自增指定步长</li><li><code>SETNX</code>: 添加一个<code>String</code>类型键值对，前提是没有key，否则不执行</li><li><code>SETEX</code>: 添加一个<code>String</code>类型键值对，并指定有效期，<code>setex key 有效期 value</code></li></ol></div></li><li><p><code>Hash</code></p><ul><li>value是一个无序字段</li><li><code>String</code>将对象序列化以后存储，修改某个字段不方便。比如value为<code>&#123;name: Jack, age: 21&#125;</code></li><li><code>Hash</code>每个字段独立存储，可以单独处理</li></ul> <div class="note info flat"><p>常用命令:</p><ol><li><code>HSET key field value</code>: 添加或修改已经存在的一个<code>Hash</code>类型键值对</li><li><code>HGET key field</code>: 根据key获取<code>Hash</code>类型的value</li><li><code>HMSET, HMGET</code>: 批量添加和批量获取多个<code>Hash</code>类型键值对</li><li><code>HGETALL</code>: 获取一个<code>Hash</code>类型中所有的field</li><li><code>HKEYS</code>: 获取<code>Hash</code>类型中所有的field</li><li><code>HVALS</code>: 获取<code>Hash</code>类型中所有的value</li><li><code>HINCRBY</code>: 让<code>Hash</code>的key自增并指定步长</li><li><code>HSETNX</code>: 添加一个<code>Hash</code>类型key的field，前提是没有field，否则不执行</li></ol></div></li><li><p><code>List</code></p><ul><li>可以看作双向链表，有序、元素可以重复、插入删除速度快，但是<strong>查询速度一般</strong></li><li>朋友圈点赞，或评论列表</li></ul> <div class="note info flat"><p>常用命令:</p><ol><li><code>LPUSH key element ...</code>: 左侧插入一个 or 多个元素</li><li><code>LPOP key</code>: 左侧移除并返回第一个元素，没有就返回<code>nil</code></li><li><code>RPUSH key element ...</code>: 右侧插入一个 or 多个元素</li><li><code>RPOP key</code>: 右侧移除并返回第一个元素，没有就返回<code>nil</code></li><li><code>LRANGE key start end</code>: 返回一段角标范围内的所有元素</li><li><code>BLPOP</code>, <code>BRPOP</code>: 在没有元素时等待指定的时间，而不是直接范围<code>nil</code></li></ol></div></li><li><p><code>Set</code></p><ul><li>无序，元素不重复，查找快，支持交、并、差集</li></ul> <div class="note info flat"><p>常用命令:</p><ol><li><code>SADD key member</code>: 向<code>Set</code>中添加一个或者多个元素</li><li><code>SREM key member</code>: 移除<code>Set</code>中指定的元素</li><li><code>SCARD key</code>: 返回<code>Set</code>中元素的个数</li><li><code>SISMEMBER key memeber</code>: 判断一个元素是否存在于<code>Set</code>中</li><li><code>SMEMBERS</code>: 获取<code>Set</code>中所有的元素</li><li><code>SINTER key1 key2</code>: 求key1 和 key2的交集</li><li><code>SDIFF key1 key2</code>: 求key1 和 key2的差集</li><li><code>SUNION key1 key2</code>: 求key1 和 key2的并集</li></ol></div></li><li><p><code>SortedSet</code></p><ul><li>可排序集合，每个元素都带有<code>score</code>属性，底层是实现一个跳表和哈希表</li><li>可排序，不重复，查询速度快。用于实现排行榜</li></ul> <div class="note info flat"><p>常用命令:</p><ol><li><code>ZADD key score member</code>: 添加一个 or 多个元素，如果已经存在则更新<code>score</code></li><li><code>ZREM key member</code>: 移除指定的元素</li><li><code>ZSCORE key member</code>: 获取指定元素的<code>score</code>值</li><li><code>ZRANK key member</code>: 获取指定元素排名</li><li><code>ZSCARD key</code>: 返回元素的个数</li><li><code>ZCOUNT key min max</code>: 统计<code>score</code>在给定范围内元素的个数</li><li><code>ZINCRBY key increment member</code>: 让指定元素自增，步长为<code>incrememnt</code></li><li><code>ZRANGE key min max</code>: 按照<code>score</code>排序后，获取指定排名范围内的元素</li><li><code>ZRANGEBYSCORE key min max</code>: 按照<code>score</code>排序后，获取指定<code>score</code>范围内的元素</li><li><code>ZINTER key1 key2</code>: 求key1 和 key2的交集</li><li><code>ZDIFF key1 key2</code>: 求key1 和 key2的差集</li><li><code>ZUNION key1 key2</code>: 求key1 和 key2的并集</li><li>在<code>Z</code>后面添加<code>REV</code>即可实现降序</li></ol></div></li></ol><h2 id="特殊类型">特殊类型</h2><ol><li><code>GEO</code></li><li><code>BitMap</code></li><li><code>HyperLog</code></li></ol><h1>缓存更新策略</h1><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">内存淘汰</th><th style="text-align:center">超时剔除</th><th style="text-align:center">主动更新</th></tr></thead><tbody><tr><td style="text-align:center">说明</td><td style="text-align:center">不用自己维护，利用内存淘汰机制，内存不足时自动淘汰部分数据，下次查询时再更新</td><td style="text-align:center">给缓存数据添加TTL时间，到期后自动删除缓存，下次查询时更新缓存</td><td style="text-align:center">编写业务逻辑，修改数据库的同时更新缓存</td></tr><tr><td style="text-align:center">一致性</td><td style="text-align:center">差</td><td style="text-align:center">一般</td><td style="text-align:center">好</td></tr><tr><td style="text-align:center">维护成本</td><td style="text-align:center">无</td><td style="text-align:center">低</td><td style="text-align:center">高</td></tr></tbody></table><div class="note info flat"><ul><li>对于低一致性需求，使用内存淘汰机制。比如店铺类型这种修改频率很少的内容</li><li>对于高一致性需求，使用主动更新，并且将超时剔除作为兜底方案。比如店铺的详情、优惠券查询缓存</li></ul></div><h2 id="主动更新策略">主动更新策略</h2><ol><li><code>Cache Aside Pattern</code>: 由缓存调用者在更新数据库的同时更新缓存<ul><li>可控性更高，用的更多</li></ul></li><li><code>Read/ Write Through Pattern</code>: 缓存与数据库整合为一个服务，由服务来维护一致性。<strong>调用者调用该服务，无需关心缓存一致性问题</strong></li><li><code>Write Behind Caching Pattern</code>: <strong>调用者只操作缓存</strong>，由其他线程异步将缓存数据持久化到数据库，最终保持一致<ul><li>需要维护异步线程</li><li>一致性难以保证</li></ul></li></ol><h3 id="Cache-Aside-Pattern"><code>Cache Aside Pattern</code></h3><ol><li>删除缓存和更新缓存的选择<ul><li>更新缓存：每次更新数据库都要更新缓存，如果对应的是写多读少的环境，则会产生大量的无效写操作</li><li>删除缓存：每次更新数据库时都让缓存失效，查询时再更新缓存，延迟加载，有效更新更多，因此用的更多</li></ul></li><li>如果保证缓存与数据库的操作同时成功或失败<ul><li>单体系统，将缓存与数据库放在一个事务中</li><li>分布式系统，就需要利用<code>TCC</code>分布式事务方案</li></ul></li><li>先操作缓存还是操作数据库(线程安全问题)<ul><li><p>初始缓存和数据库内容均为10</p></li><li><p>先删除缓存再操作数据库:</p><ul><li><p>线程1删除缓存，线程1更新数据库=20</p></li><li><p>线程2查询缓存未命中，查询数据库得到20，并写入缓存。正常</p></li><li><p><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Redis/cachesqlright.png" alt="cachesqlright"></p></li><li><p>线程1删除缓存</p></li><li><p>线程2查询缓存未命中，查询数据库得到10，并写入缓存</p></li><li><p>线程1更新数据库=20。异常(<strong>概率高</strong>)</p></li><li><p><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Redis/cachesqlerror.png" alt="cachesqlerror"></p></li></ul></li><li><p><strong>先操作数据库再删缓存</strong></p><ul><li><p>线程2更新数据库=20，再删除缓存</p></li><li><p>线程1查询缓存未命中，查询数据库得到20，并写入缓存。正常</p></li><li><p><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Redis/sqlcacheright.png" alt="sqlcacheright"></p></li><li><p>假设<strong>缓存失效了</strong>，线程1查询缓存未命中，查询数据库得到10</p></li><li><p>线程2更新数据库=20，删除缓存</p></li><li><p>线程1写入缓存=10。异常(<strong>概率低</strong>)</p></li><li><p><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Redis/sqlcacheerror.png" alt="sqlcacheerror"></p></li></ul></li></ul></li></ol><div class="note info flat"><ul><li>因此，<strong>先操作数据库再删缓存</strong>用的更多一些，可以加上超时剔除策略兜底<ul><li>读操作:<ul><li>缓存命中则直接返回</li><li>缓存未命中则查询数据库，写入缓存，设定超时时间</li></ul></li><li>写操作：<ul><li>先写数据库，然后删除缓存</li><li>确保数据库与缓存操作的原子性</li></ul></li></ul></li></ul></div><h1>缓存穿透</h1><ul><li>客户端请求的数据在缓存和数据库中都不存在，则永远不会生效，请求永远会打到数据库中</li></ul><h2 id="解决办法">解决办法</h2><ol><li>缓存空对象<ul><li>优点: 实现简单，维护方便</li><li>缺点:<ul><li>额外内存消耗，可以设置短的TTL进行过期删除</li><li>可能造成短期的不一致性，也可以通过短的TTL缓解</li></ul></li></ul></li><li>布隆过滤器<ul><li>客户端请求的时候先请求布隆过滤器，如果存在则放行，不存在则直接拒绝</li><li>布隆过滤器判断不存在说明一定不存在，判断存在但是不一定真的存在，如果实际上不存在，则又发生了穿透</li><li>优点: 内存占用小，没有多余的key</li><li>缺点:<ul><li>实现复杂</li><li>存在误判</li></ul></li></ul></li><li>增加id的复杂度，避免被猜测规律</li><li>数据基础格式校验</li><li>热点参数限流</li></ol><h1>缓存雪崩</h1><ul><li>同一时段大量的缓存同时失效，或者<code>Redis</code>服务宕机，导致大量请求到达服务器，带来巨大压力</li></ul><h2 id="解决办法-2">解决办法</h2><ol><li>给不同的key添加<code>TTL</code>随机值</li><li>利用<code>Redis</code>集群提高可用性</li><li>给缓存业务添加降级限流策略</li><li>给业务添加多级缓存</li></ol><h1>缓存击穿(热点key问题)</h1><ul><li>被高并发访问并且缓存重建业务比较复杂的key失效了，无数请求访问会在瞬间给数据库带来巨大的冲击</li></ul><h2 id="解决办法-3">解决办法</h2><ol><li>互斥锁<ul><li>只有获取锁的人才能重建缓存，其他人就休眠一会再重试</li><li>会出现互相等待的问题，只有一个在获取数据，其他都在等待</li><li><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Redis/lock.png" alt="lock"></li></ul></li><li>逻辑过期<ul><li>不设置<code>TTL</code>，只设置逻辑过期时间，其他用户发现逻辑过期了，就开启独立新线程，查询<strong>数据库数据</strong>，重置逻辑时间</li><li>其他人在没有得到互斥锁的时候直接返回<strong>旧缓存数据</strong></li><li><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Redis/logicexpire.png" alt="logicexpire"></li></ul></li></ol><table><thead><tr><th style="text-align:center">方案</th><th style="text-align:center">优点</th><th style="text-align:center">缺点</th></tr></thead><tbody><tr><td style="text-align:center">互斥锁</td><td style="text-align:center">乜有额外内存消耗；保证一致性；实现简单</td><td style="text-align:center">线程需要等待，性能受影响；有死锁风险</td></tr><tr><td style="text-align:center">逻辑过期</td><td style="text-align:center">线程无需等待，性能较好</td><td style="text-align:center">不能保证一致性；有额外内存消耗；实现复杂</td></tr></tbody></table><div class="note info flat"><ul><li>因此互斥锁和逻辑过期两种方案实际上是<strong>一致性和可用性</strong>之间的取舍</li></ul></div>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL笔记_5</title>
      <link href="/posts/572df2c5.html"/>
      <url>/posts/572df2c5.html</url>
      
        <content type="html"><![CDATA[<h1>日志</h1><div class="note info flat"><ul><li><code>MySQL</code>中日志分为四类: 错误日志、二进制日志、查询日志、慢查询日志</li></ul></div><h2 id="错误日志">错误日志</h2><ul><li>记录了当<code>mysqld</code>启动和停止时，以及服务器在运行过程中发生的任何<strong>严重错误</strong>时的相关信息。服务器出现故障无法使用就看这个日志</li><li>默认开启，存放在<code>/var/log/</code>中，日志文件名为<code>mysqld.log</code></li><li>查看错误日志位置: <code>show variables like '%log_error%';</code></li></ul><h2 id="二进制日志">二进制日志</h2><blockquote><p><code>binlog</code>是<strong>server层</strong>日志</p></blockquote><ul><li><code>binlog</code>记录了所有的<code>DDL, DML</code>语句，<strong>不包含查询语句</strong></li><li><code>binlog</code>默认开启，查看二进制日志位置: <code>show variables like '%log_bin%';</code></li><li>最开始<code>MySQL</code>只有<code>MyISAM</code>引擎，只有<code>binlog</code>用于归档，没有<code>crash-safe</code>的能力，后面<code>InnoDB</code>设计了另一套日志系统，利用<code>redo log</code>来实现<code>crash-safe</code>的能力</li></ul><h3 id="作用">作用</h3><ol><li>灾难时数据恢复</li><li><code>MySQL</code>主从复制</li></ol><h3 id="日志格式">日志格式</h3><ul><li>查看二进制的日志格式: <code>show variables like '%binlog_format%';</code></li></ul><table><thead><tr><th style="text-align:center">日志格式</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">STATEMENT</td><td style="text-align:center">基于<code>SQL</code>语句的日志记录，记录<code>SQL</code>语句，对数据进行修改的<code>SQL</code>都会记录在日志文件中</td></tr><tr><td style="text-align:center">ROW</td><td style="text-align:center">基于行的日志记录，记录的是每一行的数据变更(默认)</td></tr><tr><td style="text-align:center">MIXED</td><td style="text-align:center">混合了STATEMENT与ROW两种格式，默认采用STATEMENT，某些情况下会自动切换为ROW记录</td></tr></tbody></table><div class="note info flat"><ul><li>如果要修改二进制文件的日志格式，就去修改<code>/etc/my.cnf</code>，添加<code>binlog_format=STATMENT</code>后，使用<code>systemctl restart mysqld</code>重新启动服务即可</li></ul></div><h3 id="查看二进制日志">查看二进制日志</h3><p><code>mysqlbinlog [参数] binlog文件名</code><br>参数:</p><ul><li><code>-d</code>  指定数据库名称，只列出指定数据库的相关操作</li><li><code>-o</code>  忽略日志中前n行命令</li><li><code>-v</code>  将行事件(数据变更)重构为<code>SQL</code>语句</li><li><code>-vv</code> 将行事件(数据变更)重构为<code>SQL</code>语句，并输出注释信息</li></ul><h3 id="删除二进制日志">删除二进制日志</h3><p>配置二进制日志的过期时间，到了过期时间会自动删除: <code>show variables like '%binlog_expire_logs_seconds%';</code></p><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">reset master</td><td style="text-align:center">删除全部的<code>binlog</code>日志，删除之后日志编号从<code>binlog.000001</code>重新开始</td></tr><tr><td style="text-align:center">purge master logs to ‘binlog.******’</td><td style="text-align:center">删除******之前的所有日志</td></tr><tr><td style="text-align:center">purge master logs before ‘yyyy-mm-dd hh24:mm:ss’</td><td style="text-align:center">删除日志为’yyyy-mm-dd hh24:mm:ss’之前产生的所有日志</td></tr></tbody></table><h3 id="更新语句流程">更新语句流程</h3><ol><li>执行器调用引擎找到<code>ID=2</code>的一行，如果这一行的数据页本身就在内存中，那么就直接返回给执行器，否则读入内存后再返回</li><li>执行器拿到引擎返回的数据，加1，调用引擎写入新数据</li><li>引擎将数据更新到内存中，同时更新<code>redo log</code>，此时<code>redo log</code>处于<code>prepare</code>状态，告知执行器写入完成，可以提交事务。</li><li>执行器生成<code>binlog</code>，并将<code>binlog</code>写入磁盘</li><li>执行器调用引擎的提交接口，把<code>redo log</code>状态改为<code>commit</code>状态，完成更新</li></ol><blockquote><p>这里的<code>prepare</code>和<code>commit</code>就是两阶段提交，为了保证两个日志逻辑一致，所以只有在<code>binlog</code>写入完成以后，<code>redo log</code>才会从<code>prepare</code>变为<code>commit</code></p></blockquote><blockquote><p><code>binlog</code>记录的是数据操作的原始逻辑操作，也就是sql语句，所以回放的时候使用的是<code>binlog</code></p><ul><li>某时刻有一次删表操作，需要找到最近的一次全量备份，从备份的时间点开始，回放<code>binlog</code>，重放到误删表的时刻即可</li></ul></blockquote><div class="note info flat"><p>如果不是两阶段提交, 例如更新ID=2的记录中c字段原始 = 0, 更新后 + 1</p><ol><li><p>先写<code>redo log</code>，后写<code>binlog</code></p><ul><li><code>redo log</code>写完了，<code>binlog</code>没有写完就宕机了，恢复后系统依然可以得到c=1，但是<code>binlog</code>没有写完，所以<code>binlog</code>没有这个语句，备份日志就有语句丢失，如果需要使用<code>binlog</code>恢复恢复临时库，就少了一次更新，导致最终临时库中c=0, 与原始库不同</li></ul></li><li><p>先写<code>binlog</code>，后写<code>redo log</code></p><ul><li><code>binlog</code>写完了，但是<code>redo log</code>还没有写，崩溃恢复以后事务无效，所以c=0，但是<code>binlog</code>已经将c=1的更新语句记录下来了，所以使用<code>binlog</code>进行恢复的时候就会得到c=1，与原始库不同</li></ul></li></ol><ul><li>如果面临数据库的扩容问题的时候，就需要<strong>全量备份 + binlog</strong>，如果<code>binlog</code>和<code>redo log</code>记录的状态不一致，就会导致主从不一致问题</li></ul></div><h2 id="查询日志">查询日志</h2><ul><li>查询日志中记录了客户端的<strong>所有</strong>操作语句，而二进制日志不包含查询语句。</li><li><strong>默认未开启</strong>，使用<code>show variables like '%general%';</code>查看</li></ul><div class="note info flat"><p>按照如下方式修改<code>/etc/my.cnf</code>可以打开查询日志</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">general_log=1</span><br><span class="line">general_log_file=mysql_query.log # 设置日志的文件名，如果没有指定则默认为host_name.log</span><br></pre></td></tr></table></figure><p><code>systemctl restart mysqld</code> # 重启mysql服务</p></div><h2 id="慢查询日志">慢查询日志</h2><ul><li>记录所有执行时间超过参数<code>long_query_time</code>，并且扫描记录数不小于<code>min_examined_row_limit</code>的所有<code>SQL</code>语句的日志，<strong>默认未开启</strong>。</li><li><code>long_query_time</code>默认10秒，最小为0，默认文件名为<code>localhost-slow.log</code></li><li>慢查询默认不会记录管理语句，也不会记录不使用索引进行的查询语句。使用<code>log_slow_admin_statements</code>和<code>log_queries_not_using_indexes</code>更改此行为，即  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 记录执行较慢的管理语句</span><br><span class="line">log_slow_admin_statements=1</span><br><span class="line"># 记录执行较慢的未使用索引的语句</span><br><span class="line">log_queries_not_using_indexes=1</span><br></pre></td></tr></table></figure></li></ul><h2 id="redo-log"><code>redo log</code></h2><blockquote><p><code>redo log</code>是<strong>引擎层</strong>日志</p></blockquote><ul><li><code>Writing-Ahead Logging(WAL)</code>先写日志，再写磁盘，避免每次更新一条数据就要写入磁盘，导致大量的IO消耗</li><li>当一条记录需要更新，<code>InnoDB</code>就先写入到<code>redo log</code>中，并更新内存，就算更新完成。然后在适当的时候再将记录更新到磁盘中。因为写入日志是顺序写入的，比写入磁盘这种随机写入要快的多。</li><li><code>redo log</code>的大小是固定的，可以配置为一组4个文件，每个文件大小是<code>1GB</code>，从头开始写，写到末尾会重新从头写入<br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/MySQL/45_redolog.png" alt="45_redolog"></li></ul><div class="note info flat"><ul><li><code>writepos</code>是当前写入的位置，边写边后移。</li><li><code>checkpoint</code>是当前擦除的位置，边擦边后移，擦除时将当前记录更新到数据文件中。</li><li><code>writepos</code>和<code>checkpoint</code>就是可以写入的位置，如果二者相等，表明此时不能写入新的数据了，需要先擦除一些记录，才能继续写入。</li><li><code>InnoDB</code>通过<code>redo log</code>保证数据库重启以后依然可以实现数据恢复，提交的记录都不会丢失，就是<code>crash-safe</code></li></ul></div><h3 id="redo-log-VS-binlog"><code>redo log</code> VS <code>binlog</code></h3><ol><li><code>redo log</code>是<code>InnoDB</code>引擎特有的，<code>binlog</code>属于<code>server</code>层，所有引擎都可以使用</li><li><code>redo log</code>是物理日志，记录在某个数据页上修改了什么；<code>binlog</code>是逻辑日志，记录原始逻辑，比如对<code>ID = 2</code>这行的c字段+1</li><li><code>redo log</code>循环写，空间固定，会消耗完；<code>binlog</code>追加写入，一定大小后切换到下一个，不会覆盖以前的日志</li></ol><h3 id="redo-log刷脏页"><code>redo log</code>刷脏页</h3><ol><li>内存数据页与磁盘数据页不同，内存数据页就是脏页，内存写入磁盘后，就是干净页</li><li>更新写入<code>redo log</code>，没有写入磁盘，就是脏页<ul><li><code>MySQL</code>空闲，就会<code>flush</code>到磁盘上</li><li><code>MySQL</code>正常关闭，会<code>flush</code>到磁盘</li><li><code>redo log</code>写满了，没有办法接受行的请求，所有更新暂停，<code>flush</code>脏页</li><li>内存不够用了，要先<code>flush</code>一部分<ul><li>读取数据的时候，需要申请行的页，那么如果没有内存空间了，就需要淘汰干净页。如果没有干净页，就需要<code>flush</code>脏页以后变成干净页再淘汰</li></ul></li></ul></li></ol><h3 id="控制刷脏页">控制刷脏页</h3><ol><li>配置<code>innodb_io_capacity</code>参数，设置为磁盘的<code>IOPS</code>，告诉<code>InnoDB</code>磁盘能力，可以利用<code>fio</code>工具测试<br><code>fio -filename=$filename -direct=1 -iodepth 1 -thread -rw=randrw -ioengine=psync -bs=16k -size=500M -numjobs=10 -runtime=10 -group_reporting -name=mytest</code><ul><li>设置这个参数，可以控制全力刷脏页。如果设置的较低，就会导致刷脏页速度变慢</li></ul></li><li>控制全力刷脏页速度的占比，有两个因素，脏页再内存中占比和<code>redo log</code>写盘的速度<ul><li><p>配置参数<code>innodb_max_dirty_pages_pct</code>，默认<code>75%</code>，<code>InnoDB</code>会计算当前脏页的占比<code>M</code></p></li><li><p>每次日志记录都有编号，跟<code>checkpoint</code>对应序号的差输入函数计算，得到<code>N</code>，<code>N</code>越大，计算结果越大。最后<code>N</code>和<code>M</code>取最大值，然后取百分号乘上全力刷脏页的速度，并以这个速度进行<code>flush</code><br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/MySQL/45_redologflush.png" alt="45_redologflush"></p></li><li><p>脏页的比例通过<code>Innodb_buffer_pool_pages_dirty/Innodb_buffer_pool_pages_total</code>计算的得到<br><code>select VARIABLE_VALUE into @a from global_status where VARIABLE_NAME = 'Innodb_buffer_pool_pages_dirty';select VARIABLE_VALUE into @b from global_status where VARIABLE_NAME = 'Innodb_buffer_pool_pages_total';select @a/@b;</code></p></li><li><p>刷新脏页的时候，如果旁边也是脏页，就会继续刷新旁边的页</p><ul><li><code>innodb_flush_neighbors = 1</code>就是连坐刷新</li><li><code>innodb_flush_neighbors = 0</code>表示只刷自己</li></ul></li><li><p>机械硬盘的话，连坐刷新有意义；但如果是SSD，建议设置为0，<strong>8.0版本后</strong>默认为0</p></li></ul></li></ol><h3 id="总结">总结</h3><ol><li><code>redo log</code>用于恢复主机故障时没有更新的数据；<code>binlog</code>用于备份</li><li>恢复数据时:<ul><li>如果<code>redo log</code>的状态为<code>commit</code>，表明<code>binlog</code>也是成功的，就可以直接恢复数据；</li><li>如果<code>redo log</code>状态是<code>prepare</code>，则需要查询<code>binlog</code>对应的事务是否成功，来决定是需要回滚还是执行</li></ul></li><li>因此，<code>redo log</code>保证了<code>crash-safe</code>的能力，<code>innodb_flush_log_at_trx_commit</code>参数表示<code>redo log</code>持久化方式<ul><li><code>innodb_flush_log_at_trx_commit = 1</code>表示每次事务的<code>redo log</code>都持久化到磁盘上，可以保证每次异常重启以后数据都不会丢失；</li><li><code>sync_binlog = 1</code>表示每次事务的<code>binlog</code>都会持久化到磁盘</li><li>所以这两个参数都建议设置为1</li><li>两个参数有<code>0 1 2</code>三个值可选，<ul><li>0表示每秒将<code>log buffer</code>同步到<code>os buffer</code>，并刷新到磁盘；</li><li>1表示每个事务都刷新到磁盘；</li><li>2表示每个事务提交都将<code>log buffer</code>同步到<code>os buffer</code>中，但是每秒刷新到磁盘</li></ul></li></ul></li></ol><h2 id="45讲对于日志的叙述">45讲对于日志的叙述</h2><ol><li><code>redo log</code>在<code>prepare</code>状态，写入<code>binlog</code>之前，崩溃了，恢复后因为<code>redo log</code>没有提交，<code>binlog</code>没有写，事务回滚，并且由于没有写<code>binlog</code>，所以从库无影响</li><li><code>redo log</code>没有<code>commit</code>, 写入<code>binlog</code>之后，<ul><li>如果<code>redo log</code>事务完整，也就是已经有了<code>commit</code>标识(但是还没有<code>commit</code>)，就直接提交</li><li>如果<code>redo log</code>只有<code>prepare</code>，判断<code>binlog</code>是否存在并完整<ul><li>如果<code>binlog</code>存在并完整，则提交事务</li><li>否则回滚事务</li><li><code>binlog</code>判断完整性：<ul><li><code>statement</code>格式<code>binlog</code>的最后会有<code>COMMIT</code></li><li><code>row</code>格式<code>binlog</code>最后会有<code>XID EVENT</code></li><li><strong>5.6版本之后</strong>引入了<code>binlog-checksum</code>验证<code>binlog</code>完整性</li></ul></li></ul></li></ul><blockquote><p>所以只要<code>binlog</code>完整，就可以通过<code>redo log</code>恢复数据，因为<code>binlog</code>完整的话，从库就会拿去用，就需要主库也有同样的数据</p></blockquote></li><li>如果没有两阶段提交，那么<code>redo log</code>写好了，就无法回滚，此时如果<code>binlog</code>写入失败，也无法回滚，导致不一致</li><li>只有<code>binlog</code>无法支持崩溃恢复，因为<code>binlog</code>是<code>WAL</code>的，如果先写了，但是事务没有<code>commit</code>，此时崩溃，就会不一致</li><li>如果只有<code>redo log</code>，可以崩溃恢复，也不需要两阶段提交。但是<code>binlog</code>可以归档，而且<code>redo log</code>循环写，历史无法保留；并且高可用，依赖监听<code>binlog</code></li><li><code>redo log</code>可以直接设置为4个文件，每个1GB。<ul><li><code>innodb_log_file_size</code>指定每个<code>redo log</code>大小，默认<code>48M</code></li><li><code>innodb_log_files_in_group</code>指定 个数，默认2</li></ul></li><li><code>redo log</code>没有记录页面的完整数据，所以不能更新磁盘，数据最终写入都依赖内存数据页的脏页</li></ol><div class="note info flat"><p>有两张表，<code>like</code>和<code>friend</code>，任何一方单方面关注的时候，只会添加在<code>like</code>表中，如果互相关注，需要在<code>friend</code>表中添加。如果两个人同时点击关注对方，就有可能出现两个单方面关注，<code>friend</code>表为空。<br>- <code>like</code>表添加一个字段<code>relationship</code><br>- 为1表示<code>userid</code>关注<code>likeid</code><br>- 为2表示<code>likeid</code>关注<code>userid</code><br>- 为3表示互相关注<br>- 设定<code>userid &lt; likeid</code></p><ul><li>插入数据比较两个用户id(A B)大小<ul><li>如果<code>A &lt; B</code>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>; <span class="comment">/*启动事务*/</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `<span class="keyword">like</span>`(user_id, liker_id, relation_ship) <span class="keyword">values</span>(A, B, <span class="number">1</span>) <span class="keyword">on</span> duplicate key <span class="keyword">update</span> relation_ship<span class="operator">=</span>relation_ship <span class="operator">|</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> relation_ship <span class="keyword">from</span> `<span class="keyword">like</span>` <span class="keyword">where</span> user_id<span class="operator">=</span>A <span class="keyword">and</span> liker_id<span class="operator">=</span>B;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">代码中判断返回的 relation_ship，</span></span><br><span class="line"><span class="comment">如果是1，事务结束，执行 commit</span></span><br><span class="line"><span class="comment">如果是3，则执行下面这两个语句：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">insert</span> ignore <span class="keyword">into</span> friend(friend_1_id, friend_2_id) <span class="keyword">values</span>(A,B);</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure></li><li>如果<code>A &gt; B</code>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>; <span class="comment">/*启动事务*/</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `<span class="keyword">like</span>`(user_id, liker_id, relation_ship) <span class="keyword">values</span>(B, A, <span class="number">2</span>) <span class="keyword">on</span> duplicate key <span class="keyword">update</span> relation_ship<span class="operator">=</span>relation_ship <span class="operator">|</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">select</span> relation_ship <span class="keyword">from</span> `<span class="keyword">like</span>` <span class="keyword">where</span> user_id<span class="operator">=</span>B <span class="keyword">and</span> liker_id<span class="operator">=</span>A;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">代码中判断返回的 relation_ship，</span></span><br><span class="line"><span class="comment">如果是2，事务结束，执行 commit</span></span><br><span class="line"><span class="comment">如果是3，则执行下面这两个语句：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">insert</span> ignore <span class="keyword">into</span> friend(friend_1_id, friend_2_id) <span class="keyword">values</span>(B,A);</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure></li><li><code>insert on duplicate</code>强制占住一行，<code>select relationship</code>在行锁保护下进行</li><li><code>|</code> 按位或 和 <code>insert ignore</code>避免重复调用</li></ul></li></ul></div><h1>主从复制</h1><ul><li>主从复制就是将主数据库的<code>DDL, DML</code>语句通过<strong>二进制日志</strong>传到从库服务器中，然后在从库上对这些日志重新执行(重做)，从而使主从库数据同步</li><li><code>MySQL</code>支持一台主库同时向多台从库进行复制，从库也可以作为其他服务器的主库，实现链状复制</li></ul><h2 id="优点">优点</h2><ol><li>主库出现问题，快速切换从库提供服务(高可用)</li><li>实现读写分离，降低主库访问压力</li><li>在从库备份，避免备份期间影响主库服务</li></ol><h2 id="原理">原理</h2><p>主数据库执行<code>DML, DDL</code>语句后，会写入<code>binlog</code>日志中。此时从数据库的<code>IOthread</code>会读取主数据库的<code>binlog</code>，写入自己的中继日志<code>Relay log</code>中，然后从数据库的<code>SQLthread</code>会读取<code>Relay log</code>，并重做其中的<code>DML, DDL</code>语句，实现主从复制</p><div class="note info flat"><p>主从复制分三步:</p><ol><li>master在事务提交时，把数据变更记录在二进制日志文件<code>binlog</code>中</li><li>从库读取主库的<code>binlog</code>，写入到从库的中继日志<code>Relay Log</code>中</li><li>slave重做中继日志的事件，改变自己的数据</li></ol></div><h2 id="主库配置">主库配置</h2><ol><li>修改<code>/etc/my.cnf</code> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># MySQL服务ID，保证集群环境中唯一，取值范围为(1 ~ 2^32-1)，默认为1</span><br><span class="line">server-id=1</span><br><span class="line"># 是否只读，1表示只读，0表示读写</span><br><span class="line">read-only=0</span><br><span class="line"># 忽略的数据，指不需要同步的数据库</span><br><span class="line"># binlog-ignore-db=mysql</span><br><span class="line"># 指定同步的数据库</span><br><span class="line"># binlog-do-db=db01</span><br><span class="line"># 不指定这两个设置，则表示所有数据库都需要同步</span><br></pre></td></tr></table></figure></li><li>重启<code>MySQL</code>服务: <code>systemctl restart mysqld</code></li><li>登录<code>MySQL</code>，创建远程连接账号，授予主从复制权限 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建用户，并设置密码，可以在任意主机连接mysql服务</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">with</span> mysql_native_password <span class="keyword">by</span> <span class="string">&#x27;密码&#x27;</span>;</span><br><span class="line"><span class="comment">-- 为用户分配主从复制权限</span></span><br><span class="line"><span class="keyword">grant</span> replication slave <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li>查看二进制日志坐标: <code>show master status;</code> <div class="note info flat"><p>字段含义:<br>file: 从哪个日志文件开始推送<br>position: 从日志文件的哪个位置开始推送日志<br>binlog_ignore_db: 指定不需要同步的数据库</p></div></li></ol><h2 id="从库配置">从库配置</h2><ol><li>修改<code>/etc/my.cnf</code> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># MySQL服务ID，保证集群环境中唯一，取值范围为(1 ~ 2^32-1)，和主库不一样即可</span><br><span class="line">server-id=2</span><br><span class="line"># 是否只读，1表示只读，0表示读写</span><br><span class="line">read-only=1</span><br></pre></td></tr></table></figure> <div class="note info flat"><ul><li>从库的<code>read-only=1</code>表示从库只需要查询即可</li><li>但是这个只读只是针对普通用户权限，对超级管理员仍然是可写</li><li>如果需要禁止超级管理员的写权限，则需要在<code>/etc/my.cnf</code>中再指定一个<code>super-read-only=1</code>参数</li></ul></div></li><li>重启<code>MySQL</code>服务: <code>systemctl restart mysqld</code></li><li>登录从库的<code>MySQL</code>，设置主库配置 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">change replication source <span class="keyword">to</span> source_host<span class="operator">=</span><span class="string">&#x27;主机ip&#x27;</span>, source_user<span class="operator">=</span><span class="string">&#x27;用户名&#x27;</span>, source_password<span class="operator">=</span><span class="string">&#x27;密码&#x27;</span>, source_log_file<span class="operator">=</span><span class="string">&#x27;同步的日志文件&#x27;</span>, source_log_pos<span class="operator">=</span>日志文件开始同步的位置; <span class="comment">--8.0.23</span></span><br><span class="line"></span><br><span class="line">change master <span class="keyword">to</span> master master_host<span class="operator">=</span><span class="string">&#x27;主机ip&#x27;</span>, master_user<span class="operator">=</span><span class="string">&#x27;用户名&#x27;</span>, master_password<span class="operator">=</span><span class="string">&#x27;密码&#x27;</span>, master_log_file<span class="operator">=</span><span class="string">&#x27;同步的日志文件&#x27;</span>, master_log_pos<span class="operator">=</span>日志文件开始同步的位置; <span class="comment">--8.0.23之前</span></span><br></pre></td></tr></table></figure></li><li>开启同步 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> replica; <span class="comment">--8.0.22</span></span><br><span class="line"><span class="keyword">start</span> slave; <span class="comment">--8.0.22之前</span></span><br></pre></td></tr></table></figure></li><li>查看主从同步状态 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> replica status; <span class="comment">--8.0.22</span></span><br><span class="line"><span class="keyword">show</span> slave status; <span class="comment">--8.0.22之前</span></span><br></pre></td></tr></table></figure> <div class="note info flat"><ul><li>文件显示比较乱，可以在后面加上\G，就会按行显示:<code>show replica status\G;</code></li><li>主要看两行:<ul><li><code>Replica_IO_Running: Yes</code></li><li><code>Replica_SQL_Running: Yes</code></li><li>只要这两行开启了，主从复制就没有问题</li></ul></li></ul></div></li></ol><h1>分库分表</h1><div class="note info flat"><ol><li>IO瓶颈: 热点数据太多，数据库缓存不足，产生大量磁盘I/O，请求数据太多，带宽不够</li><li>CPU瓶颈: 排序、分组、连接查询、聚合统计等<code>SQL</code>会消耗大量的CPU资源，请求数太多，CPU出现瓶颈</li></ol></div><ul><li><p>拆分维度分为垂直拆分和水平拆分，拆分粒度方面分为分库和分表</p><ol><li><strong>垂直分库</strong>: 以<strong>表</strong>为依据，将不同的业务拆分到不同数据库中<br>特点: 每个库<strong>表结构不一样</strong>、库中数据不同，所有库的并集才是全部的数据</li><li>垂直分表: 以<strong>字段</strong>为依据，根据字段属性将不同字段拆分到不同的表中<br>特点: 每个<strong>表结构不一样</strong>、每个表的数据不同，一般通过一列(主键/外键)关联、所有表的并集是全部数据</li><li>水平分库: 以<strong>字段</strong>为依据，将一个库的数据拆分到多个库中<br>特点: 每个<strong>库表结构一样</strong>、每个库数据不同、所有库的并集是全部的数据</li><li><strong>水平分表</strong>: 以<strong>字段</strong>为依据，将一个表的数据拆分到多个表中<br>特点: 每个表的<strong>表结构一样</strong>、每个表的数据不同、所有表的并集是全部的数据</li></ol>  <div class="note info flat"><ul><li><code>shardingJDBC</code>: 基于<code>AOP</code>，在应用程序对本地执行的<code>SQL</code>进行拦截，解析，改写，路由处理。只支持<code>Java</code>，性能好</li><li><code>MyCat</code>: 数据库分库分表的中间件，不用调整代码即可实现分库分表，支持多种语言</li><li>使用<code>mysql</code>一样的链接命令可以登录<code>mycat</code>，只有端口不一样，<code>mycat</code>端口是8066</li></ul></div></li></ul><h2 id="MyCat结构"><code>MyCat</code>结构</h2><ul><li><p>所有数据都存储在<strong>物理结构</strong>内<br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/MySQL/Mycat.png" alt="MyCat"></p></li><li><p>分片规则决定了某个数据应该插入到哪一个库的表中，一般水平分表的时候需要指定，默认是<code>auto-sharding-long</code>，其中规则为:根据id选择对应的数据库，但是如果超过了1500万，则直接报错</p></li></ul><h2 id="MyCat配置"><code>MyCat</code>配置</h2><ol><li><code>schema.xml</code>包含三组标签: <code>schema, datanode, datahost</code><ul><li><code>schema</code>核心属性:<ul><li><code>name</code>: 指定自定义的逻辑库库名</li><li><code>checkSQLschema</code>: 在<code>SQL</code>语句操作时指定了数据库名称，执行时是否自动去除。如果为<code>true</code>，表示第一次指定一下，后面就可以不用再指定数据库名称了。如果为<code>false</code>，则表明需要使用<code>use 数据库名;</code>进行指定</li><li><code>sqlMaxLimit</code>: 如果没有指定<code>limit</code>进行查询，列表查询模式返回查询了多少条记录</li></ul></li><li><code>schema.table</code>核心属性:<ul><li><code>name</code>: 定义逻辑表表名，在该逻辑库下唯一</li><li><code>dataNode</code>: 定义逻辑表所属的<code>dataNode</code>，需要与<code>dataNode</code>标签中的<code>name</code>对应，多个<code>dataNode</code>使用逗号分割</li><li><code>rule</code>: 分片规则名字，在<code>rule.xml</code>中定义</li><li><code>primaryKey</code>: 逻辑表对应真实表的主键</li><li><code>type</code>: 逻辑表的类型，只有全局表和普通表，默认为普通表。</li></ul></li><li><code>dataNode</code>核心属性:<ul><li><code>name</code>: 定义数据节点名称</li><li><code>dataHost</code>: 数据库实例主机名称，引用自<code>dataHost</code>标签中的<code>name</code>属性</li><li><code>database</code>: 定义分片需要的数据库</li></ul></li><li><code>dataHost</code>核心属性:<ul><li><code>name</code>: 唯一标识，供上层标签使用</li><li><code>maxCon/minCon</code>: 最大/最小连接数</li><li><code>balance</code>: 负载均衡策略，取值0,1,2,3</li><li><code>writeType</code>: 写操作分发方式，0表示写操作转发到第一个<code>writeHost</code>，第一个挂了就转发到第二个，1表示写操作随机分发到配置的<code>writeHost</code></li><li><code>dbDriver</code>: 数据库驱动，支持<code>native, jdbc</code></li></ul></li></ul></li><li><code>ruler.xml</code>包含两类标签: <code>tableRule、function</code></li><li><code>server.xml</code>主要包含两个标签: <code>system、user</code></li></ol><h2 id="MyCat分片"><code>MyCat</code>分片</h2><div class="note info flat"><ul><li>字典表类型的表可以设置成全局表</li></ul></div><h3 id="分片规则">分片规则</h3><ol><li>范围分片<code>auto-sharding-long</code></li><li>取模<code>mod-long</code></li><li>枚举<code>sharding-by-intfile-enumstatus</code></li><li>一致性哈希<code>sharding-by-murmur</code>: 计算指定的哈希值，根据哈希值计算落在哪一个逻辑表中。相同的哈希因子计算值总是划分到相同的分区表中，不会因为分区节点的增加而改变原来数据的分区位置</li><li>应用指定<code>sharding-by-substring</code>: 运行阶段由应用自主决定路由到哪个分片，并直接根据字符子串(必须是数字)计算分片号</li><li>固定分片哈希算法<code>sharding-by-long-hash</code>: 类似于十进制取模，但是为二进制操作。比如取低10位和1111111111进行位<code>&amp;</code>运算。分片长度最大默认为1024</li><li>字符串哈希解析<code>sharding-by-stringhash</code>: 截取子字符串，进行哈希算法，与<code>1023</code>进行位<code>&amp;</code>运算得出分片</li><li>按天分片<code>sharding-by-date</code></li><li>按月份分片<code>sharding-by-month</code></li></ol><h3 id="固定分片哈希算法-VS-取模">固定分片哈希算法 VS 取模</h3><ol><li>取模运算连续的值会分配到不同的分片，固定分片哈希算法中连续的值会分配到相同的分片，降低事务处理难度</li><li>固定分片哈希算法既可以均匀分配，也可以不均匀分配</li><li>分片字段必须是数字</li></ol><h2 id="MyCat管理"><code>MyCat</code>管理</h2><div class="note info flat"><ul><li>默认有两个端口，分别是8066和9066<ul><li>8066是数据访问端口，进行<code>DML</code>以及<code>DDL</code>操作</li><li>9066是数据库管理端口，即<code>MyCat</code>的服务管理控制功能，用于管理<code>MyCat</code>的整个集群状态</li></ul></li></ul></div><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">show @@help</td><td style="text-align:center">查看管理工具帮助文档</td></tr><tr><td style="text-align:center">show @@version</td><td style="text-align:center">查看mycat的版本</td></tr><tr><td style="text-align:center">reload @@config</td><td style="text-align:center">重新加载mycat的配置文件</td></tr><tr><td style="text-align:center">show @@datasource</td><td style="text-align:center">查看mycat的数据源信息</td></tr><tr><td style="text-align:center">show @@datanode</td><td style="text-align:center">查看mycat现有的分片节点信息</td></tr><tr><td style="text-align:center">show @@threadpool</td><td style="text-align:center">查看mycat线程池信息</td></tr><tr><td style="text-align:center">show @@sql</td><td style="text-align:center">查看执行的sql</td></tr><tr><td style="text-align:center">show @@sql.sum</td><td style="text-align:center">查看执行的sql统计</td></tr></tbody></table><h1>读写分离</h1><ul><li><p>主库写，从库读，配置<code>MyCat</code>的<code>writeHost</code>以及<code>readHost</code></p></li><li><p>读写分离需要修改<code>balance=1 or 3</code>，问题在于主库宕机了，就只能进行查询了(不满足高可用性)</p><table><thead><tr><th style="text-align:center">参数值</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">不开启读写分离机制，所有读操作发送到当前可用的writeHost上</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">全部的readHost与备用的writeHost都参与select语句的负载均衡(主要针对双主双从)</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">所有的读写操作都随机在writeHost，readHost上分发 (没有读写分离)</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">所有的读请求随机分发到writeHost对应的readHost上执行，writeHost不负担读压力</td></tr></tbody></table></li><li><p>为了避免主数据库挂了以后服务宕机的问题，可以使用<strong>双主双从</strong>的设置。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 日志 </tag>
            
            <tag> 主从复制 </tag>
            
            <tag> 读写分离 </tag>
            
            <tag> 分库分表 </tag>
            
            <tag> MyCat </tag>
            
            <tag> 分片规则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL笔记_4</title>
      <link href="/posts/202ac253.html"/>
      <url>/posts/202ac253.html</url>
      
        <content type="html"><![CDATA[<h1>锁</h1><p><img src="https://gitee.com/sang3112/blog_imgs/raw/master/MySQL/lock.png" alt="lock"></p><h2 id="全局锁">全局锁</h2><div class="note info flat"><ul><li>锁整个数据库的，加锁后<strong>数据库只读</strong>。后续的<code>DML</code>、<code>DDL</code>包括已经更新操作的事务提交都被阻塞</li><li>应用场景:数据库逻辑备份，获得一致性视图，保证完整性</li><li><code>set global readonly=true</code>也可以实现全库只读<ul><li>但是<code>readonly</code>的值可能用来处理其他逻辑，比如主从库判断；</li><li>并且<code>FTWRL</code>可以再数据库异常退出的时候<strong>自动释放</strong>，但是<code>readonly</code>不行</li></ul></li></ul></div><ul><li><p>加全局锁: <code>flush tables with read lock;</code>(<code>FTWRL</code>)</p></li><li><p>数据库备份: <code>musqldump -u用户名 -p密码 数据库名 &gt; 路径/数据库名.sql</code></p></li><li><p>解锁: <code>unlock tables;</code></p>  <div class="note info flat"><ul><li>数据库备份的<code>mysqldump</code>命令只是一个工具，不是<code>mysql</code>内部的命令，因此不能在<code>mysql</code>界面中使用。在控制台使用即可，如果备份远程数据库，则需要使用<code>-h 设置ip</code></li></ul></div></li><li><p>缺点:</p><ol><li>主库上备份，则备份期间业务停摆，无法更新</li><li>从库上备份，则备份期间主库可以更新，但是从库无法执行主库同步的二进制日志(<code>binlog</code>)，导致主从延迟</li></ol>  <div class="note info flat"><ul><li><code>InnoDB</code>引擎中为了解决这个问题，加上<code>--single-transaction</code>参数完成不加锁的一致性备份。</li><li><code>mysqldump --single-transaction -u用户 -p密码 数据库名 &gt; 路径/数据库名.sql</code></li><li>实际上通过<strong>快照读</strong>实现，这种方式<strong>不需要</strong>添加全局锁</li><li>但是<code>MyISAM</code>中不支持这个隔离级别，所以就要<code>FTWRL</code>，因为<code>–single-transaction</code>需要数据库中所有的表的引擎都支持事务才行。</li></ul></div></li></ul><h2 id="表级锁">表级锁</h2><div class="note info flat"><ul><li>每次锁住整张表，粒度大，<strong>锁冲突的概率最高，并发度最低</strong>。</li><li>表级锁分三类:表锁、元数据锁(MDL)、意向锁</li></ul></div><h3 id="表锁">表锁</h3><div class="note info flat"><ul><li>表锁分两类: 表共享读锁(read lock)、表独占写锁(write lock)<ol><li>表共享读锁，<strong>所有人(包括自己)都只能看，不能写入</strong></li><li>表独占写锁，<strong>其他人不能看也不能写，加锁的人可读可写</strong></li></ol></li></ul></div><ul><li>加锁: <code>lock tables 表名... read / write</code></li><li>解锁: <code>unlock tables;</code>或者关闭客户端</li></ul><h3 id="元数据锁">元数据锁</h3><div class="note info flat"><ul><li>系统自动控制，无需显式使用，访问表的时候自动加上, 是<code>server</code>层的锁</li><li>维护表元数据的一致性，在表有活动事务的时候，不能对元数据进行写入</li><li>为了<strong>避免<code>DML</code>和<code>DDL</code>的冲突</strong>，保证读写的正确性</li><li>在对一张表进行增删改查(<code>DML</code>)，自动加<code>MDL</code>共享读锁</li><li>在对表结构变更的时候(<code>DDL</code>)，自动加<code>MDL</code>独占写锁</li><li>查看元数据锁: <code>select object_type, object_schema, object_name, lock_type, lock_duration from performance_schema.metadata_locks;</code><ul><li>如果<code>session A</code>申请<code>MDL</code>读锁，<code>session B</code>在之后申请<code>MDL</code>读锁，不会有问题。<code>session C</code>在之后申请<code>MDL</code>写锁，会被阻塞；如果<code>session D</code>再<code>session C</code>后面申请<code>MDL</code>读锁，也会被阻塞，因为<code>session C</code>的申请没有被处理。</li><li>为了解决这个问题，就要解决<strong>长事务</strong>；或者在<code>alert table</code>(<code>DDL</code>)中加入等待时间，如果等待时间内没有拿到<code>MDL</code>写锁就放弃</li></ul></li></ul></div><table><thead><tr><th style="text-align:center">对应SQL</th><th style="text-align:center">锁类型</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">lock tables xxx read / write</td><td style="text-align:center">SHARED READ ONLY / SHARED NO READ WRITE</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">select、select … lock in share mode</td><td style="text-align:center">SHARED READ</td><td style="text-align:center">与SHARED READ，SHARED WRITE兼容，与EXCLUSIVE互斥</td></tr><tr><td style="text-align:center">insert、update、delete、select…for update</td><td style="text-align:center">SHARED WRITE</td><td style="text-align:center">与SHARED READ，SHARED WRITE兼容，与EXCLUSIVE互斥</td></tr><tr><td style="text-align:center">alter table …</td><td style="text-align:center">EXCLUSIVE</td><td style="text-align:center">与其他MDL都互斥</td></tr></tbody></table><h3 id="意向锁">意向锁</h3><div class="note info flat"><ul><li>A更新某一行，添加了行锁，B同时想加表锁。这个时候，需要B一行一行检查是否存在行锁，性能极低。</li><li>为了减少<code>DML</code>在执行时，加的<strong>行锁和表锁的冲突</strong>，在<code>InnoDB</code>中引入了意向锁。</li><li>意向锁不用检查每行是否加锁，可以减少表锁的检查。</li><li>A更新某一行，添加了行锁，然后会对表添加意向锁。B同时想加表锁， 就先去检查是否存在意向锁。</li><li>意向锁分为两类: 意向共享锁(IS)、意向排他锁(IX)</li><li>查看<strong>意向锁以及行锁</strong>: <code>select object_schema, object_name, index_name, lock_type, lock_mode, lock_data from performance_schema.data_locks;</code></li></ul></div><ol><li><p>意向共享锁(IS)</p><ul><li>由语句<code>select ... lock in share mode</code>添加</li><li>与表锁中的共享锁(read)兼容，与表锁排他锁(write)互斥</li><li><code>select * form score where id=1 lock in share mode;</code>会加上行共享锁，同时会添加意向共享锁</li></ul></li><li><p>意向排他锁(IX)</p><ul><li>由语句<code>insert、update、delete、select ... for update</code>添加</li><li>与表锁共享锁(read)以及排他锁(write)都互斥，意向锁之间不互斥</li><li><code>update score set math=66 where id = 1</code>会加上行锁，同时会添加意向排他锁。</li></ul></li></ol><h2 id="行级锁">行级锁</h2><div class="note info flat"><ul><li>每次锁住对应的行，粒度小，<strong>锁冲突的概率最低，并发度最高</strong>。</li><li><code>InnoDB</code>数据基于索引组织，行锁通过对索引上的<strong>索引项加锁</strong>实现，<strong>不是对记录加锁</strong>。</li><li>行级分三类: 行锁、间隙锁、临键锁</li></ul></div><h3 id="行锁">行锁</h3><div class="note info flat"><ul><li>锁定单个行记录，防止其他事务进行<code>update</code>或<code>delete</code>，在<code>RC</code>,<code>RR</code>下都支持</li><li>行锁分两类: 共享锁(S)、排他锁(X)</li><li>行锁需要的时候才会加，但是在提交的时候才会释放，这就是<strong>两阶段协议</strong><ul><li>所以如果会锁住多行，要把最可能冲突的行影响并发度的行放后面</li></ul></li></ul></div><ol><li><p>共享锁(S)</p><ul><li>允许一个事务读一行，阻止其他事物获得相同数据集的排他锁</li></ul></li><li><p>排他锁(X)</p><ul><li>允许获取排他锁的事务更新数据，阻止其他事物获得相同数据集的排他锁和共享锁</li></ul></li></ol><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">共享锁</th><th style="text-align:center">排他锁</th></tr></thead><tbody><tr><td style="text-align:center">共享锁</td><td style="text-align:center">兼容</td><td style="text-align:center">冲突</td></tr><tr><td style="text-align:center">排他锁</td><td style="text-align:center">冲突</td><td style="text-align:center">冲突</td></tr></tbody></table><table><thead><tr><th style="text-align:center">SQL</th><th style="text-align:center">行锁类型</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">INSERT</td><td style="text-align:center">排他锁</td><td style="text-align:center">自动加锁</td></tr><tr><td style="text-align:center">UPDATE</td><td style="text-align:center">排他锁</td><td style="text-align:center">自动加锁</td></tr><tr><td style="text-align:center">DELETE</td><td style="text-align:center">排他锁</td><td style="text-align:center">自动加锁</td></tr><tr><td style="text-align:center">SELECT</td><td style="text-align:center">不加锁</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">SELECT … LOCK IN SHARE MODE</td><td style="text-align:center">共享锁</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">SELECT … FOR UPDATE</td><td style="text-align:center">排他锁</td><td style="text-align:center"></td></tr></tbody></table><div class="note info flat"><ul><li><code>InnoDB</code>在<code>RR</code>下会使用临键锁进行搜索和索引扫描，防止幻读。</li><li>针对唯一索引进行检索时，对已经存在的记录进行等值匹配时，会自动优化为行锁</li><li><code>InnoDB</code>行锁针对索引加锁，不通过索引条件检索数据，那么<code>InnoDB</code>将对表中所有记录加锁，此时升级为表锁。</li></ul></div><h3 id="间隙锁">间隙锁</h3><ul><li>锁定索引记录间隙(不包含该记录)，确保索引记录间隙不变，防止其他事物在这个间隙<code>insert</code>，导致幻读，在<code>RR</code>隔离级别下支持</li></ul><div class="note info flat"><ul><li><code>InnoDB</code>在<code>RR</code>下会使用临键锁进行搜索和索引扫描，防止幻读。</li><li>索引上的等值查询(唯一索引)，给不存在的记录加锁时，会优化为间隙锁</li><li>索引上的等值查询(普通索引)，向右遍历时最后一个值不满足查询要求时，临键锁退化为间隙锁</li></ul></div><h3 id="临键锁">临键锁</h3><ul><li>行锁和间隙锁的组合，同时锁住数据以及数据前的间隙，在<code>RR</code>隔离级别下支持</li></ul><div class="note info flat"><ul><li><code>InnoDB</code>在<code>RR</code>下会使用临键锁进行搜索和索引扫描，防止幻读。</li><li>索引上的范围查询(唯一索引)，会访问到不满足条件的第一个值为止，生成临键锁</li></ul></div><h2 id="死锁">死锁</h2><p><img src="https://gitee.com/sang3112/blog_imgs/raw/master/MySQL/45_deadlock.png" alt="45_deadlock"></p><ul><li>事务A等待事务B释放<code>id=2</code>的行锁，事务B等待事务A释放<code>id=1</code>的行锁，循环等待，进入死锁。</li></ul><div class="note info flat"><p>解决死锁的两种策略</p><ol><li>直接进入等待，直到超时，超时时间为<code>innodb_lock_wait_timeout</code>，默认50s，特别长，但是又不能缩短为1s，这样如果正常的请求时间长点就会被误杀。</li><li>死锁检测，发现死锁以后回滚某一个事务，让其他事务可以正常执行，将<code>innodb_deadlock_detect</code>设置为on，表示开启死锁检测逻辑</li></ol><ul><li>一般会使用死锁检测的方法，就是一个事务被锁的时候，判断依赖的线程有没有被别人锁住，最后判断是否出现循环等待，也就是死锁。</li><li>但是如果多个事务更新同一行，每个后面来的线程都会判断是不是由于自己导致死锁，时间复杂度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，每个线程都要遍历一次其他线程，所以最终时间复杂度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><ul><li>比如1000个线程同时修改一行数据，那么每个线程都要遍历其他999个线程判断是否存在循环依赖，就需要判断100万次。这样虽然不会出现死锁，但是CPU利用率很高，每秒却无法处理几个事务。<ul><li>对于上述的热点行，可以临时关闭死锁检测，就需要等待50s超时，风险较高</li><li><code>server</code>层限流，限制同一时间进入更新的线程数；可以使用中间件, 或者修改<code>MySQL</code>源码，对于同一行的修改，进入引擎之前排队。</li><li>拆行，将一行拆分为多行减少冲突概率，原理上就是分段汇总，比如<code>java</code>的原子类<code>LongAdder</code></li></ul></li></ul></li></ul></div><h1><code>InnoDB</code>引擎</h1><h2 id="逻辑存储结构-表空间-段-区-页-行">逻辑存储结构: 表空间 - 段 - 区 - 页 - 行</h2><ol><li>表空间(<code>ibd</code>文件)，一个<code>MySQL</code>实例可以对应多个表空间，用于存储记录，索引</li><li>段分为数据段(Leaf node segment)，索引段(Non-leaf node segment)，回滚段(Rollback segment)。数据段就是B+树叶子节点，索引段就是非叶子节点，段用来管理多个区</li><li>区默认大小为1M，默认存储64个页</li><li>页默认大小为16K，为了保证页的连续性，<code>InnoDB</code>每次从磁盘申请4~5个区。</li><li>行，数据按行存放。<code>Trx_id</code>就是最后一次事务操作的id;<code>Roll_pointer</code>是某条记录改动时，把旧版本写入<code>undo log</code>中，相当于一个指针，可以找到记录修改前的信息。</li></ol><h2 id="架构">架构</h2><ul><li>左侧是内存结构，右侧是磁盘结构:<br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/MySQL/architecture.png" alt="architecture"></li></ul><h3 id="内存结构">内存结构</h3><ol><li><p><code>Buffer Pool</code></p><ul><li>缓冲池是主内存中的一个区域，可以缓存磁盘上经常操作的真实数据。<strong>增删改查操作缓冲池中的数据，没有数据则从磁盘中加载到缓冲池中</strong>，再以一定的频率刷新到磁盘，减少磁盘I/O，加快处理速度。缓冲池以<strong>页</strong>为单位，底层采用<strong>链表</strong>管理页，页分三类:<br>(1) <code>free page</code>: 空闲页，没有使用<br>(2) <code>clean page</code>: 被使用的页，数据没有修改过<br>(3) <code>dirty page</code>: 脏页，被使用过被修改过，与磁盘不一致的数据(缓冲池中还没有刷新到磁盘的数据)</li></ul></li><li><p><code>Change Buffer</code></p><ul><li>更改缓冲区，(<strong>针对非唯一二级索引页</strong>，主键索引这种唯一索引是<strong>不会</strong>存储在更改缓冲区中)，执行<code>DML</code>语句时，如果这些数据页没有在缓冲池中，不会直接操作磁盘，而是将数据变更存在<code>Change Buffer</code>中，在未来数据被读取时，合并恢复到缓冲池中，再将合并后的数据刷新到磁盘</li><li>因为二级索引通常是非唯一的，以随机顺序插入二级索引。删除和更新可能会影响索引树中不相邻的二级索引页。每一次都操作磁盘则会产生大量的磁盘I/O，更改缓冲区可以在缓冲池中合并处理，减少磁盘I/O</li></ul></li><li><p><code>Adaptive Hash Index</code></p><ul><li>自适应哈希索引，<code>InnoDB</code>本身不支持哈希索引，支持B+树索引。但是B+树索引是等值索引，因此引入自适应哈希索引优化对缓冲池数据的查询。<code>InnoDB</code>会监控表上对各索引页的查询，如果观察到哈希索引可以提高速度，则会<strong>自动</strong>建立哈希索引，即为自适应哈希索引。</li><li>参数: <code>adaptive_hash_index</code>是自适应哈希索引的开关，默认是开启的</li></ul></li><li><p><code>Log Buffer</code></p><ul><li>日志缓冲区，用来保存将要写入到磁盘中的<code>Log</code>日志数据(<code>redo log</code>, <code>undo log</code>)，大小默认为<code>16MB</code>。日志会定期刷新到磁盘中，如果需要更新、插入或删除多行事务，增加日志缓冲区的大小可以节省磁盘I/O</li><li>参数: <code>innode_log_buffer_size</code> 缓冲区大小</li><li><code>innodb_flush_log_at_trx_commit</code> 日志刷新到磁盘的时机<ul><li>0: 日志每秒写入并刷新</li><li>1(<strong>默认</strong>): 日志在每次事务提交时写入并刷新到磁盘</li><li>2: 日志在每次事务提交后写入，并且每秒刷新到磁盘</li></ul></li></ul></li></ol><h3 id="磁盘结构">磁盘结构</h3><ol><li><p><code>System Tablespace</code></p><ul><li>系统表空间，是<strong>更改缓冲区</strong>的存储区域。如果表在系统表空间而不是每个表文件或者通用表空间中创建的，也可能包含表和索引数据</li><li>参数: <code>innodb_data_file_path</code></li></ul></li><li><p><code>File-Per-Table Tablespaces</code></p><ul><li>每个表的文件表空间包含单个表的数据和索引，存储在文件系统的单个数据文件中。</li><li>参数: <code>innodb_file_per_table</code>默认为开启的，如果不开启，则存储在系统表空间中</li></ul></li><li><p><code>General Tablespaces</code></p><ul><li>通用表空间，需要通过<code>create tablespace</code>语法创建，建表时可以指定该表空间</li><li>创建一个表空间: <code>create tablespace 表空间名 add datafile 表名.ibd engine=引擎名;</code></li><li>创建一张表并指定表空间: <code>create table xxx ... tablespae 表空间名;</code></li></ul></li><li><p><code>Undo Tablespaces</code></p><ul><li>撤销表空间，<code>MySQL</code>初始化时自动创建两个默认的<code>undo</code>表空间，初始大小<code>16M</code>，用于存储<code>undo log</code></li></ul></li><li><p><code>Temporary Tablespaces</code></p><ul><li>临时表空间，使用会话临时表空间和全局临时表空间，存储用户创建的临时表等数据</li></ul></li><li><p><code>Doublewrite Buffer Files</code></p><ul><li>双写缓冲区，<code>InnoDB</code>将数据页从缓冲池刷新到磁盘前，将数据页写入双写缓冲区文件中，便于系统异常时恢复数据</li><li>后缀: <code>.dblwr</code></li></ul></li><li><p><code>Redo Log</code></p><ul><li>重做日志，实现事务的<strong>持久性</strong>。日志文件由两部分组成，重做日志缓冲区<code>redo log buffer</code>和重做日志文件<code>redo log</code>。前者在内存中，后者在磁盘中。事务提交以后会把所有的修改信息都存到该日志中用于在刷新脏页到磁盘时，发生错误时进行数据恢复使用。</li><li><code>redo log</code> <strong>不会循环写</strong>，每隔一段时间清理之前没用的内容。</li><li><code>ib_logfile</code></li></ul></li></ol><h3 id="后台线程">后台线程</h3><ol><li><code>Master Thread</code> 核心后台线程，负责调度其他线程，同时将缓冲池中的数据<strong>异步</strong>刷新到磁盘中，保持数据的<strong>一致性</strong>。包括脏页的刷新，合并插入缓存，<code>undo</code>页的回收</li><li><code>IO Thread</code> 使用AIO来处理IO请求，<code>IO Thread</code>主要负责这些I/O请求的回调</li></ol><table><thead><tr><th style="text-align:center">线程类型</th><th style="text-align:center">默认个数</th><th style="text-align:center">职责</th></tr></thead><tbody><tr><td style="text-align:center">Read Thread</td><td style="text-align:center">4</td><td style="text-align:center">负责读</td></tr><tr><td style="text-align:center">Write Thread</td><td style="text-align:center">4</td><td style="text-align:center">负责写</td></tr><tr><td style="text-align:center">Log Thread</td><td style="text-align:center">1</td><td style="text-align:center">负责将日志缓冲区刷新到磁盘</td></tr><tr><td style="text-align:center">Insert Buffer Thread</td><td style="text-align:center">1</td><td style="text-align:center">负责将写缓冲区的内容刷新到磁盘</td></tr></tbody></table><ul><li><code>show engine innodb status;</code>查看<code>InnoDB</code>引擎的状态信息</li></ul><ol start="3"><li><code>Purge Thread</code>回收事务已经提交了的<code>undo log</code>，事务提交之后，<code>undo log</code>可能不用了，就用该线程来回收</li><li><code>Page Cleaner Thread</code>是协助 <code>Master Thread</code>刷新脏页到磁盘的线程，减轻<code>Master Thread</code>的工作压力，减少阻塞</li></ol><h3 id="事务原理">事务原理</h3><ul><li><p>一致性是通过<code>redo log, undo log</code>来保证的</p></li><li><p>隔离性通过锁机制，<code>MVCC</code>(多版本并发控制)实现</p></li><li><p>持久性由<code>redo log</code>保证</p></li><li><p>原子性由<code>undo log</code>保证<br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/MySQL/WAL.png" alt="WAL"></p></li><li><p><code>undo log</code>记录数据被修改前的信息，包含回滚和MVCC</p></li><li><p><code>undo log</code>记录逻辑日志，<code>redo log</code>记录物理日志</p></li><li><p>当<code>delete</code>时，<code>undo log</code>会记录一条<code>insert</code>记录；<code>update</code>时，<code>undo log</code>会有一条相反的<code>update</code>。执行<code>rollback</code>时，可以从逻辑记录中读取到相应的内容并回滚</p></li><li><p><code>undo log</code>销毁: <code>undo log</code>在事务执行时产生，事务提交时，不会立即删除，因为可能还要用于MVCC</p></li><li><p><code>undo log</code>存储: 采用<strong>段</strong>的方式进行管理和记录，存放在<code>rollback segment</code>中，内部包含1024个<code>undo log segment</code></p></li></ul><h2 id="MVCC-多版本并发控制">MVCC(多版本并发控制)</h2><div class="note info flat"><ul><li><code>MVCC</code>: 维护一个数据库的多个版本，使得<strong>读写操作没有冲突</strong>。</li><li>快照读为<code>MVCC</code>提供了一个非阻塞读的功能。</li><li>MVCC依赖:数据库记录中的三个隐式字段， <code>undo log</code>，<code>readView</code>实现</li></ul></div><div class="note info flat"><ol><li>当前读: 读取的是记录的<strong>最新版本</strong>，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。<ul><li><code>select ... lock in share mode</code>(共享锁)</li><li><code>select ... for update</code>、<code>update</code>、<code>insert</code>、<code>delete</code>(排他锁)</li><li>上述二者都是一种当前读</li></ul></li><li>快照读: 简单的<code>select</code>(不加锁)就是快照读，读取的是记录数据的可见版本，有可能是历史数据，非阻塞读<ul><li><code>Read Committed</code>: 每次<code>select</code>都生成一个快照读</li><li><code>Repeatable Read</code>: 开启事务后第一个<code>select</code>语句才是快照读的地方，后面实际上查询的都是<strong>第一个读生成的快照</strong></li><li><code>Serializable</code>: 快照读会退化为当前读</li></ul></li></ol></div><ol><li><p>记录中的隐式字段</p><table><thead><tr><th style="text-align:center">隐藏字段</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">DB_TRX_ID</td><td style="text-align:center">最近修改事务的ID，记录插入这条记录或最后一次修改该记录的事务ID</td></tr><tr><td style="text-align:center">DB_ROLL_PTR</td><td style="text-align:center">回滚指针，指向这条记录的上一个版本，用于配合undo log</td></tr><tr><td style="text-align:center">DB_ROW_ID</td><td style="text-align:center">隐藏主键，如果表没有主键才会生成</td></tr></tbody></table> <div class="note info flat"><ul><li>查看表空间<code>ibd</code>文件: <code>ibd2sdi 文件名.idb</code></li></ul></div></li><li><p><code>undo log</code></p><ul><li><code>undo log</code>日志可以被删除，但是不会立即删除<ul><li>当<code>insert</code>的时候，产生的<code>undo log</code>只在回滚时需要，事务提交以后，可以立即被删除</li><li>当<code>update, delete</code>的时候，产生的<code>undo log</code>日志不仅在回滚时需要，在快照读的时候也需要，不会立即被删除</li></ul></li></ul> <div class="note info flat"><p><code>undo log</code> 版本链</p><ul><li>不同事物或相同事务对同一条记录进行修改，导致该记录的<code>undo log</code>生成一条记录版本链表，链表头部是<strong>最新的旧记录</strong>，链表尾部是<strong>最早的旧记录</strong></li></ul></div></li><li><p><code>readView</code></p><ul><li>读视图是快照读<code>SQL</code>执行时<code>MVCC</code>提取数据的依据，记录并维护系统当前活跃的事务(<strong>未提交的</strong>)<code>id</code>，包含四个核心字段</li></ul><table><thead><tr><th style="text-align:center">字段</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">m_ids</td><td style="text-align:center">当前活跃事务ID</td></tr><tr><td style="text-align:center">min_trx_id</td><td style="text-align:center">最小活跃事务ID</td></tr><tr><td style="text-align:center">max_trx_id</td><td style="text-align:center">预分配事务，当前最大事务ID + 1(因为事务ID自增)</td></tr><tr><td style="text-align:center">creator_trx_id</td><td style="text-align:center"><code>readView</code>创建者的事务ID</td></tr></tbody></table></li></ol><h3 id="版本链数据访问规则">版本链数据访问规则:</h3><p><code>trx_id</code>表示当前事务ID</p><ol><li><code>trx_id</code> == <code>creator_trx_id</code> ? 可以访问该版本，因为等式成立表示数据是当前事务更改的(自己改的数据自己肯定可以先访问)</li><li><code>trx_id</code> &lt; <code>min_trx_id</code> ? 可以访问该版本，因为这个表明数据已经提交了，所以可以访问</li><li><code>trx_id</code> &gt; <code>max_trx_id</code> ? <strong>不可以</strong>访问该版本，因为表明当前事务是在<code>readView</code>生成后才开启的</li><li><code>min_trx_id</code> &lt;= <code>trx_id</code> &lt;= <code>max_trx_id</code> ? 如果<code>trx_id</code>不在<code>m_ids</code>中是可以访问该版本的。因为如果成立，表示数据已经提交了</li></ol><div class="note info flat"><ul><li><code>Read Committed</code>在事务中每一次执行快照读的时候生成<code>readView</code></li><li><code>Repeatable Read</code>在事务第一次执行快照读的时候生成<code>readView</code>，后续复用该<code>readView</code></li></ul></div><h1>MySQL四个系统数据库</h1><table><thead><tr><th style="text-align:center">数据库</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">mysql</td><td style="text-align:center">存储MySQL服务器正常运行所需要的各种信息(时区，主从，用户，权限等)</td></tr><tr><td style="text-align:center">information_schema</td><td style="text-align:center">提供了访问数据库元数据的各种表和视图，包含数据库、表、字段类型已经访问权限等</td></tr><tr><td style="text-align:center">performance_schema</td><td style="text-align:center">为MySQL服务器运行时状态提供了一个底层监控功能，用于手机数据库服务器性能参数</td></tr><tr><td style="text-align:center">sys</td><td style="text-align:center">一系列方便DBA和开发人员利用performance_schema性能数据库进行性能调优和诊断的视图</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 锁 </tag>
            
            <tag> InnoDB引擎架构 </tag>
            
            <tag> MVCC </tag>
            
            <tag> 系统库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL笔记_3</title>
      <link href="/posts/be4e57f0.html"/>
      <url>/posts/be4e57f0.html</url>
      
        <content type="html"><![CDATA[<h1><code>SQL</code>优化</h1><h2 id="insert优化"><code>insert</code>优化</h2><ol><li>使用批量插入，一次性插入500~1000条数据，而不是一条一条插入，也不能一次性插入过多</li><li>使用手动事务提交</li><li>主键顺序插入</li><li>如果需要插入大批量的数据，可以使用<code>MySQL</code>提供的<code>load</code>指令，而不使用<code>insert</code> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用load需要修改</span></span><br><span class="line"><span class="comment">-- 客户端链接服务端 加上--local-infile参数</span></span><br><span class="line">mysql \<span class="operator">-</span>\<span class="operator">-</span><span class="keyword">local</span><span class="operator">-</span>infile <span class="operator">-</span>u root <span class="operator">-</span>p</span><br><span class="line"><span class="comment">-- 设置全局参数local-infile为1，开启本地加载文件到数据库的开关</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> <span class="keyword">local</span><span class="operator">-</span>infile <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 执行load指令 将准备好的数据加载到表结构中</span></span><br><span class="line">load data <span class="keyword">local</span> infile <span class="string">&#x27;/root/sql1.log&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> <span class="string">&#x27;user&#x27;</span> fields terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span> lines terminated <span class="keyword">by</span> <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="comment">-- 每个字段之间使用,分割，每行之间使用&#x27;\n&#x27;分割</span></span><br></pre></td></tr></table></figure></li><li>对于<code>load</code>命令而言，同样顺序插入比乱序插入更好</li></ol><h2 id="主键优化">主键优化</h2><div class="note info flat"><ul><li>表数据都是根据主键顺序存放的，这种存储方式的表称为索引组织表(<code>index organized table, IOT</code>)</li><li><code>InnoDB</code>中的页可以为空，也可以填充一半，或者存满。规定每个页至少包含两行数据，最多包含<code>N</code>行数据。因为如果只有一行数据，相当于形成了一个链表，如果一行数据比较大，超出于阈值后又会形成溢出现象。</li><li>行与行之间根据主键排列</li></ul></div><h3 id="主键顺序插入">主键顺序插入</h3><ul><li>如果主键顺序插入，则一页存放满以后自动开启新页并将数据存放其中<br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/MySQL/primary_key_ordered.png" alt="primary_key_ordered"></li></ul><h3 id="主键乱序插入">主键乱序插入</h3><ul><li>如果主键乱序插入，存放满以后，开启新的数据页，找到本应该要存放的数据页的50%的位置，后面的行移动到新的数据页，再决定要插入的行存放在原来剩下的50%的数据页中还是新数据页中，最后改变链表指针, 称为<strong>页分裂</strong></li><li>删除一行记录时，没有物理删除，只是标记为删除并且可以被其他记录使用</li><li>页中删除的记录达到<code>MERGE_THRESHOLD</code>，即默认页的50%时，<code>InnoDB</code>就会查找最近的前后两个页是否可以合并，如果可以合并，就会优化空间，称为<strong>页合并</strong><br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/MySQL/primary_key_unordered_1.png" alt="primary_key_unordered_1"><br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/MySQL/primary_key_unordered_2.png" alt="primary_key_unordered_2"><br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/MySQL/primary_key_unordered_3.png" alt="primary_key_unordered_3"></li></ul><div class="note info flat"><p>推荐使用主键自增</p><ul><li>比如身份证号，如果拿身份证号作为主键，导致所有二级索引存储主键的值就会占用<code>20B</code>，如果是自增主键，大小就会很小，所以主键长度越小，普通索引的叶子节点就越小，占用空间也就越小。</li><li>但是如果只有一个唯一索引，并且是<code>K-V</code>键值对查询的索引，那就可以不用主键自增，避免回表</li></ul></div><h3 id="主键设计原则">主键设计原则</h3><ol><li>满足业务需求的情况下尽量降低主键的长度。因为主键索引只有一个，二级索引的叶子节点中记录的是主键，如果主键较长，会占用较多的磁盘空间。</li><li>插入数据使用<strong>顺序插入</strong>，使用<code>auto_increment</code></li><li>不要使用<code>UUID</code>或者身份证号作为主键</li><li>避免对主键的修改</li></ol><h2 id="order-by优化"><code>order by</code>优化</h2><div class="note info flat"><ol><li><code>Using filesort</code>: 通过<strong>表索引</strong>或<strong>全表扫描</strong>，读取满足条件的数据行。在排序缓冲区中<code>sort buffer</code>完成排序操作，所有不是通过索引直接返回排序结果的排序都是<code>filesort</code>排序</li><li><code>Using index</code>: 通过有序索引顺序扫描直接返回有序数据，就是<code>using index</code>，不需要额外的排序，操作效率高。</li></ol></div><ul><li>当没有<code>(age, phone)</code>这个联合索引的时候，<code>select id, age, phone from user order by age, phone;</code>这个查询语句使用的是<code>using filesort</code></li><li>当有<code>(age, phone)</code>这个联合索引的时候，则该语句使用<code>using index</code><ul><li>若语句改变为<code>select id, age, phone from user order by age desc, phone desc;</code> 依然是<code>using index</code></li><li>但是如果语句改变为<code>select id, age, phone from user order by age, phone desc;</code> 则会出现前一个使用<code>using index</code>，后一个变为<code>using filesort</code>这是因为创建索引的时候值都是从小到大排列的，可以通过<code>show index from user</code>查看其中的<code>Collection</code>列是<code>A</code>就表示升序排列</li><li>为了解决这个问题，只需要在创建索引的时候指定顺序即可，比如<code>create index idx_user_age_phone_ad on user(age asc, phone desc);</code> 此时在进行上一次的排序，就会发现<code>using index</code></li><li>如果排序变为<code>select id, age, phone from user order by phone, age;</code> 就会出现前一个使用<code>using filesort</code>，后一个使用<code>using index</code>，因为这个违背了最左前缀法则，所以会出现两个。这个不像<code>where ... and ...</code>可以自动匹配顺序变化。</li></ul></li></ul><div class="note info flat"><ul><li>如果有联合索引，则全部是升序排序，或者全部是降序排序，均可实现<code>using index</code>；</li><li>但是如果一个是升序，另一个是降序，则需要在创建一个指定排序的索引才行</li><li>这些都是建立在覆盖索引，不需要回表查询的基础上。如果需要回表，则一定是<code>using filesort</code>，比如: <code>select * from user order by age, phone;</code></li></ul></div><h3 id="排序设计原则">排序设计原则</h3><ol><li>建立合适的索引，多字段排序也遵循最左前缀法则</li><li>使用覆盖索引</li><li>多字段排序，一个升序一个降序，注意联合索引在创建时的规则</li><li>不可避免出现<code>filesort</code>的情况下，出现大数据排序时可以增大缓冲区的大小，<code>sort_buffer_size</code>默认为<code>256K</code></li></ol><div class="note info flat"><p><code>select city,name,age from t where city='杭州' order by name limit 1000;</code></p><ul><li>初始化<code>sort buffer</code>, 确定要放入<code>city name age</code>字段</li><li>从索引<code>city</code>中根据索引找到第一个满足条件的主键ID</li><li>根据主键ID返回<code>name city age</code>存入<code>sort buffer</code></li><li>从索引ID取下一个符合要求的主键ID，直到取完</li><li><code>sort buffer</code>按照<code>name</code>快排</li><li>取<code>1000</code>行返回</li></ul><blockquote><p>这是全字段排序，可能在内存中完成，也可能在外部完成，取决于<code>sort_buffer_size</code>, <code>number_of_tmp_files</code>表示排序的过程中需要使用的临时文件个数，所以配置的<code>sort_buffer_size</code>越小，<code>number_of_tmp_files</code>就越大</p></blockquote><ul><li>全字段排序如果一行内容很多，就会导致<code>sort buffer</code>放不下，产生很多临时文件，性能就不好</li><li>配置<code>max_length_for_sort_data</code>，如果单行长度超过这个值，<code>MySQL</code>就会换一个排序方法<ul><li>如果<code>max_length_for_sort_data</code>变小，比如只能放入<code>name</code>，就不能直接返回了</li><li>初始化<code>sort buffer</code>，确定放入<code>name</code>和<code>id(rowid)</code></li><li>根据<code>city</code>索引找到主键id，根据主键id返回<code>name</code>和<code>id</code>字段，存入<code>sort buffer</code>中</li><li>从索引<code>city</code>取下一个主键ID，重复，直到不满足<code>city</code>条件为止</li><li><code>sort buffer</code>对<code>name</code>字段排序</li><li>结果根据id找到<code>city name age</code>返回</li><li>所以比全字段排序多了一次回表</li></ul></li><li>如果建立<code>(city,name)</code>联合索引，这条语句就不会进行排序<ul><li>从索引<code>city</code>中找到第一个满足条件的主键ID</li><li>从主键ID找到<code>city name age</code>作为结果集的一部分直接返回</li></ul></li><li>如果建立<code>(city, name, age)</code>联合索引，则变成了覆盖索引，不需要回表，直接返回结果</li></ul></div><ul><li>如果<code>explain</code>的结果中，是<code>using temporary, using filesort</code>的话，那么结果就是需要临时表，并且需要排序</li></ul><div class="note info flat"><p>如果现在有单词表，需要每次随机显示三个单词:<code>select word from words order by rand() limit 3;</code></p><ul><li><p>创建临时表，引擎<code>Memory</code>，两个字段，一个随机值<code>R</code>，一个单词<code>word</code>，没有索引</p></li><li><p>按照单词表主键顺序读出<code>word</code>，生成<code>0-1</code>之间的随机数，存入临时表中</p></li><li><p>按照字段<code>R</code>排序</p><ul><li>初始化<code>sort buffer</code>， 两个字段，一个是<code>double</code>，一个是整型</li><li>从内存临时表读取<code>R</code>和<code>rowid</code>，存入<code>sort buffer</code>中</li><li><code>sort buffer</code>根据<code>R</code>进行排序</li><li>取前三个<code>rowid</code>，根据<code>rowid</code>在内存表找到对应的<code>word</code>，返回</li></ul></li><li><p>对于<code>InnoDB</code>表，全字段排序减少磁盘访问，会优先选择</p></li><li><p><code>order by rowid</code>用的就是内存表进行排序</p></li><li><p>对于内存表，回表就是根据行数据，直接访问内存得到数据，不会多访问磁盘，所以优化器优先考虑行越小越好，所以会选择根据<code>rowid</code>排序</p></li><li><p><code>rowid</code>就是<code>InnoDB</code>唯一标识数据行的值，如果主键被删除了，<code>InnoDB</code>会自动生成一个<code>6B</code>的<code>rowid</code></p></li><li><p>对于<code>Memory</code>引擎，<code>rowid</code>就是数组下标。如果内存临时表中进行排序，这个临时表就是<code>Memory</code>引擎的</p></li><li><p><code>tmp_table_size</code>参数设置了内存临时表的大小，默认<code>16MB</code>，超过大小就是磁盘临时表，<code>InnoDB</code>引擎，如果使用磁盘临时表，就是一个没有显式主键的<code>InnoDB</code>表排序过程</p></li><li><p>如果<code>limit</code>值特别小的情况，引擎会使用优先队列排序优化</p></li></ul></div><h2 id="limit优化"><code>limit</code>优化</h2><div class="note info flat"><ul><li>由于需要排序记录，并且将其他记录全部丢弃，查询排序的时间非常长。因此，<code>limit</code>越往后时间越长</li><li>可以使用<strong>覆盖索引 + 子查询</strong>的形式优化</li></ul></div><ul><li>原始语句: <code>select * from 表名 order by id limit 9000000, 10;</code></li><li>覆盖索引: <code>select id from 表名 order by id limit 9000000, 10;</code></li><li>子查询: <code>select * from 表名 where id in (select id from 表名 order by id limit 9000000, 10);</code> 这句话会报错，因为不能在<code>in</code>后面使用<code>limit</code></li><li><code>select s.* from 表名 s, (select id from 表名 order by id limit 90000000, 10) a where s.id=a.id;</code> 将limit查询结果作为一个表联合查询</li></ul><h2 id="count优化"><code>count</code>优化</h2><div class="note info flat"><ul><li><code>MyISAM</code>把表的总行数存储在磁盘上，<code>count(*)</code>直接返回这个数，效率高，前提是没有<code>where</code>条件</li><li><code>InnoDB</code>即使没有<code>where</code>条件，也需要将数据一行一行读出，然后累加<ul><li>这是因为<code>MVCC</code>，所以不能记录<code>count(*)</code>的值直接返回，因为每一次返回的值是不确定的</li><li><code>InnoDB</code>会保证逻辑正确的情况下，找索引树最小的那棵来遍历计数</li></ul></li><li>优化只有自己计数，例如使用<code>redis</code></li></ul></div><ul><li><code>count(列名)</code>返回的是列中不为<code>null</code>的个数，</li><li><code>count(主键)</code>遍历整张表，把每一行主键id取出，返回给服务层，服务层拿到主键以后直接累加，因为主键不会为<code>null</code></li><li><code>count(字段)</code>需要看字段是否有<code>not null</code>约束，如果没有该约束，需要将每行字段值取出，返回给服务层。服务层判断是否为<code>null</code>，不为<code>null</code>才累加计数<ul><li>如果有<code>not null</code>约束，则跟主键处理一样</li></ul></li><li><code>count(1)</code>遍历整张表，但是不取值，服务层对于返回的每一行，都放一个数字1进去，直接按行累加。参数是什么数字都可以，0，-1都可以，返回一样的结果</li><li><code>count(*)</code>不会把全部字段取出来，而是专门优化了，直接在服务层累加</li><li>所以最终的效率<code>count(*)</code>性能最高，类似于<code>count(1)</code>，然后才是<code>count(主键)</code>，性能最差的是<code>count(字段)</code>, 推荐使用<code>count(*)</code></li></ul><h3 id="缓存系统计数">缓存系统计数</h3><ul><li>使用<code>Redis</code>计数，插入一行，计数就加一，反之减一<ul><li>可能丢失更新，<code>Redis</code>在内存中，虽然可以持久化保存在磁盘中，如果没有保存的时候异常重启了，那么再启动时，<code>Redis</code>从磁盘中得到的数据就丢失了，不过可以通过异常重启以后执行<code>count(*)</code>更新值</li><li>就算这样，逻辑也会有问题，比如取出总数同时显示最近100条，就需要从<code>Redis</code>中取出数据，再从<code>MySQL</code>中取100条<ul><li>返回的100条的时候可能新加入了数据</li><li>可能100条数据中有新数据，但是<code>Redis</code>没有 + 1</li><li>可能100条数据中没有新数据，但是<code>Redis</code> + 1</li></ul></li></ul></li></ul><h3 id="数据库计数">数据库计数</h3><ul><li>单独存储一张表用来计数</li><li>可以崩溃恢复</li><li>可以利用事务隔离保证计数和返回的结果不会有偏差</li></ul><h2 id="update优化"><code>update</code>优化</h2><ul><li>更新数据时，<strong>根据索引字段级进行更新，否则行锁会升级成表锁。</strong></li><li><code>update course set name='Java' where id=1;</code>这句话是行锁，别的事务更新别的行不会被卡住</li><li><code>update course set name='Springboot' where name='kafka';</code>这句话是表锁，别的事务更新别的行会被卡住，因为<code>name</code>字段没有索引<ul><li>如果建立了<code>name</code>的索引，则上句更新就是行锁了</li></ul></li><li>一定要根据索引字段进行更新！否则表锁会锁住整张表。</li></ul><h1>存储对象: 视图、存储过程、触发器、存储函数</h1><h2 id="视图">视图</h2><div class="note info flat"><ul><li>视图是虚拟存在的表，视图中的数据不在数据库中真实存在，行列数据来自视图查询中使用的表，称为基表，在使用视图时动态生成</li><li>视图只保存<code>SQL</code>逻辑，不保存查询结果。创建视图主要工作在<code>SQL</code>查询语句上</li></ul></div><h3 id="增">增</h3><ul><li>创建视图: <code>create [or replace] view 视图名[(列名列表)] as select语句 [with [cascade | local] check option];</code><ul><li>替换视图就使用<code>or replace</code></li><li><code>select语句</code>关联的表就是<strong>基表</strong></li><li>创建视图的时候指定<code>with cascade check option</code>，并且设置了视图<code>select语句</code>为<code>where id &lt; 20</code>，若此时增加了一条<code>id = 30</code>的数据就会报错，提示无法插入。如果没有设置<code>check option</code>就不会报错，可以正常插入</li></ul></li></ul><h3 id="删">删</h3><ul><li>删除视图: <code>drop view [if exists] 视图名[, 视图名1, ...];</code></li></ul><h3 id="改">改</h3><ul><li>替换视图: <code>create or replace view 视图名[(列名列表)] as select语句 [with [cascade | local] check option];</code></li><li>修改视图: <code>alter view 视图名[(列名列表)] as select语句 [with [cascade | local] check option];</code></li></ul><h3 id="查">查</h3><ul><li>查询创建视图语句: <code>show create view 视图名;</code></li><li>查看视图数据: <code>select * from 视图名;</code>视图就是虚拟存在的表，所以可以跟操作表一样操作视图</li></ul><div class="note info flat"><ul><li>在视图中插入数据会插入到对应的基表中，因为视图不会保存数据。</li><li><code>with check option</code> 就是检查项，在增删改的时候都会检查是否符合视图创建时的定义。<code>MySQL</code>允许创建视图的视图，检查依赖视图规则有两个选项，就是<code>cascade</code>以及<code>local</code></li></ul></div><h3 id="cascade"><code>cascade</code></h3><ul><li><code>create view v1 as select id, name from student where id &lt;= 20;</code> 这里<strong>没有设置</strong><code>check option</code>，所以修改数据不会检查<code>id &lt;= 20</code></li><li><code>create view v2 as select id, name from v1 where id &gt;= 10 with cascade check option;</code> 这里修改了<code>v2</code>的数据时，不仅会检查<code>id &gt;= 10</code>，还会检查<code>id &lt;= 20</code></li><li><code>create view v3 as select id, name from v2 where id &lt;= 15;</code> 这里修改<code>v3</code>的数据<code>&gt; 15</code>也可以插入，但是如果<code>&gt; 20</code>则不能插入，因为不能满足<code>v2</code>的检查项</li></ul><h3 id="local"><code>local</code></h3><ul><li><code>create view v1 as select id, name from student where id &lt;= 15;</code> 修改<code>v1</code>中的数据不会检查<code>id &lt;= 15</code></li><li><code>create view v2 as select id, name from v1 where id &gt;= 10 with local check option;</code> 先检查是否满足<code>v2</code>条件，然后再找<code>v1</code>是否需要检查，发现<code>v1</code>不需要检查，则直接插入。所以插入<code>id = 17</code>也可以</li><li><code>create view v3 as select id, name from v2 where id &lt; 20;</code> 没有定义检查选项，会先找<code>v2</code>的检查项，发现<code>v2</code>需要检查<code>id &gt;= 10</code>，再发现<code>v1</code>没有检查选项，所以最终<code>id &gt;= 10</code>即可</li></ul><div class="note info flat"><ul><li>视图如果要能够更新，必须满足视图中的行与基表中的行<strong>一对一关系</strong>，只要包含下面<strong>任意一项</strong>，则视图不可更新<ol><li>聚合函数或窗口函数<code>sum, min, max, count</code></li><li><code>distinct</code></li><li><code>group by</code></li><li><code>having</code></li><li><code>union</code>, <code>union all</code></li></ol></li></ul></div><h3 id="视图作用">视图作用</h3><ol><li>操作简单，将复杂的经常使用的查询定义在视图中，不需要每次都指定同样的相同操作</li><li>安全，由于<code>MySQL</code>不能授权到特定的行列，只能授权到表。所以可以通过视图修改用户能见到的数据</li><li>数据独立: 可以帮助用户屏蔽真实表结构带来的变化</li></ol><h3 id="例子">例子:</h3><ol><li>为了保证安全性，操作<code>user</code>表时，只能看到用户的基本字段，屏蔽手机号和邮箱两个字段:<br><code>create view user_view as select id, name, profession, age, gender, status, create_time from user;</code></li><li>为了简化操作，查询每个学生所选修课程，三表联查，定义一个视图: <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> s.name, s.no, c.name <span class="keyword">from</span> student s, student_course sc, course c <span class="keyword">where</span> s.id <span class="operator">=</span> sc.studentid <span class="keyword">and</span> c.id <span class="operator">=</span> sc.courseid;</span><br><span class="line"><span class="comment">-- 封装成视图</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> stu_course_view <span class="keyword">as</span> <span class="keyword">select</span> s.name studentname, s.no studentno, c.name coursename </span><br><span class="line"><span class="keyword">from</span> student s, student_course sc, course c <span class="keyword">where</span> s.id <span class="operator">=</span> sc.studentid <span class="keyword">and</span> c.id <span class="operator">=</span> sc.courseid;</span><br></pre></td></tr></table></figure></li></ol><h2 id="存储过程">存储过程</h2><div class="note info flat"><ul><li>很多地方<strong>禁止</strong>使用</li><li>事先编译并存储在数据库中的一段<code>SQL</code>语句集合，减少数据库和应用服务器之间的传输，提高数据处理效率</li><li>就是<code>SQL</code>语句封装重用</li><li>特点：封装、复用；可以接收参数和返回数据；减少网络交互，提升效率</li></ul></div><h3 id="增-2">增</h3><ul><li>创建存储过程  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> 存储过程名称([<span class="keyword">in</span><span class="operator">/</span><span class="keyword">out</span><span class="operator">/</span><span class="keyword">inout</span>参数列表])</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="comment">-- SQL语句</span></span><br><span class="line"><span class="keyword">end</span>; <span class="comment">-- 这里有个分号</span></span><br><span class="line"><span class="comment">-- 如果是在命令行中创建存储过程，遇到分号就自动结束了，所以会报错，需要通过delimiter指定sql语句结束符</span></span><br><span class="line"><span class="comment">--  delimiter $$</span></span><br><span class="line"><span class="comment">--  会一直到$$才认为是语句结束了</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="删-2">删</h3><ul><li>删除存储过程: <code>drop procedure if exists 存储过程名;</code></li></ul><h3 id="调用">调用</h3><ul><li>调用存储过程: <code>call 存储过程名([参数])</code></li></ul><h3 id="查-2">查</h3><ul><li>查询指定数据库的存储过程以及状态信息: <code>select * from information_schema.routines where routine_schema='xxx';</code></li><li>查询存储过程定义: <code>show create procedure 存储过程名;</code></li></ul><h3 id="变量">变量</h3><p><code>MySQL</code>变量分为三类，系统变量，用户自定义变量以及局部变量</p><div class="note info flat"><ul><li>存储过程的参数类型：<code>in, out, inout</code>三种类型，默认是<code>in</code>类型的，作为输入，<code>out</code>类型作为输出，作为返回值，<code>inout</code>既可以作为输入又可以作为输出</li></ul></div><h4 id="系统变量">系统变量:</h4><ul><li>不需要用户自定义，属于服务器，分为全局变量<code>global</code>以及会话变量<code>session</code></li><li>会话变量表示在当前会话内有效</li><li>查询所有系统变量: <code>show [session | global] variables;</code></li><li>模糊查询: <code>show [session | global] variables like ...;</code></li><li>查询指定的系统变量，不写默认是<code>session</code>: <code>show @@[session | global].系统变量名;</code></li><li><code>MySQL</code>重启后，设置的<code>global</code>会失效，需要在<code>my.cnf</code>中完成设置才能保持</li></ul><h4 id="用户自定义变量">用户自定义变量</h4><ul><li>直接<code>@变量名</code>即可</li><li>赋值自定义变量:  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="variable">@var_name</span> <span class="operator">=</span> expr[, <span class="variable">@var_name</span> <span class="operator">=</span> expr, ...];</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@var_name</span> :<span class="operator">=</span> expr[, <span class="variable">@var_name</span> :<span class="operator">=</span> expr, ...];</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@var_name</span> :<span class="operator">=</span> expr</span><br><span class="line"><span class="keyword">select</span> 字段名 <span class="keyword">into</span> <span class="variable">@var_name</span> <span class="keyword">from</span> 表名;</span><br></pre></td></tr></table></figure></li><li>使用<code>select @varname</code>，如果<code>var_name</code>没有赋值，这个语句不会报错，只会显示<code>null</code></li></ul><h4 id="局部变量">局部变量</h4><ul><li>使用<code>declare</code>申明，存储过程内的局部变量和输入参数，在<code>begin ... end</code>模块内生效</li><li>声明变量: <code>declare 变量名 变量类型 [default ...];</code></li><li>赋值局部变量:  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> 变量名 <span class="operator">=</span> 值;</span><br><span class="line"><span class="keyword">set</span> 变量名 :<span class="operator">=</span> 值;</span><br><span class="line"><span class="keyword">select</span> 字段名 <span class="keyword">into</span> 变量名 <span class="keyword">from</span> 表名;</span><br></pre></td></tr></table></figure></li></ul><h3 id="case"><code>case</code></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> case_value</span><br><span class="line"><span class="keyword">when</span> value1 <span class="keyword">then</span> statement1</span><br><span class="line"><span class="keyword">when</span> value2 <span class="keyword">then</span> statement2</span><br><span class="line"><span class="keyword">else</span> statement3</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">case</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> </span><br><span class="line"><span class="keyword">when</span> condition1 <span class="keyword">then</span> statement1</span><br><span class="line"><span class="keyword">when</span> condition2 <span class="keyword">then</span> statement2</span><br><span class="line"><span class="keyword">else</span> statement3</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">case</span>;</span><br></pre></td></tr></table></figure><h3 id="while"><code>while</code></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while 条件 do</span><br><span class="line"><span class="comment">-- sql语句</span></span><br><span class="line"><span class="keyword">end</span> while;</span><br></pre></td></tr></table></figure><h3 id="repeat"><code>repeat</code></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">repeat</span><br><span class="line"><span class="comment">-- sql语句</span></span><br><span class="line">until 条件</span><br><span class="line"><span class="keyword">end</span> repeat; <span class="comment">-- 满足条件就退出循环</span></span><br></pre></td></tr></table></figure><h3 id="loop"><code>loop</code></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[begin_label:] loop</span><br><span class="line"><span class="comment">-- sql语句</span></span><br><span class="line"><span class="keyword">end</span> loop[end_label];</span><br><span class="line">leave [label] <span class="comment">-- 退出指定的循环</span></span><br><span class="line">iterate [label] <span class="comment">-- 跳过当前循环直接进入下一次循环</span></span><br><span class="line"><span class="comment">-- 如果不退出就是死循环</span></span><br></pre></td></tr></table></figure><h3 id="游标">游标</h3><ul><li>用于存储查询结果集的数据类型，在存储过程个函数中可以使用游标对结果集进行循环处理，包括游标声明，<code>open, fetch, close</code></li><li>声明游标: <code>declare 游标名称 cursor for 查询语句;</code></li><li>打开游标: <code>open 游标名称;</code></li><li>打开游标后才能获取游标记录: <code>fetch 游标名称 into 变量[, 变量];</code></li><li>关闭游标: <code>close 游标名称;</code></li></ul><h3 id="例子-2">例子:</h3><ol><li>根据传入参数<code>uage</code>, 查询<code>user</code>表，用户年龄小于等于<code>uage</code>的用户姓名<code>name</code>和专业<code>profession</code>插入到创建的一张表<code>id, name, profession</code>中 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p(<span class="keyword">in</span> uage <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> uname <span class="type">varchar</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">declare</span> upro <span class="type">varchar</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">declare</span> u_cursor <span class="keyword">cursor</span> <span class="keyword">for</span> <span class="keyword">select</span> name, profession <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age <span class="operator">&lt;=</span> uage;</span><br><span class="line">    <span class="comment">-- 游标的申明应该放在普通变量后面</span></span><br><span class="line">    <span class="keyword">declare</span> exit handler <span class="keyword">for</span> <span class="keyword">sqlstate</span> <span class="string">&#x27;02000&#x27;</span> <span class="keyword">close</span> u_cursor;</span><br><span class="line">    <span class="comment">-- 满足SQL状态码是02000的, 触发退出操作，关闭游标u_cursor</span></span><br><span class="line">    <span class="comment">-- 同样可以将sqlstate &#x27;02000&#x27; 替换成not found</span></span><br><span class="line">    <span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> user_pro;</span><br><span class="line">    <span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> user_pro(</span><br><span class="line">        id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">        name <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">        profession <span class="type">varchar</span>(<span class="number">100</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> u_cursor;</span><br><span class="line">    while <span class="literal">true</span> do </span><br><span class="line">        <span class="keyword">fetch</span> u_cursor <span class="keyword">into</span> uname, upro;</span><br><span class="line">        <span class="keyword">insert</span> <span class="keyword">into</span> user_pro <span class="keyword">values</span>(<span class="keyword">null</span>, uname, upro);</span><br><span class="line">    <span class="keyword">end</span> while; <span class="comment">-- 但是这里是死循环，因为不知道游标什么时候会结束</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">close</span> u_cursor;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><ul><li>条件处理程序<code>handler</code>定义在流程遇到问题和相应的处理步骤</li><li><code>declare handler_action handler for condition_value[, condition_value ...] statement;</code></li><li><code>handler_action</code>包括两个内容，<code>continue</code>以及<code>exit</code></li><li><code>condition_value</code>有<code>SQLSTATE sqlstate_value</code>状态码，比如<code>02000</code>; <code>sqlwarning</code>是所有以<code>01</code>开头的<code>sqlstate</code>代码的缩写，<code>not found</code>是所有以<code>02</code>开头的代码的缩写，<code>sqlexception</code>是所有其他的<code>sqlstate</code>代码的缩写</li></ul></li></ol><h2 id="存储函数">存储函数</h2><div class="note info flat"><ul><li>就是有返回值的存储过程，并且参数只能为<code>in</code>类型，可以被存储过程替代</li></ul></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> 存储函数名([参数列表])</span><br><span class="line"><span class="keyword">return</span> type [characteristic ...]</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="comment">-- SQL语句</span></span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><p><code>characteristic</code>:</p><ul><li><code>deterministic</code>: 相同的输入参数总是产生相同的结果</li><li><code>no sql</code>: 不包含<code>SQL</code>语句</li><li><code>reads sql data</code>: 包含读取数据的语句，但是不包含写入数据的语句</li></ul><h2 id="触发器">触发器</h2><div class="note info flat"><ul><li>不建议使用</li><li><code>MySQL</code>只支持行级触发器，不支持语句级触发器，因此一次修改多行，就会触发多次</li></ul></div><table><thead><tr><th style="text-align:center">触发器类型</th><th style="text-align:center">NEW 和 OLD</th></tr></thead><tbody><tr><td style="text-align:center">INSERT型</td><td style="text-align:center">NEW表示将要或者已经新增的数据</td></tr><tr><td style="text-align:center">UPDATE型</td><td style="text-align:center">OLD表示修改之前的数据，NEW表示将要或已经修改的数据</td></tr><tr><td style="text-align:center">DELETE型</td><td style="text-align:center">OLD表示将要或已经删除的数据</td></tr></tbody></table><ul><li><p>创建触发器:</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> trigger_name </span><br><span class="line">before<span class="operator">/</span>after <span class="keyword">insert</span><span class="operator">/</span> <span class="keyword">update</span><span class="operator">/</span> <span class="keyword">delete</span> </span><br><span class="line"><span class="keyword">on</span> 表名 <span class="keyword">for</span> eachrow </span><br><span class="line"><span class="keyword">begin</span> </span><br><span class="line">    <span class="comment">-- trigger_stmt; </span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></li><li><p>查看触发器: <code>show triggers;</code></p></li><li><p>删除触发器: <code>drop triggers [schema_name.]trigger_namel</code> 如果没有指定<code>schema_name</code>，默认为当前数据库</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> SQL优化 </tag>
            
            <tag> 存储过程 </tag>
            
            <tag> 触发器 </tag>
            
            <tag> 视图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL笔记_2</title>
      <link href="/posts/c9496766.html"/>
      <url>/posts/c9496766.html</url>
      
        <content type="html"><![CDATA[<h1>索引</h1><div class="note info flat"><ul><li>高效获取数据的<strong>有序</strong>数据结构</li><li>提高检索效率，降低IO成本。</li><li>索引列对数据进行<strong>排序</strong>，降低排序成本，减少CPU的消耗</li><li>但是需要占用一些空间，提高查询效率有时候会降低更新表的速度，比如增删改。但是实际上增删改比例较少。</li></ul></div><table><thead><tr><th style="text-align:center">索引结构</th><th style="text-align:center">描述</th><th style="text-align:center"><code>InnoDB</code></th><th style="text-align:center"><code>MyISAM</code></th><th style="text-align:center"><code>Memory</code></th></tr></thead><tbody><tr><td style="text-align:center">B+树索引</td><td style="text-align:center">最常见的索引类型，大部分引擎都支持</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">Hash索引</td><td style="text-align:center">底层使用哈希表实现，只能精确匹配索引列的查询才有效，<strong>不支持</strong>范围查询</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">R-tree(空间索引)</td><td style="text-align:center">是<code>MyISAM</code>引擎的一个特殊索引类型，用于地理空间数据类型，使用较少</td><td style="text-align:center">-</td><td style="text-align:center">支持</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">Full-text(全文索引)</td><td style="text-align:center">通过建立倒排索引，快速匹配文档的方式，类似于<code>Lucene, Solr, ES</code></td><td style="text-align:center">5.6版本后支持</td><td style="text-align:center">支持</td><td style="text-align:center">-</td></tr></tbody></table><h2 id="常见索引模型">常见索引模型</h2><ol><li>哈希表<ul><li>比如拉链法解决哈希冲突，追加新数据的速度很快，但是如果需要区间查找，就很慢。所以哈希表只适合等值查找</li></ul></li><li>有序数组<ul><li>可以解决范围查找问题，等值和范围查找都可以达到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">log(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，但是插入删除元素需要移动数据，只适合静态搜索</li></ul></li><li>搜索树<ul><li>二叉搜索树就是<code>左子树&lt;父节点&lt;右子树</code>，只要能维持平衡状态，就可以达到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">log(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>的复杂度，但是如果不是平衡的，可能会出现单链表的情况。</li><li>二叉的效率<strong>最高</strong>，但是大多数都不会用二叉，因为索引也需要存储在磁盘，二叉树高度太高了，所以一般会使用B+树。索引越多读磁盘次数就越多</li><li><code>MySQL</code>一个节点都是一页，默认大小是<code>16K</code>，一个整数<code>bigint</code>大小为<code>8B</code>，每个整数都有<code>6B</code>的指向子树的指针，所以一个整数占用<code>14B</code>，所以一个节点可以存储<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>16</mn><mi>K</mi><mi>B</mi><mi mathvariant="normal">/</mi><mn>14</mn><mi>B</mi><mo>=</mo><mn>1170</mn></mrow><annotation encoding="application/x-tex">16KB / 14B=1170</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">16</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord">/14</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1170</span></span></span></span>，所以m叉树就是1170叉，高为4的时候可以存储<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1170</mn><mo>∗</mo><mn>1170</mn><mo>∗</mo><mn>1170</mn><mo>−</mo><mn>1</mn><mo>=</mo><mn>16</mn></mrow><annotation encoding="application/x-tex">1170 * 1170 * 1170 - 1 = 16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1170</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1170</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1170</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">16</span></span></span></span>亿左右的数据，由于部分数据还在内存中，所以顶多只需要访问三次磁盘即可</li></ul></li></ol><h2 id="B-树">B+树</h2><ul><li><p>B+树的<strong>所有元素都在叶子节点处</strong>，非叶子节点只用于索引，存储都在叶子节点处，<strong>所有叶子节点形成了一个单向链表</strong>。<br><img src="https://gitee.com/sang3112/blog_imgs/raw/d97d1acffa4285fae00105cf631f50575b612f38/MySQL/B+tree.png" alt="B+tree"></p></li><li><p><code>MySQL</code>对B+树进行优化，在原来的B+树基础上，增加了一个指向相邻叶子节点的链表指针，形成了带顺序指针的B+树，提高区间访问性能。<br><img src="https://gitee.com/sang3112/blog_imgs/raw/d97d1acffa4285fae00105cf631f50575b612f38/MySQL/MySQLB+tree.png" alt="MySQLB+tree"></p></li></ul><h3 id="InnoDB为何使用B-树索引，没有选择哈希索引、二叉树或者红黑树索引？"><code>InnoDB</code>为何使用B+树索引，没有选择哈希索引、二叉树或者红黑树索引？</h3><ol><li>如果是二叉树，顺序插入最后会形成链表，搜索性能很低，红黑树可以解决</li><li>但是红黑树本质上还是二叉树，<strong>自平衡二叉树</strong>，某些场景下层级太多了<ul><li>层级越多, 随机访问磁盘次数越多, 速度越慢</li></ul></li><li>B+树相对于二叉树层级更少，搜索效率更高，这也是B树的优点</li><li>但是B树无论叶子还是非叶子节点，都会保存数据，最终导致一页中存储的键值减少，指针也减少。如果要保存大量的数据，只能增加树的高度，导致性能降低。</li><li>对于B+树，找什么都去叶子节点中，所以搜索效率稳定</li><li><code>MySQL</code>中B+树的叶子节点形成了双向链表，便于范围搜索</li><li>哈希索引<strong>不支持</strong>排序和范围匹配，只能等值匹配。</li><li><code>InnoDB</code>也有自适应哈希功能，有的条件下会<strong>自动</strong>将B+树索引转换为哈希索引。(这点在后面会介绍)</li></ol><h3 id="MyISAM-VS-InnoDB"><code>MyISAM</code> VS <code>InnoDB</code></h3><ol><li>二者都使用<code>B+</code>树实现索引<ul><li><code>MyISAM</code>叶子节点的<code>data</code>域存放的是数据记录的<strong>地址</strong>，所以先用B+树找到索引，如果<code>key</code>存在，就通过对应的地址找到数据记录</li><li><code>InnoDB</code>数据文件本身就是索引文件，叶子节点<code>data</code>域保存了完整的数据记录，辅助索引<code>data</code>域存储主键的值，而不是地址，所以辅助索引都使用主键作为<code>data</code>域</li></ul></li><li><code>InnoDB</code>中，一张表就是<strong>多个</strong><code>B+</code>树(一个主键索引树和多个非主键索引树)，主键索引是一级索引，也是聚簇索引；非主键索引是二级索引，非主键索引只存储了主键值，所以需要在主键索引中再查找一次才能找到数据，所以使用非主键索引就需要回表</li></ol><h2 id="索引分类">索引分类</h2><table><thead><tr><th style="text-align:center">分类</th><th style="text-align:center">含义</th><th style="text-align:center">特点</th><th style="text-align:center">关键字</th></tr></thead><tbody><tr><td style="text-align:center">主键索引</td><td style="text-align:center">针对于表中主键创建的索引</td><td style="text-align:center">默认自动创建，只能有一个</td><td style="text-align:center"><code>PRIMARY</code></td></tr><tr><td style="text-align:center">唯一索引</td><td style="text-align:center">避免同表某数据列中的值重复</td><td style="text-align:center">可以多个</td><td style="text-align:center"><code>UNIQUE</code></td></tr><tr><td style="text-align:center">常规索引</td><td style="text-align:center">快速定位特定数据</td><td style="text-align:center">可以多个</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">全文索引</td><td style="text-align:center">查找文本中关键词，而不是比较索引值</td><td style="text-align:center">可以多个</td><td style="text-align:center"><code>FULLTEXT</code></td></tr></tbody></table><h3 id="按存储形式分类">按<strong>存储形式</strong>分类</h3><table><thead><tr><th style="text-align:center">分类</th><th style="text-align:center">含义</th><th style="text-align:center">特点</th></tr></thead><tbody><tr><td style="text-align:center">聚集索引</td><td style="text-align:center">数据和索引放在一块，索引结构的叶子节点保存了行数据</td><td style="text-align:center">必须有且只有一个</td></tr><tr><td style="text-align:center">二级索引</td><td style="text-align:center">将数据和索引分开存储，索引结构的叶子节点关联的是对应的主键</td><td style="text-align:center">可以多个</td></tr></tbody></table><div class="note info flat"><ul><li>如果存在主键，则主键索引就是聚集索引</li><li>如果没有主键，则<strong>第一个</strong>唯一索引就是聚集索引</li><li>没有主键索引和唯一索引的话，则<code>InnoDB</code>会自动生成一个<code>rowid</code>作为隐藏的聚集索引</li></ul></div><div class="note info flat"><ul><li>聚集索引下面挂的是一整行的数据，二级索引下面挂的是主键</li><li>回表查询: 先走二级索引找到对应的主键，然后再从聚集索引找到需要的数据</li></ul></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">10</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name<span class="operator">=</span>&quot;A&quot;;</span><br><span class="line"><span class="comment">-- 其中 id 为主键，name也有对应的索引</span></span><br><span class="line"><span class="comment">-- 前者性能更高，因为不需要回表查询了，可以直接通过聚集索引找到数据</span></span><br></pre></td></tr></table></figure><h3 id="InnoDB主键索引中B-树高度为多少？"><code>InnoDB</code>主键索引中B+树高度为多少？</h3><ol><li>假设一行数据为1K，一页中存储16行(因为一页大小固定为<code>16K</code>)，<code>InnoDB</code>指针占用6B，主键即使为<code>BIGINT</code>，占用8B</li><li>如果树高为2，假设有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>个键，就有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>个指针，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>∗</mo><mn>8</mn><mo>+</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>∗</mo><mn>6</mn><mo>=</mo><mn>16</mn><mo>∗</mo><mn>1024</mn></mrow><annotation encoding="application/x-tex">n * 8 + (n + 1) * 6 = 16 * 1024</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4653em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">16</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1024</span></span></span></span>计算得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≈</mo><mn>1170</mn></mrow><annotation encoding="application/x-tex">n \approx 1170</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4831em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1170</span></span></span></span></li><li>所以一个节点下面最多1171个指针，一个指针指向下面的子节点，一个子节点表示一个页，最多可以存16行数据。所以如果B+树高2，能够存储数据量为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1171</mn><mo>∗</mo><mn>16</mn><mo>=</mo><mn>18736</mn></mrow><annotation encoding="application/x-tex">1171 * 16 = 18736</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1171</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">16</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">18736</span></span></span></span></li><li>如果树高为3，则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1171</mn><mo>∗</mo><mn>1171</mn><mo>∗</mo><mn>16</mn><mo>=</mo><mn>21939856</mn></mrow><annotation encoding="application/x-tex">1171 * 1171 * 16 = 21939856</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1171</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1171</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">16</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">21939856</span></span></span></span>，所以即使存储两千多万条数据，树结构也只有三层</li></ol><h2 id="索引增删查">索引增删查</h2><h3 id="创建索引">创建索引</h3><p><code>create [unique | fulltext] index 索引名 on 表名 (索引关联字段1, 索引关联字段2, ...);</code></p><div class="note info flat"><ul><li>如果一个索引只关联了一个字段，则称为单列索引</li><li>如果关联了多个字段，则称为联合索引</li></ul></div><h3 id="删除索引">删除索引</h3><p><code>drop index 索引名 on 表名;</code></p><h3 id="查看索引">查看索引</h3><p><code>show index from 表名;</code></p><h2 id="性能分析">性能分析</h2><h3 id="执行频率">执行频率</h3><ul><li><code>show [session | global] status;</code>查看服务器状态信息</li><li><code>show global status like 'Com_______';</code>查看当前数据库的<code>insert, update, delete, select</code>的访问频次 (Com后面是7个下划线)</li></ul><h3 id="慢查询日志">慢查询日志</h3><ul><li>慢查询日志记录了所有执行时间超过指定参数(<code>long_query_time</code>单位: 秒，默认为10秒)的所有语句的日志</li><li><code>show variables like 'slow_query_log';</code>查看慢查询日志是否开启，默认是关闭状态<ul><li>需要在<code>/etc/my.cnf</code>中配置慢查询日志开关，表示超过200ms就是慢查询了<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slow_query_log=1</span><br><span class="line">long_query_time=0.2</span><br></pre></td></tr></table></figure></li></ul></li><li>慢查询日志存放在<code>var/log/mysql/mysql_slow.log</code></li></ul><h3 id="语句耗时">语句耗时</h3><ul><li><code>show profiles;</code>可以查看SQL语句耗时，<code>select @@have_profiling;</code>可以查看当前<code>MySQL</code>是否支持</li><li>确认支持后，还需要查看是否开启了<code>select @@profiling;</code>使用<code>set @@profiling=1</code>开启</li><li>开启后，执行完命令可以使用<code>show profiles;</code>查看一条指令的耗时情况</li><li><code>show profile for query query_id</code>可以查看一条<code>query_id</code>的查询指令的耗时细节</li><li><code>show profile cpu for query query_id</code>可以查看指定指令的CPU耗时细节</li></ul><h3 id="执行计划">执行计划</h3><ul><li>在任意<code>select</code>之前加上<code>explain</code>或者<code>desc</code>就可以查看执行计划<ul><li><code>id</code>: <code>select</code>查询的序列号，表示执行顺序，<code>id</code>相同，从上到下执行；<code>id</code>不同，越大越早执行</li><li><code>select_type</code>: 表示<code>select</code>类型，常见有:<ul><li><code>simple</code>: 简单单表查询</li><li><code>primary</code>: 最外层的主查询</li><li><code>union</code>: 联合查询中的第二个查询</li><li><code>subquery</code>: <code>select/where</code>后的子查询</li></ul></li><li><code>type</code>: 表示连接类型，性能由好到差分别为<code>null, system, const, eq_ref, ref, range, index, all</code><ul><li><code>null</code>: 查询时不访问任何表，比如<code>select 'A';</code></li><li><code>system</code>: 访问系统表</li><li><code>const</code>: 根据主键、唯一索引访问</li><li><code>ref</code>: 根据非唯一索引访问</li><li><code>range</code>: 非唯一索引，但是范围匹配，比如<code>age &gt; 18</code></li><li><code>index</code>: 虽然使用了索引，但是遍历整个索引树扫描，性能也低</li><li><code>all</code>: 全表扫描，性能最低</li></ul></li><li><code>extra</code>:<ul><li><code>using index condition</code>: 查找使用了索引，但是<strong>需要回表</strong>查询</li><li><code>using where; using index</code>: 查找使用了索引，但是需要的数据在索引列中都能找到，<strong>不需要回表</strong></li></ul></li><li><code>possible_key</code>: 表示这表中可能用到的索引，一个或多个</li><li><code>key</code>: 表示实际用到的索引，<code>null</code>表示没有用到索引</li><li><code>key_len</code>: 表示索引中使用的字节数，是索引字段的最大长度，不是实际使用的长度，不损失精度的前提下越短越好</li><li><code>rows</code>: 表示查询的行数，只是预估值，不是精确值</li><li><code>filtered</code>: 表示查询返回行数占总读取行数的百分比，越大越好</li></ul></li></ul><h2 id="最左前缀法则"><strong>最左前缀法则</strong></h2><ul><li><p>如果有联合索引，查询从索引的最左列开始，不跳过中间的列。如果跳过某一列，则所有后面的字段都失效</p></li><li><p>如果没有索引最左边的列，则索引失效</p></li><li><p>只需要<code>where</code>条件有最左边的列即可，只要存在就行，跟在<code>where</code>中的位置无关</p></li><li><p>联合索引中出现了范围查询<code>&gt;, &lt;</code>，则右边的索引失效</p><ul><li><code>select * from user where profession='A' and age &gt; 30 and status='0';</code>则<code>stauts</code>失效</li><li>如果是<code>&gt;=, &lt;=</code> 则不会产生影响，所以尽量少用<code>&gt;, &lt;</code></li></ul><div class="note info flat"><ul><li><code>MySQL</code>会一直向右匹配，直到范围查询，所以比如<code>where</code>第一个条件就是范围查找，那么就只会用到最左边的索引，<strong>5.6版本</strong>提出索引下推(<code>ICP</code>)，在只能够使用最左边的索引，而无法使用全部联合索引的情况下，在遍历索引的时候，就对<code>where</code>条件将进行过滤，这样就可以减少遍历查询得到的主键条数，从而减少回表次数。<ul><li>因为<strong>在5.6版本之前</strong>，如果只能使用最左边的索引，那么就会一个个回表查询所有信息 再对<code>where</code>条件过滤，回表次数增加。</li></ul></li></ul></div></li></ul><h2 id="索引失效">索引失效</h2><div class="note info flat"><ol><li><p>如果在索引列上进行运算，则索引失效</p><ul><li><code>select * from user where phone='12312312312';</code> 走单列索引，<code>type=const</code></li><li><code>select * from user where substring(phone, 10, 2)='15';</code> 走全表扫描，<code>type=all</code></li><li>因为<code>B+</code>树的快速定位能力，实际上是通过<strong>同一层兄弟节点的有序性</strong>得到的，函数计算，索引选择都是<code>server</code>层的，跟<code>InnoDB</code>引擎无关，依然会使用索引树，但是函数操作会破坏索引的有序性，所以优化器就放弃走索引搜素的功能，不得不在这个索引树上遍历全树扫描</li><li>即便不改变有序性，也不会走索引快速搜索</li><li>所以<code>MySQL</code>如果是字符串和数字比较，就会将字符串转为数字<ul><li>如果id类型是<code>varchar</code>，<code>where id = 11111</code>就不会使用索引，会导致全表扫描，因为涉及字符串的强制类型转换，也就是函数操作</li><li>如果id类型是<code>int</code>，<code>where id = &quot;11111&quot;</code>，这个会把<code>&quot;11111&quot;</code>转换为数字，不会对表上的字段进行类型转换，因此会使用索引</li><li>如果两个表关联查询，两个表字符集不同，比如一个是<code>utf8</code>，另一个是<code>utf8mb4</code>，第二个表就会没办法使用索引，因为<code>utf8mb4</code>是<code>utf8</code>的超集，所以会将<code>utf8</code>转换为<code>utf8mb4</code>，同样会使用函数操作，导致全表扫描</li></ul><blockquote><p>只需要保证参数值小于等于索引，就不会走全表，因为会将参数进行类型转换，而不会将索引类型转换，就没问题</p></blockquote></li></ul></li><li><p>字符串不加引号索引就会失效</p><ul><li><code>select * from user where phone=12312312312;</code> 走的是全表扫描，因为没有添加引号</li></ul></li><li><p>仅仅使用尾部模糊匹配，索引不会失效；只要有头部模糊匹配，索引会失效</p><ul><li><code>select * from user where profession like '软件%';</code> 走索引，<code>type=range</code></li><li><code>select * from user where profession like '%软件';</code> 不走索引，<code>type=all</code></li><li><strong>大数据量一定要规避模糊匹配前面加上%的情况</strong></li></ul></li><li><p>使用<code>or</code>分割的条件，只有两侧都有索引，索引才会生效，不然不会生效(实际上经过测试发现必须要有两边的联合索引，or语句的索引才会生效)</p></li><li><p>如果<code>MySQL</code>评估使用索引比全表扫描还要慢，就不会用索引</p><ul><li>比如范围匹配或者判断空或非空，满足要求的条件是表中的绝大部分数据，则不会使用索引，直接走全表扫描了</li></ul></li></ol></div><h2 id="SQL提示"><code>SQL</code>提示</h2><ul><li>一个查询能满足多个索引的时候，<code>MySQL</code>会自动选择一个索引</li><li>可以给<code>MySQL</code>提示，要求选择哪个索引进行查找，从而达到优化的目的</li><li><code>use / ignore / force index;</code> 告诉<code>MySQL</code>使用哪个索引，不使用哪个索引</li><li><code>use index</code>是一个建议，<code>MySQL</code>未必接受；<code>force index</code>是强制<code>MySQL</code>使用这个索引</li></ul><h3 id="如果MySQL取错索引，应该如何操作？">如果<code>MySQL</code>取错索引，应该如何操作？</h3><ol><li>使用<code>use / ignore / force index;</code> 让<code>MySQL</code>使用某个索引</li><li>修改<code>SQL</code>语句，诱导<code>MySQL</code>选择某个索引</li><li>建立合适的索引，删除无效的索引</li></ol><h3 id="优化器选择索引的依据">优化器选择索引的依据</h3><blockquote><p>扫描行数</p></blockquote><ul><li>估算，跟索引的基数有关，基数是一个索引下，不同值的个数，基数越大，索引区分度越高，选择正确索引的概率越大。<ul><li>基数通过采样估计，选择<code>N</code>个页，计算平均基数，然后乘页数</li><li>索引值变更超过<code>1/M</code>的时候，就会触发重新计算索引统计基数</li><li>配置参数<code>innodb_stats_persistent = ON</code>，统计信息会持久化存储，<code>N=20，M=10</code></li><li><code>innodb_stats_persistent = OFF</code>，统计信息只在内存中，<code>N=8，M=16</code></li><li>如果预估的扫描行数不符和实际，可以使用<code>analyze table tablename</code>来重新评估行数</li></ul></li></ul><h2 id="覆盖索引">覆盖索引</h2><ul><li>尽量使用覆盖索引，而不用<code>select *</code></li><li>如果二级索引查询的结果仅仅是主键，那就不需要回表查主键索引，就称为覆盖索引</li><li>二级索引会默认和主键做联合索引</li></ul><div class="note info flat"><ul><li>如果有根据身份证号查找人名的应用，就可以对身份证号和人名做联合索引，这样的话，人名信息也会放在身份证号的索引上，就不需要回表了。</li><li>根据最左前缀法则，有身份证号-人名索引了，就不需要再去单独建立身份证号的索引了。如果这样的联合索引可以少维护一个索引的话，那这样的联合索引顺序就是优先考虑的。</li><li>第二考虑的就是两个字段的占用字节数，比如用户名和年龄，那年龄占用字节数较少，所以可以构建索引用户名-年龄，然后年龄单独再做一个索引，也就长索引在前，短索引构建两遍。</li></ul></div><h2 id="前缀索引">前缀索引</h2><ul><li>如果需要索引很长的字符串，可以使用前缀索引，或者使用<code>ES</code>实现</li><li><code>create index idx_xxx on 表名(字段名(n));</code> 建立前缀索引，<code>n</code>表示要提取这个字段中的前<code>n</code>个字符构建索引</li><li><code>n</code>是前缀长度，可以根据索引<strong>选择性</strong>决定，选择性是<strong>不重复的索引值</strong>(基数)与<strong>数据表的记录总数</strong>的比值。<ul><li>选择性越高，查询效率越高</li><li>唯一索引的选择性就是1，是最高的索引选择性，性能也是最好的<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> email) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> <span class="keyword">user</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="built_in">substring</span>(email, <span class="number">1</span>, <span class="number">5</span>)) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>前缀索引不支持覆盖索引，所以一定会回表</strong></li></ul><div class="note info flat"><p>存储身份证号，可以<strong>倒序存储</strong>，取前缀索引。</p><ul><li>或者使用<code>crc32()</code>或者别的<code>hash</code>函数在插入身份证号的时候存储校验码字段，然后对校验码添加索引</li><li>倒序和<code>hash</code>都<strong>无法支持范围查找</strong></li><li>倒序存储不需要额外字段空间，<code>hash</code>存储需要额外校验码</li><li>倒序存储需要<code>reverse()</code>，<code>hash</code>需要<code>crc32()</code>，相比之下，<code>hash</code>消耗的cpu稍大</li><li><code>hash</code>稳定一些，<code>crc32()</code>冲突概率很低</li></ul></div><h2 id="单列索引-VS-联合索引">单列索引 VS 联合索引</h2><ol><li>如果<code>where</code>有两个部分，分别都只有单列索引，这时候第一个条件会走单列索引，第二个条件不会走索引<br><code>select id, phone, name from user where phone='12312312312' and name='123';</code> 此时只有<code>phone</code>走单列索引，<code>name</code>没有走索引，导致最终回表</li><li>如果这时候有两个部分的单列索引，以及两个部分的联合索引，简单的使用<code>where</code>，依然是只有第一部分使用单列索引。因此需要指定使用联合索引才行</li><li>如果涉及多个查询条件，推荐使用联合索引</li></ol><h2 id="索引设计原则">索引设计原则</h2><ol><li>数据量较大(&gt; 100万)，查询频繁的表需要涉及索引。如果只插入，不查询，就不用建立索引</li><li>针对常常作为查询条件<code>where</code>，排序<code>order by</code>，分组<code>group by</code>这几个字段建立索引</li><li>建立索引使用区分度高的列作为索引，尽量建立唯一索引。如果是性别，状态这种字段没有必要建立索引</li><li>字符串较长考虑使用前缀索引</li><li>尽量使用联合索引，减少单列索引，以达到使用覆盖索引，避免回表</li><li>控制索引的数量，索引越多，增删改的效率越低</li><li>索引列不能存储<code>NULL</code>，建表的时候使用<code>NOT NULL</code>约束，可以更有效的使用索引</li></ol><h2 id="例子">例子:</h2><div class="note info flat"><p>索引命名规范: <code>idx_表名_字段名</code><br>创建联合索引对字段顺序有要求</p></div><ol><li><code>name</code>是姓名字段，可能重复: <code>create index idx_user_name on user(name);</code> 创建常规索引</li><li><code>phone</code>是手机号，非空，唯一，创建索引: <code>create unique index idx_user_phone on user(phone);</code> 创建唯一索引</li><li>为<code>profession, age, status</code>创建索引: <code>create index idx_user_pro_age_status on user(profession, age, status);</code> 创建联合索引</li><li>为<code>email</code>创建合适的索引: <code>create index idx_user_email on user(email);</code> 创建常规索引</li><li>一张表四个字段<code>(id, username, password, status)</code>如何优化<code>select id, username, password from user where username='a';</code>:<ul><li>建立<code>username, password</code>联合索引，并且<code>username</code>放在第一个，从而满足最左前缀法则，可以避免回表</li></ul></li></ol><h2 id="唯一索引-VS-普通索引">唯一索引 VS 普通索引</h2><ol><li>二者查询性能差距微乎其微，因为<code>MySQL</code>都是一页一页在内存中读取的，唯一索引无非就是只要找到就能返回，而普通索引找到一个以后还需要找下一个是否满足,直到找到下一个不满足的才能返回</li><li>普通索引比唯一索引写性能更好，因为普通索引可以使用<code>change buffer</code>，但是唯一索引用不了<ul><li>唯一索引插入数据之前要先判断是否唯一，此时需要将数据读入内存才能判断，因此唯一索引插入的时候不需要再使用<code>change buffer</code>了</li><li><code>change buffer</code>用的时<code>buffer pool</code>中的内存，不能无限增大，可以配置<code>innodb_change_buffer_max_size=50</code>表明最多占用<code>50%</code>的<code>buffer pool</code></li></ul></li></ol><div class="note info flat"><ul><li>如果目标页在内存中(插入4)<ul><li>唯一索引：找到3和5中间，判断没有冲突，插入4</li><li>普通索引：找到3和5中间，插入4</li><li>性能差异微乎其微，只有一个判断</li></ul></li><li>如果目标页不在内存中(插入4)<ul><li>唯一索引：将目标页读入内存，判断没有冲突，插入4</li><li>普通索引：更新记录在<code>change buffer</code>中</li><li>性能差异明显，因为减少随机访问磁盘</li></ul></li></ul></div><h3 id="总结">总结</h3><ol><li>对于<code>change buffer</code>，只有在<code>merge</code>的时候，才是真正写入数据的时候，所以如果写多读少，页面写完以后马上被访问的概率较小，<code>change buffer</code>的效果最好，比如账单，日志</li><li>如果写完立马进行查询，就会出现<code>change buffer</code>反复<code>merge</code>的情况，效果更差，所以如果是写了以后立马查询的话，可以使用普通索引，同时关闭<code>change buffer</code>，也就是<code>innodb_change_buffer_max_size</code>设置为0，同理对于账单日志，可以将<code>change buffer</code>尽量开大一些</li></ol><h3 id="数据更新过程">数据更新过程</h3><ol><li>如果更新一个数据页，并且数据页在内存中，就直接更新。如果不在内存中，就将更新写入<code>change buffer</code>中，下次查询需要访问对应的数据页的时候，将数据页读入内存，然后执行<code>change buffer</code>中与这个数据页有关操作。</li><li><code>change buffer</code>中的数据更新到数据页上称为<code>merge</code>，查询会执行<code>merge</code>，正常关闭数据库会执行<code>merge</code>，后台线程也会定期<code>merge</code></li></ol><ul><li><code>redo log</code>减少的是随机写入磁盘的消耗，就是变成了<strong>顺序写</strong>；</li><li><code>change buffer</code>是减少了随机读磁盘的消耗，等到后面读取了磁盘以后，再讲内存写入</li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 索引结构 </tag>
            
            <tag> B+树高 </tag>
            
            <tag> 最左前缀法则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL笔记_1</title>
      <link href="/posts/504036dc.html"/>
      <url>/posts/504036dc.html</url>
      
        <content type="html"><![CDATA[<h1>函数</h1><h2 id="字符串函数">字符串函数</h2><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">CONCAT(S1, S2, …, Sn)</td><td style="text-align:center">字符串拼接，将S1, S2, …, Sn拼接成一个字符串</td></tr><tr><td style="text-align:center">LOWER(str)</td><td style="text-align:center">将字符串转为小写</td></tr><tr><td style="text-align:center">UPPER(str)</td><td style="text-align:center">将字符串转为大写</td></tr><tr><td style="text-align:center">LPAD(str, n, pad)</td><td style="text-align:center">左填充，用字符串pad对str的左边进行填充，达到长度n</td></tr><tr><td style="text-align:center">RPAD(str, n, pad)</td><td style="text-align:center">右填充，用字符串pad对str的右边进行填充，达到长度n</td></tr><tr><td style="text-align:center">TRIM(str)</td><td style="text-align:center">去掉字符串头部和尾部的空格</td></tr><tr><td style="text-align:center">SUBSTRING(str, start, len)</td><td style="text-align:center">返回从字符串str的start位置起的len个长度的字符串</td></tr></tbody></table><div class="note info flat"><ul><li><code>trim</code>不能去除中间的空格</li><li><code>substring</code>的<code>start</code>从1开始，不是0</li><li><code>substring()</code>可以只输入两个参数，表示从<code>start</code>的位置截取到字符串末尾</li><li><code>start</code>参数可以为负，如果是负数，则自动忽略<code>len</code>参数，表示截取最后几个字符</li><li><code>lpad</code>和<code>rpad</code>如果输入的字符串过长，超过了第二个参数n，则自动变为<strong>从左往右</strong>的n个字符</li></ul></div><h2 id="数值函数">数值函数</h2><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">CEIL(x)</td><td style="text-align:center">向上取整</td></tr><tr><td style="text-align:center">FLOOR(x)</td><td style="text-align:center">向下取整</td></tr><tr><td style="text-align:center">MOD(x, y)</td><td style="text-align:center">取<code>x/y</code>的模</td></tr><tr><td style="text-align:center">RAND( )</td><td style="text-align:center">返回0~1内随机数</td></tr><tr><td style="text-align:center">ROUND(x, y)</td><td style="text-align:center">x四舍五入，并保留y位小数</td></tr></tbody></table><h2 id="日期函数">日期函数</h2><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">CURDTE()</td><td style="text-align:center">返回当前日期</td></tr><tr><td style="text-align:center">CURTIME()</td><td style="text-align:center">返回当前时间</td></tr><tr><td style="text-align:center">NOW()</td><td style="text-align:center">返回当前日期和时间</td></tr><tr><td style="text-align:center">YEAR(date)</td><td style="text-align:center">获取指定date的年份</td></tr><tr><td style="text-align:center">MONTH(date)</td><td style="text-align:center">获取指定date的月份</td></tr><tr><td style="text-align:center">DAY(date)</td><td style="text-align:center">获取指定date的日期</td></tr><tr><td style="text-align:center">DATE_ADD(date, INTERVAL expr, type)</td><td style="text-align:center">在date后的日期加上时间长度</td></tr><tr><td style="text-align:center">DATEDIFF(date1, date2)</td><td style="text-align:center">返回起始时间date1和结束时间date2之间的天数</td></tr></tbody></table><div class="note info flat"><p><code>date_add(date, interval expr, type);</code>中，<code>interval</code>是固定的。</p></div><h2 id="流程控制函数">流程控制函数</h2><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">IF(value, t, f)</td><td style="text-align:center">如果value为true，则返回t，否则返回f</td></tr><tr><td style="text-align:center">IFNULL(value1, value2)</td><td style="text-align:center">如果value1<strong>不为空</strong>，则返回value1，否则返回value2</td></tr><tr><td style="text-align:center">CASE WHEN [val1] THEN [res1] … ELSE [default] END</td><td style="text-align:center">如果val1为true，返回res1，…，否则返回default</td></tr><tr><td style="text-align:center">CASE [expr] WHEN [val1] THEN [res1] … ELSE [default] END</td><td style="text-align:center">如果expr值等于val1，返回res1，…，否则返回default</td></tr></tbody></table><div class="note info flat"><ul><li><code>ifnull('OK', 'D');</code> 返回’OK’</li><li><code>ifnull('', 'D');</code> 返回’’</li><li><code>ifnull(null, 'D');</code> 返回’D’</li></ul></div><h1>约束</h1><table><thead><tr><th style="text-align:center">关键字</th><th style="text-align:center">约束</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">NOT NULL</td><td style="text-align:center">非空约束</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">UNIQUE</td><td style="text-align:center">唯一约束</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">PRIMARY KEY</td><td style="text-align:center">主键约束</td><td style="text-align:center">一行数据的唯一标识，非空且唯一</td></tr><tr><td style="text-align:center">DEFAULT</td><td style="text-align:center">默认约束</td><td style="text-align:center">保存数据时，未指定某个字段，则使用默认值</td></tr><tr><td style="text-align:center">CHECK</td><td style="text-align:center">检查约束</td><td style="text-align:center">保证字段值满足某条件</td></tr><tr><td style="text-align:center">FOREIGN KEY</td><td style="text-align:center">外键约束</td><td style="text-align:center">让两张表的数据建立连接，保证数据的完整性和一致性</td></tr></tbody></table><table><thead><tr><th style="text-align:center">删除/更新行为</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">NOT ACTION</td><td style="text-align:center">在父表中删除/更新对应记录时，首先检查该记录是否有外键，如果有则不允许删除/更新。(与RESTRICT一致)</td></tr><tr><td style="text-align:center">RESTRICT</td><td style="text-align:center">在父表中删除/更新对应记录时，首先检查该记录是否有外键，如果有则不允许删除/更新。(与NOT ACTION一致)</td></tr><tr><td style="text-align:center">CASCADE</td><td style="text-align:center">在父表中删除/更新对应记录时，首先检查该记录是否有外键，如果有则也删除/更新外键在子表中的记录</td></tr><tr><td style="text-align:center">SET NULL</td><td style="text-align:center">在父表中删除对应记录时，检查该记录是否有对应外键，如果有则设置子表中该外键的值为NULL(这要求该外键允许为NULL)</td></tr><tr><td style="text-align:center">SET DEFAULT</td><td style="text-align:center">父表有变更时，子表将外键列设为一个默认值 (InnoDB不支持)</td></tr></tbody></table><div class="note info flat"><ul><li>自增 <code>auto_increment</code></li><li>外键约束一般不使用</li><li>添加外键约束: <code>alter table 表名 add constraint 外键名 foreign key (外键字段名) references 主表(主表列名);</code>括号是必须要有的</li><li>删除外键约束: <code>alter table 表名 drop foreign key 外键名;</code></li><li>设置外键在删除/更新都是级联的: <code>alter table 表名 add constraint 外键名 foreign key (外键字段) references 主表(主表列名) on update cascade on delete cascade;</code></li></ul></div><h1>多表查询</h1><table><thead><tr><th style="text-align:center">关系</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">一对多</td><td style="text-align:center">多的一方建立外键，指向一，比如员工和部门</td></tr><tr><td style="text-align:center">多对多</td><td style="text-align:center">建立中间表，包含两个外键，分别关联二者主键，比如学生课程</td></tr><tr><td style="text-align:center">一对一</td><td style="text-align:center">随便在一个表中建立外键，主要用于单表拆分，对外建需要设置唯一约束</td></tr></tbody></table><h2 id="内连接">内连接:</h2><ul><li>隐式内连接: <code>select 字段列表 from A, B where 条件;</code></li><li>显式内连接: <code>select 字段列表 from A [inner] join B on 条件;</code></li></ul><div class="note info flat"><ul><li><code>inner</code>可以省略</li><li>查询AB交集，查询不到某张表的<code>NULL</code></li></ul></div><h2 id="外连接">外连接:</h2><ul><li>左外连接:  <code>select 字段列表 from A left [outer] join B on 条件;</code></li><li>右外连接:  <code>select 字段列表 from A right [outer] join B on 条件;</code></li></ul><div class="note info flat"><ul><li>外连接<strong>可以</strong>查找出<code>NULL</code></li><li>左外连接查找左表中所有数据以及两个表的交集</li><li>右外连接查找右表中所有数据以及两个表的交集</li></ul></div><h2 id="自连接">自连接:</h2><p><code>select 字段列表 from A 别名A join A 别名B on 条件;</code></p><div class="note info flat"><ul><li>当前表和自身进行连接查询，自连接需要使用表别名</li></ul></div><h2 id="联合查询">联合查询:</h2><p><code>select 字段列表 from A ... union [all] select 字段列表 from B;</code></p><div class="note info flat"><ul><li>联合查询是将多次查询结果合并起来，形成新查询结果集</li><li><code>all</code>将查询结果合并，如果不使用<code>all</code>，则会去重</li><li>两个不同的<code>select</code>中字段列表必须保持一致</li></ul></div><h2 id="子查询">子查询:</h2><p><code>select * from A where c1 = (select c1 from B);</code></p><div class="note info flat"><ul><li>子查询内部可以使用<code>insert/delete/update/select</code></li><li>标量子查询，列子查询，行子查询，表子查询，分别表示子查询返回的结果数量是一个值，一列，一行，还是一个表</li><li><code>where/from/select</code>之后都可以出现子查询</li><li>列子查询中<code>any</code>与<code>some</code>等价，都表示其中任意一个满足即可</li></ul></div><h2 id="例子">例子:</h2><ol><li>查询员工姓名，年龄，职位，部门信息(隐式内连接):<br><code>select e.name, e.age e.job d.name from emp e, dept d where e.dept_id = d.id;</code></li><li>查询年龄小于30的员工的姓名年龄，职位，部门信息(显式内连接):<br><code>select e.name, e.age, e.job d.name from emp e join dept d on e.dept_id = d.id where e.age &lt; 30;</code></li><li>查询拥有员工的部门id和部门名称:<br><code>select distinct d.id, d.name from emp e, dept d where e.dept_id = d.id;</code> (内连接求交集)</li><li>查询所有年龄大于40的员工，及其归属的部门名称，如果员工没有分配部门，也需要展示:<br><code>select e.*, d.name from emp e left join dept d on e.dept_id = d.id where e.age &gt; 40;</code></li><li>查询所有员工的工资等级:<br><code>select e.*, s.grade from emp e, salgrade s where e.salary &gt;= s.losal and e.salary &lt;= s.hisal;</code></li><li>查询研发部所有员工的信息以及工资等级:<br><code>select e.*, s.grade from emp e, salgrade s, dept d where e.dept_id = d.id and (e.salary between s.losal and s.hisal) and d.name = '研发';</code></li><li>查询研发部员工的平均工资:<br><code>select avg(e.salary) from emp e, dept d where e.dept_id = d.id and d.name = '研发';</code></li><li>查询工资比A高的员工信息:<br><code>select * from emp where salary &gt; (select salary from emp where name = 'A');</code></li><li>查询比平均工资高的员工信息:<br><code>select * from emp where salary &gt; (select avg(salary) from emp);</code></li><li>查询低于本部门平均工资的员工:<br><code>select * from emp e2 where e2.salary &lt; (select avg(e1.salary) from emp e1 where e1.dept_id = d2.dept_id);</code></li><li>查询所有部门信息，并统计部门员工人数:<br><code>select d.id , d.name, (select count(*) from emp e where e.dept_id = d.id) '人数' from dept d;</code></li><li>查询所有学生的选课情况，展示出学生名称，学号，课程名称:<br><code>select s.name, s.no, c.name from student s, student_course sc, course c where s.id = sc.studentid and sc.courseid = c.id;</code></li></ol><h1>事务</h1><div class="note info flat"><ul><li>MySQL事务默认自动提交，执行一条DML语句，会立刻隐式提交事务</li><li><code>select @@autocommit;</code>查看当前事务是否自动提交，如果为1，则表示自动提交</li><li><code>set @@autocommit=0;</code>设置手动提交，需要手动写<code>commit</code>才会提交事务</li><li>出错可以使用<code>rollback;</code>回滚事务</li><li>开启事务<code>start transaction</code>或者<code>begin</code>，这样不需要修改<code>@@autocommit</code></li></ul></div><h2 id="四大特性-ACID">四大特性 <strong>ACID</strong></h2><ul><li>原子性: 事务是不可分割的最小单元，要么全部成功，要么全部失败</li><li>一致性: 事务完成时，所有数据都需要保持一致状态</li><li>隔离性: 数据库提供隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</li><li>持久性: 事务一旦提交或者回滚，对数据库中的数据改变就是永久的</li></ul><h2 id="并发问题与隔离级别">并发问题与隔离级别</h2><h3 id="并发问题">并发问题</h3><ul><li>脏读: 一个事务读到另一个事务还没有提交的数据</li><li>不可重复读: 一个事务先后读取同一条记录，但是两次读取的数据不同</li><li>幻读: 一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现数据已经存在</li></ul><h3 id="隔离级别">隔离级别</h3><table><thead><tr><th style="text-align:center">隔离级别</th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th style="text-align:center">幻读</th></tr></thead><tbody><tr><td style="text-align:center">Read Uncommitted</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">Read Committed</td><td style="text-align:center">解决</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">Repeatable Read (默认)</td><td style="text-align:center">解决</td><td style="text-align:center">解决</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">Serializable</td><td style="text-align:center">解决</td><td style="text-align:center">解决</td><td style="text-align:center">解决</td></tr></tbody></table><div class="note info flat"><ul><li>读未提交的隔离级别下，三种并发问题都有可能出现</li><li>可重复读是<code>MySQL</code>的默认配置，<code>Orical</code>是读可提交</li><li>串行化，性能最差，隔离级别最高，失去并发能力</li><li><code>select @@transaction_isolation;</code>查看事务的隔离级别</li><li><code>set [session|global] transaction isolation level {read uncommitted | read committed | repeatable read | serializable}</code> <code>session</code>表示对当前会话窗口有效，<code>global</code>是对所有窗口有效</li><li>尽管相比于默认的可重复读，读提交不能解决不可重复读的问题，但是可重复读这一隔离级别在并发时会导致死锁，未来打算放一篇专门的笔记分析。</li></ul></div><div class="note info flat"><ol><li>读未提交<code>RU</code>: 别的事务可以读到自己还没有提交的变更</li><li>读已提交<code>RC</code>: 只有自己提交以后，别的事务才能读取到变更</li><li>可重复读<code>RR</code>: 一个事务的执行过程中看到的数据，总是和这个事务启动时看到的数据一样。<ul><li>因此<code>RR</code>下，没有提交的数据也是不可见的；并且别人就算已经提交了，我也不会去读</li></ul></li><li>串行化<code>S</code>:对于同一行记录，写加写锁，读加读锁，读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行</li></ol><ul><li><p>数据库会创建一个视图，实际返回的结果以视图的逻辑结果为准。</p><ul><li><code>RR</code>的视图在事务启动时候创建</li><li><code>RC</code>在<code>SQL</code>语句开始的时候创建</li><li><code>RU</code>直接返回记录的最新值，没有视图的概念，串行化直接使用加锁避免并行访问</li></ul></li><li><p>现在两个表，一个存余额，一个存明细。如果需要校对明细是否可以对的上 上个月的余额与本月余额的差值，并且希望校对过程中即便数据更新，也不会产生影响 ，就可以使用<code>RR</code>，这样事务启动时就是静态的，不会被其他事务影响。</p></li></ul></div><div class="note info flat"><ul><li>每条操作除了会记录<code>redo log</code>，还会记录相反的<code>undo log</code></li><li>在没有比回滚日志更早的读视图时，也就是事务开启时创建的读视图都比回滚日志更晚，那么这个数据就不会再回滚了，就可以删除<code>undo log</code>，由<code>purge</code>线程自动删除</li><li>长事务会导致<code>undo log</code>一直存在，不能被删除，也就是在这个事务提交之前，数据库中跟他有关的回滚记录都必须保留，<strong>5.5版本</strong>之前，回滚日志跟数据字典一起放在<code>ibdata</code>中，所以长事务被提交了，文件也不会变小。并且长事务占用锁资源，导致整个库都拖垮了。</li></ul></div><h2 id="事务启动方式">事务启动方式</h2><ol><li><code>begin</code> 或者 <code>start transaction;commit</code> 或者 <code>rollback</code></li><li><code>set autocommit = 0</code>，将线程自动提交关闭，表明使用<code>select</code>就会开启事务，直到主动<code>commit</code>为止<ul><li>为了避免默认的关闭自动提交，所以应该<code>set autocommit = 1</code>，主动显式开启事务(默认就是<code>autocommit=1</code>)</li><li>也可以使用<code>commit work and chain</code>可以提交本次事务，并开启下一个事务<br>查找持续时间超过60s的事务: <code>select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))&gt;60</code></li></ul></li></ol><div class="note info flat"><ul><li><code>begin/start transaction</code><strong>不是</strong>事务的起点，后面第一个操作<code>InnoDB</code>的表才是事务的起点</li><li><code>start transaction with consistent snapshot</code>这个语句会<strong>立马</strong>开启事务</li></ul></div><ul><li>如果<strong>只有读取</strong>的话，在<code>MySQL</code>的<code>RC</code>和<code>RR</code>隔离标准下，不需要添加事务，否则会导致<code>undo log</code>片段过大</li><li>业务连接数据库的时候<ul><li>可以<strong>全局</strong>设置<code>SET GLOBAL MAX_EXECUTION_TIME=1000</code>: 避免事务执行时间过长。</li><li>对某个<code>session</code>设置<code>SET SESSION MAX_EXECUTION_TIME=1000;</code></li><li>对某个语句设置<code>SELECT max_execution_time=1000 SLEEP(10), a.* from test a;</code></li></ul></li><li>监控<code>information_schema.Innodb_trx</code>，如果出现超过阈值的长事务，就直接kill掉</li></ul><div class="note info flat"><p>MySQL中存在两个视图</p><ol><li><code>create view as</code> 调用时执行查询语句生成结果</li><li><code>MVCC</code>一致性视图，<code>consistent read view</code>，用于支持<code>RC</code>和<code>RR</code>, 没有物理结构，定义执行时能看到什么数据</li></ol></div><h2 id="快照读">快照读</h2><ol><li><code>InnoDB</code>事务都具有<strong>唯一，自增</strong>的事务ID(<code>transaction ID</code>)，事务开始的时候申请，<strong>只读</strong>事务的ID很大，而<strong>非只读</strong>事务的ID从1开始自增</li><li>每次更新数据都会生成一个新的数据版本，并且把<code>transaction ID</code>赋值给数据版本事务ID，也就是<code>row trx_id</code>(其实就是指向上一个数据版本的引用)</li></ol><div class="note info flat"><ul><li>所以一行记录，可能有多个版本<code>row</code>，都通过<code>row trx_id</code>连接形成<strong>版本链</strong></li><li>需要旧版本的记录时，就通过最新版本和<code>undo log</code>计算出来</li></ul></div><ul><li><code>InnoDB</code>每个事务都有一个数组，保存了当事务启动时<strong>还没有提交的</strong>事务的ID，其中<strong>事务最小值</strong>为低水位，<strong>已经创建过的事务ID</strong>的最大值 + 1(这个已经创建过的可能已经不活跃了)为高水位，可见性基于<code>row trx_id</code>对比得到</li></ul><p><img src="https://gitee.com/sang3112/blog_imgs/raw/master/MySQL/45_MVCC.png" alt="45_MVCC"></p><div class="note info flat"><ol><li><strong>低水位之前可见</strong>，表明是<strong>已经提交</strong>的事务，或者是当前事务自己生成的</li><li><strong>高水位之后不可见</strong>，表明是当前事务启动时，还没启动的事务产生的数据，不可见</li><li>如果在中间，判断<code>row trx_id</code>:<ul><li>如果<code>row trx_id</code>在数组中，表明自己事务启动时，这个事务<strong>还没提交</strong>，不可见</li><li>如果<code>row trx_id</code>不在数组中，表明自己事务启动时，这个事务<strong>已经提交了</strong>，可见</li></ul></li></ol></div><ul><li>更新操作一定是<strong>先读后写</strong>，并且是<strong>当前读</strong>，跟隔离级别<strong>没有关系</strong>；</li><li><code>select</code>如果加锁也是当前读，比如<code>lock in share mode</code>(读锁，S锁，共享锁); <code>for update</code>(X锁，写锁，排他锁)</li></ul><div class="note info flat"><ul><li><code>RC</code>和<code>RR</code>的区别：<ul><li><code>RR</code>下每个事务都会创建一个视图，同一事务其他语句也共用，<code>RC</code>下每个语句都会重新计算生成一个新的<code>view</code></li></ul></li></ul></div><h1>体系结构</h1><ul><li><p>连接层: 最上层，客户端和连接服务，连接处理、授权认证、相关安全方案。服务器安全接入每个客户端并验证它所具有的操作权限:</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h &lt;ip&gt; -u &lt;username&gt; -p</span><br></pre></td></tr></table></figure><ul><li>首先完成TCP三次握手以后，再验证用户名和密码:<ul><li>有误则会收到<code>Access denied for user</code>，程序结束；</li><li>如果正确，则会查询权限表，此后的权限判断都依赖<strong>此时</strong>查到的权限。</li></ul></li><li>因此，即使对权限修改以后，也不会影响到已经存在连接的权限，只有重新建立连接的权限才会被修改。</li><li>完成连接以后如果没有后续的动作，则连接处于空闲。使用<code>show processlist</code>可以查询到当前状态，<code>Command</code>列为<code>Sleep</code>就表示空闲。如果空闲时长超过了参数<code>wait_timeout</code>(默认8h)，就会自动断开连接<ul><li>如果连接断开了以后，又发送了请求，则会报错：<code>Lost Connection to MySQL server during query</code>，需要重新连接才能继续执行请求</li></ul></li><li>如果客户端有请求并持续使用一个连接,就是长连接；</li><li>而短连接是执行几次查询就关闭，新建一个请求再执行</li></ul>  <div class="note info flat"><ul><li>尽量使用长连接。但是长连接会导致内存占用上涨非常快，因为执行过程中临时使用的内存是管理在连接对象里面的，直到连接断开才会释放内存，因此最后可能导致<code>OOM</code>,即异常重启</li><li>可以定期断开长连接，比如判断一个占用内存的大查询后就断开连接，之后再重连</li><li><strong>5.7版本后</strong>，可以在每次执行较大查询以后使用<code>mysql_reset_connection</code>重新初始化连接资源，不需要重连和权限验证，但是会恢复到刚刚连接的状态,释放之前占用的内存。</li></ul></div></li><li><p>服务层: 完成大多数的核心服务功能，比如<code>SQL</code>接口，完成缓存查询，<code>SQL</code>分析和优化，内置函数执行。所有跨存储引擎的功能也在这层实现，比如过程，函数</p><ul><li>查询缓存中之前执行过的语句会通过<code>k-v</code>形式存储在内存中，连接完成后直接查询缓存<ul><li>如果能找到<code>key</code>，则<code>value</code>会直接返回客户端;</li><li>如果不在缓存中就会执行到后面的查询数据库阶段，执行完成以后将结果写入缓存中</li></ul></li></ul>  <div class="note info flat"><ul><li>但是大多数情况建议<strong>不要</strong>查询缓存<ul><li>因为缓存失效非常频繁，如果更新一张表，那么这个表的所有查询缓存都会被清空，因此缓存命中率会非常的低，除非是存放系统配置的静态表，才会使用查询缓存</li></ul></li><li>设置参数<code>query_cache_type</code>为<code>DEMAND</code>, 这样默认就不会使用查询缓存; 如果需要使用缓存，可以使用指定的查询语句显式查询，比如<code>select SQL_CACHE * from table_name</code>进行查询，因为带有<code>SQL_CACHE</code>，所以这个查询会使用缓存</li><li><strong>8.0版本</strong>将查询缓存删除了，不需要考虑这块</li></ul></div><ul><li><p>如果没有查询缓存，就会通过<strong>分析器</strong>解析语句</p><ul><li>分为词法分析，语法分析. 如果语句不对就报错：<code>You have an error in your SQL syntax</code></li></ul></li><li><p><strong>优化器</strong>决定使用哪个索引,以及决定<code>join</code>连接顺序</p></li></ul>  <div class="note info flat"><p><code>select * from t1 join t2 using(ID) where t1.c = 10 and t2.d = 20;</code><br>t1 t2内连接，<code>using(ID)</code>是简写，表明<code>t1.ID == t2.ID</code></p><ul><li>可以t1中取出<code>c=10</code>的记录，然后根据ID关联到t2，再判断<code>t2.d==20</code>是否成立</li><li>也可以t2中取出<code>d=20</code>的记录，通过ID关联到t1，再判断<code>t1.c==10</code>是否成立</li><li>结果相同，但是效率不同。<ul><li>如果连接字段没有索引，就先将<code>t1.c=10</code>和<code>t2.d=20</code>全表扫描，得到的较小的数据放入<code>join_buffer</code>，全表扫描另外一张表，和内存中的行匹配。</li></ul></li></ul></div><ul><li>执行的时候执行器会检查是否有对应的权限，同样查询缓存也会判断是否存在查询权限。</li><li>执行器通过调用数据库引擎的API实现数据操作</li></ul>  <div class="note info flat"><p><code>select * from T where ID = 10;</code></p><ul><li>如果ID没有索引，那么InnoDB会取第一行判断是否等于10，不等于就跳过，等于就放到结果集中</li><li>取下一行，重复判断，直到表末，返回结果集。</li><li>如果ID有索引，就变成了取满足条件的第一行和<strong>满足条件</strong>的下一行</li><li>所以有索引，在<strong>引擎层</strong>就已经将数据过滤了，没有索引的话需要在<code>server</code>层才会进行数据过滤</li><li>慢查询日志中存在<code>rows_examined</code>字段，表示语句执行过程中扫描了多少行，这个值就是执行器调用引擎获取行数的时候累加的</li><li><code>rows_examined</code>是获取数据的行数，并不是真正的扫描行数，有可能执行器调用一次，引擎扫描了多行。</li></ul></div></li><li><p>引擎层: 负责<code>MySQL</code>的数据存储和提取，服务器通过API和存储引擎进行通信，不同的存储引擎具有不同功能</p></li><li><p>存储层: 将数据存储在文件系统之上，完成与存储引擎的交互</p></li></ul><div class="note info flat"><ul><li>索引是在存储引擎层实现的</li><li>存储引擎基于表的，不是基于库的，所以存储引擎也被称为表类型</li><li>创建表的时候指定存储引擎，<code>show engines;</code>显示当前支持的存储引擎</li><li>MySQL早期存储引擎为<code>MyISAM</code>，<code>5.5</code>版本后替换为<code>InnoDB</code></li></ul></div><p><img src="https://gitee.com/sang3112/blog_imgs/raw/master/MySQL/InnoDB.png" alt="InnoDB"></p><div class="note info flat"><ul><li><code>page</code>是磁盘操作的最小单元，大小固定为16K;<code>extent</code>区域大小固定为1M，也就是一个区中包含64个页</li></ul></div><h2 id="MySQL45讲">MySQL45讲</h2><blockquote><p>MySQL45讲中简化了对架构的描述: 大体将引擎架构分为<code>Server</code>层和存储引擎层两块</p><ol><li><code>Server</code>层包含了<code>MySQL</code>所有核心服务和内置函数(日期，时间，加密函数等)，或者跨存储引擎的功能，比如触发器，存储过程和视图</li><li>存储引擎层是插件式的，实现了数据的存储和提取，从5.5.5版本后开始默认的是<code>InnoDB</code><br>最终，不同的存储引擎共用一个<code>Server</code>层<br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/MySQL/45_architecture.png" alt="45_architecture"></li></ol></blockquote><h2 id="MyISAM-VS-InnoDB-VS-Memory"><code>MyISAM</code> VS <code>InnoDB</code> VS <code>Memory</code></h2><ul><li><code>MyISAM</code>不支持事务，不支持外键，支持表锁而不支持行锁，访问速度快</li><li><code>InnoDB</code>支持事务，支持外键保证完整性和一致性，支持行锁，提高并发性能。</li><li><code>MyISAM</code>涉及三个格式: <code>MYD MYI sdi</code>分别存储数据 索引和表结构</li><li><code>InnoDB</code>对应文件是<code>表名.idb</code>，每张表都会存储表结构(早期为<code>frm</code>,8.0版本后改为<code>sdi</code>)、数据和索引。<code>innodb_file_per_table</code>是一个开关，表名是否每张表都对应一个表空间文件<code>idb</code></li><li><code>Memory</code> 数据只在内存中，只能临时存储，或作为缓存使用，支持<code>hash</code>索引，只有<code>sdi</code>文件，存储表结构</li></ul><div class="note info flat"><ul><li>如果数据除了插入和查询以外，还包含很多更新、删除操作，那么选择<code>InnoDB</code>可以保证数据一致性</li><li>应用以读和插入操作为主，很少的更新和删除操作，并且给对事物完整性，并发性要求不高，就使用<code>MyISAM</code></li><li><code>Memory</code>将所有数据保存在内存中，访问速度快，通常用于临时表和缓存。但是对表大小有限制，并且无法保障安全性，(不如用<code>Redis</code>)</li></ul></div><table><thead><tr><th style="text-align:center">特点</th><th style="text-align:center">InnoDB</th><th style="text-align:center">MyISAM</th><th style="text-align:center">Memory</th></tr></thead><tbody><tr><td style="text-align:center">存储限制</td><td style="text-align:center">64TB</td><td style="text-align:center">4GB</td><td style="text-align:center">16MB</td></tr><tr><td style="text-align:center">事务安全</td><td style="text-align:center">支持</td><td style="text-align:center">无</td><td style="text-align:center">无</td></tr><tr><td style="text-align:center">锁</td><td style="text-align:center">行锁</td><td style="text-align:center">表锁</td><td style="text-align:center">表锁</td></tr><tr><td style="text-align:center">B+树索引</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">Hash索引</td><td style="text-align:center">无</td><td style="text-align:center">无</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">全文索引</td><td style="text-align:center">支持(5.6)版本后</td><td style="text-align:center">支持</td><td style="text-align:center">无</td></tr><tr><td style="text-align:center">空间使用</td><td style="text-align:center">高</td><td style="text-align:center">低</td><td style="text-align:center">N/A</td></tr><tr><td style="text-align:center">内存使用</td><td style="text-align:center">高</td><td style="text-align:center">低</td><td style="text-align:center">中等</td></tr><tr><td style="text-align:center">批量插入速度</td><td style="text-align:center">低</td><td style="text-align:center">高</td><td style="text-align:center">高</td></tr><tr><td style="text-align:center">支持外键</td><td style="text-align:center">支持</td><td style="text-align:center">无</td><td style="text-align:center">无</td></tr></tbody></table><h2 id="InnoDB表结构和数据"><code>InnoDB</code>表结构和数据</h2><ol><li><strong>8.0版本</strong>之前，<code>InnoDB</code>分为表结构定义和数据，表结构定义存储在<code>frm</code>后缀文件中；<strong>8.0版本后</strong>，可以把表结构定义存储在系统数据表中</li><li><code>innodb_file_per_table = ON</code>表示每个<code>InnoDB</code>表数据存储在<code>ibd</code>后缀文件中<br><code>innodb_file_per_table = OFF</code>表示表数据存在系统表空间<br><strong>5.6版本</strong>开始默认为<code>ON</code><ul><li>建议为<code>ON</code>，这样结构清楚，并且<code>drop table</code>后就会删除文件</li><li>如果在系统表空间中(<code>OFF</code>)，<code>drop table</code>后空间不会回收</li></ul></li></ol><ul><li><strong>记录</strong>如果被删除了，只是标记删除，以后如果插入数据符合对应的位置，就会复用删除的位置</li><li><strong>数据页</strong>被删除了，任意需要插入新的数据页，都可以进行复用，不需要判断位置</li><li>如果两个数据页利用率较低，就会合并，并将另一个数据页标记为可以复用</li><li>如果整个表都删除了，会将整个表标记为可复用，但是文件不会变小</li><li>增删改都会造成复用空洞，如果随机增加数据，导致页分裂，那原来的页面没有使用的部分就是空洞；修改数据就是先删除，再增加，也会导致空洞</li><li><code>ELECT DATA_LENGTH,DATA_FREE from information_schema.tables where table_schema='test' and table_name='test';</code> 查看空洞数<code>data_free</code></li><li>如果空洞数较多，可以重建表，<code>alter table A engine=InnoDB </code><ul><li><strong>5.5版本</strong>之前，这个操作不能有更新数据，但是<strong>5.6版本</strong>开始支持<code>Online</code>的重建表(<code>Online DDL</code>)<ul><li>建立临时文件，扫描表A主键所有数据页</li><li>用数据页中表A的记录生成B+树，存储到临时文件中</li><li>生成临时文件中所有对A的操作记录再日志<code>row log</code>中</li><li>生成后将<code>row log</code>中的操作应用到临时文件中</li><li>临时文件替换表A</li></ul></li><li><code>Online DDL</code>会有短暂的<code>MDL</code>写锁，但是再真正拷贝数据之前就已经退化为读锁了，只会阻塞修改表结构的<code>DDL</code></li></ul><blockquote><p><code>github</code>有一个开源的缩小表空间的工具，<code>gh-ost</code></p></blockquote><ul><li><code>Online DDL</code>一定是<code>inplace</code>的，原地的，但是<code>inplace</code>不一定是<code>Online</code>的，比如全文索引</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 多表查询 </tag>
            
            <tag> 四大特性 </tag>
            
            <tag> 事务 </tag>
            
            <tag> 隔离级别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL笔记_0</title>
      <link href="/posts/fae54f81.html"/>
      <url>/posts/fae54f81.html</url>
      
        <content type="html"><![CDATA[<h1>创建数据库</h1><h2 id="字符集选择-utf8mb4">字符集选择: <code>utf8mb4</code></h2><ul><li><code>Unicode</code>编码，也称作统一码，万国码。如：<code>utf8, utf16, utf32</code></li><li><code>utf8mb4</code>兼容<code>utf8</code>，并且可以表示更多的字符。具体来说:  <div class="note info flat"><p><code>Unicode</code>中的第<code>1-126</code>行是<code>utf8</code>的区域，<code>utf8mb4</code>同样兼容这一片区域，剩下<code>126</code>行以下的部分是<code>utf8mb4</code>扩充区域。</p></div></li><li>一般不选择<code>utf8</code>，因为其占用3B；而实际上很多内容，比如表情，就需要4B空间，所以一般使用<code>utf8mb4</code></li></ul><h2 id="排序规则选择：">排序规则选择：</h2><ul><li>对于<code>utf8mb4</code>而言，常用的排序规则有<code>utf8mb4_unicode_ci</code>，<code>utf8mb4_general_ci</code>，<code>utf8mb4_bin</code></li></ul><table><thead><tr><th style="text-align:center"><code>utf8mb4_unicode_ci</code></th><th style="text-align:center"><code>utf8mb4_general_ci</code></th><th style="text-align:center"><code>utf8mb4_bin</code></th></tr></thead><tbody><tr><td style="text-align:center"><strong>基于标准的Unicode</strong>规则来排序和比较</td><td style="text-align:center">没有实现Unicode排序规则</td><td style="text-align:center">将字符串的每个字符用二进制数据编译存储</td></tr><tr><td style="text-align:center">各语言<strong>精确排序</strong></td><td style="text-align:center">在某些特殊语言字符集，排序结果可能不一致</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>不区分大小写</strong></td><td style="text-align:center"><strong>不区分大小写</strong></td><td style="text-align:center"><strong>区分大小写</strong></td></tr><tr><td style="text-align:center">为了能够处理特殊字符，实现了略微复杂的排序算法</td><td style="text-align:center">比较和排序的时候更快</td><td style="text-align:center"> </td></tr></tbody></table><h1><code>SQL</code>分类</h1><table><thead><tr><th style="text-align:center">分类</th><th style="text-align:center">全称</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">DDL</td><td style="text-align:center">Data Definition Language</td><td style="text-align:center">数据定义语言，定义数据库、表、字段</td></tr><tr><td style="text-align:center">DML</td><td style="text-align:center">Data Manipulation Language</td><td style="text-align:center">数据操作语言，对数据<strong>增 删 改</strong></td></tr><tr><td style="text-align:center">DQL</td><td style="text-align:center">Data Query Language</td><td style="text-align:center">数据查询语言，<strong>查</strong></td></tr><tr><td style="text-align:center">DCL</td><td style="text-align:center">Data Control Language</td><td style="text-align:center">数据控制语言，创建数据库用户，设置访问权限</td></tr></tbody></table><h2 id="DDL"><code>DDL</code></h2><h3 id="查">查</h3><ul><li><p>查询<strong>所有</strong>数据库: <code>show databases;</code></p></li><li><p>查询当前数据库: <code>select database();</code></p></li><li><p>查询当前数据库中<strong>所有</strong>的表: <code>show tables;</code></p></li><li><p>查询表结构: <code>desc 表名;</code></p></li><li><p>查询建表语句: <code>show create table 表名;</code></p></li></ul><h3 id="增">增</h3><ul><li><p>创建数据库: <code>create database [if not exists] 数据库名 [default charset 字符集] [collate 排序规则];</code></p></li><li><p>创建表: <code>create table 表名 (字段名 字段类型 [comment '字段注释'], 字段名 字段类型 [comment '字段注释'], ...) [comment '表注释'];</code></p></li><li><p>添加表字段: <code>alter table 表名 add 字段名 类型 [comment '字段注释'];</code></p></li></ul><h3 id="删">删</h3><ul><li><p>删除数据库: <code>drop database [if exists] 数据库名;</code></p></li><li><p>删除表: <code>drop table [if exists] 表名;</code></p></li><li><p>删除并重新创建表: <code>truncate table 表名;</code></p></li><li><p>删除字段: <code>alter table 表名 drop 字段名;</code></p></li></ul><h3 id="改">改</h3><ul><li><p>修改表名: <code>alter table 表名 rename to 新表名;</code></p></li><li><p>修改字段数据类型: <code>alter table 表名 modify 字段名 新类型;</code></p></li><li><p>修改字段名和数据类型: <code>alter table 表名 change 原字段名 新字段名 类型 [comment '字段注释'];</code></p></li></ul><h3 id="类型">类型</h3><table>    <tr>        <th>分类</th><th>类型</th><th>大小</th><th>有符号范围</th><th>无符号范围</th><th>描述</th>    </tr>    <tr>        <td rowspan="8">数值</td>        <td>TINYINT</td><td>1B</td><td>(-128, 127)</td><td>(0, 255)</td><td></td>    </tr>    <tr>        <td>SMALLINT</td><td>2B</td><td>(-32768, 32767)</td><td>(0, 65535)</td><td></td>    </tr>    <tr>        <td>MIDIUMINT</td><td>3B</td><td>(-8388608, 8388607)</td><td>(0, 16777215)</td><td></td>    </tr>    <tr>        <td>INT or INTEGER</td><td>4B</td><td>(-2147483648, 2147483647)</td><td>(0, 4294967295)</td><td></td>    </tr>    <tr>        <td>BIGINT</td><td>8B</td><td>(-2^63, 2^63 - 1)</td><td>(0, 2^64 - 1)</td><td></td>    </tr>    <tr>        <td>FLOAT</td><td>4B</td><td>(-3.4028E+38, 3.4028E+38)</td><td>0 and (1.17549E-38, 3.4028E+38)</td><td></td>    </tr>    <tr>        <td>DOUBLE</td><td>8B</td><td>(-1.79769E+308, 1.79769E+308)</td><td>0 and (2.22507E-308, 1.79769E+308)</td><td></td>    </tr>    <tr>        <td>DECIMAL</td><td></td><td>由M(精度),D(标度)决定</td><td>由M(精度),D(标度)决定</td><td>精确定点数</td>    </tr></table><table>    <tr>        <th>分类</th><th>类型</th><th>大小</th><th>描述</th>    </tr>    <tr>        <td rowspan="10">字符串</td>        <td>CHAR</td><td>(0, 255B)</td><td>定长字符串</td>    </tr>    <tr>        <td>VARCHAR</td><td>(0, 65535B)</td><td>变长字符串</td>    </tr>    <tr>        <td>TINYBLOB</td><td>(0, 255B)</td><td>不超过255个字符的二进制数据</td>    </tr>    <tr>        <td>TINYTEXT</td><td>(0, 255B)</td><td>短文本</td>    </tr>    <tr>        <td>BLOB</td><td>(0, 65535B)</td><td>二进制长文本</td>    </tr>    <tr>        <td>TEXT</td><td>(0, 65535B)</td><td>长文本</td>    </tr>    <tr>        <td>MEDIUMBLOB</td><td>(0, 16777215B)</td><td></td>    </tr>    <tr>        <td>MEDIUMTEXT</td><td>(0, 16777251B)</td><td></td>    </tr>    <tr>        <td>LONGBLOB</td><td>(0, 4294967295B)</td><td></td>    </tr>    <tr>        <td>LONGTEXT</td><td>(0, 4294967295B)</td><td></td>    </tr></table><table>    <tr>        <th>分类</th><th>类型</th><th>大小</th><th>范围</th>    </tr>    <tr>        <td rowspan="5">日期</td>        <td>DATE</td><td>3B</td><td>1000-01-01至9999-12-31</td>    </tr>    <tr>        <td>TIME</td><td>3B</td><td>-838:59:59至838:59:59</td>    </tr>    <tr>        <td>YEAR</td><td>1B</td><td>1901至2155</td>    </tr>    <tr>        <td>DATETIME</td><td>8B</td><td>1000-01-01 00:00:00至9999-12-31 23:59:59</td>    </tr>    <tr>        <td>TIMESTAMP</td><td>4B</td><td>1970-01-01 00:00:01至2038-01-19 03:14:07</td>    </tr></table><div class="note info flat"><ul><li>存储年龄，使用<code>tinyint unsigned</code>，不能写<code>unsigned tinyint</code></li><li>存分数，一位小数，存储钱数，可以使用<code>decimal(4,1)</code>，表示最多四位，小数在最后一位之前</li><li><code>char(10)</code>定长为10，性能好，存储性别可以使用<code>char(1)</code></li><li><code>varchar(10)</code>不定长，性能差一些</li><li><code>timestamp</code>最大时间到2038，所以一般不用</li><li>记录生日使用<code>date</code></li></ul></div><h2 id="DML"><code>DML</code></h2><h3 id="增-2">增</h3><ul><li><p>给指定字段添加数据: <code>insert into 表名 (字段1, 字段2) values (值1, 值2);</code></p></li><li><p>给所有字段添加数据: <code>insert into 表名 values (值1, 值2, ...);</code></p></li><li><p>批量添加数据:</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名 (字段<span class="number">1</span>, 字段<span class="number">2</span>) <span class="keyword">values</span> (值<span class="number">1</span>, 值<span class="number">2</span>), (值<span class="number">3</span>, 值<span class="number">4</span>), ...</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名 <span class="keyword">values</span> (值<span class="number">1</span>, 值<span class="number">2</span>, 值<span class="number">3</span>, 值<span class="number">4</span>, ...), ... </span><br></pre></td></tr></table></figure></li><li><p>插入数据为字符串或者日期类型，应使用<strong>引号</strong>，否则不会走索引</p></li></ul><h3 id="删-2">删</h3><ul><li>删除数据: <code>delete from 表名 [where 条件];</code></li></ul><h3 id="改-2">改</h3><ul><li>修改数据: <code>update 表名 set 字段1=值1, 字段2=值2,..., [where 条件];</code></li></ul><h2 id="DQL"><code>DQL</code></h2><ul><li><p>查询语句: <code>select 字段列表 from 表名列表 [where 条件] [group by 分组字段列表] [having 分组后过滤条件列表] [order by 排序字段列表] [limit 分页参数];</code></p></li><li><p>查询时可以设置别名: <code>select 字段1 as 别名1, 字段2 as 别名2;</code></p></li><li><p>查询去重: <code>select distinct 字段列表 from 表名;</code></p></li><li><p>条件查询:</p></li></ul><table><thead><tr><th style="text-align:center">比较运算符</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>&lt;&gt; or !=</code></td><td style="text-align:center">不等于</td></tr><tr><td style="text-align:center"><code>BETWEEN min AND max</code></td><td style="text-align:center">在<code>[min, max]</code>范围内, 包含边界</td></tr><tr><td style="text-align:center"><code>IN(...)</code></td><td style="text-align:center">在列表中多选一</td></tr><tr><td style="text-align:center"><code>LIKE</code></td><td style="text-align:center">模糊匹配(<code>_</code>匹配单个字符, <code>%</code>匹配任意个字符)</td></tr><tr><td style="text-align:center"><code>IS NULL</code></td><td style="text-align:center">为空</td></tr></tbody></table><ul><li><p>聚合函数 <code>count, max, min, avg, sum</code>:</p><ul><li>作用于某一列，所有<code>null</code><strong>不参与</strong>聚合函数计算</li><li><code>where</code>是分组之前过滤，在聚合函数之前执行，因此<strong>不能</strong>使用聚合函数；<code>having</code>是分组之后过滤，聚合函数在<code>having</code>之前已经执行了，因此<strong>可以</strong>使用聚合函数</li><li>分组查询一般查询分组之后的字段和聚合函数，其他没有意义</li></ul></li><li><p>排序 <code>order by 字段1 排序方式1, 字段2 排序方式2</code>:</p><ul><li>升序<code>asc</code>，降序<code>desc</code>，默认为升序</li></ul></li><li><p>分页查询 <code>limit 起始索引, 查询记录数</code>:</p><ul><li>起始索引从0开始，<code>起始索引 = (查询页码 - 1) * 每页记录个数</code></li><li>分页查询是数据库的<strong>方言</strong>，不同数据库关键字不同，<code>MySQL</code>中使用<code>limit</code>，如果查询第一页的数据，则起始索引可以省略</li></ul></li></ul><h3 id="DQL执行顺序"><code>DQL</code>执行顺序:</h3><ul><li><code>from, where, group by, having, select, order by, limit</code></li><li>首先执行<code>from</code>找到表名，然后执行<code>where</code>判断条件，再<code>group by</code>分组和<code>having</code>，再<code>select</code>选择字段列表，最后<code>order by</code>排序和<code>limit</code>分页</li></ul><h2 id="DCL"><code>DCL</code></h2><h3 id="查-2">查</h3><ul><li><p>查询用户: <code>use mysql; select * from user;</code></p>  <div class="note info flat"><p>用户信息都存放在<code>mysql</code>系统数据库中</p></div></li><li><p>查询用户权限: <code>show grants for '用户名'@'主机名';</code></p></li></ul><h3 id="增-3">增</h3><ul><li>创建用户: <code>create user '用户名'@'主机名' identified by '密码';</code>  <div class="note info flat"><p>如果需要该用户可以在任意主机上访问该数据库，需要将主机名修改为<code>%</code>即可</p></div></li></ul><h3 id="删-3">删</h3><ul><li>删除用户: <code>drop user '用户名'@'主机名';</code></li></ul><h3 id="改-3">改</h3><ul><li><p>修改密码: <code>alter user '用户名'@'主机名' identified with mysql_native_password by '新密码';</code></p></li><li><p>授权: <code>grant 权限列表 on 数据库名.表名 to '用户名'@'表名'</code>;</p></li><li><p>撤销权限: <code>revoke 权限列表 on 数据库名.表名 from '用户名'@'表名';</code></p>  <div class="note info flat"><p><code>'用户名'@'表名'</code> 中间不能存在空格</p></div></li></ul><table><thead><tr><th style="text-align:center">权限</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">ALL, ALL PRIVILEGES</td><td style="text-align:center">所有权限</td></tr><tr><td style="text-align:center">SELECT</td><td style="text-align:center">查询数据</td></tr><tr><td style="text-align:center">INSERT</td><td style="text-align:center">插入数据</td></tr><tr><td style="text-align:center">UPDATE</td><td style="text-align:center">修改数据</td></tr><tr><td style="text-align:center">DELETE</td><td style="text-align:center">删除数据</td></tr><tr><td style="text-align:center">ALTER</td><td style="text-align:center">修改表</td></tr><tr><td style="text-align:center">DROP</td><td style="text-align:center">删除数据库/表/视图</td></tr><tr><td style="text-align:center">CREATE</td><td style="text-align:center">创建数据库/表</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> SQL分类 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* @font-face {  font-family: Candyhome;  src: url(https://npm.elemecdn.com/anzhiyu-blog@1.1.6/fonts/Candyhome.ttf);  font-display: swap;  font-weight: lighter;} */@font-face {    font-family: ZhuZiAYuanJWD;    src: url(https://npm.elemecdn.com/anzhiyu-blog@1.1.6/fonts/ZhuZiAWan.woff2);    font-display: swap;    font-weight: lighter;  }    div#menus {    font-family: "ZhuZiAYuanJWD";  }  h1#site-title {    font-family: ZhuZiAYuanJWD;    font-size: 3em !important;  }  a.article-title,  a.blog-slider__title,  a.categoryBar-list-link,  h1.post-title {    font-family: ZhuZiAYuanJWD;  }    .iconfont {    font-family: "iconfont" !important;    font-size: 3em;    /* 可以定义图标大小 */    font-style: normal;    -webkit-font-smoothing: antialiased;    -moz-osx-font-smoothing: grayscale;  }    /* 时间轴生肖icon */  svg.icon {    /* 这里定义svg.icon，避免和Butterfly自带的note标签冲突 */    width: 1em;    height: 1em;    /* width和height定义图标的默认宽度和高度*/    vertical-align: -0.15em;    fill: currentColor;    overflow: hidden;  }    .icon-zhongbiao::before {    color: #f7c768;  }  /* bilibli番剧插件 */  #article-container .bangumi-tab.bangumi-active {    background: var(--anzhiyu-theme);    color: var(--anzhiyu-ahoverbg);    border-radius: 10px;  }  a.bangumi-tab:hover {    text-decoration: none !important;  }  .bangumi-button:hover {    background: var(--anzhiyu-theme) !important;    border-radius: 10px !important;    color: var(--anzhiyu-ahoverbg) !important;  }  a.bangumi-button.bangumi-nextpage:hover {    text-decoration: none !important;  }  .bangumi-button {    padding: 5px 10px !important;  }    a.bangumi-tab {    padding: 5px 10px !important;  }  svg.icon.faa-tada {    font-size: 1.1em;  }  .bangumi-info-item {    border-right: 1px solid #f2b94b;  }  .bangumi-info-item span {    color: #f2b94b;  }  .bangumi-info-item em {    color: #f2b94b;  }    /* 解决artitalk的图标问题 */  #uploadSource > svg {    width: 1.19em;    height: 1.5em;  }    /*top-img黑色透明玻璃效果移除，不建议加，除非你执着于完全一图流或者背景图对比色明显 */  #page-header:not(.not-top-img):before {    background-color: transparent !important;  }    /* 首页文章卡片 */  #recent-posts > .recent-post-item {    /* background: rgba(255, 255, 255, 0); */    background: rgba(28, 28, 28, 0.98) !important;    border-style: solid;    border-width: 1px;    border-color:  rgba(169, 169, 169, 0.7);  }  /* 首页侧栏卡片 */  #aside-content .card-widget {    /* background: rgba(255, 255, 255, 0); */    background: rgba(28, 28, 28, 0.98) !important;    border-style: solid;    border-width: 1px;    border-color:  rgba(169, 169, 169, 0.7);  }    /* 文章页面正文背景 */  div#post {    /* background: rgba(255, 255, 255, 0); */    background: rgba(28, 28, 28, 0.98) !important;    border-style: solid;    border-width: 1px;    border-color:  rgba(169, 169, 169, 0.7);  }    /* 分页页面 */  div#page {    /* background: rgba(255, 255, 255, 0); */    background: rgba(28, 28, 28, 0.98) !important;    border-style: solid;    border-width: 1px;    border-color:  rgba(169, 169, 169, 0.7);  }  div.pagination{    display: none  }    /* 归档页面 */  div#archive {    background: rgba(255, 255, 255, 0) !important;  }    /* 标签页面 */  div#tag {    /* background: rgba(255, 255, 255, 0); */    background: rgba(28, 28, 28, 0.98) !important;    border-style: solid;    border-width: 1px;    border-color:  rgba(169, 169, 169, 0.7);  }    /* 分类页面 */  div#category {    /* background: rgba(255, 255, 255, 0); */    background: rgba(28, 28, 28, 0.98) !important;    border-style: solid;    border-width: 1px;    border-color:  rgba(169, 169, 169, 0.7);  }    /*夜间模式伪类遮罩层透明*/  [data-theme="dark"] #recent-posts > .recent-post-item {    background: #121212;  }    [data-theme="dark"] .card-widget {    background: #121212 !important;  }    [data-theme="dark"] div#post {    background: #121212 !important;  }    [data-theme="dark"] div#tag {    background: #121212 !important;  }    [data-theme="dark"] div#archive {    background: #121212 !important;  }    [data-theme="dark"] div#page {    background: #121212 !important;  }    [data-theme="dark"] div#category {    background: #121212 !important;  }    [data-theme="dark"] div#category {    background: transparent !important;  }  /* 页脚透明 */  #footer {    background: transparent !important;  }    /* 头图透明 */  #page-header {    background: transparent !important;  }    #rightside > div > button {    border-radius: 5px;  }    /* 滚动条 */    ::-webkit-scrollbar {    width: 10px;    height: 10px;  }    ::-webkit-scrollbar-thumb {    background-color: #3b70fc;    border-radius: 2em;  }    ::-webkit-scrollbar-corner {    background-color: transparent;  }    ::-moz-selection {    color: #fff;    background-color: #3b70fc;  }    /* 音乐播放器 */    /* .aplayer .aplayer-lrc {    display: none !important;  } */    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {    left: -66px !important;    transition: all 0.3s;    /* 默认情况下缩进左侧66px，只留一点箭头部分 */  }    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {    left: 0 !important;    transition: all 0.3s;    /* 鼠标悬停是左侧缩进归零，完全显示按钮 */  }    .aplayer.aplayer-fixed {    z-index: 999999 !important;  }    /* 评论框  */  .vwrap {    box-shadow: 2px 2px 5px #bbb;    background: rgba(255, 255, 255, 0.3);    border-radius: 8px;    padding: 30px;    margin: 30px 0px 30px 0px;  }    /* 设置评论框 */    .vcard {    box-shadow: 2px 2px 5px #bbb;    background: rgba(255, 255, 255, 0.3);    border-radius: 8px;    padding: 30px;    margin: 30px 0px 0px 0px;  }    /* md网站下划线 */  #article-container a:hover {    text-decoration: none !important;  }    #article-container #hpp_talk p img {    display: inline;  }    /* 404页面 */  #error-wrap {    position: absolute;    top: 40%;    right: 0;    left: 0;    margin: 0 auto;    padding: 0 1rem;    max-width: 1000px;    transform: translate(0, -50%);  }    #error-wrap .error-content {    display: flex;    flex-direction: row;    justify-content: center;    align-items: center;    margin: 0 1rem;    height: 18rem;    border-radius: 8px;    background: var(--card-bg);    box-shadow: var(--card-box-shadow);    transition: all 0.3s;  }    #error-wrap .error-content .error-img {    box-flex: 1;    flex: 1;    height: 100%;    border-top-left-radius: 8px;    border-bottom-left-radius: 8px;    background-color: #3b70fc;    background-position: center;    background-size: cover;  }    #error-wrap .error-content .error-info {    box-flex: 1;    flex: 1;    padding: 0.5rem;    text-align: center;    font-size: 14px;    font-family: Titillium Web, "PingFang SC", "Hiragino Sans GB", "Microsoft JhengHei", "Microsoft YaHei", sans-serif;  }  #error-wrap .error-content .error-info .error_title {    margin-top: -4rem;    font-size: 9em;  }  #error-wrap .error-content .error-info .error_subtitle {    margin-top: -3.5rem;    word-break: break-word;    font-size: 1.6em;  }  #error-wrap .error-content .error-info a {    display: inline-block;    margin-top: 0.5rem;    padding: 0.3rem 1.5rem;    background: var(--btn-bg);    color: var(--btn-color);  }    #body-wrap.error .aside-list {    display: flex;    flex-direction: row;    flex-wrap: nowrap;    bottom: 0px;    position: absolute;    padding: 1rem;    width: 100%;    overflow: scroll;  }    #body-wrap.error .aside-list .aside-list-group {    display: flex;    flex-direction: row;    flex-wrap: nowrap;    max-width: 1200px;    margin: 0 auto;  }    #body-wrap.error .aside-list .aside-list-item {    padding: 0.5rem;  }    #body-wrap.error .aside-list .aside-list-item img {    width: 100%;    object-fit: cover;    border-radius: 12px;  }    #body-wrap.error .aside-list .aside-list-item .thumbnail {    overflow: hidden;    width: 230px;    height: 143px;    background: var(--anzhiyu-card-bg);    display: flex;  }    #body-wrap.error .aside-list .aside-list-item .content .title {    -webkit-line-clamp: 2;    overflow: hidden;    display: -webkit-box;    -webkit-box-orient: vertical;    line-height: 1.5;    justify-content: center;    align-items: flex-end;    align-content: center;    padding-top: 0.5rem;    color: white;  }    #body-wrap.error .aside-list .aside-list-item .content time {    display: none;  }    /* 代码框主题 */  #article-container figure.highlight {    border-radius: 10px;  }/* 侧边栏个人信息卡片动态渐变色 */#aside-content > .card-widget.card-info {    background: linear-gradient(      -45deg,      #e8d8b9,      #eccec5,      #a3e9eb,      #bdbdf0,      #eec1ea    );    box-shadow: 0 0 5px rgb(66, 68, 68);    position: relative;    background-size: 400% 400%;    -webkit-animation: Gradient 10s ease infinite;    -moz-animation: Gradient 10s ease infinite;    animation: Gradient 10s ease infinite !important;  }  @-webkit-keyframes Gradient {    0% {      background-position: 0% 50%;    }    50% {      background-position: 100% 50%;    }    100% {      background-position: 0% 50%;    }  }  @-moz-keyframes Gradient {    0% {      background-position: 0% 50%;    }    50% {      background-position: 100% 50%;    }    100% {      background-position: 0% 50%;    }  }  @keyframes Gradient {    0% {      background-position: 0% 50%;    }    50% {      background-position: 100% 50%;    }    100% {      background-position: 0% 50%;    }  }    /* 黑夜模式适配 */  [data-theme="dark"] #aside-content > .card-widget.card-info {    background: #191919ee;  }    /* 个人信息Follow me按钮 */  #aside-content > .card-widget.card-info > #card-info-btn {    background-color: #3eb8be;    border-radius: 8px;  }  /* 一级菜单居中 */#nav .menus_items {    position: absolute !important;    width: fit-content !important;    left: 50% !important;    transform: translateX(-50%) !important;  }  /* 子菜单横向展示 */  #nav .menus_items .menus_item:hover .menus_item_child {    display: flex !important;  }  /* 这里的2是代表导航栏的第2个元素，即有子菜单的元素，可以按自己需求修改 */  .menus_items .menus_item:nth-child(2) .menus_item_child {    left: -125px;  }/* 背景宇宙星光  */#universe{    display: block;    position: fixed;    margin: 0;    padding: 0;    border: 0;    outline: 0;    left: 0;    top: 0;    width: 100%;    height: 100%;    pointer-events: none;    z-index: 10;  }]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/universe.js"/>
      <url>/js/universe.js</url>
      
        <content type="html"><![CDATA[function dark() {window.requestAnimationFrame=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame;var n,e,i,h,t=.05,s=document.getElementById("universe"),o=!0,a="180,184,240",r="226,225,142",d="226,225,224",c=[];function f(){n=window.innerWidth,e=window.innerHeight,i=.216*n,s.setAttribute("width",n),s.setAttribute("height",e)}function u(){h.clearRect(0,0,n,e);for(var t=c.length,i=0;i<t;i++){var s=c[i];s.move(),s.fadeIn(),s.fadeOut(),s.draw()}}function y(){this.reset=function(){this.giant=m(3),this.comet=!this.giant&&!o&&m(10),this.x=l(0,n-10),this.y=l(0,e),this.r=l(1.1,2.6),this.dx=l(t,6*t)+(this.comet+1-1)*t*l(50,120)+2*t,this.dy=-l(t,6*t)-(this.comet+1-1)*t*l(50,120),this.fadingOut=null,this.fadingIn=!0,this.opacity=0,this.opacityTresh=l(.2,1-.4*(this.comet+1-1)),this.do=l(5e-4,.002)+.001*(this.comet+1-1)},this.fadeIn=function(){this.fadingIn&&(this.fadingIn=!(this.opacity>this.opacityTresh),this.opacity+=this.do)},this.fadeOut=function(){this.fadingOut&&(this.fadingOut=!(this.opacity<0),this.opacity-=this.do/2,(this.x>n||this.y<0)&&(this.fadingOut=!1,this.reset()))},this.draw=function(){if(h.beginPath(),this.giant)h.fillStyle="rgba("+a+","+this.opacity+")",h.arc(this.x,this.y,2,0,2*Math.PI,!1);else if(this.comet){h.fillStyle="rgba("+d+","+this.opacity+")",h.arc(this.x,this.y,1.5,0,2*Math.PI,!1);for(var t=0;t<30;t++)h.fillStyle="rgba("+d+","+(this.opacity-this.opacity/20*t)+")",h.rect(this.x-this.dx/4*t,this.y-this.dy/4*t-2,2,2),h.fill()}else h.fillStyle="rgba("+r+","+this.opacity+")",h.rect(this.x,this.y,this.r,this.r);h.closePath(),h.fill()},this.move=function(){this.x+=this.dx,this.y+=this.dy,!1===this.fadingOut&&this.reset(),(this.x>n-n/4||this.y<0)&&(this.fadingOut=!0)},setTimeout(function(){o=!1},50)}function m(t){return Math.floor(1e3*Math.random())+1<10*t}function l(t,i){return Math.random()*(i-t)+t}f(),window.addEventListener("resize",f,!1),function(){h=s.getContext("2d");for(var t=0;t<i;t++)c[t]=new y,c[t].reset();u()}(),function t(){document.getElementsByTagName('html')[0].getAttribute('data-theme')=='dark'&&u(),window.requestAnimationFrame(t)}()};dark()]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/ali_font.js"/>
      <url>/js/ali_font.js</url>
      
        <content type="html"><![CDATA[window._iconfont_svg_string_4455139='<svg><symbol id="icon-002_youxiang" viewBox="0 0 1024 1024"><path d="M904.4 273.2c0.7 1 1.5 2.1 2.2 3.2 4.8 7.4 2.6 17.5-4.5 22.7l-360 260.4-4.3 3.7c-9.7 10-25.6 10-35.4 0L128 289.6c-7.8-5.7-9.5-17.3-3.1-24.5 3.2-3.6 6.6-6.9 10.3-9.9-7.6 0.8-14.3 7-14.3 15.7V800c0 47.9 38.8 86.7 86.7 86.7h614.8c47.9 0 86.7-38.8 86.7-86.7V284.5c0-4.6-1.8-8.5-4.7-11.3z" fill="#5E9EFC" ></path><path d="M145.8 258L464 484.2c16.7 15.6 38.1 23.4 59.5 23.4s42.7-7.8 59.4-23.4l301.4-212.7c6.7-4.7 15-3.3 20.1 1.6-16.4-23.2-43-38.3-73-38.3h-640c-21.3 0-40.8 7.6-56.2 20.3 3.6-0.3 7.3 0.6 10.6 2.9z" fill="#12F4FF" ></path><path d="M124.9 265.1c-6.4 7.2-4.7 18.8 3.1 24.5l374.5 273.6c9.7 10 25.6 10 35.4 0l4.3-3.7L902 299.1c7.1-5.1 9.3-15.3 4.5-22.7-0.7-1.1-1.4-2.1-2.2-3.2-5.1-5-13.4-6.4-20.1-1.6L582.9 484.3c-16.7 15.6-38.1 23.4-59.4 23.4-21.4 0-42.8-7.8-59.5-23.4L145.8 258c-3.3-2.4-7.1-3.2-10.6-2.9-3.7 3.1-7.1 6.4-10.3 10z" fill="#0797FC" ></path><path d="M609.6 823.6H420.5c-17.4 0-31.5-14.1-31.5-31.5s14.1-31.5 31.5-31.5h189.2c17.4 0 31.5 14.1 31.5 31.5-0.1 17.4-14.2 31.5-31.6 31.5z" fill="#BFD8FE" ></path></symbol><symbol id="icon-github-fill" viewBox="0 0 1024 1024"><path d="M511.6 76.3C264.3 76.2 64 276.4 64 523.5 64 718.9 189.3 885 363.8 946c23.5 5.9 19.9-10.8 19.9-22.2v-77.5c-135.7 15.9-141.2-73.9-150.3-88.9C215 726 171.5 718 184.5 703c30.9-15.9 62.4 4 98.9 57.9 26.4 39.1 77.9 32.5 104 26 5.7-23.5 17.9-44.5 34.7-60.8-140.6-25.2-199.2-111-199.2-213 0-49.5 16.3-95 48.3-131.7-20.4-60.5 1.9-112.3 4.9-120 58.1-5.2 118.5 41.6 123.2 45.3 33-8.9 70.7-13.6 112.9-13.6 42.4 0 80.2 4.9 113.5 13.9 11.3-8.6 67.3-48.8 121.3-43.9 2.9 7.7 24.7 58.3 5.5 118 32.4 36.8 48.9 82.7 48.9 132.3 0 102.2-59 188.1-200 212.9 23.5 23.2 38.1 55.4 38.1 91v112.5c0.8 9 0 17.9 15 17.9 177.1-59.7 304.6-227 304.6-424.1 0-247.2-200.4-447.3-447.5-447.3z" fill="#1296DB" ></path></symbol><symbol id="icon-fenlei" viewBox="0 0 1024 1024"><path d="M184.637696 812.567543 109.098255 812.567543c-13.890358 0-25.178449 11.269671-25.178449 25.174356 0 13.908778 11.288091 25.183566 25.178449 25.183566l75.538417 0c13.891382 0 25.179472-11.275811 25.179472-25.183566C209.817168 823.836191 198.529077 812.567543 184.637696 812.567543zM914.82909 812.567543 360.890932 812.567543c-13.895475 0-25.183566 11.269671-25.183566 25.174356 0 13.908778 11.289114 25.183566 25.183566 25.183566L914.82909 862.925465c13.890358 0 25.178449-11.275811 25.178449-25.183566C940.008562 823.836191 928.719448 812.567543 914.82909 812.567543zM184.637696 485.235426 109.098255 485.235426c-13.890358 0-25.178449 11.274788-25.178449 25.182542 0 13.904685 11.288091 25.178449 25.178449 25.178449l75.538417 0c13.891382 0 25.179472-11.274788 25.179472-25.178449C209.817168 496.510214 198.529077 485.235426 184.637696 485.235426zM914.82909 485.235426 360.890932 485.235426c-13.895475 0-25.183566 11.274788-25.183566 25.182542 0 13.904685 11.289114 25.178449 25.183566 25.178449L914.82909 535.596418c13.890358 0 25.178449-11.274788 25.178449-25.178449C940.008562 496.510214 928.719448 485.235426 914.82909 485.235426zM184.637696 157.909449 109.098255 157.909449c-13.890358 0-25.178449 11.276834-25.178449 25.181519 0 13.902638 11.288091 25.177426 25.178449 25.177426l75.538417 0c13.891382 0 25.179472-11.273764 25.179472-25.177426C209.817168 169.18526 198.529077 157.909449 184.637696 157.909449zM360.890932 208.267371 914.82909 208.267371c13.890358 0 25.178449-11.273764 25.178449-25.177426 0-13.904685-11.288091-25.181519-25.178449-25.181519L360.890932 157.908426c-13.895475 0-25.183566 11.276834-25.183566 25.181519C335.707366 196.993606 346.99648 208.267371 360.890932 208.267371z" fill="#5D5D5D" ></path></symbol><symbol id="icon-youxiang" viewBox="0 0 1024 1024"><path d="M838.954667 234.666667H170.666667c-3.626667 0-7.168 0.448-10.56 1.322666l323.690666 323.669334a21.333333 21.333333 0 0 0 30.165334 0L838.954667 234.666667z m46.144 14.186666l-260.693334 260.693334 262.933334 262.912c5.44-7.168 8.661333-16.106667 8.661333-25.792V277.333333c0-10.944-4.117333-20.906667-10.88-28.48zM843.861333 789.333333l-249.6-249.621333-50.133333 50.133333a64 64 0 0 1-90.517333 0l-50.112-50.133333L156.373333 786.88c4.48 1.578667 9.28 2.453333 14.314667 2.453333h673.194667zM128.661333 754.218667L373.333333 509.525333 129.578667 265.813333A42.709333 42.709333 0 0 0 128 277.333333v469.333334c0 2.56 0.213333 5.098667 0.661333 7.552zM170.666667 192h682.666666a85.333333 85.333333 0 0 1 85.333334 85.333333v469.333334a85.333333 85.333333 0 0 1-85.333334 85.333333H170.666667a85.333333 85.333333 0 0 1-85.333334-85.333333V277.333333a85.333333 85.333333 0 0 1 85.333334-85.333333z" fill="#333333" ></path></symbol><symbol id="icon-iconcopy" viewBox="0 0 1024 1024"><path d="M76.844522 542.45287a22.26087 22.26087 0 0 0-2.048 38.288695l225.413565 150.216348 28.360348 170.073044a22.26087 22.26087 0 0 0 41.049043 7.835826l90.112-150.216348 289.52487 206.803478a22.26087 22.26087 0 0 0 34.816-13.935304l164.908522-865.903305-872.18087 456.837566z m182.628174 214.861913l-209.341218-139.575653a66.782609 66.782609 0 0 1 6.054957-114.732521L1009.975652 3.428174l-182.182956 956.416a66.782609 66.782609 0 0 1-104.403479 41.850435l-250.301217-178.754783-65.313391 108.811131a66.782609 66.782609 0 0 1-123.102609-23.373914l-25.199304-151.06226z" fill="#979797" ></path><path d="M282.89113 772.630261l712.347827-712.347826-31.521392-31.521392-712.347826 712.347827z" fill="#979797" ></path><path d="M476.91687 813.990957l520.904347-756.869566a22.26087 22.26087 0 1 0-36.685913-25.199304l-520.904347 756.869565a22.26087 22.26087 0 1 0 36.685913 25.199305z" fill="#979797" ></path></symbol><symbol id="icon-shengdanwancan" viewBox="0 0 1080 1024"><path d="M678.177545 210.357848c7.062069 2.824828 17.139641 6.829021 30.225655 12.005518 155.859862 61.722483 239.898483 184.531862 279.163586 342.792827 0.564966 2.309297 1.977379 3.884138 4.237242 4.731586 5.3248 2.026814 10.691972 3.629903 16.101517 4.802207 39.97131 8.827586 65.041655 56.002207 70.126345 93.14869 2.966069 21.376883 2.994317 50.239559 0.07062 86.580965-3.199117 40.020745-21.440441 70.408828-54.731034 91.171311-9.131255 5.69909-16.899531 11.136883-23.304828 16.313379a11.045076 11.045076 0 0 0-3.813517 5.790897c-10.352993 37.245352-28.008166 67.965352-52.965517 92.16-72.174345 69.87211-152.018097 78.579641-239.54538 26.129655-3.813517-2.330483-11.29931-9.533793-17.725793-12.21738a6.58891 6.58891 0 0 0-6.638344 0.635587c-88.628966 59.109517-184.814345 61.016276-268.852966-3.460414a2.365793 2.365793 0 0 0-3.03669 0.141241 133.56491 133.56491 0 0 1-35.451586 24.50538c-84.271669 40.253793-159.482703 29.335834-225.633103-32.768-31.447393-29.519448-52.704221-66.242207-63.770483-110.168276a6.122814 6.122814 0 0 0-4.307862-4.660966c-37.711448-12.288-67.937103-51.623724-71.256276-91.948138-4.025379-48.375172-9.463172-105.648552 23.51669-142.936276 23.799172-26.906483 39.688828-42.372414 75.069793-38.347034a4.766897 4.766897 0 0 0 5.084689-3.531035c5.225931-19.49131 8.474483-41.94869 13.629794-58.897655 43.975503-143.11989 134.864331-242.017103 272.666482-296.677517 5.134124-2.019752 7.302179-5.762648 6.497104-11.22869-9.533793-64.264828 1.765517-137.216 57.485241-175.492413 47.668966-32.768 112.357517-35.663448 159.249655-0.847449 54.30731 40.324414 70.69131 111.298207 54.872276 176.410483-0.656772 2.824828 0.353103 4.781021 3.03669 5.861517z m-189.051586-12.641103l100.563862-1.059311a17.867034 17.867034 0 0 0 17.725793-18.008275l-0.353104-32.344276c-0.437848-41.765076-30.790621-75.302841-67.795862-74.928552h-2.259862c-17.775228 0.183614-34.745379 8.333241-47.17462 22.648055-12.415117 14.314814-19.279448 33.629572-19.067587 53.692911l0.353104 32.344275a17.867034 17.867034 0 0 0 18.008276 17.655173z m-203.670069 376.478896l539.118344-0.141241 83.261794-0.211862a5.014069 5.014069 0 0 0 4.943448-6.002759c-22.316138-107.809545-78.671448-191.191393-169.065931-250.138482-46.327172-30.225655-93.876083-48.113876-142.653793-53.671725l-11.087449 2.189242c-196.749241-33.191724-371.535448 118.148414-409.882482 304.940138a3.629903 3.629903 0 0 0 0.755641 3.086124 3.785269 3.785269 0 0 0 2.916635 1.362979l101.693793-1.412414z m584.386207 355.010207c27.309021-15.345876 46.496662-39.921876 57.555862-73.728a5.367172 5.367172 0 0 0-5.08469-7.062069l-112.569379-1.977379c-20.974345-0.776828-48.657655-13.135448-50.14069-36.934621-1.129931-18.502621 11.934897-27.68331 29.448828-27.542069 38.799007 0.423724 75.846621 0.706207 111.156965 0.847449 25.522317 1.511283 49.815834 1.723145 72.880552 0.635586 58.33269-2.683586 40.825821-99.433931 27.965793-131.566345-2.683586-6.730152-8.615724-10.190566-17.796414-10.381241-30.084414-0.656772-60.2112-0.586152-90.394483 0.211862-279.135338 1.652524-535.608497 1.299421-769.412413-1.059311-13.771034-0.141241-25.705931-0.494345-34.462897 11.511173-19.632552 26.835862-30.578759 131.425103 22.104276 130.224551 66.199834-1.504221 134.461793-2.259862 204.8-2.259862 22.415007 0 30.628193 10.804966 24.646621 32.414897l-0.706207 2.542345c-6.115752 22.08309-20.621241 33.099917-43.502345 33.050483l-134.10869-0.141242a2.28811 2.28811 0 0 0-1.836138 0.918069 2.443476 2.443476 0 0 0-0.423724 2.048c26.553379 99.151448 151.905103 135.026759 217.794207 47.810207 9.745655-12.923586 25.211586-46.892138 44.985379-19.844414 21.680552 29.73131 52.541793 60.168828 91.948138 66.948414 56.454179 9.703283 102.64011-6.920828 138.557793-49.858207a2988.173241 2988.173241 0 0 0 25.352828-30.72 2.436414 2.436414 0 0 1 3.319172-0.423724 232.624552 232.624552 0 0 1 41.94869 37.85269c12.429241 14.314814 22.718676 23.7568 30.861241 28.318896 36.115421 20.10571 74.483641 19.49131 115.111725-1.836138z" fill="#343333" ></path><path d="M489.125959 197.716745a17.867034 17.867034 0 0 1-18.008276-17.655173l-0.353104-32.344275c-0.211862-20.056276 6.652469-39.378097 19.067587-53.692911 12.429241-14.321876 29.399393-22.464441 47.17462-22.648055h2.259862c37.005241-0.37429 67.358014 33.163476 67.795862 74.928552l0.353104 32.344276a17.867034 17.867034 0 0 1-17.725793 18.008275l-100.563862 1.059311z" fill="#FEFEFE" ></path><path d="M589.972303 266.218814c2.683586 2.591779 4.166621 4.922262 4.449104 6.991448a3.848828 3.848828 0 0 1-3.177931 4.237241c-159.320276 25.352828-272.948966 140.535172-305.787586 296.748138l-101.693793 1.412414a3.785269 3.785269 0 0 1-2.916635-1.362979 3.629903 3.629903 0 0 1-0.755641-3.086124c38.347034-186.791724 213.133241-338.131862 409.882482-304.940138z" fill="#E4D1A8" ></path><path d="M589.972303 266.218814l11.087449-2.189242c0.190676 4.194869 1.200552 7.676469 3.036689 10.451862 1.271172 1.935007 2.944883 3.418041 5.014069 4.449104 93.854897 46.539034 170.619586 144.984276 200.915862 245.195034 4.943448 16.433434 9.79509 33.078731 14.547862 49.928828l-539.118344 0.141241c32.838621-156.212966 146.46731-271.39531 305.787586-296.748138a3.848828 3.848828 0 0 0 3.177931-4.237241c-0.282483-2.069186-1.765517-4.399669-4.449104-6.991448z" fill="#CA9F54" ></path><path d="M601.059752 264.029572c48.77771 5.557848 96.326621 23.446069 142.653793 53.671725 90.394483 58.94709 146.749793 142.328938 169.065931 250.138482a5.014069 5.014069 0 0 1-4.943448 6.002759l-83.261794 0.211862a3011.661683 3011.661683 0 0 0-14.547862-49.928828c-30.296276-100.210759-107.060966-198.656-200.915862-245.195034a12.704662 12.704662 0 0 1-5.014069-4.449104c-1.836138-2.775393-2.846014-6.256993-3.036689-10.451862z" fill="#AC884A" ></path><path d="M892.864441 641.709021l8.333242 2.189241c3.389793 0.896883 3.933572 2.6624 1.624276 5.296552l-1.483035 1.836138a8.086069 8.086069 0 0 0-2.118621 5.720276l0.98869 126.057931c-35.310345-0.141241-72.357959-0.423724-111.156965-0.847449-17.513931-0.141241-30.578759 9.039448-29.448828 27.542069 1.483034 23.799172 29.166345 36.157793 50.14069 36.934621 24.293517 25.140966 44.328607 52.732469 60.098207 82.767448-40.628083 21.327448-78.996303 21.941848-115.111725 1.836138-8.142566-4.562097-18.432-14.004083-30.861241-28.318896a232.624552 232.624552 0 0 0-41.94869-37.85269 2.436414 2.436414 0 0 0-3.319172 0.423724 2988.173241 2988.173241 0 0 1-25.352828 30.72c-35.917683 42.937379-82.103614 59.56149-138.557793 49.858207-39.406345-6.779586-70.267586-37.217103-91.948138-66.948414-19.773793-27.047724-35.239724 6.920828-44.985379 19.844414-65.889103 87.216552-191.240828 51.341241-217.794207-47.810207a2.443476 2.443476 0 0 1 0.423724-2.048 2.28811 2.28811 0 0 1 1.836138-0.918069l134.10869 0.141242c22.881103 0.049434 37.386593-10.967393 43.502345-33.050483l0.706207-2.542345c5.981572-21.609931-2.231614-32.414897-24.646621-32.414897-70.338207 0-138.600166 0.755641-204.8 2.259862-52.683034 1.200552-41.736828-103.38869-22.104276-130.224551 8.756966-12.005517 20.691862-11.652414 34.462897-11.511173 233.803917 2.358731 490.277076 2.711834 769.412413 1.059311z m-425.701517 159.955862c-12.288 54.660414 94.137379 47.739586 120.620138 45.056 21.892414-2.189241 47.739586-17.725793 45.338483-42.513655-4.096-42.301793-100.069517-32.838621-128.317793-30.084414-21.46869 2.168055-34.010924 11.348745-37.640828 27.542069z" fill="#FEFEFE" ></path><path d="M892.864441 641.709021c30.183283-0.798014 60.310069-0.868634 90.394483-0.211862 9.18069 0.190676 15.112828 3.65109 17.796414 10.381241 12.852966 32.132414 30.366897 128.882759-27.965793 131.566345-23.064717 1.087559-47.358234 0.875697-72.880552-0.635586l-0.98869-126.057931a8.086069 8.086069 0 0 1 2.118621-5.720276l1.483035-1.836138c2.309297-2.634152 1.765517-4.399669-1.624276-5.296552l-8.333242-2.189241z" fill="#CBCCCE" ></path><path d="M467.162924 801.664883c3.629903-16.193324 16.172138-25.374014 37.640828-27.542069 28.248276-2.754207 124.221793-12.217379 128.317793 30.084414 2.401103 24.787862-23.446069 40.324414-45.338483 42.513655-26.482759 2.683586-132.908138 9.604414-120.620138-45.056z" fill="#343333" ></path><path d="M809.74389 846.4384l112.569379 1.977379a5.367172 5.367172 0 0 1 5.08469 7.062069c-11.0592 33.806124-30.246841 58.382124-57.555862 73.728-15.7696-30.034979-35.80469-57.626483-60.098207-82.767448z" fill="#CBCCCE" ></path></symbol><symbol id="icon-shengdanlihe" viewBox="0 0 1024 1024"><path d="M776.151311 252.860185c9.900927 2.665113 20.344371 4.136689 31.330331 4.407947 80.468768 2.258225 131.736583 3.275444 153.803444 3.051656 34.809219-0.318728 52.461351 16.499285 52.963179 50.45404a1238.212662 1238.212662 0 0 1-4.950464 128.779867c-2.170066 23.735099-37.298013 19.394967-53.641324 18.784636a5.221722 5.221722 0 0 0-5.289537 4.340133 12176.173775 12176.173775 0 0 0-76.766092 493.825695c-2.576954 19.171179-6.672954 36.91147-12.274437 53.234437a14.342781 14.342781 0 0 1-13.562914 9.697483c-218.362914-0.271258-436.705483-0.250914-655.020927 0.067815-23.59947 0-43.33351-5.764238-47.063312-30.652185-26.542623-175.551576-53.397192-350.804768-80.563708-525.766358a4.00106 4.00106 0 0 0-4.068875-3.322914c-17.157086 0.406887-50.793113 5.221722-51.94596-21.090331A4182.002437 4182.002437 0 0 1 5.628609 310.706013c-0.406887-37.298013 21.497219-51.064371 57.303312-50.928741 60.585536 0.135629 120.825219 0.135629 180.725827 0a4.204503 4.204503 0 0 0 3.119471-6.984901 379.551364 379.551364 0 0 1-47.944901-68.357086c-16.004238-29.024636-2.441325-44.282914 16.885828-70.323709 28.848318-38.742464 52.603762-67.387338 71.273112-85.921059 27.261457-27.037669 59.676821-31.126887 97.246093-12.274438 13.067868 6.598358 35.107603 26.447682 66.119205 59.541193a5646.193589 5646.193589 0 0 0 62.050331 65.237615c1.763179 1.851338 3.458543 1.783523 5.086093-0.203443 41.461828-51.084715 81.309669-91.095311 119.557086-120.031788 27.898914-21.110675 54.997616-25.091391 81.309669-11.935365 12.030305 6.015152 27.783629 21.361589 47.266755 46.046093a1771.757351 1771.757351 0 0 0 53.302252 64.356027c15.868609 18.309934 27.736159 34.381987 17.835232 57.099867-13.562914 31.126887-36.687682 51.674702-61.44 73.375364a2.034437 2.034437 0 0 0 0.813774 3.458543z m-325.374304-34.721059l4.340132-1.017219c17.041801-4.157033 19.890013-12.932238 8.544636-26.312053a1202.487947 1202.487947 0 0 0-113.250331-115.962914c-3.980715-3.573828-7.778331-3.390728-11.392848 0.542517l-30.652185 33.364768c-3.797616 4.116344-3.30257 7.663046 1.49192 10.646888 38.383046 23.735099 63.81351 50.182781 100.501192 87.345165 11.297907 11.440318 24.772662 15.237934 40.417484 11.392848z m112.50437-24.616689a14.410596 14.410596 0 0 0 2.034438 17.021457c14.512318 15.258278 32.279735 4.679205 46.45298-7.323973 34.354861-29.248424 67.719629-56.102993 100.094304-80.563709 10.212874-7.730861 11.074119-16.363656 2.576954-25.905166l-14.173245-16.072053c-8.680265-9.812768-18.018331-10.511258-28.007417-2.102251-40.756556 34.246358-84.157881 71.069669-108.978014 114.945695z m184.794702-33.161324l-72.42596 62.050331a1.288477 1.288477 0 0 0-0.135629 1.830993l0.474702 0.542517c2.74649 3.214411 8.815894 3.35004 16.865483 0.386543s17.428344-8.781987 26.06114-16.187338l9.222781-7.934305c8.632795-7.39857 15.827921-15.773669 19.984954-23.280741 4.157033-7.507073 4.950464-13.522225 2.19041-16.729855l-0.406887-0.542516a1.288477 1.288477 0 0 0-1.830994-0.135629z m-400.10596 59.880264l-71.408742-53.980397a1.017219 1.017219 0 0 0-1.424105 0.203444l-0.474702 0.678146c-2.753272 3.628079-1.647894 9.934834 3.072 17.543629 4.713113 7.602013 12.66098 15.882172 22.087205 23.009483l1.966622 1.491921c9.439788 7.140874 19.584848 12.545695 28.197298 15.007364 8.61245 2.46845 14.98702 1.803868 17.713166-1.851338l0.474702-0.678146a1.017219 1.017219 0 0 0-0.203444-1.424106z m202.969007 102.128742a5.560795 5.560795 0 0 0-5.696424-5.628609l-65.169801 1.830993a5.560795 5.560795 0 0 0-5.425166 5.560795l-0.067814 65.101987a5.560795 5.560795 0 0 0 5.560794 5.560794l64.288212-0.135629a5.560795 5.560795 0 0 0 5.560795-5.49298l0.949404-66.797351z m267.189404 73.171921l120.845563 0.74596a5.899868 5.899868 0 0 0 5.967682-5.832053l1.017218-64.084768a1.939497 1.939497 0 0 0-0.576423-1.430888 2.068344 2.068344 0 0 0-1.458014-0.603549l-116.844503 0.203443-197.882914-0.74596a4.068874 4.068874 0 0 0-4.068874 4.00106l-0.678146 64.152583a3.899338 3.899338 0 0 0 1.146066 2.827867c0.74596 0.74596 1.776742 1.173192 2.848212 1.173192l189.677351-0.406887z m-411.620874-65.325775a5.899868 5.899868 0 0 0-5.906649-5.886305l-319.81351 0.55608a5.899868 5.899868 0 0 0-5.893086 5.91343l0.101721 58.727417c0.006781 3.255099 2.65155 5.899868 5.913431 5.886305l319.81351-0.556079a5.899868 5.899868 0 0 0 5.886304-5.913431l-0.101721-58.727417zM230.311841 459.965881l-95.550728 0.203444a2.265007 2.265007 0 0 0-1.763179 0.806993 2.414199 2.414199 0 0 0-0.542517 1.905589l76.020133 484.874172c0.176318 1.308821 0.922278 1.966623 2.23788 1.966623l77.30861 0.610331 117.047947 1.017219a3.187285 3.187285 0 0 0 3.255099-3.187285l0.339073-486.705166a2.848212 2.848212 0 0 0-2.848212-2.848212l-175.504106 1.356292z m318.931921 4.543576a4.475762 4.475762 0 0 0-4.475762-4.475762h-63.881325a4.475762 4.475762 0 0 0-4.475761 4.475762v481.890331c0 2.475232 2.00053 4.475762 4.475761 4.475762h63.881325a4.475762 4.475762 0 0 0 4.475762-4.475762v-481.890331z m156.583841 486.298278l95.957616-0.203444c3.255099-0.04747 5.153907-1.67502 5.696423-4.882649l76.155762-481.754702c0.406887-2.529483-0.657801-3.797616-3.187285-3.797615l-92.499073 0.067814-165.467549-0.610331a3.661987 3.661987 0 0 0-3.661987 3.661987l-3.526358 481.483443a5.086093 5.086093 0 0 0 5.018278 5.153908l85.514173 0.881589z" fill="#343333" ></path><path d="M450.777007 218.139126c-15.644821 3.845086-29.119576 0.04747-40.417484-11.392848-36.687682-37.162384-62.118146-63.610066-100.501192-87.345165-4.79449-2.983841-5.289536-6.530543-1.49192-10.646888l30.652185-33.364768c3.614517-3.933245 7.412132-4.116344 11.392848-0.542517a1202.487947 1202.487947 0 0 1 113.250331 115.962914c11.345377 13.379815 8.497166 22.15502-8.544636 26.312053l-4.340132 1.017219zM563.281377 193.522437c24.820132-43.876026 68.221457-80.699338 108.978014-114.945695 9.989086-8.409007 19.327152-7.710517 28.007417 2.102251l14.173245 16.072053c8.497166 9.54151 7.635921 18.174305-2.576954 25.905166-32.374675 24.460715-65.739444 51.315285-100.094304 80.563709-14.173245 12.003179-31.940662 22.582252-46.45298 7.323973a14.410596 14.410596 0 0 1-2.034438-17.021457zM748.076079 160.361113a1.288477 1.288477 0 0 1 1.830994 0.135629l0.406887 0.542516c2.753272 3.207629 1.966623 9.222781-2.19041 16.729855s-11.352159 15.882172-19.984954 23.280741l-9.222781 7.934305c-8.632795 7.405351-18.01155 13.223841-26.06114 16.187338-8.049589 2.963497-14.118993 2.827868-16.865483-0.386543l-0.474702-0.542517a1.288477 1.288477 0 0 1 0.135629-1.830993l72.42596-62.050331zM347.970119 220.241377a1.017219 1.017219 0 0 1 0.203444 1.424106l-0.474702 0.678146c-2.726146 3.655205-9.100715 4.319788-17.713166 1.851338s-18.75751-7.86649-28.197298-15.007364l-1.966622-1.491921c-9.426225-7.127311-17.374093-15.40747-22.087205-23.009483-4.719894-7.608795-5.832053-13.91555-3.072-17.543629l0.474702-0.678146a1.017219 1.017219 0 0 1 1.424105-0.203444l71.408742 53.980397zM550.939126 322.370119l-0.949404 66.797351a5.560795 5.560795 0 0 1-5.560795 5.49298l-64.288212 0.135629a5.560795 5.560795 0 0 1-5.560794-5.560794l0.067814-65.101987a5.560795 5.560795 0 0 1 5.425166-5.560795l65.169801-1.830993a5.560795 5.560795 0 0 1 5.696424 5.628609z" fill="#FCC556" ></path><path d="M827.080053 324.540185c2.170066 24.596344-0.813775 48.263629-8.951523 71.001855l-189.677351 0.406887a4.034967 4.034967 0 0 1-2.854994-1.173192 3.899338 3.899338 0 0 1-1.152847-2.827867l0.678145-64.152583a4.068874 4.068874 0 0 1 4.068875-4.00106l197.882914 0.74596z" fill="#FF5646" ></path><path d="M74.887368 324.897441m5.899859-0.010297l319.813023-0.55818q5.899859-0.010297 5.910155 5.889561l0.102499 58.727328q0.010297 5.899859-5.889561 5.910156l-319.813023 0.558179q-5.899859 0.010297-5.910156-5.889561l-0.102499-58.727328q-0.010297-5.899859 5.889562-5.910155Z" fill="#FF5646" ></path><path d="M827.080053 324.540185l116.844503-0.203443c0.549298 0 1.078252 0.217007 1.458014 0.603549a1.939497 1.939497 0 0 1 0.576423 1.430888l-1.017218 64.084768a5.899868 5.899868 0 0 1-5.967682 5.832053l-120.845563-0.74596c8.137748-22.738225 11.121589-46.40551 8.951523-71.001855z" fill="#CD4C3D" ></path><path d="M288.02204 950.333033a8990.285987 8990.285987 0 0 1-57.710199-490.367152l175.504106-1.356292a2.848212 2.848212 0 0 1 2.848212 2.848212l-0.339073 486.705166a3.187285 3.187285 0 0 1-3.255099 3.187285l-117.047947-1.017219z" fill="#FF5646" ></path><path d="M230.311841 459.965881a8990.285987 8990.285987 0 0 0 57.710199 490.367152l-77.30861-0.610331c-1.315603 0-2.061563-0.657801-2.23788-1.966623l-76.020133-484.874172a2.414199 2.414199 0 0 1 0.542517-1.905589 2.265007 2.265007 0 0 1 1.763179-0.806993l95.550728-0.203444z" fill="#FBD2BD" ></path><path d="M476.410914 460.033695m4.475761 0l63.881325 0q4.475762 0 4.475762 4.475762l0 481.890331q0 4.475762-4.475762 4.475762l-63.881325 0q-4.475762 0-4.475761-4.475762l0-481.890331q0-4.475762 4.475761-4.475762Z" fill="#FCC556" ></path><path d="M787.951046 460.237139c4.611391 3.390728 5.716768 12.884768 3.322914 28.482119-9.765298 62.748821-20.188397 125.389139-31.262516 187.914172a16493.466278 16493.466278 0 0 0-34.314172 200.052981c-4.340132 26.176424-11.596291 49.57245-19.869669 74.121324l-85.514173-0.881589a5.086093 5.086093 0 0 1-5.018278-5.153908l3.526358-481.483443a3.661987 3.661987 0 0 1 3.661987-3.661987l165.467549 0.610331z" fill="#FF5646" ></path><path d="M787.951046 460.237139l92.499073-0.067814c2.529483 0 3.594172 1.268132 3.187285 3.797615l-76.155762 481.754702c-0.542517 3.207629-2.441325 4.835179-5.696423 4.882649l-95.957616 0.203444c8.273377-24.548874 15.529536-47.944901 19.869669-74.121324 11.026649-66.777007 22.466967-133.459073 34.314172-200.052981 11.074119-62.525033 21.497219-125.165351 31.262516-187.914172 2.393854-15.597351 1.288477-25.091391-3.322914-28.482119z" fill="#CD4C3D" ></path></symbol><symbol id="icon-shengdanmilu" viewBox="0 0 1024 1024"><path d="M163.033196 176.051219a2103.290226 2103.290226 0 0 1-16.116275-32.465276c-14.388284-29.788927-21.468973-61.922568-21.236246-96.406741 0.116363-22.399877 14.138104-55.097878 41.425226-45.43975 12.509022 4.479975 18.501716 18.094446 18.850805 31.883461 1.338174 53.585159 8.14541 96.174015 36.421617 137.715605 2.32726 3.415254 3.723616 3.083619 4.189068-0.989086 4.130886-35.897984 26.4144-110.893934 74.297773-107.868496 15.592641 0.989085 22.458058 21.527154 19.316257 35.083443-0.814541 3.49089-3.764343 9.250858-8.843588 17.279904-26.065311 41.1925-36.828888 86.556614-32.290731 136.086523 0.40727 4.247249-0.698178 13.381744 0.523634 19.607165 0.506179 2.600713 1.669809 2.909075 3.490889 0.930904 28.508934-31.010738 72.66869-79.010474 105.424874-96.34856 11.79339-6.242875 21.003521-3.042892 27.636211 9.599947 9.192677 17.530085 6.632691 33.122727-7.679957 46.777924-30.952557 29.498019-84.886805 63.999647-85.410439 111.999383-0.581815 55.737875 49.047002 98.850364 81.97773 136.610156a9.774492 9.774492 0 0 0 9.541766 3.025438l71.737786-17.047179c1.471992-0.349089 2.193442-1.279993 2.152716-2.792712-0.232726-30.603468-2.32726-56.028782 26.123492-73.366868 6.557055-3.997069 12.509022-2.501804 17.86172 4.479975 15.301734 19.839891 16.116275 43.985212 15.94173 67.6069a5.0327 5.0327 0 0 0 3.665434 4.945427l65.803274 18.61808a4.218159 4.218159 0 0 0 4.770883-1.91999 246.904821 246.904821 0 0 1 32.290731-43.51976c26.356218-28.450752 67.6069-80.232285 47.592465-116.94481-20.247161-37.119795-55.796056-67.025085-87.563154-94.137663-4.65452-3.997069-9.210131-10.431943-13.672652-19.316257a8.820315 8.820315 0 0 1-0.698178-5.643605c3.217437-15.94173 12.584658-26.606399 28.101664-31.999824 2.018898-0.698178 3.997069-0.599269 5.934512 0.290907a102.16671 102.16671 0 0 1 31.010739 21.992607 1162.757228 1162.757228 0 0 0 79.534107 74.646861 2.967256 2.967256 0 0 0 4.945427-2.094534c2.618167-50.443358 0.058181-101.177624-29.439838-146.908281-12.625385-19.607165-21.992606-39.039785 1.338175-53.526978 44.916116-27.927119 76.392306 74.530498 81.745004 100.24672 1.122903 5.428334 2.89162 5.643605 5.294516 0.639997 20.75334-43.479033 31.63328-89.931141 32.63982-139.344687 0.581815-29.14893 36.363436-37.236158 50.966992-12.45084 15.185371 25.716222 1.861808 88.726784-7.38905 113.803009-2.519259 6.906144-9.55922 22.591875-21.119884 47.068831a1.687263 1.687263 0 0 0 2.501805 2.152716c23.272599-15.418097 88.261332-53.934248 111.243023-22.981692 15.127189 20.305343-0.814541 42.996127-22.51624 50.850629-60.508757 21.934425-112.872105 38.86524-166.864535 81.163189a6.458146 6.458146 0 0 0-2.385441 3.781797l-19.43262 81.686823a2.443623 2.443623 0 0 0 3.49089 2.792712c18.850805-9.15195 37.70161-18.367899 56.552415-27.636212 29.788927-14.603556 40.436141-30.487105 58.996039-52.537892 18.385353-21.876243 39.097966 10.763577 35.025261 29.14893-9.949036 45.090661-52.188803 71.039608-90.53041 86.399524-60.62512 24.261684-116.479358 37.992518-148.944634 101.526713-0.930904 1.861808-0.890177 3.723616 0.116363 5.585424a55.167696 55.167696 0 0 0 12.683567 15.12719c1.786172 1.512719 3.450163 1.396356 5.003609-0.349089 27.653666-29.980926 60.799665-51.333535 99.432179-64.057829 57.89059-19.141713 136.784701-24.436229 193.10439 2.73453 14.37083 6.923598 0.989085 42.065223-3.839979 52.945163-36.113256 82.542091-103.231431 129.529468-201.366163 140.973768-3.298891 0.389816-4.578884 2.193442-3.839978 5.41088 15.749731 68.578531 8.826133 132.962176-20.770795 193.162571-105.6576 215.038815-411.226824 209.627936-511.589908-6.807235-27.461667-59.188037-33.80345-123.420411-19.025349-192.69712 0.465452-2.251624-0.447998-3.49089-2.734531-3.723615-83.839538-7.621776-162.38456-55.15606-194.617109-135.853797-4.712701-11.810844-17.279905-50.210632 1.279993-56.145145 77.206847-24.49441 163.839097-19.548983 234.820524 20.770794 17.221723 9.774492 33.687087 24.668955 49.570636 37.934337a9.367221 9.367221 0 0 0 8.901769 1.687263c6.091603-1.978171 9.30904-6.731599 9.658129-14.254467 1.221811-24.261684-26.298037-51.141536-44.857935-63.301469-8.104683-5.277062-23.970777-11.944661-47.592465-20.014435-43.51976-14.836282-127.301117-44.159757-139.86832-95.650382-3.141801-12.724294-1.41381-24.651501 5.178153-35.781621 17.512631-29.614382 45.148842 15.825367 55.679693 29.207112 18.967168 24.203503 70.050523 38.574333 100.537628 44.217938a2.385441 2.385441 0 0 0 2.385441-3.665434c-16.366455-24.279139-26.687853-51.624443-30.952556-82.035912-0.930904-6.458146-5.294516-11.170848-10.298125-14.196285-44.567027-26.647126-98.152186-44.159757-146.8501-61.788751-14.079922-5.119972-28.392571-12.625385-33.80345-27.228941-7.621776-20.479887 8.14541-44.567027 32.407094-39.039784a297.394725 297.394725 0 0 1 81.221371 31.767097c2.519259 1.471992 3.124346 0.91345 1.803626-1.687263z m114.326643 388.768766c-50.966992-45.905202-112.581198-62.486928-182.457177-53.759703-1.902535 0.232726-2.559986 1.279993-1.978171 3.1418 18.559898 55.912419 103.155795 88.901328 157.031862 93.206759a7.796321 7.796321 0 0 0 6.98178-3.258163l21.410791-30.312561a6.865417 6.865417 0 0 0-0.989085-9.018132z m567.618689 23.970777c39.639054-12.142479 68.962529-36.555435 87.970425-73.250505a3.723616 3.723616 0 0 0-3.258164-5.410879c-73.075961-0.349089-126.312031 6.749054-182.689902 55.097878a8.290863 8.290863 0 0 0-1.396356 10.996303c4.962882 7.022507 10.199217 14.446466 15.709004 22.283513 2.17017 3.066165 4.439248 4.788337 6.807235 5.178154 2.48435 0.389816 5.544697 0.273453 9.192677-0.349089 32.38964-5.777423 54.940788-10.62976 67.665081-14.545375z m-344.434465-66.210544c-31.575099 3.141801-57.349502 8.279227-77.32321 15.418097-190.195315 68.130534-185.424433 326.281838-8.959951 405.641401 20.520614 8.959951 41.675407 14.271921 63.476014 15.94173 2.135261 0.191999 3.3338-0.773814 3.607253-2.909075 1.937444-14.737373-2.792712-26.222401-14.196285-34.443446a9.30904 9.30904 0 0 1-3.199983-11.170848c14.004286-33.977995 38.167062-43.595396 72.494146-28.858023 14.312648 6.126512 20.380979 17.86172 18.210809 35.199806a7.621776 7.621776 0 0 1-2.152716 4.363613c-10.065399 9.890855-37.177977 24.843499-10.87994 39.039784 53.061526-6.324329 97.529644-29.690018 133.410174-70.108704 43.444124-48.988821 62.137839-107.2285 56.086964-174.719037-2.635622-29.364202-10.065399-53.83534-22.283514-73.42505-22.417331-43.51976-54.24261-75.59522-95.475837-96.232197-22.92351-11.461755-64.290555-23.796232-88.20315-27.228941-12.991928-1.861808-21.19552-0.698178-24.610774 3.49089z" fill="#343333" ></path><path d="M94.902662 511.060282c69.875979-8.727225 131.490184 7.854502 182.457177 53.759703 2.54835 2.32726 2.973075 6.190511 0.989085 9.018132l-21.410791 30.312561a7.796321 7.796321 0 0 1-6.98178 3.258163c-53.876067-4.305431-138.471964-37.29434-157.031862-93.206759-0.581815-1.861808 0.075636-2.909075 1.978171-3.1418zM844.978528 588.790762c-12.724294 3.915615-35.275442 8.767952-67.665081 14.545375-3.64798 0.622542-6.708327 0.738905-9.192677 0.349089-2.367987-0.389816-4.637065-2.111988-6.807235-5.178154-5.509788-7.837048-10.746123-15.261007-15.709004-22.283513a8.290863 8.290863 0 0 1 1.396356-10.996303c56.377871-48.348824 109.613941-55.446967 182.689902-55.097878a3.723616 3.723616 0 0 1 3.258164 5.410879c-19.007895 36.69507-48.33137 61.108027-87.970425 73.250505zM708.833824 642.550466c0.971631 5.311971-1.16363 8.727225-6.399964 10.239944-21.818062 6.22542-59.46149-47.534283-77.788663-14.894464a13.090837 13.090837 0 0 0 1.978171 15.418097c9.192677 9.483584 20.305343 15.709004 28.043482 26.181674 30.719831 41.367045 39.505237 84.130445 15.94173 131.490184-24.145321 48.697913-58.588768 96.464923-102.166709 129.337469-9.268313 6.98178-18.210809 13.806469-26.821671 20.479887-26.298037-14.196285 0.814541-29.14893 10.87994-39.039784a7.621776 7.621776 0 0 0 2.152716-4.363613c2.17017-17.338086-3.89816-29.073294-18.210809-35.199806-34.327084-14.737373-58.489859-5.119972-72.494146 28.858023a9.30904 9.30904 0 0 0 3.199983 11.170848c11.403574 8.221046 16.133729 19.706073 14.196285 34.443446-0.273453 2.135261-1.471992 3.101074-3.607253 2.909075-21.800607-1.669809-42.9554-6.98178-63.476014-15.94173 3.531617 0.657451 6.126512 0.191999 7.796321-1.396356 1.512719-1.471992 1.821081-3.159255 0.930904-5.061791a302.514696 302.514696 0 0 1-27.112578-97.570371c-0.890177-8.686498-7.429777-18.327172-19.607165-28.916204 79.65047 8.669043 63.185106-116.072088-13.730833-92.566763-16.250092 5.003609-24.959862 17.204269-26.123492 36.596162-15.901003-38.632514-13.713379-75.810491 6.574509-111.533931 26.938033-47.476102 69.759616-71.272334 119.737522-95.243111 6.242875-3.025438 18.850805-11.479209 37.817973-25.367133 3.415254-4.189068 11.618845-5.352698 24.610774-3.49089 23.912595 3.432708 65.27964 15.767186 88.20315 27.228941 41.233227 20.636977 73.058506 52.712437 95.475837 96.232197z m-81.279552 164.863091c22.714057 1.710536 42.79831-19.089349 44.857935-46.452107 0.989085-13.1432-2.397078-26.071129-9.413766-35.944529-7.016689-9.8734-17.087906-15.877731-27.996937-16.69809-22.714057-1.710536-42.79831 19.089349-44.857935 46.452107-0.989085 13.1432 2.397078 26.071129 9.413767 35.94453 7.016689 9.8734 17.082088 15.877731 27.996936 16.698089z" fill="#CA9F54" ></path><path d="M500.544063 522.580218c-18.967168 13.887923-31.575099 22.341695-37.817973 25.367133-49.977906 23.970777-92.799489 47.767009-119.737522 95.243111-20.287888 35.723439-22.475512 72.901416-6.574509 111.533931 6.475601 26.647126 19.764255 45.305932 39.854325 55.970601 12.177387 10.589033 18.716988 20.229707 19.607165 28.916204a302.514696 302.514696 0 0 0 27.112578 97.570371c0.890177 1.902535 0.581815 3.589798-0.930904 5.061791-1.669809 1.588355-4.264704 2.053807-7.796321 1.396356-176.464482-79.359563-181.235365-337.510867 8.959951-405.641401 19.973708-7.13887 45.748112-12.276296 77.32321-15.418097z" fill="#E4D1A8" ></path><path d="M708.833824 642.550466c12.218114 19.58971 19.647892 44.060848 22.283514 73.42505 6.050876 67.490537-12.642839 125.730216-56.086964 174.719037-35.88053 40.418686-80.348648 63.784376-133.410174 70.108704 8.610862-6.673418 17.553358-13.498107 26.821671-20.479887 43.577942-32.872546 78.021388-80.639556 102.166709-129.337469 23.563506-47.359739 14.7781-90.12314-15.94173-131.490184-7.738139-10.47267-18.850805-16.69809-28.043482-26.181674a13.090837 13.090837 0 0 1-1.978171-15.418097c18.327172-32.63982 55.970601 21.119884 77.788663 14.894464 5.236335-1.512719 7.371596-4.927973 6.399964-10.239944z" fill="#AC884A" ></path><path d="M635.003356 708.319057a41.250682 49.686999 4.3 1 0-7.450936 99.094274 41.250682 49.686999 4.3 1 0 7.450936-99.094274Z" fill="#343333" ></path><path d="M376.268384 810.694994c-20.090071-10.664668-33.378725-29.323475-39.854325-55.970601 1.16363-19.391893 9.8734-31.592553 26.123492-36.596162 76.91594-23.505325 93.381304 101.235806 13.730833 92.566763z" fill="#343333" ></path></symbol><symbol id="icon-xing" viewBox="0 0 1024 1024"><path d="M419.264 900.618667l60.373333-211.68a10.666667 10.666667 0 0 1 4.416-6.005334l31.338667-20.501333a10.666667 10.666667 0 0 1 16.490667 9.386667l-10.56 239.946666a10.421333 10.421333 0 0 1-9.482667 9.994667c-43.093333 3.594667-72.970667-3.605333-87.690667-9.898667-4.341333-1.845333-6.176-6.709333-4.885333-11.242666z" fill="#CD9220" ></path><path d="M483.84 682.613333l-11.466667-17.525333 31.338667-20.512 11.68 17.856-31.338667 20.501333a10.666667 10.666667 0 0 0-4.416 6.005334l-60.373333 211.68c-1.28 4.533333 0.554667 9.386667 4.885333 11.242666l-8.384 19.626667c-15.893333-6.794667-20.725333-23.701333-17.013333-36.714667l60.373333-211.690666a32 32 0 0 1 13.248-17.994667l11.466667 17.525333z m-59.690667 229.248l-8.384 19.626667c18.346667 7.829333 51.754667 15.370667 97.856 11.52 16.298667-1.354667 28.32-14.72 29.013334-30.304l10.56-239.946667c1.152-26.048-27.669333-42.453333-49.493334-28.181333l11.690667 17.856a10.666667 10.666667 0 0 1 16.490667 9.386667l-10.56 239.946666a10.421333 10.421333 0 0 1-9.482667 9.994667c-43.093333 3.594667-72.970667-3.605333-87.690667-9.898667z" fill="#915117" ></path><path d="M478.730667 922.496c9.973333 0.426667 21.013333 0.266667 33.12-0.746667a10.421333 10.421333 0 0 0 9.472-9.984l10.56-239.946666a10.666667 10.666667 0 0 0-16.490667-9.386667l-6.037333 3.946667c0.832 1.578667 1.28 3.424 1.194666 5.44l-10.56 239.946666a10.421333 10.421333 0 0 1-9.482666 9.994667c-4.042667 0.330667-7.968 0.576-11.776 0.736z" fill="#BA8111" ></path><path d="M458.218667 764.010667l2.453333-0.010667c23.466667 0 45.941333 4.053333 66.645333 11.445333l4.565334-103.626666a10.666667 10.666667 0 0 0-16.490667-9.386667l-31.338667 20.501333a10.666667 10.666667 0 0 0-4.416 6.005334l-21.418666 75.072z" fill="#995E05" ></path><path d="M195.605333 352.725333l201.472-21.813333a10.666667 10.666667 0 0 0 7.498667-4.352l74.08-102.314667 66.304-91.562666a10.666667 10.666667 0 0 1 18.272 1.685333l102.506667 216.32a10.666667 10.666667 0 0 0 6.56 5.642667l194.069333 58.346666a10.666667 10.666667 0 0 1 3.797333 18.378667l-174.506666 146.954667a10.666667 10.666667 0 0 0-3.733334 9.258666l20.757334 201.301334a10.666667 10.666667 0 0 1-16.288 10.122666l-188.16-118.250666a10.666667 10.666667 0 0 0-9.6-0.885334l-206.634667 81.781334a10.666667 10.666667 0 0 1-14.154667-12.938667l57.28-194.090667a10.666667 10.666667 0 0 0-1.984-9.781333l-144.64-176.437333a10.666667 10.666667 0 0 1 7.104-17.365334z" fill="#FFE24B" ></path><path d="M390.08 310.208l137.6-190.037333c14.261333-19.701333 44.416-16.917333 54.826667 5.066666l100.48 212.021334 189.525333 56.992c24.352 7.317333 30.848 38.741333 11.402667 55.125333L713.706667 592.693333l20.181333 195.690667c2.741333 26.528-26.272 44.565333-48.853333 30.368l11.349333-18.058667a10.666667 10.666667 0 0 0 16.288-10.133333l-20.757333-201.290667a10.666667 10.666667 0 0 1 3.733333-9.258666L870.165333 433.066667a10.666667 10.666667 0 0 0-3.797333-18.378667l-194.069333-58.346667a10.666667 10.666667 0 0 1-6.570667-5.653333l-102.496-216.309333a10.666667 10.666667 0 0 0-18.272-1.685334L404.576 326.56a10.666667 10.666667 0 0 1-7.498667 4.352l-201.472 21.813333a10.666667 10.666667 0 0 0-7.104 17.365334l144.64 176.437333a10.666667 10.666667 0 0 1 1.984 9.781333l-57.28 194.090667a10.666667 10.666667 0 0 0 14.154667 12.938667l7.850667 19.84c-24.8 9.813333-50.016-13.226667-42.464-38.816l55.68-188.672-141.056-172.074667c-16.128-19.669333-3.978667-49.365333 21.301333-52.106667l196.757333-21.301333z m111.381333 393.173333l183.573334 115.370667 11.36-18.058667-188.16-118.250666a10.666667 10.666667 0 0 0-9.6-0.885334l-206.634667 81.781334 7.850667 19.84 201.6-79.786667z" fill="#D97D11" ></path><path d="M311.936 395.808l113.706667-12.309333a10.666667 10.666667 0 0 0 7.498666-4.352l44.213334-61.056 36.416-50.304a10.666667 10.666667 0 0 1 18.282666 1.685333l58.869334 124.245333a10.666667 10.666667 0 0 0 6.570666 5.653334l109.536 32.928a10.666667 10.666667 0 0 1 3.797334 18.378666l-99.136 83.488a10.666667 10.666667 0 0 0-3.733334 9.258667l11.584 112.405333a10.666667 10.666667 0 0 1-16.288 10.133334l-106.037333-66.645334a10.666667 10.666667 0 0 0-9.6-0.885333l-116.458667 46.08a10.666667 10.666667 0 0 1-14.165333-12.928l32-108.384a10.666667 10.666667 0 0 0-1.994667-9.781333l-82.165333-100.245334a10.666667 10.666667 0 0 1 7.104-17.365333z" fill="#F6D737" ></path><path d="M359.701333 406.506667l75.690667-8.192a10.666667 10.666667 0 0 0 7.488-4.352l31.253333-43.168 23.477334-32.426667a10.666667 10.666667 0 0 1 18.282666 1.696l39.957334 84.341333a10.666667 10.666667 0 0 0 6.570666 5.653334l72.906667 21.909333a10.666667 10.666667 0 0 1 3.797333 18.368l-66.474666 55.989333a10.666667 10.666667 0 0 0-3.733334 9.248l7.616 73.898667a10.666667 10.666667 0 0 1-16.288 10.122667l-70.464-44.277334a10.666667 10.666667 0 0 0-9.6-0.885333l-77.365333 30.613333a10.666667 10.666667 0 0 1-14.154667-12.928l21.013334-71.253333a10.666667 10.666667 0 0 0-1.973334-9.770667l-55.104-67.221333a10.666667 10.666667 0 0 1 7.104-17.365333z" fill="#FFE24B" ></path><path d="M287.978667 716.053333l-10.133334 34.346667a10.666667 10.666667 0 0 0 14.154667 12.938667l206.634667-81.781334a10.666667 10.666667 0 0 1 9.6 0.885334l188.16 118.250666a10.666667 10.666667 0 0 0 16.288-10.133333l-20.757334-201.290667a10.666667 10.666667 0 0 1 3.733334-9.258666L870.165333 433.066667a10.666667 10.666667 0 0 0-3.797333-18.378667l-40.565333-12.192-172.8 145.525333a10.666667 10.666667 0 0 0-3.754667 9.258667l20.768 201.301333a10.666667 10.666667 0 0 1-16.288 10.122667l-188.16-118.250667a10.666667 10.666667 0 0 0-9.6-0.885333L287.989333 716.053333zM657.173333 332.597333l-93.930666-198.24a10.666667 10.666667 0 0 0-18.272-1.685333l-6.069334 8.362667 84.170667 177.632a10.666667 10.666667 0 0 0 6.570667 5.653333l27.530666 8.277333z" fill="#E3C731" ></path><path d="M475.733333 268.8a10.666667 10.666667 0 0 1 2.133334 14.933333l-64 85.333334a10.666667 10.666667 0 0 1-7.573334 4.224l-58.666666 5.333333a10.666667 10.666667 0 0 1-1.92-21.248l53.941333-4.906667L460.8 270.933333a10.666667 10.666667 0 0 1 14.933333-2.133333z" fill="#FFF9D8" ></path><path d="M661.333333 682.666667a10.666667 10.666667 0 1 1-21.333333 0 10.666667 10.666667 0 0 1 21.333333 0zM672 640a10.666667 10.666667 0 1 1-21.333333 0 10.666667 10.666667 0 0 1 21.333333 0zM682.666667 554.666667a10.666667 10.666667 0 1 1-21.333334 0 10.666667 10.666667 0 0 1 21.333334 0zM633.002667 550.165333a6.165333 6.165333 0 1 1-12.341334 0 6.165333 6.165333 0 0 1 12.341334 0zM682.666667 514.837333a6.165333 6.165333 0 1 1-12.330667 0 6.165333 6.165333 0 0 1 12.330667 0zM658.005333 589.504a10.165333 10.165333 0 1 1-20.341333 0 10.165333 10.165333 0 0 1 20.341333 0zM769.002667 461.141333a6.165333 6.165333 0 1 1-12.341334 0 6.165333 6.165333 0 0 1 12.341334 0zM817.002667 459.146667a6.165333 6.165333 0 1 1-12.341334 0 6.165333 6.165333 0 0 1 12.341334 0zM773.002667 489.834667a8.170667 8.170667 0 1 1-16.341334 0 8.170667 8.170667 0 0 1 16.341334 0zM684.330667 608A6.165333 6.165333 0 1 1 672 608a6.165333 6.165333 0 0 1 12.330667 0zM630.997333 627.669333a6.165333 6.165333 0 1 1-12.330666 0 6.165333 6.165333 0 0 1 12.330666 0zM692.672 716.672a6.165333 6.165333 0 1 1-12.341333 0 6.165333 6.165333 0 0 1 12.341333 0zM620.672 592a12.672 12.672 0 1 1-25.344 0 12.672 12.672 0 0 1 25.344 0zM736 517.333333a16 16 0 1 1-32 0 16 16 0 0 1 32 0z" fill="#DBA416" ></path></symbol><symbol id="icon-xiaxue" viewBox="0 0 1024 1024"><path d="M853.333333 464.138667c0-71.253333-60.650667-129.013333-135.466666-129.013334 0-106.88-90.976-193.525333-203.2-193.525333-89.045333 0-164.714667 54.549333-192.170667 130.464-82.72 10.624-146.496 78.133333-146.496 159.818667 0 89.066667 75.818667 161.28 169.333333 161.28H717.866667c74.816 0 135.466667-57.770667 135.466666-129.024z" fill="#D3F2FF" ></path><path d="M738.24 315.050667C814.474667 324.586667 874.666667 386.901333 874.666667 464.138667c0 84-71.189333 150.346667-156.8 150.346666H345.333333c-104.309333 0-190.666667-80.778667-190.666666-182.602666 0-89.056 66.154667-162.090667 152.469333-178.933334 33.888-78.293333 114.4-132.693333 207.530667-132.693333 116.053333 0 212.970667 84.757333 223.573333 194.794667z m-20.373333 20.074666c74.816 0 135.466667 57.76 135.466666 129.013334 0 71.253333-60.650667 129.013333-135.466666 129.013333H345.333333c-93.514667 0-169.333333-72.202667-169.333333-161.269333 0-81.685333 63.776-149.194667 146.496-159.808 27.456-75.925333 103.125333-130.474667 192.170667-130.474667 112.224 0 203.2 86.645333 203.2 193.525333z" fill="#68B9DC" ></path><path d="M778.666667 348.810667c26.261333 23.530667 42.666667 56.938667 42.666666 93.994666 0 71.253333-60.650667 129.013333-135.466666 129.013334H313.333333c-29.077333 0-56.448-6.976-80.362666-19.274667 29.898667 25.269333 69.248 40.608 112.362666 40.608H717.866667c74.816 0 135.466667-57.76 135.466666-129.013333 0-50.432-30.378667-94.101333-74.666666-115.328z m-61.653334-31.594667c-6.24-64.725333-45.941333-120.224-102.485333-150.677333 43.658667 35.498667 71.338667 88.298667 71.338667 147.253333 10.72 0 21.141333 1.173333 31.146666 3.413333z" fill="#AAE0F8" ></path><path d="M347.989333 729.322667a47.274667 47.274667 0 1 1-94.549333 0 47.274667 47.274667 0 0 1 94.549333 0z" fill="#D3F2FF" ></path><path d="M369.322667 729.322667a68.608 68.608 0 1 1-137.216 0 68.608 68.608 0 0 1 137.216 0z m-68.608 47.274666a47.274667 47.274667 0 1 0 0-94.549333 47.274667 47.274667 0 0 0 0 94.549333z" fill="#68B9DC" ></path><path d="M446.762667 881.728a38.805333 38.805333 0 1 1-77.610667 0 38.805333 38.805333 0 0 1 77.610667 0z" fill="#D3F2FF" ></path><path d="M468.096 881.728a60.138667 60.138667 0 1 1-120.277333 0 60.138667 60.138667 0 0 1 120.277333 0zM407.957333 920.533333a38.805333 38.805333 0 1 0 0-77.610666 38.805333 38.805333 0 0 0 0 77.610666z" fill="#68B9DC" ></path><path d="M611.872 748.373333a60.682667 60.682667 0 1 1-121.365333 0 60.682667 60.682667 0 0 1 121.365333 0z" fill="#D3F2FF" ></path><path d="M633.205333 748.373333a82.016 82.016 0 1 1-164.032 0 82.016 82.016 0 0 1 164.032 0z m-82.016 60.682667a60.682667 60.682667 0 1 0 0-121.354667 60.682667 60.682667 0 0 0 0 121.354667z" fill="#68B9DC" ></path><path d="M775.552 786.474667a38.805333 38.805333 0 1 1-77.610667 0 38.805333 38.805333 0 0 1 77.610667 0z" fill="#D3F2FF" ></path><path d="M796.885333 786.474667a60.138667 60.138667 0 1 1-120.277333 0 60.138667 60.138667 0 0 1 120.277333 0zM736.746667 825.28a38.805333 38.805333 0 1 0 0-77.610667 38.805333 38.805333 0 0 0 0 77.610667z" fill="#68B9DC" ></path><path d="M556.298667 726.858667a20.810667 20.810667 0 1 1-41.632 0 20.810667 20.810667 0 0 1 41.632 0zM300.714667 715.584a13.738667 13.738667 0 1 1-27.477334 0 13.738667 13.738667 0 0 1 27.477334 0zM407.957333 872.917333a13.738667 13.738667 0 1 1-27.477333 0 13.738667 13.738667 0 0 1 27.477333 0zM743.072 776.597333a13.738667 13.738667 0 1 1-27.477333 0 13.738667 13.738667 0 0 1 27.477333 0z" fill="#EDFAFF" ></path><path d="M464 416a101.333333 101.333333 0 1 0-100.778667-90.656A100.906667 100.906667 0 0 0 330.666667 320c-53.013333 0-96 40.597333-96 90.666667s42.986667 90.666667 96 90.666666 96-40.597333 96-90.666666c0-0.597333 0-1.173333-0.021334-1.770667A101.066667 101.066667 0 0 0 464 416z" fill="#EDFAFF" ></path><path d="M789.333333 522.666667a10.666667 10.666667 0 1 1-21.333333 0 10.666667 10.666667 0 0 1 21.333333 0zM757.333333 554.666667a10.666667 10.666667 0 1 1-21.333333 0 10.666667 10.666667 0 0 1 21.333333 0zM649.333333 565.333333a10.666667 10.666667 0 1 1-21.333333 0 10.666667 10.666667 0 0 1 21.333333 0zM789.333333 453.333333a16 16 0 1 1-32 0 16 16 0 0 1 32 0zM832 480a10.666667 10.666667 0 1 1-21.333333 0 10.666667 10.666667 0 0 1 21.333333 0zM675.338667 504.330667a7.669333 7.669333 0 1 1-15.338667 0 7.669333 7.669333 0 0 1 15.338667 0zM729.333333 461.664a7.669333 7.669333 0 1 1-15.338666 0 7.669333 7.669333 0 0 1 15.338666 0zM832 437.333333a7.669333 7.669333 0 1 1-15.338667 0A7.669333 7.669333 0 0 1 832 437.333333zM621.333333 537.002667a7.669333 7.669333 0 1 1-15.338666 0 7.669333 7.669333 0 0 1 15.338666 0zM586.666667 562.336a7.669333 7.669333 0 1 1-15.338667 0 7.669333 7.669333 0 0 1 15.338667 0zM789.333333 398.666667a7.669333 7.669333 0 1 1-15.338666 0 7.669333 7.669333 0 0 1 15.338666 0zM704 549.333333a16 16 0 1 1-32 0 16 16 0 0 1 32 0zM748.672 510.005333a19.338667 19.338667 0 1 1-38.677333 0 19.338667 19.338667 0 0 1 38.677333 0z" fill="#75CEF3" ></path></symbol><symbol id="icon-xingxing" viewBox="0 0 1024 1024"><path d="M117.557333 745.482667C250.88 444.352 506.666667 356.458667 619.52 326.858667a10.421333 10.421333 0 0 1 1.504-0.277334c84.181333-9.322667 89.6 11.093333 75.04 36.768a10.122667 10.122667 0 0 1-3.008 3.274667C549.952 467.733333 413.024 765.077333 351.765333 928.362667c-3.658667 9.749333-16.992 9.045333-18.826666-1.205334-12.64-70.570667-17.514667-180.16-12.736-242.282666 0.554667-7.104-5.653333-12.949333-12.554667-11.093334-52.842667 14.208-127.274667 58.24-176.469333 84.501334a9.781333 9.781333 0 0 1-13.621334-12.8z" fill="#F6BF34" ></path><path d="M98.048 736.853333c137.237333-310.016 400.885333-400.426667 516.053333-430.634666 1.6-0.426667 3.125333-0.682667 4.576-0.853334 21.76-2.4 39.381333-3.008 53.397334-1.845333 13.546667 1.130667 26.208 4.074667 35.861333 10.933333 11.221333 7.978667 16.213333 19.701333 15.701333 31.893334-0.437333 10.464-4.810667 20.117333-9.024 27.52l-18.56-10.517334c14.581333-25.674667 9.152-46.090667-75.029333-36.768a10.378667 10.378667 0 0 0-1.493333 0.277334C506.666667 356.458667 250.858667 444.341333 117.546667 745.482667a9.781333 9.781333 0 0 0 13.621333 12.8l10.048 18.816c-27.008 14.421333-55.061333-13.397333-43.178667-40.256zM331.84 920.746667c-11.818667-70.645333-16.266667-175.605333-11.626667-235.882667 0.554667-7.104-5.653333-12.949333-12.544-11.093333-43.370667 11.658667-101.258667 43.392-147.818666 68.917333-10.186667 5.589333-19.84 10.88-28.661334 15.584l10.048 18.816c9.248-4.928 19.082667-10.325333 29.354667-15.957333 17.962667-9.856 37.28-20.437333 57.184-30.645334 24.917333-12.757333 49.162667-24.042667 70.186667-31.370666-3.114667 65.28 2.048 165.12 13.984 231.786666a30.666667 30.666667 0 0 0 28.48 25.642667 31.445333 31.445333 0 0 0 31.317333-20.693333c30.357333-80.906667 79.477333-195.061333 138.624-301.312 59.605333-107.061333 127.68-202.922667 195.008-250.496 3.584-2.538667 6.826667-5.909333 9.248-10.176l-18.56-10.528a10.122667 10.122667 0 0 1-2.986667 3.274666c-141.514667 99.978667-276.992 391.84-339.221333 556.224l-0.010667 0.032-0.213333 0.576c-0.64 1.642667-1.248 3.285333-1.856 4.906667-3.658667 9.749333-16.992 9.045333-18.826667-1.205333a573.002667 573.002667 0 0 1-1.088-6.261334l-0.021333-0.138666z" fill="#D97D11" ></path><path d="M627.264 352.533333a16 16 0 0 1-10.474667 20.064c-177.6 55.744-298.986667 199.210667-364.266666 281.354667a16 16 0 0 1-25.045334-19.904c65.386667-82.304 192-233.066667 379.733334-291.978667a16 16 0 0 1 20.053333 10.474667z" fill="#ECAF11" ></path><path d="M647.648 335.690667a16 16 0 0 1-0.672 22.613333C510.4 487.008 415.701333 659.381333 379.093333 763.968a16 16 0 0 1-30.208-10.581333c38.069333-108.746667 135.36-285.706667 276.128-418.346667a16 16 0 0 1 22.613334 0.661333z" fill="#ECAF11" ></path><path d="M427.978667 402.752c50.762667 29.12 93.514667 71.253333 124.032 122.016 44.48-66.741333 92.405333-123.776 141.045333-158.144a10.122667 10.122667 0 0 0 3.008-3.274667c14.56-25.674667 9.141333-46.08-75.04-36.768a10.432 10.432 0 0 0-1.504 0.277334c-46.058667 12.074667-115.914667 33.866667-191.541333 75.893333z" fill="#DA8D19" ></path><path d="M490.645333 293.728l86.506667-49.76a21.333333 21.333333 0 0 0 10.208-13.984l16.106667-74.613333 10.496-48.661334c3.424-15.850667 22.581333-22.24 34.826666-11.626666l95.296 82.613333a21.333333 21.333333 0 0 0 16.576 5.056l99.04-12.16c16.832-2.058667 29.226667 15.381333 21.749334 30.592l-50.837334 103.445333a21.333333 21.333333 0 0 0 0.597334 19.946667l47.178666 82.986667c8.778667 15.466667-4.085333 34.250667-21.674666 31.648l-107.616-15.925334a21.333333 21.333333 0 0 0-18.293334 6.101334l-76.490666 77.354666c-12.501333 12.64-34.08 5.333333-36.330667-12.298666l-12.106667-94.688a21.333333 21.333333 0 0 0-11.498666-16.32l-102.762667-52.192c-15.114667-7.68-15.669333-29.066667-0.970667-37.514667z" fill="#FFE24B" ></path><path d="M480 275.232l86.506667-49.749333 26.613333-123.274667c6.826667-31.701333 45.141333-44.48 69.653333-23.232l95.285334 82.602667 99.050666-12.16c33.642667-4.117333 58.432 30.752 43.488 61.173333l-50.837333 103.445333 47.168 82.986667c17.578667 30.912-8.16 68.501333-43.338667 63.296L745.973333 444.373333l-76.48 77.354667c-25.013333 25.28-68.16 10.688-72.672-24.586667l-12.106666-94.688-102.762667-52.202666c-30.218667-15.36-31.328-58.133333-1.941333-75.029334z m97.141333-31.253333l-86.506666 49.749333c-14.688 8.448-14.133333 29.834667 0.981333 37.514667l102.762667 52.202666a21.333333 21.333333 0 0 1 11.498666 16.32l12.106667 94.677334c2.250667 17.642667 23.829333 24.938667 36.330667 12.298666l76.490666-77.354666a21.333333 21.333333 0 0 1 18.293334-6.101334l107.616 15.925334c17.589333 2.602667 30.453333-16.192 21.674666-31.648l-47.178666-82.986667a21.333333 21.333333 0 0 1-0.597334-19.946667l50.837334-103.445333c7.466667-15.210667-4.917333-32.64-21.749334-30.581333l-99.04 12.149333a21.333333 21.333333 0 0 1-16.576-5.056l-95.296-82.602667c-12.245333-10.624-31.402667-4.234667-34.826666 11.626667L587.36 229.973333a21.333333 21.333333 0 0 1-10.218667 13.984z" fill="#D97D11" ></path><path d="M592.746667 288.896l48.224-27.733333a10.666667 10.666667 0 0 0 5.109333-6.997334l8.746667-40.544 5.952-27.573333a10.666667 10.666667 0 0 1 17.418666-5.802667l52.650667 45.642667a10.666667 10.666667 0 0 0 8.288 2.528l55.221333-6.773333a10.666667 10.666667 0 0 1 10.869334 15.285333L776.981333 294.4a10.666667 10.666667 0 0 0 0.298667 9.973333l26.453333 46.549334a10.666667 10.666667 0 0 1-10.826666 15.818666l-60.053334-8.885333a10.666667 10.666667 0 0 0-9.141333 3.050667l-42.677333 43.168a10.666667 10.666667 0 0 1-18.165334-6.154667l-6.794666-53.109333a10.666667 10.666667 0 0 0-5.749334-8.149334l-57.088-29.013333a10.666667 10.666667 0 0 1-0.490666-18.752z" fill="#FFED8D" ></path><path d="M626.229333 245.034667l-44.117333 25.376c-22.037333 12.672-21.205333 44.746667 1.461333 56.266666l52.053334 26.442667 6.08 47.509333c3.381333 26.453333 35.733333 37.408 54.496 18.442667l38.88-39.317333 54.698666 8.096c26.378667 3.904 45.685333-24.288 32.501334-47.466667l-23.669334-41.642667 25.76-52.405333c11.210667-22.816-7.381333-48.96-32.618666-45.866667l-50.517334 6.186667-49.066666-42.528c-18.378667-15.936-47.114667-6.346667-52.245334 17.418667l-13.696 63.488z m14.741334 16.128l-48.224 27.733333a10.666667 10.666667 0 0 0 0.490666 18.762667l57.088 29.002666a10.666667 10.666667 0 0 1 5.76 8.149334l6.784 53.12a10.666667 10.666667 0 0 0 18.165334 6.144l42.666666-43.168a10.666667 10.666667 0 0 1 9.152-3.050667l60.053334 8.885333A10.666667 10.666667 0 0 0 803.733333 350.933333l-26.453333-46.549333a10.666667 10.666667 0 0 1-0.298667-9.973333l28.245334-57.472a10.666667 10.666667 0 0 0-10.88-15.285334l-55.210667 6.773334a10.666667 10.666667 0 0 1-8.288-2.528l-52.650667-45.653334a10.666667 10.666667 0 0 0-17.418666 5.824l-14.698667 68.106667a10.666667 10.666667 0 0 1-5.109333 6.997333z" fill="#F9BF2A" ></path><path d="M321.472 505.109333a10.666667 10.666667 0 0 1-1.248 15.04c-67.818667 57.386667-127.946667 152.448-149.472 192.864a10.666667 10.666667 0 0 1-18.837333-10.026666c22.037333-41.365333 83.68-139.189333 154.528-199.125334a10.666667 10.666667 0 0 1 15.04 1.248zM455.061333 640.330667a10.666667 10.666667 0 0 1 3.274667 14.72c-45.824 72.021333-85.034667 186.410667-98.005333 230.666666a10.666667 10.666667 0 0 1-20.469334-5.994666c13.088-44.661333 52.96-161.461333 100.48-236.117334a10.666667 10.666667 0 0 1 14.72-3.274666z" fill="#FFE194" ></path></symbol><symbol id="icon-shengdanwa" viewBox="0 0 1024 1024"><path d="M735.168 795.914667l101.578667-411.616c-12.490667-20.650667-232-66.453333-329.525334-86.784L446.08 631.445333c-56.96-14.005333-154.005333-21.397333-205.717333-12.149333-52.757333 9.44-113.429333 5.386667-127.690667 94.922667-10.112 63.413333 61.152 93.76 100.010667 106.976 76.021333 25.866667 244.768 76.672 357.354666 87.893333 110.464 10.986667 155.402667-66.133333 165.130667-113.173333z" fill="#E73434" ></path><path d="M859.584 380.821333l-103.605333 419.829334c-5.674667 27.008-21.216 62.186667-51.274667 89.418666-30.88 27.968-75.754667 46.314667-136.789333 40.234667-115.210667-11.466667-285.973333-63.008-362.101334-88.917333-19.914667-6.773333-50.4-18.613333-74.848-38.208-24.981333-20.032-46.037333-50.421333-39.36-92.32 3.936-24.693333 11.306667-44.437333 22.048-60.032 10.88-15.765333 24.469333-26.24 39.157334-33.322667 14.378667-6.933333 29.589333-10.517333 43.658666-12.992a650.485333 650.485333 0 0 1 20.288-3.136l0.533334-0.074667a573.12 573.12 0 0 0 19.317333-3.008c28.373333-5.066667 67.552-5.418667 106.026667-2.933333 29.802667 1.92 60.266667 5.621333 86.432 10.592l61.109333-333.781333 21.397333 4.469333c48.714667 10.144 128.298667 26.741333 197.301334 43.413333 34.453333 8.32 66.666667 16.746667 91.232 24.490667 12.224 3.84 23.072 7.68 31.52 11.413333 4.202667 1.866667 8.32 3.914667 11.882666 6.186667 3.008 1.92 8.074667 5.461333 11.488 11.104l4.586667 7.573333zM446.08 631.445333c-6.474667-1.6-13.472-3.093333-20.853333-4.512-57.6-10.965333-139.029333-15.84-184.853334-7.637333-6.72 1.205333-13.578667 2.186667-20.448 3.178667-47.029333 6.752-94.805333 13.610667-107.253333 91.733333-10.112 63.434667 61.152 93.76 100.010667 106.986667 76.021333 25.866667 244.768 76.672 357.354666 87.893333 110.464 10.986667 155.402667-66.133333 165.130667-113.173333l101.578667-411.616c-11.669333-19.274667-203.829333-60.501333-308.629334-82.421334l-20.896-4.362666-61.141333 333.930666z" fill="#811313" ></path><path d="M565.333333 64a21.333333 21.333333 0 0 1 21.333334 21.333333v200.672a21.333333 21.333333 0 1 1-42.666667 0V85.333333a21.333333 21.333333 0 0 1 21.333333-21.333333z" fill="#48A2B6" ></path><path d="M535.658667 412.586667a21.333333 21.333333 0 0 1 15.744 25.738666L507.413333 620.992a21.333333 21.333333 0 1 1-41.472-9.994667l44-182.656a21.333333 21.333333 0 0 1 25.728-15.744z" fill="#FB5B5B" ></path><path d="M768.821333 357.536l-97.653333 395.712c-9.728 47.04-54.666667 124.16-165.130667 113.173333-112.586667-11.221333-281.333333-62.037333-357.354666-87.893333a350.506667 350.506667 0 0 1-20.298667-7.573333c21.632 26.453333 59.541333 41.813333 84.298667 50.24 76.021333 25.866667 244.768 76.672 357.354666 87.893333 110.464 10.986667 155.402667-66.133333 165.130667-113.173333l101.578667-411.616c-4.106667-6.794667-30.666667-16.32-67.925334-26.773334z" fill="#C42727" ></path><path d="M836.746667 384.298667l-101.578667 411.616c-0.928 4.48-2.176 9.248-3.776 14.186666l84.021333-340.469333c-12.266667-20.266667-224-64.778667-324.021333-85.632l15.829333-86.485333c97.525333 20.330667 317.034667 66.133333 329.525334 86.784z" fill="#AE1E1E" ></path><path d="M742.944 764.309333l-7.776 31.605334c-9.728 47.04-54.666667 124.16-165.130667 113.173333-32.490667-3.242667-69.653333-9.770667-107.914666-18.058667C478.869333 802.677333 554.538667 736 645.333333 736c35.786667 0 69.216 10.346667 97.610667 28.309333z" fill="#E99345" ></path><path d="M470.048 861.824a194.741333 194.741333 0 0 0-7.925333 29.205333c38.261333 8.277333 75.424 14.816 107.914666 18.048 110.464 10.997333 155.402667-66.133333 165.130667-113.173333l7.776-31.594667a182.325333 182.325333 0 0 0-68.106667-25.92l-3.669333 14.858667c-9.728 47.04-54.666667 124.16-165.130667 113.173333a707.914667 707.914667 0 0 1-35.989333-4.586666z" fill="#CA7B32" ></path><path d="M543.168 767.264c-41.749333 28.384-65.952 74.346667-70.752 109.909333a10.666667 10.666667 0 1 1-21.141333-2.848c5.578667-41.365333 32.970667-92.8 79.893333-124.693333 47.637333-32.384 114.474667-44.064 196.981333-6.933333a10.666667 10.666667 0 0 1-8.757333 19.445333c-76.234667-34.304-135.168-22.784-176.213333 5.12z" fill="#FFAF66" ></path><path d="M455.232 238.112a53.333333 53.333333 0 0 1 61.76-43.306667l347.413333 60.938667a53.333333 53.333333 0 0 1 43.306667 61.749333l-6.528 37.226667a53.333333 53.333333 0 0 1-61.749333 43.328l-347.413334-60.949333a53.333333 53.333333 0 0 1-43.306666-61.76l6.517333-37.226667z" fill="#CEFCEB" ></path><path d="M520.672 173.781333l347.413333 60.949334a74.666667 74.666667 0 0 1 60.64 86.442666l-6.528 37.237334a74.666667 74.666667 0 0 1-86.453333 60.64l-347.413333-60.949334a74.666667 74.666667 0 0 1-60.64-86.442666l6.538666-37.226667a74.666667 74.666667 0 0 1 86.442667-60.650667z m-3.690667 21.013334a53.333333 53.333333 0 0 0-61.738666 43.306666l-6.538667 37.248a53.333333 53.333333 0 0 0 43.306667 61.749334l347.424 60.938666a53.333333 53.333333 0 0 0 61.749333-43.306666l6.528-37.237334a53.333333 53.333333 0 0 0-43.306667-61.749333l-347.413333-60.949333z" fill="#79DAB8" ></path><path d="M506.24 305.216a16 16 0 0 1 18.538667-12.970667l338.656 59.786667a16 16 0 0 1-5.568 31.52l-338.645334-59.797333a16 16 0 0 1-12.981333-18.538667z" fill="#9FF3F3" ></path><path d="M483.594667 221.418667a16 16 0 0 1 18.613333-12.864l133.333333 24.373333a16 16 0 1 1-5.76 31.477333l-133.333333-24.373333a16 16 0 0 1-12.853333-18.613333z" fill="#FFFFFF" ></path><path d="M502.549333 456.746667c-10.890667 1.290667-21.493333 5.856-27.701333 9.6a10.666667 10.666667 0 0 1-11.029333-18.272c8.192-4.928 21.653333-10.784 36.202666-12.522667 14.634667-1.749333 31.957333 0.565333 45.056 14.293333 21.578667 22.613333 45.013333 23.818667 65.738667 21.621334 4.522667-0.490667 9.738667-1.856 16.053333-3.648l2.186667-0.64c5.482667-1.557333 11.626667-3.328 17.706667-4.48 13.930667-2.613333 31.008-2.592 43.914666 12.416 9.354667 10.88 14.122667 15.477333 19.626667 17.92 5.408 2.389333 12.885333 3.242667 29.088 2.069333l5.237333-0.394667a300.032 300.032 0 0 1 17.152-1.002666c6.944-0.117333 13.941333 0.32 20.672 2.453333 14.432 4.565333 24.405333 15.712 32.874667 34.858667a10.666667 10.666667 0 1 1-19.52 8.629333c-7.221333-16.362667-13.6-21.194667-19.776-23.146667-3.573333-1.12-7.946667-1.568-13.877333-1.461333-4.608 0.074667-9.578667 0.458667-15.445334 0.906667-1.834667 0.138667-3.754667 0.288-5.781333 0.426666-16.512 1.205333-28.661333 0.864-39.274667-3.84-10.528-4.661333-18.186667-13.077333-27.157333-23.509333-5.408-6.293333-12.522667-7.466667-23.786667-5.354667-5.013333 0.949333-10.154667 2.421333-15.744 4.021334l-2.261333 0.64c-6.154667 1.76-13.034667 3.648-19.626667 4.341333-23.786667 2.528-55.285333 1.386667-83.424-28.096-6.784-7.104-16.277333-9.130667-27.093333-7.84z" fill="#811313" ></path><path d="M517.781333 444.309333a72.768 72.768 0 0 0-25.866666 8.405334 10.666667 10.666667 0 0 1-10.496-18.570667 94.037333 94.037333 0 0 1 33.994666-11.029333c13.621333-1.525333 29.952 0.437333 42.442667 12.693333 19.989333 19.637333 41.834667 20.768 61.312 18.826667 4.234667-0.426667 9.109333-1.621333 15.018667-3.2l2.058666-0.554667c5.12-1.376 10.901333-2.922667 16.586667-3.936 12.949333-2.272 29.077333-2.368 41.418667 11.093333 8.746667 9.525333 13.109333 13.450667 18.133333 15.541334 5.024 2.08 12.021333 2.837333 27.2 1.813333l4.906667-0.352c5.642667-0.405333 11.104-0.8 16.074666-0.885333 6.506667-0.106667 13.056 0.288 19.381334 2.165333 13.632 4.032 23.189333 14.005333 31.274666 31.125333a10.666667 10.666667 0 0 1-19.296 9.109334c-6.624-14.048-12.373333-18.101333-18.037333-19.786667-3.328-0.981333-7.413333-1.365333-12.981333-1.28-4.309333 0.074667-8.96 0.405333-14.464 0.8l-5.408 0.384c-15.456 1.045333-26.848 0.746667-36.832-3.392-9.973333-4.149333-17.258667-11.648-25.674667-20.821333-4.8-5.248-11.338667-6.378667-21.994667-4.501334-4.693333 0.832-9.493333 2.112-14.72 3.52l-2.122666 0.565334c-5.76 1.546667-12.224 3.2-18.4 3.818666-22.186667 2.208-51.808 1.269333-78.378667-24.821333-6.144-6.026667-14.933333-7.872-25.130667-6.72z" fill="#BEC11F" ></path><path d="M566.133333 876.714667a10.346667 10.346667 0 1 1-18.101333-10.026667 10.346667 10.346667 0 0 1 18.101333 10.026667zM611.616 870.389333a10.346667 10.346667 0 1 1-18.101333-10.026666 10.346667 10.346667 0 0 1 18.101333 10.026666zM723.648 796.448a13.973333 13.973333 0 1 1-24.426667-13.525333 13.973333 13.973333 0 0 1 24.426667 13.525333zM529.685333 854.741333a10.474667 10.474667 0 1 1-18.325333-10.144 10.474667 10.474667 0 0 1 18.325333 10.144zM689.792 815.477333a21.728 21.728 0 1 1-38.005333-21.045333 21.728 21.728 0 0 1 38.005333 21.045333zM652.650667 768.298667a13.973333 13.973333 0 1 1-24.437334-13.525334 13.973333 13.973333 0 0 1 24.426667 13.525334zM658.933333 863.530667a13.973333 13.973333 0 1 1-24.437333-13.525334 13.973333 13.973333 0 0 1 24.426667 13.525334zM622.848 824.277333a8.469333 8.469333 0 1 1-14.826667-8.202666 8.469333 8.469333 0 0 1 14.826667 8.213333zM584.245333 833.354667a13.973333 13.973333 0 1 1-24.426666-13.525334 13.973333 13.973333 0 0 1 24.426666 13.536zM609.12 792.746667a13.973333 13.973333 0 1 1-24.426667-13.546667 13.973333 13.973333 0 0 1 24.426667 13.546667zM543.925333 815.328a10.474667 10.474667 0 1 1-18.336-10.154667 10.474667 10.474667 0 0 1 18.336 10.154667z" fill="#B86A0F" ></path><path d="M628.874667 249.205333a10.666667 10.666667 0 0 1 8.874666 12.202667l-9.770666 62.037333a10.666667 10.666667 0 1 1-21.077334-3.306666l9.781334-62.048a10.666667 10.666667 0 0 1 12.192-8.885334z" fill="#3DB7D1" ></path><path d="M660.736 271.818667a10.666667 10.666667 0 0 1-5.44 14.058666l-57.472 25.365334a10.666667 10.666667 0 1 1-8.608-19.52l57.461333-25.354667a10.666667 10.666667 0 0 1 14.058667 5.44z" fill="#3DB7D1" ></path><path d="M652.266667 319.893333a10.666667 10.666667 0 0 1-15.082667 0.32l-45.333333-43.466666a10.666667 10.666667 0 0 1 14.752-15.392l45.333333 43.466666a10.666667 10.666667 0 0 1 0.32 15.082667zM756.416 279.061333a10.666667 10.666667 0 0 1 0.234667 15.082667l-43.712 45.098667a10.666667 10.666667 0 1 1-15.317334-14.848l43.712-45.098667a10.666667 10.666667 0 0 1 15.082667-0.234667z" fill="#3DB7D1" ></path><path d="M769.450667 315.893333a10.666667 10.666667 0 0 1-12.554667 8.362667l-61.578667-12.352a10.666667 10.666667 0 1 1 4.192-20.917333l61.589334 12.352a10.666667 10.666667 0 0 1 8.352 12.554666z" fill="#3DB7D1" ></path><path d="M734.826667 350.325333a10.666667 10.666667 0 0 1-12.501334-8.426666l-12.042666-61.642667a10.666667 10.666667 0 1 1 20.938666-4.085333l12.042667 61.642666a10.666667 10.666667 0 0 1-8.426667 12.512zM863.125333 325.12a10.666667 10.666667 0 0 1-5.909333 13.888l-47.658667 19.189333a10.666667 10.666667 0 1 1-7.968-19.786666l47.658667-19.2a10.666667 10.666667 0 0 1 13.866667 5.92z" fill="#3DB7D1" ></path><path d="M860.416 358.826667a10.666667 10.666667 0 0 1-14.869333 2.549333l-41.92-29.685333a10.666667 10.666667 0 1 1 12.32-17.408l41.92 29.685333a10.666667 10.666667 0 0 1 2.56 14.869333z" fill="#3DB7D1" ></path><path d="M821.088 373.845333a10.666667 10.666667 0 0 1-8.021333-12.778666l11.477333-50.08a10.666667 10.666667 0 0 1 20.8 4.768l-11.477333 50.08a10.666667 10.666667 0 0 1-12.778667 8.010666zM563.296 250.645333a10.666667 10.666667 0 0 1-5.909333 13.866667l-47.658667 19.2a10.666667 10.666667 0 1 1-7.968-19.786667l47.658667-19.2a10.666667 10.666667 0 0 1 13.866666 5.92z" fill="#3DB7D1" ></path><path d="M560.586667 284.352a10.666667 10.666667 0 0 1-14.869334 2.538667l-41.92-29.685334a10.666667 10.666667 0 1 1 12.32-17.408l41.92 29.685334a10.666667 10.666667 0 0 1 2.56 14.869333z" fill="#3DB7D1" ></path><path d="M521.258667 299.36a10.666667 10.666667 0 0 1-8.010667-12.778667l11.466667-50.08a10.666667 10.666667 0 0 1 20.8 4.768l-11.477334 50.08a10.666667 10.666667 0 0 1-12.778666 8.010667z" fill="#3DB7D1" ></path><path d="M440 693.333333c0 36.085333-59.690667 41.333333-133.333333 41.333334s-133.333333-5.248-133.333334-41.333334 59.690667-65.333333 133.333334-65.333333 133.333333 29.248 133.333333 65.333333z" fill="#FB5B5B" ></path><path d="M280.106667 642.784a427.36 427.36 0 0 1 41.813333-0.778667 16 16 0 0 1-1.173333 31.978667c-8.48-0.309333-23.029333-0.32-38.485334 0.725333-15.701333 1.066667-31.189333 3.136-42.154666 6.56a16 16 0 0 1-9.546667-30.538666c14.634667-4.576 33.141333-6.837333 49.546667-7.946667z" fill="#FFADAD" ></path></symbol><symbol id="icon-shengdanye" viewBox="0 0 1024 1024"><path d="M685.482667 708.224c-20.629333 36.266667-82.848 79.306667-111.370667 96.298667-163.989333-33.525333-207.253333-159.274667-208.373333-217.962667 112.928-5.589333 77.653333-139.125333 45.898666-205.184 84.16-4.170667 57.354667-108.746667 33.44-160.522667 63.968-2.101333 52.170667-96.469333 38.282667-143.402666 18.613333 7.530667 59.210667 36.586667 72.661333 92.522666 13.450667 55.936 50.869333 56.661333 67.893334 50.026667-42.485333 198.613333 55.936 185.92 110.464 154.730667-88.874667 167.808-16.448 197.941333 30.869333 192.042666-42.218667 10.101333-53.973333 96.117333-79.765333 141.450667z" fill="#536704" ></path><path d="M585.024 822.848a21.333333 21.333333 0 0 1-15.189333 2.570667c-175.893333-35.957333-224.149333-172.138667-225.429334-238.442667a21.333333 21.333333 0 0 1 20.266667-21.717333c23.786667-1.173333 36.608-8.768 44.032-17.568 7.872-9.344 12.341333-23.264 12.917333-41.706667 1.173333-37.397333-13.973333-83.669333-29.205333-115.370667a21.333333 21.333333 0 0 1 18.165333-30.549333c16.256-0.8 24.106667-6.08 28.48-11.562667 4.949333-6.186667 8.149333-16.021333 8.501334-30.069333 0.714667-28.426667-10.496-64.042667-21.856-88.629333a21.333333 21.333333 0 0 1 18.666666-30.272c9.962667-0.32 15.178667-3.829333 18.773334-8.458667 4.309333-5.546667 7.637333-14.613333 9.066666-27.466667 2.88-25.770667-2.773333-58.005333-9.312-80.096a21.333333 21.333333 0 0 1 28.458667-25.834666c23.808 9.632 70.069333 43.52 85.408 107.306666 5.632 23.434667 15.136 31.36 21.12 34.250667 6.837333 3.296 14.165333 2.496 18.293333 0.896a21.333333 21.333333 0 0 1 28.586667 24.341333c-10.346667 48.362667-11.648 81.941333-8.106667 104.586667 3.488 22.357333 11.338667 32.245333 18.101334 36.842667 7.093333 4.832 17.130667 6.634667 30.165333 4.650666 12.981333-1.973333 26.848-7.466667 38.858667-14.336a21.333333 21.333333 0 0 1 29.44 28.501334c-44.074667 83.210667-43.445333 124.32-35.146667 142.186666 7.146667 15.338667 24.714667 21.173333 44.522667 18.698667a21.333333 21.333333 0 0 1 7.605333 41.92c-3.754667 0.896-8.554667 3.84-14.378667 11.818667-5.856 8.021333-11.306667 19.168-16.832 32.906666-3.712 9.216-7.093333 18.634667-10.602666 28.416-1.781333 4.949333-3.594667 9.984-5.493334 15.146667-5.429333 14.698667-11.498667 29.994667-18.88 42.965333-12.437333 21.866667-35.914667 43.808-57.92 61.461334a570.208 570.208 0 0 1-61.077333 42.613333z m153.077333-235.413333c-12.192 17.056-21.141333 41.952-29.973333 66.517333-7.082667 19.733333-14.090667 39.242667-22.645333 54.272-20.629333 36.266667-82.848 79.306667-111.370667 96.298667-146.208-29.898667-196.448-133.077333-206.421333-196.693334a169.013333 169.013333 0 0 1-1.546667-13.066666 139.306667 139.306667 0 0 1-0.405333-8.202667c102.133333-5.056 83.04-114.752 54.976-184.554667a344.181333 344.181333 0 0 0-9.066667-20.629333c8.256-0.416 15.456-1.792 21.685333-3.989333 49.6-17.525333 38.250667-87.189333 20.298667-135.84a284.554667 284.554667 0 0 0-8.554667-20.693334c8.234667-0.266667 15.221333-2.069333 21.098667-5.098666 31.765333-16.384 31.477333-68.661333 23.914667-109.888a278.4 278.4 0 0 0-6.730667-28.416c6.656 2.698667 16.106667 8.138667 26.144 16.576 18.026667 15.157333 37.877333 40 46.517333 75.946666 8.96 37.205333 28.501333 49.984 45.610667 52.416a45.248 45.248 0 0 0 22.293333-2.378666 589.450667 589.450667 0 0 0-4.512 23.210666c-24.736 143.52 33.717333 160.138667 84.341334 144.832a150.165333 150.165333 0 0 0 30.613333-13.322666 593.493333 593.493333 0 0 0-15.146667 30.613333c-48.373333 105.610667-23.253333 146.698667 11.008 158.325333 11.456 3.893333 23.925333 4.48 35.018667 3.093334-10.784 2.592-19.594667 10.133333-27.146667 20.682666z" fill="#676E0B" ></path><path d="M533.866667 234.88a10.666667 10.666667 0 0 1 12.586666 8.32c14.645333 71.925333 44.469333 240.053333 45.546667 334.005333a10.666667 10.666667 0 1 1-21.333333 0.245334c-1.056-91.658667-30.432-257.92-45.12-329.994667a10.666667 10.666667 0 0 1 8.32-12.586667z" fill="#617807" ></path><path d="M783.232 862.005333c-98.666667 0-216 0-261.333333 11.989334-32-187.989333 21.781333-280.437333 45.333333-307.989334 24.533333 78.933333 74.218667-21.333333 96-81.344 36.266667 69.333333 120.885333 17.344 158.666667-17.322666 10.666667 25.322667 36.693333 22.72 64 17.322666 23.669333-4.661333 72-2.666667 94.666666 0-60.8 35.2-51.114667 94.677333-38.666666 120-101.333333 29.866667-92.885333 90.666667-76 117.333334-122.666667 21.333333-106.218667 102.229333-82.666667 140.010666z" fill="#62780A" ></path><path d="M510.357333 891.946667a21.333333 21.333333 0 0 1-9.493333-14.368c-32.906667-193.386667 21.952-292.448 50.154667-325.44a21.333333 21.333333 0 0 1 36.586666 7.530666c1.802667 5.792 3.509333 9.610667 4.874667 12.042667 1.92-1.632 4.32-4.106667 7.146667-7.626667 15.882667-19.808 32.789333-57.045333 43.552-86.698666a21.333333 21.333333 0 0 1 38.954666-2.613334c6.784 12.981333 14.72 18.56 22.346667 20.981334 8.288 2.634667 18.890667 2.368 31.68-1.28 25.941333-7.392 53.674667-26.666667 71.317333-42.858667a21.333333 21.333333 0 0 1 34.08 7.434667c1.354667 3.221333 2.741333 4.586667 3.690667 5.290666 1.056 0.778667 2.773333 1.621333 5.845333 2.133334 7.008 1.141333 16.853333-0.010667 30.677334-2.741334 14.176-2.794667 34.08-3.402667 52.138666-3.146666 18.453333 0.256 36.949333 1.461333 49.152 2.890666a21.333333 21.333333 0 0 1 8.192 39.648c-24.736 14.325333-33.813333 32.394667-36.426666 48.64-2.794667 17.333333 1.589333 34.058667 6.218666 43.498667a21.333333 21.333333 0 0 1-13.12 29.866667c-47.029333 13.866667-63.2 33.216-68.416 46.965333-5.450667 14.389333-1.472 29.205333 4.416 38.485333a21.333333 21.333333 0 0 1-14.368 32.426667c-56.789333 9.888-74.282667 31.925333-79.392 48.96-5.824 19.424 1.088 42.581333 11.168 58.741333a21.333333 21.333333 0 0 1-18.101333 32.618667c-49.418667 0-103.061333 0-149.994667 1.493333-47.722667 1.514667-85.941333 4.522667-105.877333 9.802667a21.333333 21.333333 0 0 1-17.002667-2.677333z m78.869334-317.973334l0.064-0.032a0.426667 0.426667 0 0 1-0.064 0.021334z m194.005333 288.021334a114.314667 114.314667 0 0 1-10.336-21.333334c-13.76-37.973333-10.442667-91.808 71.2-113.877333 6.72-1.813333 13.973333-3.424 21.802667-4.778667a67.861333 67.861333 0 0 1-8.448-20.149333c-6.624-27.413333 2.005333-65.674667 64.138666-90.24 6.218667-2.464 12.970667-4.789333 20.309334-6.944a91.125333 91.125333 0 0 1-6.912-20.213333c-5.098667-23.093333-3.594667-54.56 20.725333-80.426667 6.528-6.944 14.72-13.493333 24.853333-19.370667a451.776 451.776 0 0 0-33.066666-2.368c-21.930667-0.853333-46.666667-0.565333-61.6 2.368-18.88 3.733333-37.12 6.122667-50.133334-1.109333-5.813333-3.232-10.570667-8.384-13.866666-16.213333-4.906667 4.490667-10.592 9.28-16.874667 14.069333-36.181333 27.573333-91.701333 54.773333-126.602667 23.413333-5.653333-5.098667-10.773333-11.733333-15.189333-20.16-2.784 7.68-6.026667 16.021333-9.621333 24.554667-20.96 49.856-53.728 106.528-76.138667 78.378667-3.733333-4.693333-7.178667-11.754667-10.24-21.6-4.192 4.906667-9.344 11.872-14.794667 21.056-24.010667 40.458667-53.909333 124.128-33.845333 265.770666 0.981333 6.933333 2.08 13.973333 3.306667 21.184a192.042667 192.042667 0 0 1 20.949333-4.074666c49.28-7.189333 136.170667-7.861333 216.010667-7.925334h24.373333z" fill="#676E0B" ></path><path d="M896.362667 522.218667a10.666667 10.666667 0 0 1-5.248 14.144C796.266667 579.84 680.885333 659.893333 617.322667 774.506667a10.666667 10.666667 0 1 1-18.645334-10.346667c66.570667-120.053333 186.389333-202.666667 283.541334-247.189333a10.666667 10.666667 0 0 1 14.144 5.248z" fill="#738B11" ></path><path d="M348 884c87.466667-19.2 214.218667-24.885333 266.666667-25.333333 12.8-129.066667-41.781333-252-70.666667-297.333334-40.533333 57.6-81.781333-38.218667-97.333333-93.333333-59.733333 60.8-132.448 18.218667-161.333334-10.666667-14.666667 19.338667-33.248 39.978667-82.666666 25.333334-43.786667-12.970667-94.666667-3.552-117.333334 0 56.533333 34.133333 77.781333 115.552 70.666667 152 112 23.466667 92.885333 89.781333 69.333333 120 112-4.266667 128.448 84.448 122.666667 129.333333z" fill="#848C13" ></path><path d="M635.893333 860.768a21.333333 21.333333 0 0 1-21.045333 19.232c-52.085333 0.437333-177.034667 6.122667-262.272 24.832a21.333333 21.333333 0 0 1-25.738667-23.552c2.464-19.136-0.064-47.082667-13.984-68.906667-12.853333-20.138667-37.365333-38.272-86.709333-36.384a21.333333 21.333333 0 0 1-17.642667-34.432c9.834667-12.608 16.181333-29.834667 12.405334-43.872-3.232-11.968-16.725333-31.125333-69.28-42.133333a21.333333 21.333333 0 0 1-16.565334-24.970667c2.517333-12.928 0.192-38.112-10.378666-64.96-10.410667-26.453333-27.392-50.816-50.378667-64.693333a21.333333 21.333333 0 0 1 7.722667-39.338667l4.565333-0.736c24-3.882667 76.021333-12.309333 122.133333 1.354667 21.312 6.314667 32.768 4.16 39.488 1.109333 7.381333-3.349333 12.949333-9.418667 20.128-18.88a21.333333 21.333333 0 0 1 32.074667-2.186666c12.426667 12.426667 34.410667 27.712 58.752 33.248 22.986667 5.226667 48.245333 2.026667 72.277333-22.453334a21.333333 21.333333 0 0 1 35.754667 9.162667c7.573333 26.826667 20.938667 61.6 35.978667 82.122667 7.957333 10.858667 13.141333 13.226667 14.432 13.461333l0.074666 0.010667h0.021334a4.565333 4.565333 0 0 0 0.789333-0.352c1.333333-0.746667 4.170667-2.88 8.053333-8.394667a21.333333 21.333333 0 0 1 35.445334 0.810667c30.485333 47.850667 87.328 175.552 73.898666 310.901333zM555.52 581.173333c29.653333 55.466667 70.4 164.117333 59.157333 277.493334-48.213333 0.405333-159.221333 5.248-244.778666 20.938666-7.509333 1.386667-14.826667 2.848-21.888 4.394667a131.413333 131.413333 0 0 0 0.885333-22.005333c-1.749333-42.378667-23.210667-99.04-98.346667-106.624a181.952 181.952 0 0 0-25.205333-0.704 91.893333 91.893333 0 0 0 12.426667-21.429334c13.578667-33.226667 8.213333-79.722667-81.76-98.570666 6.058667-31.018667-8.437333-94.634667-47.754667-133.930667A120.768 120.768 0 0 0 85.333333 482.666667l4.32-0.693334a592.213333 592.213333 0 0 1 25.76-3.690666c25.130667-2.944 57.792-4.341333 87.253334 4.384 35.306667 10.453333 54.88 2.912 68.522666-9.312 5.450667-4.885333 9.962667-10.506667 14.144-16.021334 4.448 4.448 9.92 9.216 16.245334 13.877334 30.709333 22.709333 81.066667 42.986667 127.264 11.754666a116.384 116.384 0 0 0 17.824-14.965333c1.973333 7.008 4.373333 14.677333 7.125333 22.602667 16.106667 46.325333 44.533333 101.504 74.474667 85.813333 5.226667-2.730667 10.485333-7.616 15.733333-15.082667 3.52 5.514667 7.402667 12.16 11.509333 19.84z" fill="#676E0B" ></path><path d="M163.04 500.533333a10.666667 10.666667 0 0 1 13.088-7.498666c90.453333 24.576 173.866667 79.168 241.642667 138.432 67.818667 59.306667 120.64 123.893333 149.866666 169.44a10.666667 10.666667 0 1 1-17.952 11.52c-28.106667-43.797333-79.605333-106.869333-145.962666-164.906667-66.389333-58.048-146.976-110.464-233.184-133.888a10.666667 10.666667 0 0 1-7.498667-13.098667z" fill="#9BA517" ></path><path d="M756.533333 674.474667a97.152 97.152 0 1 1-194.304 0 97.152 97.152 0 0 1 194.304 0z" fill="#9F2308" ></path><path d="M777.866667 674.474667c0 65.44-53.045333 118.485333-118.485334 118.485333-65.44 0-118.485333-53.045333-118.485333-118.485333 0-65.44 53.045333-118.485333 118.485333-118.485334 65.44 0 118.485333 53.045333 118.485334 118.485334zM659.381333 771.626667a97.152 97.152 0 1 0 0-194.304 97.152 97.152 0 0 0 0 194.304z" fill="#741602" ></path><path d="M598.656 771.626667a97.152 97.152 0 1 1-194.304 0 97.152 97.152 0 0 1 194.304 0z" fill="#BF2200" ></path><path d="M619.989333 771.626667c0 65.44-53.045333 118.485333-118.485333 118.485333-65.429333 0-118.485333-53.045333-118.485333-118.485333 0-65.429333 53.056-118.485333 118.485333-118.485334 65.44 0 118.485333 53.056 118.485333 118.485334z m-118.485333 97.152a97.152 97.152 0 1 0 0-194.304 97.152 97.152 0 0 0 0 194.304z" fill="#8D1D05" ></path><path d="M790.666667 800.586667c0 62.933333-53.856 113.952-120.288 113.952-66.442667 0-120.298667-51.018667-120.298667-113.952 0-62.933333 53.866667-113.962667 120.298667-113.962667 66.432 0 120.288 51.018667 120.288 113.962667z" fill="#DF2D06" ></path><path d="M812 800.586667c0 75.786667-64.512 135.285333-141.621333 135.285333-77.12 0-141.632-59.498667-141.632-135.285333 0-75.797333 64.512-135.296 141.632-135.296s141.621333 59.498667 141.621333 135.296zM670.378667 914.538667c66.432 0 120.288-51.018667 120.288-113.952 0-62.933333-53.856-113.962667-120.288-113.962667-66.442667 0-120.298667 51.018667-120.298667 113.962667 0 62.933333 53.866667 113.952 120.298667 113.952z" fill="#B32303" ></path><path d="M688.32 754.794667a50.048 50.048 0 1 1-100.096 0 50.048 50.048 0 0 1 100.096 0z" fill="#FC4C14" ></path><path d="M537.888 742.581333a53.333333 53.333333 0 1 1-106.666667 0 53.333333 53.333333 0 0 1 106.666667 0z" fill="#D6300C" ></path><path d="M640 741.333333a16 16 0 1 1-32 0 16 16 0 0 1 32 0z" fill="#FFFFFF" ></path><path d="M488 725.333333a16 16 0 1 1-32 0 16 16 0 0 1 32 0z" fill="#FF8166" ></path></symbol><symbol id="icon-shengdanbaozhu" viewBox="0 0 1024 1024"><path d="M184.725333 272.373333a21.333333 21.333333 0 0 1 25.6 15.957334c29.002667 125.152 29.152 197.28 14.090667 254.432-7.456 28.32-18.432 52.085333-30.037333 75.552-2.090667 4.224-4.192 8.426667-6.314667 12.661333-9.738667 19.466667-19.669333 39.306667-29.194667 63.178667-22.4 56.117333-20.384 102.656-4.949333 134.912 15.210667 31.765333 44.650667 52.448 84.170667 55.914666 32.32 2.826667 61.226667-13.194667 85.024-37.952 23.850667-24.810667 39.861333-55.754667 45.824-75.445333a21.333333 21.333333 0 0 1 40.832 12.362667c-7.850667 25.952-27.232 62.837333-55.893334 92.650666-28.725333 29.877333-69.482667 55.264-119.509333 50.88-53.696-4.693333-96.853333-33.866667-118.933333-79.989333-21.845333-45.632-21.802667-105.002667 3.808-169.152 10.250667-25.696 21.109333-47.370667 30.890666-66.912l5.994667-12.021333c11.317333-22.88 20.704-43.509333 27.029333-67.52 12.522667-47.509333 13.909333-111.786667-14.4-233.92a21.333333 21.333333 0 0 1 15.968-25.6z" fill="#935F10" ></path><path d="M187.136 282.762667a10.666667 10.666667 0 0 1 12.8 7.978666c28.821333 124.394667 28.586667 194.56 14.165333 249.301334-7.168 27.242667-17.749333 50.229333-29.290666 73.546666-2.048 4.149333-4.128 8.298667-6.229334 12.490667-9.749333 19.488-19.914667 39.786667-29.621333 64.117333a10.666667 10.666667 0 1 1-19.818667-7.904c10.08-25.237333 20.693333-46.464 30.474667-65.984 2.069333-4.128 4.096-8.181333 6.08-12.181333 11.381333-23.018667 21.173333-44.437333 27.776-69.514667 13.152-49.92 14.154667-116.170667-14.325333-239.050666a10.666667 10.666667 0 0 1 7.989333-12.8z" fill="#BD8023" ></path><path d="M212.202667 432.736a10.666667 10.666667 0 0 1 11.093333 10.218667c0.906667 22.325333 0.106667 41.930667-2.058667 59.669333a10.666667 10.666667 0 1 1-21.173333-2.581333c2.016-16.469333 2.773333-34.912 1.92-56.213334a10.666667 10.666667 0 0 1 10.218667-11.093333z" fill="#E49B2D" ></path><path d="M589.866667 241.728a42.666667 42.666667 0 0 1 59.221333-11.573333l157.376 105.92a42.666667 42.666667 0 0 1 11.573333 59.221333l-304.170666 451.946667c-5.493333 8.170667-13.653333 14.229333-23.424 15.402666-25.450667 3.04-80.192 2.496-138.442667-42.645333-63.328-49.066667-73.728-88.512-74.986667-105.141333-0.426667-5.642667 1.813333-10.965333 4.970667-15.648L589.866667 241.728z" fill="#1D7F05" ></path><path d="M661.002667 212.458667l157.376 105.92a64 64 0 0 1 17.354666 88.821333l-304.170666 451.946667c-8.074667 12-21.226667 22.613333-38.581334 24.682666-29.397333 3.52-90.218667 2.506667-154.048-46.965333-67.061333-51.978667-81.386667-96.565333-83.189333-120.405333-0.928-12.352 4.042667-22.474667 8.533333-29.162667l307.893334-457.472a64 64 0 0 1 88.832-17.365333z m-11.914667 17.706666a42.666667 42.666667 0 0 0-59.221333 11.562667L281.984 699.210667c-3.157333 4.693333-5.386667 10.005333-4.96 15.648 1.248 16.64 11.648 56.064 74.976 105.141333 58.250667 45.152 112.992 45.685333 138.453333 42.645333 9.770667-1.173333 17.92-7.232 23.413334-15.402666l304.170666-451.946667a42.666667 42.666667 0 0 0-11.573333-59.221333l-157.376-105.92z" fill="#154909" ></path><path d="M306.965333 777.418667c10.773333 12.992 25.344 27.317333 45.034667 42.581333 58.250667 45.152 112.992 45.685333 138.453333 42.645333 9.770667-1.173333 17.92-7.232 23.413334-15.402666l304.170666-451.946667a42.666667 42.666667 0 0 0-11.573333-59.221333l-15.445333-10.4a42.602667 42.602667 0 0 1-4.981334 37.621333l-304.170666 451.946667c-5.493333 8.170667-13.653333 14.229333-23.424 15.402666-25.450667 3.04-80.192 2.496-138.442667-42.645333a361.6 361.6 0 0 1-13.034667-10.581333z" fill="#1F630E" ></path><path d="M584.042667 378.698667a32 32 0 0 1 8.8 44.394666l-224 334.666667a32 32 0 0 1-53.184-35.605333l224-334.666667a32 32 0 0 1 44.384-8.789333z" fill="#39AC1B" ></path><path d="M402.645333 519.925333l157.141334-233.493333L689.088 257.066667l97.994667 65.962666 12.832 99.2-166.197334 246.933334c-50.24-14.304-102.570667-36.842667-150.016-71.264-33.824-24.544-60.373333-51.189333-81.066666-77.973334z" fill="#154909" ></path><path d="M439.530667 481.333333a10.666667 10.666667 0 0 1 10.666666 10.666667c0 22.805333 5.706667 67.616 44.277334 105.056 48.896 47.445333 77.728 101.877333 82.368 141.664a10.666667 10.666667 0 1 1-21.194667 2.474667c-3.882667-33.322667-29.312-83.498667-76.032-128.832-44.288-42.986667-50.752-94.432-50.752-120.362667a10.666667 10.666667 0 0 1 10.666667-10.666667zM479.733333 429.056a10.666667 10.666667 0 0 1 10.666667 10.666667c0 22.805333 5.717333 67.616 44.288 105.056 48.885333 47.445333 77.717333 101.866667 82.368 141.653333a10.666667 10.666667 0 1 1-21.194667 2.485333c-3.882667-33.322667-29.322667-83.498667-76.032-128.832-44.288-42.986667-50.762667-94.432-50.762666-120.362666a10.666667 10.666667 0 0 1 10.666666-10.666667zM519.946667 375.434667a10.666667 10.666667 0 0 1 10.666666 10.666666c0 22.816 5.706667 67.626667 44.277334 105.066667 48.896 47.445333 77.728 101.866667 82.368 141.653333a10.666667 10.666667 0 0 1-21.184 2.485334c-3.893333-33.322667-29.333333-83.498667-76.032-128.842667-44.288-42.986667-50.773333-94.432-50.773334-120.362667a10.666667 10.666667 0 0 1 10.666667-10.666666zM400.533333 540.426667a10.666667 10.666667 0 0 1 10.666667 10.666666c0 22.805333 5.717333 67.626667 44.288 105.056 48.885333 47.456 77.717333 101.877333 82.357333 141.664a10.666667 10.666667 0 1 1-21.184 2.474667c-3.882667-33.322667-29.322667-83.488-76.032-128.832-44.288-42.986667-50.762667-94.432-50.762666-120.362667a10.666667 10.666667 0 0 1 10.666666-10.666666zM355.370667 594.037333a10.666667 10.666667 0 0 1 10.666666 10.666667c0 22.805333 5.717333 67.626667 44.288 105.066667 48.896 47.445333 77.728 101.866667 82.368 141.653333a10.666667 10.666667 0 1 1-21.194666 2.474667c-3.882667-33.312-29.322667-83.488-76.032-128.832-44.288-42.986667-50.762667-94.432-50.762667-120.362667a10.666667 10.666667 0 0 1 10.666667-10.666667zM310.666667 653.386667a10.666667 10.666667 0 0 1 10.666666 10.666666c0 21.962667 8.725333 64.736 47.765334 102.624 27.253333 26.453333 46.741333 50.741333 57.557333 79.573334a10.666667 10.666667 0 0 1-19.978667 7.498666c-9.173333-24.501333-26.058667-46.154667-52.437333-71.765333-43.818667-42.528-54.24-91.146667-54.24-117.930667a10.666667 10.666667 0 0 1 10.666667-10.666666z" fill="#B48204" ></path><path d="M402.282667 580.021333a10.666667 10.666667 0 0 1 13.034666 7.594667c2.037333 7.765333 6.506667 20.693333 13.098667 33.493333 6.698667 13.024 14.976 24.682667 24.117333 31.210667a10.666667 10.666667 0 0 1-12.394666 17.354667c-13.258667-9.461333-23.434667-24.693333-30.688-38.794667a198.133333 198.133333 0 0 1-14.762667-37.834667 10.666667 10.666667 0 0 1 7.594667-13.024zM358.293333 635.68a10.666667 10.666667 0 0 1 13.013334 7.605333c2.048 7.754667 6.517333 20.693333 13.12 33.493334 6.688 13.013333 14.965333 24.672 24.106666 31.210666A10.666667 10.666667 0 1 1 396.138667 725.333333c-13.258667-9.472-23.434667-24.704-30.688-38.794666a198.122667 198.122667 0 0 1-14.762667-37.834667 10.666667 10.666667 0 0 1 7.594667-13.034667zM314.08 695.893333a10.666667 10.666667 0 0 1 13.493333 6.752c2.528 7.616 7.818667 20.234667 15.210667 32.597334 7.52 12.565333 16.522667 23.658667 26.069333 29.6a10.666667 10.666667 0 0 1-11.274666 18.112c-13.834667-8.597333-24.96-23.146667-33.098667-36.757334a198.272 198.272 0 0 1-17.152-36.810666 10.666667 10.666667 0 0 1 6.752-13.493334zM443.626667 523.733333a10.666667 10.666667 0 0 1 13.013333 7.594667 177.066667 177.066667 0 0 0 13.12 33.493333c6.688 13.013333 14.965333 24.672 24.106667 31.2a10.666667 10.666667 0 0 1-12.394667 17.365334c-13.258667-9.472-23.434667-24.704-30.688-38.794667a198.154667 198.154667 0 0 1-14.762667-37.834667 10.666667 10.666667 0 0 1 7.594667-13.034666zM479.381333 464.426667a10.666667 10.666667 0 0 1 13.034667 7.605333c2.037333 7.765333 6.506667 20.693333 13.098667 33.504 6.698667 13.013333 14.976 24.672 24.106666 31.2a10.666667 10.666667 0 0 1-12.394666 17.365333c-13.248-9.472-23.424-24.704-30.677334-38.805333a198.154667 198.154667 0 0 1-14.762666-37.834667 10.666667 10.666667 0 0 1 7.594666-13.024z" fill="#EFB31C" ></path><path d="M430.901333 234.24l363.349334-82.517333a42.666667 42.666667 0 0 1 51.765333 36.138666l46.890667 362.613334c3.050667 23.552-13.728 45.013333-37.472 45.013333-77.653333 0-204.298667-18.538667-307.733334-93.589333-103.872-75.370667-139.146667-170.496-146.528-228.896-2.368-18.730667 11.306667-34.592 29.728-38.773334z" fill="#CA3737" ></path><path d="M426.176 213.429333l363.349333-82.506666a64 64 0 0 1 77.653334 54.197333l46.890666 362.624c4.48 34.72-20.469333 69.077333-58.634666 69.077333-80.149333 0-211.84-18.986667-320.256-97.653333-109.216-79.253333-147.136-179.968-155.168-243.488-4.021333-31.861333 19.392-56.170667 46.165333-62.250667z m368.074667-61.706666l-363.349334 82.506666c-18.410667 4.181333-32.096 20.042667-29.728 38.773334 7.381333 58.4 42.656 153.525333 146.528 228.896 103.434667 75.050667 230.08 93.589333 307.733334 93.589333 23.744 0 40.522667-21.461333 37.472-45.013333l-46.890667-362.613334a42.666667 42.666667 0 0 0-51.765333-36.138666z" fill="#730606" ></path><path d="M800 592.618667c20.234667 2.026667 38.933333 2.88 55.434667 2.88 23.744 0 40.522667-21.472 37.472-45.013334l-46.890667-362.624a42.453333 42.453333 0 0 0-14.517333-26.901333l-0.085334 1.749333-29.578666 420.170667a42.698667 42.698667 0 0 1-1.824 9.738667z" fill="#B32D2D" ></path><path d="M445.333333 265.333333l353.333334-86.666666-277.333334 245.333333c-52.266667-37.333333-72.448-121.333333-76-158.666667z" fill="#EC4747" ></path><path d="M695.093333 228.042667a16 16 0 0 1-9.802666 20.394666L544.64 297.770667a16 16 0 1 1-10.592-30.197334l140.672-49.333333a16 16 0 0 1 20.384 9.802667z" fill="#FF9B9B" ></path><path d="M447.925333 216.362667a10.666667 10.666667 0 0 1 13.045334 7.562666l0.117333 0.426667c14.613333 54.869333 41.642667 156.48 155.178667 226.570667 110.357333 68.117333 212.458667 72.128 267.146666 69.088a10.666667 10.666667 0 0 1 1.173334 21.312c-57.312 3.178667-164.224-1.066667-279.52-72.245334-120.768-74.549333-149.674667-183.157333-164.490667-238.858666l-0.213333-0.810667a10.666667 10.666667 0 0 1 7.562666-13.045333z" fill="#F6D04D" ></path><path d="M524.512 204.757333a10.666667 10.666667 0 0 1 13.056 7.573334l0.074667 0.288c11.456 43.061333 32.522667 122.208 121.024 176.842666 86.24 53.226667 166.005333 56.362667 208.725333 53.984a10.666667 10.666667 0 1 1 1.173333 21.301334c-45.333333 2.517333-129.92-0.853333-221.109333-57.130667-95.733333-59.093333-118.656-145.248-130.325333-189.130667l-0.181334-0.672a10.666667 10.666667 0 0 1 7.562667-13.056z" fill="#F6D04D" ></path><path d="M616.341333 186.090667a10.666667 10.666667 0 0 1 13.045334 7.573333l0.042666 0.16c8.341333 31.338667 23.477333 88.213333 87.146667 127.52 62.336 38.485333 119.957333 40.736 150.816 39.018667a10.666667 10.666667 0 1 1 1.173333 21.301333c-33.472 1.866667-95.904-0.64-163.189333-42.165333-70.901333-43.765333-87.893333-107.637333-96.458667-139.818667l-0.149333-0.533333a10.666667 10.666667 0 0 1 7.573333-13.056z" fill="#F6D04D" ></path><path d="M694.869333 168.362667a10.666667 10.666667 0 0 1 13.056 7.562666v0.021334c5.248 19.68 14.474667 54.346667 53.408 78.378666 38.496 23.776 74.048 25.152 93.066667 24.096a10.666667 10.666667 0 0 1 1.184 21.301334c-21.653333 1.205333-62.016-0.426667-105.461333-27.242667-46.165333-28.490667-57.248-70.165333-62.709334-90.666667l-0.106666-0.405333a10.666667 10.666667 0 0 1 7.573333-13.045333zM768.853333 158.165333a10.666667 10.666667 0 0 1 13.045334 7.562667c2.154667 8.085333 5.546667 20.565333 19.765333 29.344a60.608 60.608 0 0 0 35.605333 9.237333 10.666667 10.666667 0 1 1 1.173334 21.301334 81.941333 81.941333 0 0 1-47.978667-12.373334c-21.546667-13.301333-26.741333-32.874667-29.109333-41.770666l-0.064-0.256a10.666667 10.666667 0 0 1 7.562666-13.045334z" fill="#F6D04D" ></path></symbol><symbol id="icon-shengdanshu" viewBox="0 0 1024 1024"><path d="M469.333333 778.666667a10.666667 10.666667 0 0 1 10.666667-10.666667h64a10.666667 10.666667 0 0 1 10.666667 10.666667v113.546666c0 2.453333-0.874667 4.832-2.912 6.176C546.986667 901.536 535.573333 906.666667 512 906.666667s-34.986667-5.130667-39.754667-8.277334c-2.037333-1.354667-2.912-3.733333-2.912-6.176V778.666667z" fill="#884723" ></path><path d="M480 746.666667h64a32 32 0 0 1 32 32v113.546666c0 6.965333-2.56 17.418667-12.501333 23.989334C554.432 922.176 538.656 928 512 928c-26.666667 0-42.421333-5.824-51.498667-11.797333C450.56 909.632 448 899.168 448 892.213333V778.666667a32 32 0 0 1 32-32z m0 21.333333a10.666667 10.666667 0 0 0-10.666667 10.666667v113.546666c0 2.453333 0.874667 4.832 2.912 6.176 4.768 3.146667 16.170667 8.277333 39.754667 8.277334s34.986667-5.130667 39.754667-8.277334c2.037333-1.354667 2.912-3.733333 2.912-6.176V778.666667a10.666667 10.666667 0 0 0-10.666667-10.666667h-64z" fill="#602606" ></path><path d="M480.330667 816a10.666667 10.666667 0 0 1 10.666666 10.666667v63.338666a10.666667 10.666667 0 1 1-21.333333 0V826.666667a10.666667 10.666667 0 0 1 10.666667-10.666667z" fill="#9C5A36" ></path><path d="M234.666667 778.698667c65.866667-49.642667 222.997333-275.818667 293.333333-382.698667C622.688 561.493333 763.008 720.085333 821.333333 778.698667c-238.784 115.84-490.602667 48.277333-586.666666 0z" fill="#6DB859" ></path><path d="M528.661333 374.677333a21.333333 21.333333 0 0 1 17.856 10.730667c93.44 163.317333 232.405333 320.426667 289.941334 378.24a21.333333 21.333333 0 0 1-5.813334 34.24c-246.698667 119.690667-505.792 50.005333-605.557333-0.128a21.333333 21.333333 0 0 1-3.264-36.096c14.357333-10.816 35.2-32.586667 60.245333-62.4 24.704-29.386667 52.426667-65.269333 80.437334-103.146667 56.021333-75.712 112.661333-158.645333 147.669333-211.84a21.333333 21.333333 0 0 1 18.485333-9.6zM234.666667 778.698667c6.485333 3.264 13.685333 6.613333 21.546666 9.984 105.141333 45.152 328.192 94.88 544.544-0.458667A620.117333 620.117333 0 0 0 821.333333 778.698667c-4.714667-4.736-9.973333-10.133333-15.701333-16.138667-62.101333-65.098667-179.402667-201.418667-265.632-346.026667-4.074667-6.826667-8.074667-13.674667-12-20.533333-4.106667 6.24-8.501333 12.874667-13.162667 19.861333-68.789333 103.2-194.282667 282.112-262.645333 347.637334A200.586667 200.586667 0 0 1 234.666667 778.698667z" fill="#3B8327" ></path><path d="M491.381333 841.418667c100.970667 5.866667 216.917333-7.882667 329.952-62.72-58.325333-58.613333-198.645333-217.205333-293.333333-382.698667a4768 4768 0 0 1-44.693333 66.581333C573.834667 602.592 685.568 728.021333 736 778.709333c-82.293333 39.925333-166.133333 58.069333-244.618667 62.72z" fill="#58A245" ></path><path d="M693.813333 764.874667c0 5.856-5.034667 10.602667-11.232 10.602666-6.186667 0-11.221333-4.746667-11.221333-10.602666 0-5.866667 5.024-10.602667 11.221333-10.602667 6.197333 0 11.232 4.746667 11.232 10.602667zM664.437333 739.456c0 3.573333-3.050667 6.453333-6.826666 6.453333-3.776 0-6.826667-2.88-6.826667-6.453333 0-3.562667 3.050667-6.453333 6.826667-6.453333 3.765333 0 6.826667 2.890667 6.826666 6.453333zM575.914667 760.725333c0 3.562667-3.061333 6.453333-6.826667 6.453334-3.786667 0-6.837333-2.890667-6.837333-6.453334 0-3.562667 3.050667-6.453333 6.826666-6.453333 3.776 0 6.826667 2.88 6.826667 6.453333zM525.653333 810.912c0 3.573333-3.050667 6.453333-6.826666 6.453333-3.765333 0-6.826667-2.88-6.826667-6.453333 0-3.562667 3.061333-6.453333 6.826667-6.453333 3.776 0 6.826667 2.890667 6.826666 6.453333zM630.186667 764.874667c0 5.856-5.013333 10.602667-11.221334 10.602666-6.186667 0-11.221333-4.746667-11.221333-10.602666 0-5.866667 5.024-10.602667 11.221333-10.602667 6.208 0 11.232 4.746667 11.232 10.602667zM591.530667 810.912c0 5.866667-5.024 10.602667-11.232 10.602667-6.186667 0-11.221333-4.746667-11.221334-10.602667 0-5.856 5.024-10.602667 11.221334-10.602667 6.208 0 11.232 4.746667 11.232 10.602667zM747.584 733.013333c0 3.882667-3.328 7.029333-7.445333 7.029334-4.106667 0-7.445333-3.157333-7.445334-7.04 0-3.882667 3.338667-7.04 7.445334-7.04 4.117333 0 7.445333 3.157333 7.445333 7.04zM716.586667 708.64c0 8.874667-7.616 16.064-17.002667 16.064-9.386667 0-17.002667-7.189333-17.002667-16.064 0-8.864 7.616-16.053333 17.002667-16.053333 9.386667 0 17.002667 7.189333 17.002667 16.053333zM761.92 768.266667c0 8.874667-7.616 16.064-17.002667 16.064-9.386667 0-17.002667-7.189333-17.002666-16.064s7.616-16.064 17.002666-16.064c9.386667 0 17.002667 7.189333 17.002667 16.064zM667.776 794.848c0 8.874667-7.605333 16.064-17.002667 16.064-9.386667 0-16.992-7.189333-16.992-16.053333 0-8.874667 7.605333-16.064 16.992-16.064s17.002667 7.189333 17.002667 16.053333z" fill="#458634" ></path><path d="M416.874667 597.184a10.666667 10.666667 0 0 1 4.608 14.357333c-39.061333 75.957333-99.221333 145.28-124.608 170.666667a10.666667 10.666667 0 0 1-15.082667-15.082667c24.394667-24.394667 82.986667-91.957333 120.725333-165.333333a10.666667 10.666667 0 0 1 14.357334-4.608z" fill="#7BD264" ></path><path d="M281.333333 592.064c52.394667-39.264 177.386667-218.186667 233.333334-302.730667 75.317333 130.912 186.944 256.373333 233.333333 302.730667-189.941333 91.637333-390.250667 38.186667-466.666667 0z" fill="#72CC52" ></path><path d="M515.328 268.010667a21.333333 21.333333 0 0 1 17.834667 10.688c74.069333 128.736 184.32 252.704 229.92 298.282666a21.333333 21.333333 0 0 1-5.813334 34.304c-197.824 95.434667-405.376 39.893333-485.472-0.138666a21.333333 21.333333 0 0 1-3.264-36.149334c10.986667-8.234667 27.285333-25.109333 47.2-48.682666 19.562667-23.146667 41.557333-51.445333 63.818667-81.365334 44.501333-59.818667 89.514667-125.354667 117.333333-167.392a21.333333 21.333333 0 0 1 18.453334-9.546666z m-233.994667 324.053333c6.389333 3.2 13.642667 6.496 21.685334 9.813333 84.661333 34.858667 256.597333 71.168 424.277333-0.405333 6.912-2.944 13.813333-6.08 20.704-9.408a896.213333 896.213333 0 0 1-15.722667-16.149333c-49.536-52.085333-138.698667-155.786667-205.546666-266.176a1054.112 1054.112 0 0 1-12.064-20.405334c-4.053333 6.122667-8.458667 12.736-13.184 19.754667-54.090667 80.469333-148.661333 214.229333-202.794667 267.637333-6.4 6.314667-12.224 11.498667-17.354667 15.338667z" fill="#3B8327" ></path><path d="M388.512 628.192c96.522667 21.418667 230.4 26.154667 359.488-36.128-46.4-46.357333-158.016-171.818667-233.333333-302.730667a3673.205333 3673.205333 0 0 1-30.005334 44.565334C556.373333 443.626667 644.192 541.632 684 581.408c-102.506667 49.461333-208.042667 56.661333-295.488 46.794667z" fill="#5DA744" ></path><path d="M631.637333 574.421333c0 4.778667-4.096 8.64-9.152 8.64-5.066667 0-9.162667-3.861333-9.162666-8.64 0-4.778667 4.096-8.650667 9.162666-8.650666 5.056 0 9.152 3.872 9.152 8.64zM607.68 553.685333c0 2.901333-2.496 5.258667-5.578667 5.258667-3.072 0-5.568-2.346667-5.568-5.258667s2.496-5.269333 5.568-5.269333c3.082667 0 5.578667 2.357333 5.578667 5.269333zM535.445333 571.029333c0 2.912-2.496 5.269333-5.568 5.269334-3.082667 0-5.578667-2.357333-5.578666-5.269334 0-2.901333 2.496-5.258667 5.578666-5.258666 3.072 0 5.568 2.346667 5.568 5.258666zM494.453333 611.978667c0 2.912-2.496 5.269333-5.578666 5.269333-3.072 0-5.568-2.357333-5.568-5.269333 0-2.901333 2.496-5.258667 5.568-5.258667 3.082667 0 5.578667 2.346667 5.578666 5.258667zM579.733333 574.421333c0 4.778667-4.096 8.64-9.152 8.64s-9.162667-3.861333-9.162666-8.64c0-4.778667 4.106667-8.650667 9.162666-8.650666s9.152 3.872 9.152 8.64zM548.192 611.978667c0 4.778667-4.106667 8.650667-9.162667 8.650666s-9.152-3.872-9.152-8.64c0-4.789333 4.096-8.661333 9.152-8.661333s9.162667 3.872 9.162667 8.650667zM675.52 548.416c0 3.168-2.730667 5.738667-6.08 5.738667-3.36 0-6.08-2.56-6.08-5.738667 0-3.168 2.72-5.738667 6.08-5.738667 3.349333 0 6.08 2.570667 6.08 5.738667zM650.218667 528.533333c0 7.253333-6.208 13.12-13.866667 13.12-7.658667 0-13.866667-5.866667-13.866667-13.12 0-7.232 6.208-13.098667 13.866667-13.098666 7.658667 0 13.866667 5.866667 13.866667 13.109333zM687.210667 577.184c0 7.242667-6.218667 13.109333-13.866667 13.109333-7.669333 0-13.866667-5.866667-13.866667-13.109333 0-7.232 6.197333-13.098667 13.866667-13.098667 7.658667 0 13.866667 5.866667 13.866667 13.098667zM610.4 598.88c0 7.232-6.208 13.098667-13.866667 13.098667-7.658667 0-13.866667-5.866667-13.866666-13.098667 0-7.242667 6.197333-13.109333 13.866666-13.109333 7.658667 0 13.866667 5.866667 13.866667 13.109333z" fill="#4A9736" ></path><path d="M466.08 411.285333a10.666667 10.666667 0 0 1 4.608 14.368c-39.072 75.946667-99.232 145.28-124.618667 170.666667a10.666667 10.666667 0 1 1-15.082666-15.093333c24.394667-24.394667 82.986667-91.946667 120.725333-165.333334a10.666667 10.666667 0 0 1 14.368-4.608z" fill="#8BF26F" ></path><path d="M328 392.672c42.666667-32 144.448-177.781333 190.005333-246.677333 61.333333 106.666667 152.213333 208.896 189.994667 246.677333-154.666667 74.666667-317.781333 31.104-380 0z" fill="#82E360" ></path><path d="M518.666667 124.672a21.333333 21.333333 0 0 1 17.824 10.698667c60.085333 104.490667 149.610667 205.226667 186.592 242.208a21.333333 21.333333 0 0 1-5.802667 34.304c-162.56 78.464-332.906667 32.821333-398.826667-0.138667a21.333333 21.333333 0 0 1-3.253333-36.149333c8.554667-6.4 21.568-19.850667 37.781333-39.04 15.861333-18.784 33.706667-41.770667 51.818667-66.112 36.181333-48.672 72.789333-102.005333 95.402667-136.213334a21.333333 21.333333 0 0 1 18.453333-9.557333zM328 392.672c6.261333 3.125333 13.546667 6.389333 21.76 9.632 69.578667 27.605333 204.821333 54.677333 337.461333-0.32 6.933333-2.88 13.866667-5.973333 20.778667-9.312a764.661333 764.661333 0 0 1-15.68-16.202667c-40.245333-42.730667-109.333333-123.658667-162.24-210.112a872.554667 872.554667 0 0 1-12.085333-20.362666 2706.773333 2706.773333 0 0 1-13.173334 19.744c-43.413333 64.405333-116.053333 166.954667-159.722666 211.445333-6.378667 6.506667-12.138667 11.765333-17.098667 15.488z" fill="#3B8327" ></path><path d="M381.76 413.376c78.976 23.754667 205.194667 37.728 326.24-20.704-37.781333-37.781333-128.672-140.010667-190.005333-246.677333-5.546667 8.394667-11.925333 17.92-18.933334 28.245333 59.093333 91.84 133.12 174.613333 166.272 207.754667-101.098667 48.810667-205.802667 47.104-283.584 31.381333z" fill="#70CA4F" ></path><path d="M628.117333 377.813333c0 3.552-3.050667 6.432-6.816 6.432-3.754667 0-6.805333-2.88-6.805333-6.432 0-3.552 3.04-6.432 6.805333-6.432 3.765333 0 6.816 2.88 6.816 6.432zM610.293333 362.389333a4.032 4.032 0 0 1-4.149333 3.925334 4.032 4.032 0 0 1-4.138667-3.925334c0-2.154667 1.856-3.914667 4.138667-3.914666 2.293333 0 4.149333 1.76 4.149333 3.914666zM556.586667 375.296a4.032 4.032 0 0 1-4.16 3.914667 4.032 4.032 0 0 1-4.138667-3.914667c0-2.165333 1.856-3.914667 4.149333-3.914667 2.282667 0 4.138667 1.749333 4.138667 3.914667zM526.090667 405.749333a4.032 4.032 0 0 1-4.149334 3.914667 4.032 4.032 0 0 1-4.138666-3.914667c0-2.165333 1.856-3.914667 4.138666-3.914666 2.293333 0 4.149333 1.749333 4.149334 3.914666zM589.514667 377.813333c0 3.552-3.050667 6.432-6.816 6.432-3.754667 0-6.805333-2.88-6.805334-6.432 0-3.552 3.050667-6.432 6.816-6.432 3.754667 0 6.805333 2.88 6.805334 6.432zM566.058667 405.749333c0 3.552-3.050667 6.432-6.816 6.432-3.765333 0-6.805333-2.88-6.805334-6.432 0-3.552 3.04-6.432 6.805334-6.432 3.765333 0 6.816 2.88 6.816 6.432zM660.736 358.474667c0 2.357333-2.026667 4.266667-4.512 4.266666a4.394667 4.394667 0 0 1-4.522667-4.266666c0-2.346667 2.026667-4.266667 4.522667-4.266667 2.496 0 4.512 1.92 4.512 4.266667zM641.930667 343.690667c0 5.386667-4.618667 9.749333-10.314667 9.749333s-10.314667-4.362667-10.314667-9.738667c0-5.386667 4.618667-9.749333 10.314667-9.749333s10.314667 4.362667 10.314667 9.738667zM669.44 379.872c0 5.386667-4.618667 9.749333-10.314667 9.749333s-10.314667-4.373333-10.314666-9.749333c0-5.386667 4.618667-9.749333 10.314666-9.749333s10.314667 4.373333 10.314667 9.749333zM612.32 396c0 5.386667-4.618667 9.749333-10.314667 9.749333s-10.314667-4.373333-10.314666-9.749333 4.618667-9.738667 10.314666-9.738667 10.314667 4.362667 10.314667 9.738667z" fill="#5CA848" ></path><path d="M512.106667 200.618667a10.666667 10.666667 0 0 1 4.618666 14.357333c-39.072 75.957333-99.232 145.28-124.618666 170.666667a10.666667 10.666667 0 0 1-15.082667-15.082667c24.394667-24.394667 82.986667-91.957333 120.725333-165.333333a10.666667 10.666667 0 0 1 14.368-4.608z" fill="#C4FFB0" ></path><path d="M641.717333 412.181333a35.434667 35.434667 0 1 1-70.869333 0 35.434667 35.434667 0 0 1 70.869333 0z" fill="#ED3333" ></path><path d="M663.050667 412.181333a56.768 56.768 0 1 1-113.536 0 56.768 56.768 0 0 1 113.536 0z m-56.768 35.434667a35.434667 35.434667 0 1 0 0-70.869333 35.434667 35.434667 0 0 0 0 70.869333z" fill="#9D0C0C" ></path><path d="M451.584 338.72a27.434667 27.434667 0 1 1-54.869333 0 27.434667 27.434667 0 0 1 54.869333 0z" fill="#ED3333" ></path><path d="M472.917333 338.72a48.768 48.768 0 1 1-97.536 0 48.768 48.768 0 0 1 97.536 0z m-48.768 27.434667a27.434667 27.434667 0 1 0 0-54.869334 27.434667 27.434667 0 0 0 0 54.869334z" fill="#9D0C0C" ></path><path d="M432.149333 515.434667a35.434667 35.434667 0 1 1-70.88 0 35.434667 35.434667 0 0 1 70.88 0z" fill="#ED3333" ></path><path d="M453.482667 515.434667a56.768 56.768 0 1 1-113.546667 0 56.768 56.768 0 0 1 113.546667 0z m-56.778667 35.434666a35.434667 35.434667 0 1 0 0-70.869333 35.434667 35.434667 0 0 0 0 70.88z" fill="#9D0C0C" ></path><path d="M709.12 619.338667a43.029333 43.029333 0 1 1-86.069333 0 43.029333 43.029333 0 0 1 86.069333 0z" fill="#ED3333" ></path><path d="M730.453333 619.338667a64.362667 64.362667 0 1 1-128.736 0 64.362667 64.362667 0 0 1 128.736 0z m-64.373333 43.029333a43.029333 43.029333 0 1 0 0-86.069333 43.029333 43.029333 0 0 0 0 86.069333z" fill="#9D0C0C" ></path><path d="M576.405333 775.210667a35.434667 35.434667 0 1 1-70.869333 0 35.434667 35.434667 0 0 1 70.869333 0z" fill="#ED3333" ></path><path d="M597.738667 775.210667a56.768 56.768 0 1 1-113.536 0 56.768 56.768 0 0 1 113.536 0z m-56.768 35.434666a35.434667 35.434667 0 1 0 0-70.869333 35.434667 35.434667 0 0 0 0 70.869333z" fill="#9D0C0C" ></path><path d="M352.213333 714.997333a35.434667 35.434667 0 1 1-70.88 0 35.434667 35.434667 0 0 1 70.88 0z" fill="#ED3333" ></path><path d="M373.546667 714.997333a56.768 56.768 0 1 1-113.546667 0 56.768 56.768 0 0 1 113.546667 0z m-56.778667 35.434667a35.434667 35.434667 0 1 0 0-70.869333 35.434667 35.434667 0 0 0 0 70.869333z" fill="#9D0C0C" ></path><path d="M587.616 244.085333a25.312 25.312 0 1 1-50.624 0 25.312 25.312 0 0 1 50.624 0z" fill="#ED3333" ></path><path d="M608.949333 244.085333a46.645333 46.645333 0 1 1-93.290666 0 46.645333 46.645333 0 0 1 93.290666 0z m-46.645333 25.312a25.312 25.312 0 1 0 0-50.624 25.312 25.312 0 0 0 0 50.624z" fill="#9D0C0C" ></path><path d="M606.282667 386.805333a12.138667 12.138667 0 1 1-24.288 0 12.138667 12.138667 0 0 1 24.288 0zM424.149333 322.133333a12.138667 12.138667 0 1 1-24.288 0 12.138667 12.138667 0 0 1 24.288 0zM566.816 225.472a12.138667 12.138667 0 1 1-24.288 0 12.138667 12.138667 0 0 1 24.288 0zM396.704 492.629333a12.138667 12.138667 0 1 1-24.277333 0 12.138667 12.138667 0 0 1 24.277333 0zM666.08 593.002667a15.669333 15.669333 0 1 1-31.328 0 15.669333 15.669333 0 0 1 31.328 0zM540.970667 769.194667a12.138667 12.138667 0 1 1-24.288 0 12.138667 12.138667 0 0 1 24.288 0zM312.298667 685.194667a12.138667 12.138667 0 1 1-24.277334 0 12.138667 12.138667 0 0 1 24.277334 0z" fill="#FF8989" ></path><path d="M469.376 102.154667l31.84-6.282667 9.621333-16.064 9.632-16.064 18.912 32.330667 31.776 6.613333-25.589333 25.653333 6.186667 32.266667-31.712-16.288-31.893334 15.946667 6.528-32.192-25.301333-25.92z" fill="#FFE24B" ></path><path d="M501.216 95.872l19.253333-32.128 18.912 32.330667 31.776 6.613333-25.589333 25.653333 6.186667 32.266667-31.712-16.288-31.893334 15.946667 6.528-32.192-25.301333-25.92 31.84-6.282667z m-18.112 35.616l-21.365333-21.888a10.666667 10.666667 0 0 1 5.568-17.92l27.2-5.354667 16.810666-28.064a10.666667 10.666667 0 0 1 18.357334 0.106667l16.522666 28.234667 27.125334 5.653333a10.666667 10.666667 0 0 1 5.386666 17.973333l-21.6 21.653334 5.12 26.72a10.666667 10.666667 0 0 1-15.338666 11.498666l-26.912-13.824-27.061334 13.536a10.666667 10.666667 0 0 1-15.221333-11.669333l5.408-26.666667z" fill="#D97D11" ></path></symbol><symbol id="icon-xuehua" viewBox="0 0 1024 1024"><path d="M888.650667 639.637333a16 16 0 0 1-12.682667 18.741334l-72.117333 13.909333 17.28 64.490667a16 16 0 0 1-30.912 8.277333l-21.728-81.088a16 16 0 0 1 12.426666-19.84l88.992-17.173333a16 16 0 0 1 18.741334 12.693333zM249.728 338.346667a16 16 0 0 1-9.344 18.922666l-69.226667 28.576a16 16 0 0 1-12.213333-29.578666l56.245333-23.221334-16.426666-61.28a16 16 0 0 1 30.912-8.277333l20.053333 74.848zM817.482667 251.968a16 16 0 0 1 9.813333 20.384l-24.277333 69.333333 64.426666 17.514667a16 16 0 1 1-8.394666 30.88l-81.013334-22.037333a16 16 0 0 1-10.901333-20.725334l29.962667-85.546666a16 16 0 0 1 20.384-9.813334zM235.594667 652.48a16 16 0 0 1 11.648 17.6l-10.133334 74.197333a16 16 0 0 1-31.712-4.330666l8.245334-60.288-61.226667-16.64a16 16 0 1 1 8.405333-30.88l74.773334 20.330666zM443.754667 118.901333a16 16 0 0 1 22.570666 1.610667l48.106667 55.509333 47.210667-47.210666a16 16 0 1 1 22.624 22.634666l-59.36 59.36a16 16 0 0 1-23.402667-0.842666l-59.36-68.48a16 16 0 0 1 1.6-22.581334zM502.282667 822.869333a16 16 0 0 1 21.066666-1.365333l59.36 45.664a16 16 0 1 1-19.52 25.365333l-48.213333-37.098666-44.864 44.864a16 16 0 1 1-22.624-22.634667l54.794667-54.794667z" fill="#75C4FE" ></path><path d="M901.28 727.573333a21.333333 21.333333 0 0 1-29.141333 7.808L140.565333 313.013333a21.333333 21.333333 0 1 1 21.333334-36.949333l731.573333 422.368a21.333333 21.333333 0 0 1 7.808 29.141333z" fill="#43AEFC" ></path><path d="M864.533333 566.496a21.333333 21.333333 0 0 1-13.226666 27.114667L736 633.28l14.336 118.890667a21.333333 21.333333 0 0 1-42.368 5.098666l-16.384-136a21.333333 21.333333 0 0 1 14.24-22.72l131.594667-45.290666a21.333333 21.333333 0 0 1 27.114666 13.226666zM342.4 389.706667a21.333333 21.333333 0 0 1-12.896 22.677333l-111.210667 46.506667a21.333333 21.333333 0 1 1-16.458666-39.36l96.010666-40.16-16.362666-115.733334a21.333333 21.333333 0 1 1 42.24-5.973333l18.677333 132.053333zM899.84 285.301333a21.333333 21.333333 0 0 1-7.925333 29.109334L158.773333 734.048a21.333333 21.333333 0 0 1-21.194666-37.024L870.72 277.376a21.333333 21.333333 0 0 1 29.12 7.914667z" fill="#43AEFC" ></path><path d="M742.154667 235.989333a21.333333 21.333333 0 0 1 16.768 25.077334l-23.733334 119.605333 109.952 47.456a21.333333 21.333333 0 1 1-16.906666 39.168l-125.770667-54.272a21.333333 21.333333 0 0 1-12.48-23.744l27.093333-136.512a21.333333 21.333333 0 0 1 25.066667-16.778667zM326.634667 598.24A21.333333 21.333333 0 0 1 339.733333 620.8l-15.765333 119.509333a21.333333 21.333333 0 1 1-42.304-5.578666l13.621333-103.178667-108.256-44.106667a21.333333 21.333333 0 0 1 16.106667-39.509333l123.498667 50.314667zM513.6 64a21.333333 21.333333 0 0 1 21.333333 21.333333v844.746667a21.333333 21.333333 0 1 1-42.666666 0V85.333333a21.333333 21.333333 0 0 1 21.333333-21.333333z" fill="#43AEFC" ></path><path d="M392.469333 176.362667a21.333333 21.333333 0 0 1 30.101334-2.101334l92.010666 80 95.797334-71.84a21.333333 21.333333 0 0 1 25.6 34.133334L526.4 298.752a21.333333 21.333333 0 0 1-26.794667-0.970667l-105.024-91.328a21.333333 21.333333 0 0 1-2.101333-30.090666zM500.448 716.928a21.333333 21.333333 0 0 1 26.069333-0.170667l95.893334 73.066667a21.333333 21.333333 0 0 1-25.856 33.930667l-82.784-63.072-92.053334 72.042666a21.333333 21.333333 0 1 1-26.293333-33.6l105.024-82.197333z" fill="#43AEFC" ></path><path d="M388.16 295.530667a21.333333 21.333333 0 0 1 19.2-1.696l107.274667 42.912 116.181333-34.421334a21.333333 21.333333 0 0 1 27.082667 16.8l17.045333 98.026667 77.034667 72.757333a21.333333 21.333333 0 0 1-0.426667 31.413334l-81.866667 73.258666-30.378666 121.493334a21.333333 21.333333 0 0 1-29.194667 14.4L512.448 688l-106.506667 34.08a21.333333 21.333333 0 0 1-27.776-18.688l-8.309333-107.978667-100.448-62.773333a21.333333 21.333333 0 0 1-1.493333-35.157333l101.866666-76.394667 8.384-109.088a21.333333 21.333333 0 0 1 9.994667-16.48z m30.325333 48.704l-6.912 89.770666a21.333333 21.333333 0 0 1-8.469333 15.424l-84.693333 63.530667 83.2 52a21.333333 21.333333 0 0 1 9.962666 16.448l7.061334 91.818667 88.458666-28.309334a21.333333 21.333333 0 0 1 15.008 0.757334l81.92 35.626666 25.856-103.424a21.333333 21.333333 0 0 1 6.474667-10.730666l69.461333-62.144-65.312-61.696a21.333333 21.333333 0 0 1-6.378666-11.850667l-14.154667-81.418667-100.32 29.717334a21.333333 21.333333 0 0 1-13.973333-0.64l-87.189334-34.88z" fill="#43AEFC" ></path><path d="M513.216 343.306667a16 16 0 0 1 14.517333 8.512l36.085334 68.16 85.248-8.106667a16 16 0 0 1 15.498666 23.690667l-40.928 73.664 40.256 60.373333a16 16 0 0 1-13.312 24.885333h-85.76l-36.768 77.6a16 16 0 0 1-28.938666-0.032l-32.714667-69.525333-73.290667-8.149333a16 16 0 0 1-11.552-24.768l39.744-59.626667-48.874666-73.312a16 16 0 0 1 14.901333-24.8l80.074667 8.010667 31.712-67.392a16 16 0 0 1 14.101333-9.173334z m1.216 51.786666l-22.890667 48.64a16 16 0 0 1-16.074666 9.12l-57.642667-5.76 36.021333 54.016a16 16 0 0 1 0 17.76l-31.072 46.613334 56.053334 6.229333a16 16 0 0 1 12.714666 9.088l22.101334 46.965333 26.581333-56.138666a16 16 0 0 1 14.464-9.141334h65.994667l-29.077334-43.626666a16 16 0 0 1-0.672-16.64l30.890667-55.605334-65.621333 6.24a16 16 0 0 1-15.658667-8.437333l-26.112-49.322667z" fill="#75C4FE" ></path></symbol><symbol id="icon-shengdanmaozi" viewBox="0 0 1024 1024"><path d="M543.808 241.386667a103.04 103.04 0 0 1-103.04 103.04 103.04 103.04 0 1 1 0-206.090667c56.906667 0 103.04 46.133333 103.04 103.04z" fill="#D6FDFF" ></path><path d="M565.141333 241.386667c0 68.693333-55.68 124.373333-124.373333 124.373333s-124.373333-55.68-124.373333-124.373333 55.68-124.384 124.373333-124.384 124.373333 55.68 124.373333 124.373333z m-124.373333 103.04a103.04 103.04 0 1 0 0-206.090667 103.04 103.04 0 0 0 0 206.08z" fill="#32CDD5" ></path><path d="M456.938667 343.157333c49.226667-7.754667 86.869333-50.368 86.869333-101.781333 0-56.906667-46.133333-103.04-103.04-103.04a102.592 102.592 0 0 0-48.170667 11.925333c5.269333-0.832 10.666667-1.258667 16.170667-1.258666 56.906667 0 103.04 46.133333 103.04 103.04a103.04 103.04 0 0 1-54.869333 91.114666z" fill="#C2EDF0" ></path><path d="M405.653333 194.666667a17.664 17.664 0 1 1-35.328 0 17.664 17.664 0 0 1 35.338667 0z" fill="#FFFFFF" ></path><path d="M541.194667 273.578667c200.938667 41.216 272.64 304.842667 283.370666 431.498666l-598.933333 25.76c21.461333-169.6 114.624-498.474667 315.562667-457.258666z" fill="#3AAAFB" ></path><path d="M847.701333 725.44l-1.877333-22.165333c-5.546667-65.450667-26.72-165.834667-72.618667-255.690667-45.824-89.706667-118.24-172.448-227.733333-194.901333-56.874667-11.669333-106.453333 3.125333-148.053333 33.973333-40.928 30.357333-73.92 76.021333-100.234667 126.656-52.672 101.290667-81.813333 228.608-92.725333 314.848l-3.178667 25.066667 646.421333-27.797334z m-23.136-20.373333l-598.933333 25.770666a917.333333 917.333333 0 0 1 2.976-21.482666c26.250667-174.293333 119.84-475.306667 312.586667-435.776 190.282667 39.04 264.672 277.493333 281.141333 410.24 0.917333 7.434667 1.664 14.538667 2.24 21.258666z" fill="#0B6BB2" ></path><path d="M432.544 324a16 16 0 0 1-1.888 22.549333c-28 23.68-92.842667 99.914667-118.08 208.085334a16 16 0 1 1-31.168-7.264c27.029333-115.84 96.138667-197.813333 128.586667-225.258667a16 16 0 0 1 22.549333 1.888z" fill="#6ED3FF" ></path><path d="M232.554667 685.162667a977.493333 977.493333 0 0 0-6.933334 45.674666l298.869334-12.853333-291.946667-32.821333z m472.768 25.045333l119.253333-5.130667c-10.741333-126.656-82.453333-390.282667-283.381333-431.498666a164.714667 164.714667 0 0 0-44.608-3.178667c173.952 69.866667 211.498667 306.24 208.736 439.808z" fill="#2697E9" ></path><path d="M539.402667 387.392a10.666667 10.666667 0 0 1-3.466667 14.688c-27.797333 17.173333-60.992 50.933333-91.637333 87.082667-30.432 35.904-57.525333 73.173333-73.109334 96.437333a10.666667 10.666667 0 1 1-17.728-11.872c15.978667-23.84 43.552-61.76 74.56-98.357333 30.805333-36.341333 65.824-72.362667 96.693334-91.445334a10.666667 10.666667 0 0 1 14.688 3.466667zM634.069333 435.392a10.666667 10.666667 0 0 1-3.466666 14.688c-27.786667 17.173333-54.826667 45.269333-79.125334 75.530667-23.072 28.725333-43.136 58.709333-58.666666 81.92l-2.293334 3.413333a10.666667 10.666667 0 1 1-17.717333-11.882667l2.368-3.541333c15.488-23.125333 36.010667-53.792 59.68-83.264 24.8-30.890667 53.653333-61.226667 84.533333-80.32a10.666667 10.666667 0 0 1 14.688 3.456z" fill="#198FE5" ></path><path d="M307.669333 499.221333a10.666667 10.666667 0 0 1 11.104-10.208c44.277333 1.856 112.970667 21.333333 177.269334 46.453334 40.682667 15.893333 80.618667 34.432 112.256 52.874666 7.594667-11.306667 14.634667-21.184 22.88-30.485333 14.154667-15.968 31.701333-30.154667 61.546666-48.597333a10.666667 10.666667 0 0 1 11.210667 18.144c-28.832 17.824-44.512 30.752-56.8 44.608-7.349333 8.298667-13.546667 16.96-20.650667 27.52 10.496 6.869333 19.605333 13.642667 26.933334 20.170666a10.666667 10.666667 0 1 1-14.186667 15.925334c-6.549333-5.834667-14.837333-11.978667-24.533333-18.314667-1.738667 2.645333-3.573333 5.408-5.514667 8.288a10.666667 10.666667 0 1 1-17.717333-11.872c1.738667-2.592 3.413333-5.12 5.034666-7.573333-29.813333-17.269333-68.096-35.146667-108.224-50.816-63.818667-24.928-129.792-43.306667-170.4-45.013334a10.666667 10.666667 0 0 1-10.208-11.104z" fill="#198FE5" ></path><path d="M389.674667 407.914667a10.666667 10.666667 0 0 1 13.749333-6.229334c71.978667 27.104 238.389333 97.781333 324.021333 162.816a10.666667 10.666667 0 0 1-12.906666 16.992c-82.890667-62.954667-246.613333-132.725333-318.634667-159.84a10.666667 10.666667 0 0 1-6.229333-13.738666zM483.157333 352.885333a10.666667 10.666667 0 0 1 13.952-5.728c28.906667 12.106667 73.685333 32.448 114.293334 54.250667 20.298667 10.890667 39.733333 22.250667 55.68 33.205333 15.594667 10.72 29.034667 21.845333 36.117333 32.469334a10.666667 10.666667 0 0 1-17.749333 11.84c-4.64-6.976-15.072-16.149333-30.464-26.730667-15.04-10.346667-33.738667-21.290667-53.674667-32-39.861333-21.386667-84-41.450667-112.437333-53.354667a10.666667 10.666667 0 0 1-5.717334-13.952z" fill="#198FE5" ></path><path d="M156.992 756.597333a64.405333 64.405333 0 0 1 64.405333-64.405333h618.261334a64.405333 64.405333 0 1 1 0 128.810667H221.397333a64.405333 64.405333 0 0 1-64.405333-64.405334z" fill="#FF5E8E" ></path><path d="M221.397333 670.858667h618.261334a85.738667 85.738667 0 0 1 0 171.477333H221.397333a85.738667 85.738667 0 1 1 0-171.477333z m0 21.333333a64.405333 64.405333 0 1 0 0 128.810667h618.261334a64.405333 64.405333 0 1 0 0-128.810667H221.397333z" fill="#B91E4C" ></path><path d="M202.325333 797.002667a16 16 0 0 1 16-16h614.666667a16 16 0 1 1 0 32H218.325333a16 16 0 0 1-16-16z" fill="#E34172" ></path><path d="M481.664 705.664a16 16 0 0 1 16 16v70.005333a16 16 0 1 1-32 0v-70.005333a16 16 0 0 1 16-16zM403.658667 705.664a16 16 0 0 1 16 16v70.005333a16 16 0 1 1-32 0v-70.005333a16 16 0 0 1 16-16zM322.325333 705.664a16 16 0 0 1 16 16v70.005333a16 16 0 1 1-32 0v-70.005333a16 16 0 0 1 16-16zM258.986667 709.002667a16 16 0 0 1 16 16v69.994666a16 16 0 1 1-32 0V725.013333a16 16 0 0 1 16-16zM204.330667 719.669333a16 16 0 0 1 16 16v37.994667a16 16 0 1 1-32 0V735.68a16 16 0 0 1 16-16zM554.325333 705.664a16 16 0 0 1 16 16v70.005333a16 16 0 1 1-32 0v-70.005333a16 16 0 0 1 16-16zM636.992 705.6a16 16 0 0 1 16 16v70.005333a16 16 0 1 1-32 0V721.6a16 16 0 0 1 16-16zM705.664 705.6a16 16 0 0 1 16 16v70.005333a16 16 0 1 1-32 0V721.6a16 16 0 0 1 16-16zM787.658667 705.664a16 16 0 0 1 16 16v70.005333a16 16 0 1 1-32 0v-70.005333a16 16 0 0 1 16-16zM852.992 710.997333a16 16 0 0 1 16 16v48.672a16 16 0 1 1-32 0v-48.672a16 16 0 0 1 16-16z" fill="#FF97B6" ></path></symbol><symbol id="icon-xueren" viewBox="0 0 1024 1024"><path d="M112.138667 317.888a16 16 0 0 1 17.973333-13.749333l80 10.666666a16 16 0 0 1 9.92 5.333334l149.333333 170.666666a16 16 0 0 1-24.074666 21.066667L199.925333 345.728l-74.037333-9.866667a16 16 0 0 1-13.749333-17.973333z" fill="#B05F31" ></path><path d="M219.786667 218.730667a10.666667 10.666667 0 0 1 9.493333 11.722666l-10.666667 101.333334a10.666667 10.666667 0 1 1-21.226666-2.24l10.666666-101.333334a10.666667 10.666667 0 0 1 11.733334-9.493333z" fill="#B05F31" ></path><path d="M780.341333 760.778667c-4.021333 145.034667-125.44 195.232-273.397333 191.136-147.946667-4.106667-266.410667-60.949333-262.4-205.973334 4.021333-145.034667 127.221333-259.285333 275.178667-255.189333 147.946667 4.106667 264.64 125.002667 260.618666 270.026667z" fill="#D0F0F2" ></path><path d="M708.746667 930.474667c-54.336 33.205333-126.421333 44.864-202.389334 42.762666-75.978667-2.112-147.306667-17.738667-199.722666-53.909333-53.738667-37.088-85.610667-94.485333-83.413334-173.984 4.362667-157.216 137.76-280.330667 297.088-275.914667 159.338667 4.416 285.717333 134.730667 281.354667 291.946667-2.197333 79.498667-37.205333 135.04-92.917333 169.098667z m-201.813334 21.44c147.968 4.096 269.386667-46.101333 273.408-191.136 4.021333-145.024-112.661333-265.92-260.618666-270.026667-147.946667-4.096-271.146667 110.144-275.178667 255.178667-4.010667 145.034667 114.442667 201.877333 262.4 205.973333z" fill="#5290BD" ></path><path d="M349.482667 598.730667a21.333333 21.333333 0 0 1-2.218667 30.08c-12.245333 10.581333-23.808 31.477333-29.824 59.36-5.92 27.392-5.888 59.018667 2.432 88.746666a21.333333 21.333333 0 0 1-41.077333 11.498667c-10.346667-36.938667-10.314667-75.637333-3.061334-109.248 7.146667-33.12 21.92-63.893333 43.669334-82.656a21.333333 21.333333 0 0 1 30.08 2.218667z" fill="#DFFDFF" ></path><path d="M479.637333 950.517333c120.458667-9.717333 211.893333-64.213333 215.370667-189.738666 3.701333-133.365333-94.677333-246.325333-225.578667-266.816a274.752 274.752 0 0 1 50.293334-3.2c147.946667 4.096 264.64 124.992 260.618666 270.016-4.021333 145.034667-125.44 195.232-273.397333 191.136a577.450667 577.450667 0 0 1-27.306667-1.386667z" fill="#A6E1E5" ></path><path d="M705.386667 722.848a11.424 11.424 0 1 1-22.858667 0 11.424 11.424 0 0 1 22.848 0zM751.637333 749.696a15.424 15.424 0 1 1-30.837333 0 15.424 15.424 0 0 1 30.837333 0zM743.925333 699.573333a11.562667 11.562667 0 1 1-23.125333 0 11.562667 11.562667 0 0 1 23.125333 0zM753.333333 815.946667a23.989333 23.989333 0 1 1-47.978666 0 23.989333 23.989333 0 0 1 47.978666 0zM705.386667 772.821333a15.424 15.424 0 1 1-30.848 0 15.424 15.424 0 0 1 30.837333 0zM712.661333 865.92a9.354667 9.354667 0 1 1-18.709333 0 9.354667 9.354667 0 0 1 18.709333 0zM680.224 895.338667a15.424 15.424 0 1 1-30.837333 0 15.424 15.424 0 0 1 30.837333 0zM682.528 842.784a15.424 15.424 0 1 1-30.837333 0 15.424 15.424 0 0 1 30.837333 0zM625.984 916.32a11.562667 11.562667 0 1 1-23.125333 0 11.562667 11.562667 0 0 1 23.125333 0z" fill="#81CFD2" ></path><path d="M714.666667 476.672c0 86.186667-76.565333 145.994667-197.333334 145.994667S320 562.858667 320 476.661333C320 390.485333 396.565333 330.666667 517.333333 330.666667S714.666667 390.474667 714.666667 476.672z" fill="#D0F0F2" ></path><path d="M674.101333 599.04C635.221333 628.266667 581.013333 644.010667 517.333333 644.010667c-63.669333 0-117.898667-15.744-156.768-44.96C321.205333 569.482667 298.666667 526.784 298.666667 476.672c0-50.112 22.538667-92.810667 61.898666-122.389333C399.445333 325.088 453.653333 309.333333 517.333333 309.333333c63.669333 0 117.898667 15.744 156.768 44.96C713.461333 383.850667 736 426.56 736 476.661333c0 50.112-22.538667 92.810667-61.898667 122.389334zM517.333333 622.677333c120.768 0 197.333333-59.808 197.333334-146.005333C714.666667 390.485333 638.101333 330.666667 517.333333 330.666667S320 390.474667 320 476.672c0 86.186667 76.565333 145.994667 197.333333 145.994667z" fill="#5290BD" ></path><path d="M435.178667 377.952a21.333333 21.333333 0 0 1-14.4 26.506667c-23.04 6.816-45.226667 41.418667-32.533334 79.466666a21.333333 21.333333 0 1 1-40.48 13.482667c-19.328-57.952 11.829333-119.349333 60.906667-133.866667a21.333333 21.333333 0 0 1 26.506667 14.4z" fill="#DFFDFF" ></path><path d="M474.666667 619.989333C570.517333 607.488 629.333333 552.213333 629.333333 476.661333c0-75.541333-58.816-130.816-154.666666-143.317333a330.026667 330.026667 0 0 1 42.666666-2.677333C638.101333 330.666667 714.666667 390.474667 714.666667 476.672c0 86.186667-76.565333 145.994667-197.333334 145.994667a330.026667 330.026667 0 0 1-42.666666-2.666667z" fill="#A5E1E4" ></path><path d="M654.005333 227.669333c0 84.810667-53.034667 143.658667-136.672 143.658667s-136.672-58.848-136.672-143.658667c0-84.821333 53.034667-143.669333 136.672-143.669333s136.672 58.848 136.672 143.669333z" fill="#D0F0F2" ></path><path d="M632.597333 345.888c-28.170667 30.08-68.202667 46.784-115.264 46.784-47.061333 0-87.093333-16.704-115.264-46.784-28.042667-29.930667-42.741333-71.381333-42.741333-118.218667 0-46.848 14.698667-88.298667 42.741333-118.229333 28.170667-30.08 68.202667-46.773333 115.264-46.773333 47.061333 0 87.093333 16.693333 115.264 46.773333 28.042667 29.930667 42.741333 71.381333 42.741334 118.229333 0 46.837333-14.698667 88.288-42.741334 118.218667zM517.333333 371.338667c83.637333 0 136.672-58.858667 136.672-143.68 0-84.8-53.034667-143.658667-136.672-143.658667s-136.672 58.848-136.672 143.669333c0 84.810667 53.034667 143.658667 136.672 143.658667z" fill="#5290BD" ></path><path d="M474.666667 359.882667c83.637333 0 136.672-58.848 136.672-143.68 0-61.685333-28.064-109.653333-75.562667-131.2 72.917333 8.053333 118.229333 64.266667 118.229333 142.666666 0 84.810667-53.034667 143.658667-136.672 143.658667-22.794667 0-43.317333-4.373333-61.12-12.448 5.973333 0.661333 12.128 1.002667 18.453334 1.002667z" fill="#A5E1E4" ></path><path d="M570.848 183.125333c4.192 16.618667-5.632 33.44-21.973333 37.568-16.32 4.128-32.96-6.005333-37.162667-22.624-4.202667-16.618667 5.632-33.44 21.962667-37.568 16.32-4.128 32.96 6.005333 37.173333 22.613334z" fill="#074894" ></path><path d="M591.530667 177.898667c6.997333 27.690667-9.322667 56.373333-37.418667 63.466666-28.096 7.114667-56.085333-10.368-63.082667-38.069333-6.997333-27.690667 9.322667-56.373333 37.418667-63.477333 28.096-7.104 56.074667 10.378667 63.082667 38.08z m-42.645334 42.794666c16.32-4.128 26.165333-20.949333 21.962667-37.568-4.202667-16.618667-20.853333-26.752-37.173333-22.613333-16.330667 4.117333-26.165333 20.938667-21.973334 37.557333 4.213333 16.618667 20.853333 26.752 37.184 22.613334z" fill="#F7FFFF" ></path><path d="M482.986667 188.416c-2.272 12.544-13.717333 20.96-25.557334 18.805333-11.84-2.144-19.584-14.048-17.301333-26.592 2.272-12.533333 13.717333-20.949333 25.546667-18.805333 11.84 2.154667 19.594667 14.058667 17.312 26.592z" fill="#074894" ></path><path d="M503.978667 192.234667c-4.170667 22.976-25.813333 40.437333-50.357334 35.978666-24.554667-4.458667-38.656-28.416-34.485333-51.392 4.170667-22.976 25.813333-40.448 50.346667-35.989333 24.554667 4.458667 38.666667 28.426667 34.496 51.402667z m-46.549334 14.986666c11.84 2.154667 23.285333-6.261333 25.557334-18.805333 2.282667-12.533333-5.472-24.437333-17.312-26.592-11.84-2.144-23.274667 6.272-25.546667 18.805333-2.282667 12.544 5.472 24.448 17.301333 26.592z" fill="#F7FFFF" ></path><path d="M851.509333 266.954667a21.333333 21.333333 0 0 1 17.536 24.554666l-16 96a21.333333 21.333333 0 0 1-8.554666 13.781334l-192 138.666666a21.333333 21.333333 0 0 1-24.981334-34.581333L812.394667 371.84l14.56-87.349333a21.333333 21.333333 0 0 1 24.554666-17.536z" fill="#8E4323" ></path><path d="M816 394.666667a16 16 0 0 1 16-16h96a16 16 0 0 1 0 32h-96a16 16 0 0 1-16-16z" fill="#8E4323" ></path><path d="M840.885333 297.418667a5.333333 5.333333 0 0 1 4.277334 6.208l-13.994667 76a5.333333 5.333333 0 0 1-2.069333 3.328l-105.333334 77.994666a5.333333 5.333333 0 0 1-6.357333-8.565333l103.648-76.757333 13.621333-73.92a5.333333 5.333333 0 0 1 6.208-4.288z" fill="#C15B30" ></path><path d="M458.133333 456.266667c-5.194667 17.28-21.706667 27.573333-36.864 23.008-15.157333-4.554667-23.232-22.261333-18.026666-39.541334 5.194667-17.28 21.706667-27.573333 36.864-23.008 15.157333 4.554667 23.232 22.261333 18.026666 39.541334z" fill="#08DDAA" ></path><path d="M478.570667 462.410667c-7.818667 25.973333-34.581333 45.984-63.445334 37.301333-28.874667-8.693333-40.128-40.149333-32.32-66.133333 7.818667-25.962667 34.581333-45.973333 63.445334-37.28 28.874667 8.682667 40.138667 40.149333 32.32 66.112z m-57.301334 16.874666c15.168 4.554667 31.669333-5.749333 36.864-23.018666 5.205333-17.28-2.869333-34.986667-18.026666-39.541334-15.157333-4.565333-31.669333 5.738667-36.864 23.008-5.205333 17.28 2.869333 34.986667 18.026666 39.552z" fill="#EEFEFF" ></path><path d="M408.853333 689.6c-1.013333 18.026667-14.645333 31.904-30.453333 31.018667-15.808-0.885333-27.808-16.202667-26.805333-34.208 1.013333-18.016 14.645333-31.893333 30.453333-31.018667 15.808 0.885333 27.797333 16.202667 26.794667 34.208z" fill="#08DDAA" ></path><path d="M430.144 690.794667c-1.514667 27.072-22.826667 52.8-52.928 51.125333-30.101333-1.674667-48.426667-29.621333-46.912-56.704 1.504-27.072 22.826667-52.8 52.928-51.125333 30.101333 1.674667 48.426667 29.621333 46.912 56.704z m-51.733333 29.824c15.797333 0.885333 29.429333-13.002667 30.432-31.018667 1.002667-18.005333-10.986667-33.322667-26.794667-34.208-15.808-0.885333-29.44 13.002667-30.453333 31.018667-1.002667 18.016 10.997333 33.322667 26.805333 34.208z" fill="#EEFEFF" ></path><path d="M520.832 235.306667c-12.8-21.866667-34.837333-16.288-44.64-10.730667-40.32 26.058667-95.466667 72.661333-106.048 80.853333-14.976 11.626667-4.725333 22.933333 6.112 20.8 10.325333-2.026667 92.373333-22.229333 142.826667-50.346666 9.152-5.109333 13.6-20.309333 1.749333-40.565334z" fill="#E58B04" ></path><path d="M470.666667 215.445333l0.266666-0.149333c6.208-3.52 16.277333-7.125333 27.274667-6.272 11.68 0.896 23.594667 6.826667 31.829333 20.906667 13.162667 22.485333 11.146667 45.834667-5.76 55.264-26.197333 14.602667-60.16 26.933333-88.458666 35.818666-28.362667 8.896-51.84 14.570667-57.493334 15.68-9.077333 1.792-19.658667-1.738667-24.309333-10.858666-5.386667-10.56 0.117333-21.482667 9.6-28.832 1.888-1.461333 5.482667-4.394667 10.346667-8.362667 20.501333-16.704 63.466667-51.712 96.448-73.024l0.256-0.16z m5.525333 9.130667c9.802667-5.546667 31.84-11.146667 44.64 10.741333 11.850667 20.256 7.402667 35.456-1.76 40.565334-50.432 28.117333-132.490667 48.32-142.816 50.346666-10.837333 2.133333-21.088-9.173333-6.112-20.8 2.090667-1.610667 5.930667-4.746667 11.061333-8.917333 20.768-16.928 62.645333-51.04 94.986667-71.936z" fill="#B36013" ></path><path d="M468.053333 230.986667c1.962667-2.336 5.578667-3.136 8.064-1.792 10.016 5.397333 30.282667 22.346667 33.514667 48.405333 0.32 2.613333-1.973333 5.258667-5.130667 5.92-3.157333 0.661333-5.984-0.917333-6.304-3.530667-2.826667-22.762667-20.821333-37.824-29.194666-42.336-2.496-1.344-2.922667-4.330667-0.96-6.666666zM434.88 257.653333c2.005333-2.304 5.632-3.061333 8.085333-1.674666 4.341333 2.442667 10.528 7.146667 15.616 13.546666s9.333333 14.837333 9.098667 24.725334c-0.053333 2.677333-2.677333 5.12-5.856 5.461333-3.168 0.341333-5.696-1.557333-5.632-4.234667 0.170667-7.466667-3.050667-14.208-7.434667-19.733333a48.106667 48.106667 0 0 0-13.056-11.392c-2.464-1.386667-2.826667-4.373333-0.821333-6.698667zM400.234667 281.962667c2.026667-2.304 5.653333-3.04 8.096-1.632 3.253333 1.856 7.786667 5.376 11.488 10.197333 3.701333 4.821333 6.794667 11.221333 6.506666 18.805333-0.096 2.677333-2.752 5.098667-5.92 5.408-3.178667 0.309333-5.664-1.621333-5.568-4.298666 0.192-5.184-1.92-9.898667-4.917333-13.792a32.469333 32.469333 0 0 0-8.917333-7.978667c-2.453333-1.397333-2.794667-4.394667-0.768-6.709333z" fill="#E16002" ></path><path d="M477.450667 230.218667a5.333333 5.333333 0 0 1-1.056 7.466666l-95.018667 71.509334a5.333333 5.333333 0 0 1-6.410667-8.533334l95.018667-71.498666a5.333333 5.333333 0 0 1 7.466667 1.056z" fill="#FFB444" ></path></symbol><symbol id="icon-shengdanxiaoniu" viewBox="0 0 1024 1024"><path d="M349.386667 113.12a21.333333 21.333333 0 0 1-9.536 28.629333c-28.096 14.037333-93.728 79.466667-64.32 226.517334 6.261333 31.285333 29.152 61.866667 57.386666 87.829333 27.893333 25.653333 58.304 44.352 74.784 52.309333a21.333333 21.333333 0 0 1-18.549333 38.432c-20.096-9.706667-54.026667-30.741333-85.12-59.338666-30.730667-28.266667-61.450667-66.453333-70.336-110.858667-32.650667-163.285333 39.466667-249.248 87.072-273.056a21.333333 21.333333 0 0 1 28.618667 9.536z" fill="#DA844B" ></path><path d="M350.506667 117.898667a10.666667 10.666667 0 0 1-4.757334 14.304c-32.970667 16.490667-100.234667 87.04-70.005333 238.154666 6.912 34.56 31.765333 67.04 60.629333 93.589334 28.693333 26.389333 59.978667 45.674667 77.365334 54.08a10.666667 10.666667 0 1 1-9.28 19.2c-19.2-9.269333-52.245333-29.717333-82.528-57.578667-30.112-27.690667-58.88-63.978667-67.104-105.098667-31.850667-159.232 38.656-240.064 81.386666-261.418666a10.666667 10.666667 0 0 1 14.293334 4.768z" fill="#BD6B34" ></path><path d="M139.882667 410.773333a21.333333 21.333333 0 0 1 27.221333-13.013333c8.874667 3.125333 25.664 7.264 45.024 8.469333 19.445333 1.205333 39.744-0.661333 56.789333-7.968a21.333333 21.333333 0 1 1 16.810667 39.210667c-25.344 10.869333-52.981333 12.778667-76.234667 11.338667-23.349333-1.450667-44.032-6.389333-56.597333-10.826667a21.333333 21.333333 0 0 1-13.013333-27.210667zM358.773333 245.941333a21.333333 21.333333 0 0 1 14.784 26.293334c-4.981333 17.781333-15.904 43.989333-33.248 65.877333-17.248 21.76-43.744 42.592-79.381333 40.501333a21.333333 21.333333 0 1 1 2.506667-42.592c15.84 0.928 30.346667-7.893333 43.434666-24.416 13.002667-16.405333 21.76-37.12 25.6-50.88a21.333333 21.333333 0 0 1 26.304-14.784z" fill="#DA844B" ></path><path d="M159.754667 200.117333a21.333333 21.333333 0 0 1 24.981333 16.917334c2.741333 14.261333 9.962667 35.914667 22.058667 53.408 12.053333 17.450667 26.56 27.690667 44.032 27.690666a21.333333 21.333333 0 1 1 0 42.666667c-37.013333 0-62.88-22.56-79.146667-46.101333-16.234667-23.509333-25.28-51.061333-28.842667-69.6a21.333333 21.333333 0 0 1 16.917334-24.981334zM336.789333 189.866667a21.333333 21.333333 0 0 1 2.005334 30.112c-5.994667 6.848-16.298667 15.872-29.290667 22.88-13.013333 7.04-30.357333 12.906667-49.674667 10.762666a21.333333 21.333333 0 1 1 4.714667-42.410666c7.925333 0.885333 16.437333-1.429333 24.693333-5.888 8.266667-4.469333 14.613333-10.208 17.450667-13.44a21.333333 21.333333 0 0 1 30.101333-2.016z" fill="#DA844B" ></path><path d="M229.493333 127.146667a21.333333 21.333333 0 0 1 21.333334 21.333333c0 4.170667 0.608 11.733333 2.432 19.285333 1.962667 8.106667 4.586667 12.938667 6.464 14.826667a21.333333 21.333333 0 0 1-30.176 30.165333c-10.229333-10.24-15.178667-24.32-17.749334-34.944a131.306667 131.306667 0 0 1-3.626666-29.333333 21.333333 21.333333 0 0 1 21.333333-21.333333z" fill="#DA844B" ></path><path d="M278.314667 161.237333a10.666667 10.666667 0 0 1 4.448 14.410667c-11.818667 22.389333-37.365333 83.274667-30.144 162.72a10.666667 10.666667 0 0 1-21.237334 1.930667c-7.712-84.821333 19.456-149.888 32.522667-174.613334a10.666667 10.666667 0 0 1 14.410667-4.448z" fill="#FAA973" ></path><path d="M663.2 113.12a21.333333 21.333333 0 0 0 9.536 28.629333c28.096 14.037333 93.728 79.466667 64.32 226.517334-6.261333 31.285333-29.152 61.866667-57.386667 87.829333-27.893333 25.653333-58.304 44.352-74.784 52.309333a21.333333 21.333333 0 0 0 18.549334 38.432c20.096-9.706667 54.026667-30.741333 85.12-59.338666 30.730667-28.266667 61.450667-66.453333 70.336-110.858667 32.650667-163.285333-39.466667-249.248-87.072-273.056a21.333333 21.333333 0 0 0-28.618667 9.536z" fill="#DA844B" ></path><path d="M683.413333 117.898667a10.666667 10.666667 0 0 0 4.757334 14.304c32.970667 16.490667 100.234667 87.04 70.005333 238.154666-6.912 34.56-31.765333 67.04-60.618667 93.589334-28.693333 26.389333-59.989333 45.674667-77.376 54.08a10.666667 10.666667 0 0 0 9.28 19.2c19.2-9.269333 52.245333-29.717333 82.528-57.578667 30.122667-27.690667 58.88-63.978667 67.104-105.098667 31.850667-159.232-38.656-240.064-81.386666-261.418666a10.666667 10.666667 0 0 0-14.293334 4.768z" fill="#BD6B34" ></path><path d="M872.704 410.773333a21.333333 21.333333 0 0 0-27.221333-13.013333c-8.874667 3.125333-25.664 7.264-45.024 8.469333-19.445333 1.205333-39.744-0.661333-56.789334-7.968a21.333333 21.333333 0 0 0-16.810666 39.210667c25.344 10.869333 52.981333 12.778667 76.245333 11.338667 23.338667-1.450667 44.021333-6.4 56.586667-10.826667a21.333333 21.333333 0 0 0 13.013333-27.210667zM653.813333 245.941333a21.333333 21.333333 0 0 0-14.784 26.293334c4.981333 17.781333 15.904 43.989333 33.248 65.877333 17.248 21.76 43.744 42.592 79.381334 40.501333a21.333333 21.333333 0 0 0-2.506667-42.592c-15.84 0.928-30.346667-7.893333-43.434667-24.405333-13.002667-16.416-21.76-37.12-25.6-50.88a21.333333 21.333333 0 0 0-26.304-14.794667z" fill="#DA844B" ></path><path d="M852.832 200.117333a21.333333 21.333333 0 0 0-24.981333 16.917334c-2.741333 14.261333-9.962667 35.914667-22.048 53.408-12.053333 17.450667-26.56 27.690667-44.053334 27.690666a21.333333 21.333333 0 1 0 0 42.666667c37.013333 0 62.890667-22.56 79.146667-46.101333 16.245333-23.509333 25.290667-51.061333 28.853333-69.6a21.333333 21.333333 0 0 0-16.917333-24.981334zM675.797333 179.2a21.333333 21.333333 0 0 0-2.005333 30.112c5.994667 6.848 16.298667 15.872 29.290667 22.88 13.013333 7.04 30.357333 12.906667 49.674666 10.762667a21.333333 21.333333 0 0 0-4.714666-42.410667c-7.925333 0.885333-16.437333-1.429333-24.682667-5.888-8.277333-4.469333-14.624-10.208-17.461333-13.44a21.333333 21.333333 0 0 0-30.101334-2.016z" fill="#DA844B" ></path><path d="M772.426667 116.48a21.333333 21.333333 0 0 0-21.333334 21.333333c0 4.170667-0.597333 11.733333-2.432 19.285334-1.962667 8.106667-4.586667 12.938667-6.464 14.826666a21.333333 21.333333 0 1 0 30.176 30.165334c10.229333-10.24 15.178667-24.32 17.76-34.944 2.709333-11.2 3.626667-22.165333 3.626667-29.333334a21.333333 21.333333 0 0 0-21.333333-21.333333z" fill="#DA844B" ></path><path d="M186.496 523.84c81.749333-54.506667 170.304-17.664 204.373333 7.573333 30.272 24.213333 22.698667 50.453333 15.136 60.544-105.973333 30.282667-190.506667-32.8-219.52-68.117333z" fill="#944F21" ></path><path d="M403.882667 514.496l0.309333 0.245333c19.04 15.242667 28.16 32.949333 29.685333 50.389334 1.450667 16.618667-4.213333 30.826667-10.805333 39.626666l-4.309333 5.738667-6.901334 1.973333c-117.290667 33.514667-209.888-36.181333-241.856-75.093333l-14.954666-18.218667 19.605333-13.066666c92.544-61.696 191.424-19.594667 228.906667 8.170666l0.32 0.234667z m-217.386667 9.344c3.968 4.821333 8.96 10.176 14.933333 15.733333 37.6 35.093333 113.088 78.517333 204.576 52.384 7.573333-10.090667 15.136-36.330667-15.146666-60.554666-31.466667-23.306667-109.472-56.533333-185.632-18.453334a174.08 174.08 0 0 0-18.730667 10.88z" fill="#652E0A" ></path><path d="M614.154667 527.626667c84.778667-75.701333 199.328-31.541333 246.005333 0-6.304 13.866667-34.069333 46.933333-94.613333 68.117333-60.554667 21.194667-126.154667-1.258667-151.392-15.146667v-52.970666z" fill="#944F21" ></path><path d="M887.04 520.042667l-7.466667 16.405333c-9.312 20.490667-42.464 56.853333-106.986666 79.434667-34.698667 12.149333-70.133333 11.573333-99.626667 6.464-29.44-5.098667-54.389333-14.965333-69.088-23.04l-11.050667-6.08v-75.157334l7.125334-6.357333c48.106667-42.954667 104.629333-51.530667 154.090666-45.482667 48.96 6.005333 92.426667 26.389333 118.069334 43.712l14.933333 10.101334z m-36.864 22.357333c5.024-5.909333 8.288-11.04 9.984-14.784-46.677333-31.530667-161.226667-75.690667-246.005333 0v52.992c25.237333 13.866667 90.837333 36.330667 151.392 15.146667 41.856-14.656 68.032-34.976 82.293333-50.709334 0.821333-0.896 1.6-1.781333 2.336-2.645333z" fill="#652E0A" ></path><path d="M806.144 538.325333a10.666667 10.666667 0 0 0-10.197333-11.125333 409.877333 409.877333 0 0 0-68.842667 3.328c-25.813333 3.541333-53.696 10.368-71.626667 23.722667a10.666667 10.666667 0 0 0 12.736 17.109333c13.290667-9.898667 36.458667-16.213333 61.781334-19.690667a388.650667 388.650667 0 0 1 65.024-3.157333 10.666667 10.666667 0 0 0 11.125333-10.186667zM239.488 532.864a10.666667 10.666667 0 0 1 12.309333-8.714667 409.813333 409.813333 0 0 1 66.592 17.824c24.469333 8.917333 50.272 21.493333 64.981334 38.346667a10.666667 10.666667 0 1 1-16.074667 14.026667c-10.890667-12.48-32.192-23.573333-56.213333-32.32a388.682667 388.682667 0 0 0-62.890667-16.853334 10.666667 10.666667 0 0 1-8.704-12.309333z" fill="#BD6B34" ></path><path d="M527.104 425.44c-207.52 0-200.576 243.477333-170.304 314.122667 102.186667 15.146667 310.336 38.602667 325.482667 11.349333 18.922667-34.058667 79.466667-325.472-155.168-325.472z" fill="#B3642F" ></path><path d="M341.888 758.922667l-4.693333-10.954667c-8.885333-20.725333-15.296-51.882667-17.045334-86.208-1.76-34.613333 1.141333-74.133333 12.16-111.754667s30.485333-74.314667 62.538667-101.653333c32.362667-27.594667 75.914667-44.245333 132.266667-44.245333 63.434667 0 109.514667 19.882667 141.205333 52.544 31.178667 32.128 46.24 74.389333 52.554667 115.52 6.325333 41.237333 4.128 83.072-0.746667 116.586666a389.088 389.088 0 0 1-8.853333 43.914667c-3.093333 11.541333-6.645333 21.941333-10.346667 28.608-3.584 6.453333-8.981333 10.410667-13.333333 12.821333-4.458667 2.474667-9.344 4.16-14.016 5.397334-9.322667 2.453333-20.693333 3.84-32.896 4.565333-24.576 1.472-56.256 0.554667-89.888-1.642667-67.488-4.405333-145.696-14.133333-197.12-21.76l-11.786667-1.738666z m14.912-19.36c-30.272-70.645333-37.216-314.133333 170.304-314.133334 234.656 0 174.101333 291.424 155.178667 325.482667-15.146667 27.253333-223.296 3.786667-325.482667-11.349333z" fill="#7A3C12" ></path><path d="M354.816 734.581333c108.512 14.336 271.466667 29.653333 284.8 5.664 16.533333-29.781333 64.917333-256.32-80.053333-312.768 196.352 25.941333 140.714667 291.050667 122.72 323.434667-15.146667 27.253333-223.296 3.786667-325.482667-11.349333a111.690667 111.690667 0 0 1-1.984-4.981334z" fill="#A75822" ></path><path d="M454.133333 463.072a16 16 0 0 1-3.2 22.4c-15.253333 11.434667-51.050667 50.069333-61.888 106.229333a16 16 0 1 1-31.424-6.069333c12.629333-65.44 53.813333-110.538667 74.112-125.76a16 16 0 0 1 22.4 3.2z" fill="#CB7941" ></path><path d="M508.181333 569.258667c0 20.906667-13.546667 37.845333-30.272 37.845333s-30.282667-16.949333-30.282666-37.845333c0-20.906667 13.557333-37.845333 30.282666-37.845334s30.272 16.938667 30.272 37.845334zM606.581333 569.258667c0 20.906667-13.546667 37.845333-30.272 37.845333s-30.272-16.949333-30.272-37.845333c0-20.906667 13.546667-37.845333 30.272-37.845334s30.272 16.938667 30.272 37.845334z" fill="#6B310A" ></path><path d="M342.24 679.008c60.554667-57.525333 128.682667-23.968 155.168 0h105.973333c140.032-64.341333 177.877333 45.418667 105.973334 151.381333-71.914667 105.973333-234.645333 98.4-298.986667 64.341334-64.341333-34.058667-143.818667-143.818667-68.128-215.722667z" fill="#FFEFB9" ></path><path d="M497.408 679.008h105.973333c140.032-64.341333 177.877333 45.418667 105.973334 151.381333-71.914667 105.973333-234.645333 98.4-298.986667 64.341334-64.341333-34.058667-143.818667-143.818667-68.128-215.722667 60.554667-57.525333 128.682667-23.968 155.168 0z m101.386667-21.333333H505.173333c-16.213333-12.757333-40.736-26.026667-69.397333-30.325334-33.930667-5.098667-72.832 2.56-108.224 36.192-22.528 21.397333-34.133333 46.4-36.864 72.501334-2.677333 25.664 3.338667 51.04 13.674667 73.824 20.437333 45.056 59.733333 84.512 96.021333 103.722666 36.832 19.498667 98.197333 30.165333 159.242667 22.656 61.461333-7.552 126.826667-34.112 167.381333-93.866666 19.36-28.544 31.818667-58.016 36.8-85.6 4.96-27.370667 2.773333-54.368-9.28-76.234667-12.48-22.666667-34.24-37.365333-62.624-41.077333-26.453333-3.466667-57.781333 2.602667-93.109333 18.208z" fill="#CBB56B" ></path><path d="M371.306667 680.213333a10.666667 10.666667 0 0 1 0.469333 15.082667c-8.373333 8.917333-18.218667 27.328-17.845333 52.309333 0.373333 24.714667 10.805333 56.832 44.544 93.130667a10.666667 10.666667 0 1 1-15.616 14.528c-36.661333-39.434667-49.792-76.426667-50.261334-107.338667-0.458667-30.634667 11.552-54.368 23.626667-67.221333a10.666667 10.666667 0 0 1 15.072-0.48z" fill="#FFF7DD" ></path><path d="M402.517333 890.24c2.634667 1.621333 5.258667 3.114667 7.850667 4.490667 64.341333 34.058667 227.072 41.632 298.986667-64.341334 50.848-74.944 46.816-151.776-9.44-167.584 34.922667 27.594667 31.52 92.949333-11.893334 156.928-67.306667 99.2-214.229333 98.901333-285.504 70.506667z m80.992-221.898667a135.178667 135.178667 0 0 0-24.661333-12.778666c6.826667 4.202667 12.650667 8.64 17.226667 12.778666h7.434666z" fill="#F1DE9D" ></path><path d="M636.864 716.853333c0 52.256-50.837333 109.76-113.536 109.76-62.709333 0-113.546667-57.504-113.546667-109.76 0-52.256 50.837333-87.04 113.546667-87.04 62.698667 0 113.536 34.784 113.536 87.04z" fill="#D94A1D" ></path><path d="M618.826667 806.282667c-23.850667 24.266667-57.493333 41.664-95.498667 41.664-38.016 0-71.658667-17.397333-95.498667-41.664-23.68-24.085333-39.381333-56.672-39.381333-89.429334 0-33.813333 16.704-61.589333 41.888-80.256 24.853333-18.421333 57.92-28.128 92.992-28.128 35.072 0 68.138667 9.706667 92.981333 28.128 25.194667 18.666667 41.888 46.453333 41.888 80.256 0 32.757333-15.701333 65.344-39.370666 89.429334z m-95.498667 20.330666c62.698667 0 113.536-57.504 113.536-109.76 0-52.256-50.837333-87.04-113.536-87.04-62.709333 0-113.546667 34.784-113.546667 87.04s50.837333 109.76 113.546667 109.76z" fill="#953416" ></path><path d="M539.434667 678.634667c6.218667 22.528-9.888 46.645333-35.968 53.834666-26.090667 7.2-52.277333-5.226667-58.496-27.765333-6.229333-22.538667 9.877333-46.645333 35.968-53.845333 26.08-7.2 52.266667 5.226667 58.496 27.776z" fill="#EC683E" ></path><path d="M499.445333 662.613333a10.666667 10.666667 0 0 1-2.72 14.826667c-2.826667 1.952-9.728 7.36-14.197333 12.725333a10.666667 10.666667 0 0 1-16.384-13.653333c6.186667-7.456 14.848-14.133333 18.464-16.629333a10.666667 10.666667 0 0 1 14.837333 2.730666z" fill="#FFF8F8" ></path><path d="M472.202667 559.317333c0-5.493333-3.466667-9.941333-7.733334-9.941333-4.266667 0-7.722667 4.448-7.722666 9.941333 0 5.482667 3.456 9.941333 7.722666 9.941334 4.266667 0 7.733333-4.458667 7.733334-9.941334zM573.738667 557.728c0-5.493333-3.456-9.941333-7.722667-9.941333-4.266667 0-7.733333 4.448-7.733333 9.941333 0 5.493333 3.466667 9.941333 7.733333 9.941333 4.266667 0 7.722667-4.448 7.722667-9.941333z" fill="#F3BC96" ></path><path d="M683.338667 840c0 4.416-4.032 8-9.002667 8-4.970667 0-9.002667-3.584-9.002667-8s4.032-8 9.002667-8c4.970667 0 8.992 3.584 8.992 8zM642.773333 834.613333c0 4.416-4.021333 8-8.992 8-4.970667 0-9.002667-3.584-9.002666-8 0-4.426667 4.032-8 9.002666-8 4.970667 0 9.002667 3.573333 9.002667 8zM624.778667 882.346667c0 4.405333-4.021333 8-8.992 8-4.970667 0-9.002667-3.594667-9.002667-8 0-4.426667 4.032-8 9.002667-8 4.970667 0 8.992 3.573333 8.992 8zM681.088 777.258667c0 2.752-2.506667 4.981333-5.6 4.981333-3.093333 0-5.6-2.24-5.6-4.981333 0-2.752 2.506667-4.970667 5.6-4.970667 3.093333 0 5.6 2.218667 5.6 4.970667zM737.098667 731.2c0 2.752-2.506667 4.981333-5.589334 4.981333-3.093333 0-5.6-2.229333-5.6-4.970666 0-2.752 2.506667-4.981333 5.6-4.981334 3.093333 0 5.589333 2.24 5.589334 4.981334zM703.434667 752.554667c0 2.752-2.506667 4.981333-5.6 4.981333-3.093333 0-5.589333-2.229333-5.589334-4.981333 0-2.741333 2.506667-4.970667 5.589334-4.970667 3.093333 0 5.6 2.229333 5.6 4.970667zM621.376 857.536c0 2.741333-2.496 4.970667-5.589333 4.970667-3.093333 0-5.6-2.229333-5.6-4.970667 0-2.752 2.506667-4.981333 5.6-4.981333 3.093333 0 5.589333 2.24 5.589333 4.981333zM594.378667 893.194667c0 2.752-2.506667 4.981333-5.6 4.981333-3.093333 0-5.589333-2.229333-5.589334-4.981333 0-2.741333 2.506667-4.970667 5.589334-4.970667 3.093333 0 5.6 2.229333 5.6 4.970667zM703.434667 794.453333c0 4.416-4.032 8-9.002667 8-4.970667 0-8.992-3.584-8.992-8 0-4.426667 4.021333-8 8.992-8 4.970667 0 9.002667 3.573333 9.002667 8zM671.84 807.562667c0 6.005333-5.482667 10.88-12.256 10.88-6.762667 0-12.245333-4.874667-12.245333-10.88 0-6.016 5.482667-10.901333 12.245333-10.901334 6.773333 0 12.256 4.885333 12.256 10.901334zM731.509333 763.445333c0 6.016-5.493333 10.890667-12.266666 10.890667-6.752 0-12.245333-4.874667-12.245334-10.88 0-6.026667 5.482667-10.901333 12.256-10.901333 6.762667 0 12.256 4.874667 12.256 10.890666zM661.365333 863.445333c0 6.016-5.482667 10.890667-12.245333 10.890667-6.773333 0-12.256-4.874667-12.256-10.88 0-6.026667 5.482667-10.901333 12.256-10.901333 6.762667 0 12.245333 4.874667 12.245333 10.890666z" fill="#DEC674" ></path></symbol><symbol id="icon-shengdanliwu1" viewBox="0 0 1024 1024"><path d="M213.333333 569.088a21.333333 21.333333 0 0 1 21.333334-21.333333h554.666666a21.333333 21.333333 0 0 1 21.333334 21.333333v320a42.666667 42.666667 0 0 1-42.666667 42.666667H256a42.666667 42.666667 0 0 1-42.666667-42.666667v-320z" fill="#F6B22F" ></path><path d="M234.666667 526.421333h554.666666a42.666667 42.666667 0 0 1 42.666667 42.666667v320a64 64 0 0 1-64 64H256a64 64 0 0 1-64-64v-320a42.666667 42.666667 0 0 1 42.666667-42.666667z m0 21.333334a21.333333 21.333333 0 0 0-21.333334 21.333333v320a42.666667 42.666667 0 0 0 42.666667 42.666667h512a42.666667 42.666667 0 0 0 42.666667-42.666667v-320a21.333333 21.333333 0 0 0-21.333334-21.333333H234.666667z" fill="#E68C06" ></path><path d="M232.672 646.666667a10.666667 10.666667 0 0 1 10.666667 10.666666v194.666667a10.666667 10.666667 0 1 1-21.333334 0v-194.666667a10.666667 10.666667 0 0 1 10.666667-10.666666z" fill="#FFC24A" ></path><path d="M217.109333 906.645333A42.666667 42.666667 0 0 0 256 931.754667h512a42.666667 42.666667 0 0 0 42.666667-42.666667v-320a21.333333 21.333333 0 0 0-21.333334-21.333333v320a42.666667 42.666667 0 0 1-42.666666 42.666666H234.666667a42.528 42.528 0 0 1-17.557334-3.776z" fill="#E7A320" ></path><path d="M213.333333 526.421333h597.333334v105.333334H213.333333v-105.333334z" fill="#E7A320" ></path><path d="M742.368 715.392a10.346667 10.346667 0 1 1-20.693333 0 10.346667 10.346667 0 0 1 20.693333 0zM761.472 890.741333a10.346667 10.346667 0 1 1-20.693333 0 10.346667 10.346667 0 0 1 20.693333 0zM784.266667 739.701333a13.973333 13.973333 0 1 1-27.936 0 13.973333 13.973333 0 0 1 27.946666 0zM777.28 694.314667a10.474667 10.474667 0 1 1-20.949333 0 10.474667 10.474667 0 0 1 20.96 0zM785.802667 799.701333a21.728 21.728 0 1 1-43.456 0 21.728 21.728 0 0 1 43.456 0zM742.368 760.64a13.973333 13.973333 0 1 1-27.925333 0 13.973333 13.973333 0 0 1 27.925333 0zM789.333333 856.341333a13.973333 13.973333 0 1 1-27.936 0 13.973333 13.973333 0 0 1 27.936 0zM748.970667 844.96a8.469333 8.469333 0 1 1-16.949334 0 8.469333 8.469333 0 0 1 16.949334 0zM719.594667 871.605333a13.973333 13.973333 0 1 1-27.936 0 13.973333 13.973333 0 0 1 27.936 0zM721.674667 824.010667a13.973333 13.973333 0 1 1-27.925334 0 13.973333 13.973333 0 0 1 27.925334 0zM670.474667 890.613333a10.474667 10.474667 0 1 1-20.949334 0 10.474667 10.474667 0 0 1 20.949334 0z" fill="#E88E07" ></path><path d="M128 473.088a85.333333 85.333333 0 0 1 85.333333-85.333333h597.333334a85.333333 85.333333 0 0 1 85.333333 85.333333v85.333333a21.333333 21.333333 0 0 1-21.333333 21.333334H149.333333a21.333333 21.333333 0 0 1-21.333333-21.333334v-85.333333z" fill="#FFC658" ></path><path d="M213.333333 366.421333h597.333334c58.912 0 106.666667 47.754667 106.666666 106.666667v85.333333a42.666667 42.666667 0 0 1-42.666666 42.666667H149.333333a42.666667 42.666667 0 0 1-42.666666-42.666667v-85.333333c0-58.912 47.754667-106.666667 106.666666-106.666667z m0 21.333334a85.333333 85.333333 0 0 0-85.333333 85.333333v85.333333a21.333333 21.333333 0 0 0 21.333333 21.333334h725.333334a21.333333 21.333333 0 0 0 21.333333-21.333334v-85.333333a85.333333 85.333333 0 0 0-85.333333-85.333333H213.333333z" fill="#CF8C0B" ></path><path d="M130.858667 569.088a21.333333 21.333333 0 0 0 18.474666 10.666667h725.333334a21.333333 21.333333 0 0 0 21.333333-21.333334v-85.333333a85.365333 85.365333 0 0 0-58.250667-80.96A85.237333 85.237333 0 0 1 874.666667 462.432v85.333333a21.333333 21.333333 0 0 1-21.333334 21.333334H130.858667z" fill="#F2B43D" ></path><path d="M472 387.754667h88.426667v544h-88.426667v-544z" fill="#FF4646" ></path><path d="M450.666667 366.421333h131.093333v586.666667H450.666667v-586.666667z m21.333333 21.333334v544h88.426667v-544h-88.426667z" fill="#CD2222" ></path><path d="M493.333333 430.421333a10.666667 10.666667 0 0 1 10.666667 10.666667v165.333333a10.666667 10.666667 0 1 1-21.333333 0v-165.333333a10.666667 10.666667 0 0 1 10.666666-10.666667z" fill="#FF7575" ></path><path d="M526.666667 554.421333a10.666667 10.666667 0 0 1 10.666666 10.666667v336a10.666667 10.666667 0 1 1-21.333333 0v-336a10.666667 10.666667 0 0 1 10.666667-10.666667z" fill="#F02E2E" ></path><path d="M294.24 435.861333c9.749333 27.008-49.994667 11.2-67.370667 35.84-28.661333 40.661333-69.6 44.16-79.36 17.152-9.749333-27.008 5.514667-61.866667 46.037334-76.490666 40.512-14.634667 90.933333-3.52 100.693333 23.498666z" fill="#FFE68F" ></path><path d="M300.618667 377.696c80.426667-23.946667 163.093333-12.608 196.437333 0l41.333333-23.946667c-133.333333-57.333333-166.005333-49.994667-202.005333-50.005333l-35.765333 73.952z" fill="#DC2C2C" ></path><path d="M507.744 396.16a21.333333 21.333333 0 0 1-18.24 1.493333c-29.088-11.008-106.965333-22.08-182.794667 0.490667a21.333333 21.333333 0 0 1-25.290666-29.738667l35.765333-73.941333a21.333333 21.333333 0 0 1 19.2-12.053333c3.136 0 6.4-0.064 9.824-0.138667 14.709333-0.32 32.725333-0.693333 58.496 3.989333 31.552 5.738667 74.709333 18.912 142.112 47.893334a21.333333 21.333333 0 0 1 2.261333 38.058666l-41.333333 23.936z m5.952-52.768c-100.832-41.141333-136.138667-40.416-166.517333-39.786667-3.626667 0.074667-7.2 0.149333-10.794667 0.149334l-35.765333 73.941333c8.981333-2.666667 17.994667-4.906667 26.965333-6.752 71.317333-14.645333 139.861333-4.448 169.472 6.752l41.333333-23.946667c-8.64-3.712-16.864-7.157333-24.693333-10.346666z" fill="#B31B1B" ></path><path d="M751.210667 381.152c-94.794667-25.418667-162.741333-22.773333-211.509334-9.376l-28.629333-8.992c121.856-64.373333 168.288-47.552 199.829333-41.813333l40.32 60.181333z" fill="#BF2222" ></path><path d="M532.928 392.085333c3.914667 1.226667 8.117333 1.290667 12.117333 0.192 44.288-12.16 108.266667-15.232 200.245334 9.429334a21.781333 21.781333 0 0 0 23.146666-8.256 21.205333 21.205333 0 0 0 0.64-24.32l-40.309333-60.181334a20.885333 20.885333 0 0 0-13.632-8.906666c-2.112-0.384-4.405333-0.853333-6.901333-1.354667-14.538667-2.954667-35.669333-7.253333-65.162667-4.266667-34.378667 3.488-79.2 16.565333-141.76 49.610667a21.706667 21.706667 0 0 0-11.562667 20.757333 20.8 20.8 0 0 0 14.549334 18.304l28.629333 8.992z m7.445333-20.48c43.210667-11.754667 101.408-15.04 179.872 2.016 9.994667 2.165333 20.309333 4.672 30.965334 7.530667l-40.309334-60.170667c-2.432-0.448-4.96-0.96-7.594666-1.493333-28.864-5.824-71.648-14.464-164.725334 29.504-8.714667 4.128-17.877333 8.704-27.509333 13.792l28.629333 8.992 0.672-0.181333z" fill="#9D1818" ></path><path d="M696.213333 328.64a10.688 10.688 0 0 0-2.133333 14.944l14.272 18.741333a10.645333 10.645333 0 0 0 14.954667 1.888c4.714667-3.605333 5.674667-10.304 2.133333-14.944l-14.272-18.741333a10.645333 10.645333 0 0 0-14.954667-1.888z" fill="#DE3838" ></path><path d="M197.589333 275.413333c132.842667-4.746667 233.333333 57.44 273.781334 87.829334l26.218666-9.834667c-88.032-112.874667-225.429333-153.024-264-154.666667l-8 40.672-28 36z" fill="#EA2F2F" ></path><path d="M478.858667 383.221333a21.333333 21.333333 0 0 1-20.298667-2.922666c-38.613333-28.992-134.314667-88.064-260.213333-83.562667a21.333333 21.333333 0 0 1-17.6-34.421333l24.885333-32 7.029333-35.690667a21.333333 21.333333 0 0 1 21.834667-17.194667c23.189333 0.992 70.122667 12.64 121.856 37.749334 52.266667 25.365333 111.530667 65.461333 158.058667 125.12a21.333333 21.333333 0 0 1-9.333334 33.088l-26.218666 9.834666zM225.6 239.413333l-28 36c9.173333-0.32 18.208-0.341333 27.072-0.053333 119.370667 3.754667 209.056 59.594667 246.72 87.893333l26.208-9.845333a372.8 372.8 0 0 0-14.421333-17.365333c-87.925333-99.658667-213.056-135.744-249.578667-137.301334l-8 40.672z" fill="#B31B1B" ></path><path d="M287.253333 275.968c-25.909333-6.922667-46.549333-7.456-52.8-6.997333a10.666667 10.666667 0 0 1-1.568-21.28c8.853333-0.64 31.893333 0.192 59.872 7.68a10.666667 10.666667 0 0 1-5.514666 20.597333z" fill="#FF4444" ></path><path d="M829.824 290.186667c-117.269333-4.181333-190.805333 30.282667-226.517333 57.098666l-43.989334-0.298666c77.717333-99.637333 207.658667-133.365333 241.706667-134.816l-0.266667 38.848 29.066667 39.168z" fill="#D92525" ></path><path d="M603.157333 368.618667a21.333333 21.333333 0 0 0 12.96-4.266667c31.616-23.754667 100.309333-56.864 212.949334-52.842667a21.333333 21.333333 0 0 0 17.888-34.026666l-24.821334-33.450667 0.213334-31.712a21.333333 21.333333 0 0 0-22.24-21.461333c-20.554667 0.874667-64.288 10.666667-112.373334 32.469333C639.253333 245.333333 584.117333 280.512 542.506667 333.866667a21.333333 21.333333 0 0 0 16.682666 34.453333l43.978667 0.298667z m197.6-117.6l29.066667 39.168c-9.194667-0.32-18.122667-0.426667-26.773333-0.288-101.792 1.461333-166.826667 32.672-199.744 57.386666l-43.989334-0.298666a301.76 301.76 0 0 1 18.208-21.205334c65.632-69.76 156-101.418667 202.133334-110.656 8.96-1.792 16.245333-2.730667 21.354666-2.954666l-0.256 38.848z" fill="#B31B1B" ></path><path d="M781.184 217.301333a10.666667 10.666667 0 0 1 10.666667 10.666667v15.893333a10.666667 10.666667 0 1 1-21.333334 0v-15.893333a10.666667 10.666667 0 0 1 10.666667-10.666667z" fill="#FF5252" ></path><path d="M580.181333 144.416c-101.184 54.848-81.514667 176-81.514666 211.328l21.333333 3.338667c8.853333-86.666667 69.034667-192 115.029333-145.333334 30.997333 31.434667-73.898667 142.698667-118.538666 162.666667h35.381333c54.848-7.338667 138.293333-83.424 154.528-153.333333 12.373333-53.333333-25.365333-133.333333-126.218667-78.666667z" fill="#E33030" ></path><path d="M495.157333 376.789333a21.333333 21.333333 0 0 1-17.824-21.045333c0-2.944-0.213333-7.2-0.490666-12.48-1.034667-20.021333-2.826667-54.869333 3.669333-89.76 8.501333-45.706667 31.552-96.426667 89.504-127.84 27.477333-14.901333 52.544-21.653333 74.965333-20.842667 22.816 0.853333 41.6 9.536 55.605334 23.093334 27.061333 26.186667 34.069333 67.786667 26.592 99.989333-9.386667 40.405333-37.322667 80.362667-68.757334 110.666667-31.082667 29.973333-69.696 54.442667-103.722666 58.986666a21.248 21.248 0 0 1-2.826667 0.192h-35.381333a21.333333 21.333333 0 0 1-21.333334-20.96z m62.112-1.290666c54.762667-11.306667 133.418667-84.757333 149.12-152.416 12.394667-53.333333-25.354667-133.333333-126.208-78.666667-89.493333 48.512-84.448 148.874667-82.090666 195.872 0.32 6.144 0.576 11.381333 0.576 15.466667l21.333333 3.328a241.173333 241.173333 0 0 1 3.082667-21.12c15.317333-81.450667 69.632-167.146667 111.946666-124.213334 24.853333 25.194667-37.621333 101.685333-86.378666 141.333334-2.506667 2.026667-4.970667 3.978667-7.392 5.802666l-0.426667 0.32c-8.693333 6.56-16.746667 11.68-23.477333 14.816a65.813333 65.813333 0 0 1-0.864 0.394667h35.381333c1.770667-0.234667 3.573333-0.544 5.397333-0.917333z m-10.325333-47.04a391.061333 391.061333 0 0 0 40.64-42.56c13.386667-16.405333 23.498667-31.989333 28.522667-44.32 3.541333-8.693333 3.338667-12.373333 3.146666-13.44-3.2-3.082667-5.536-4.010667-6.858666-4.32-1.344-0.32-3.146667-0.352-5.898667 0.704-6.368 2.421333-15.434667 9.813333-25.429333 24.106666-14.346667 20.533333-26.848 49.856-34.122667 79.84z" fill="#BC2020" ></path><path d="M543.573333 180.554667c46.997333-60.746667 105.578667-50.250667 110.517334-49.269334a10.666667 10.666667 0 1 1-4.181334 20.928c-1.728-0.352-49.813333-9.856-89.472 41.397334a10.666667 10.666667 0 0 1-16.874666-13.056z" fill="#FF4444" ></path><path d="M220.661333 426.218667a10.666667 10.666667 0 0 1-10.346666 10.976c-12.992 0.373333-22.186667 9.312-28.298667 17.866666a10.666667 10.666667 0 0 1-17.365333-12.405333c7.232-10.112 21.76-26.112 45.034666-26.794667a10.666667 10.666667 0 0 1 10.976 10.346667z" fill="#FFFFFF" ></path><path d="M304 192.181333c32 86.666667 135.338667 146.005333 206.666667 184-66.848-42.442667-131.029333-120.426667-149.333334-154.666666-18.304-34.24-6.005333-79.328 42.666667-70.656 63.018667 11.221333 101.504 158.314667 122.005333 221.141333 2.442667-35.978667-6.421333-164.085333-59.338666-229.152-81.333333-99.989333-193.749333-34.826667-162.666667 49.333333z" fill="#F23535" ></path><path d="M523.552 393.194667a21.333333 21.333333 0 0 1-22.912 1.813333c-35.808-19.072-80.896-44.138667-121.226667-75.786667-40.149333-31.52-77.461333-70.997333-95.424-119.648-19.712-53.365333 6.592-102.325333 50.986667-120.810666 44.778667-18.634667 102.837333-5.194667 148.234667 50.634666 29.856 36.693333 46.112 89.226667 54.837333 134.933334 8.8 46.090667 10.602667 88.970667 9.237333 109.12a21.333333 21.333333 0 0 1-23.733333 19.744z m-3.882667-110.208c-7.818667-48.426667-23.616-104-53.013333-140.128-81.322667-100-193.738667-34.837333-162.656 49.333333 17.098667 46.293333 54.56 84.8 96.618667 116.416 34.154667 25.674667 71.338667 46.794667 103.125333 63.872 2.336 1.258667 4.64 2.496 6.922667 3.701333a315.221333 315.221333 0 0 1-7.253334-4.746666c-32.042667-21.610667-63.104-50.773333-88.373333-78.677334-25.354667-28-44.874667-54.72-53.706667-71.242666-18.304-34.24-6.005333-79.328 42.666667-70.656 41.781333 7.434667 72.789333 74.624 94.901333 137.365333 7.573333 21.44 14.08 42.368 19.648 60.213333l2.922667 9.333334 0.288 0.938666c1.493333 4.746667 2.901333 9.194667 4.245333 13.290667 0.192-2.869333 0.32-6.325333 0.341334-10.282667 0.16-18.133333-1.525333-46.890667-6.677334-78.72z m-27.061333 54.026666c-8.554667-27.082667-18.805333-57.92-31.221333-86.410666-9.706667-22.293333-20.234667-41.834667-31.424-56.149334-11.456-14.645333-21.514667-21.141333-29.706667-22.602666-8.885333-1.578667-14.197333-0.384-17.12 0.96-2.773333 1.28-4.832 3.317333-6.314667 6.442666-3.306667 6.976-3.424 19.573333 3.328 32.213334 7.957333 14.890667 27.264 41.44 53.365334 69.888 17.749333 19.338667 38.026667 38.88 59.093333 55.658666z" fill="#BC2020" ></path><path d="M350.165333 109.546667a10.666667 10.666667 0 0 1-2.848 14.805333c-10.624 7.2-31.125333 32.234667-16.64 71.466667a10.666667 10.666667 0 1 1-20.021333 7.392c-18.581333-50.346667 7.765333-85.045333 24.693333-96.522667a10.666667 10.666667 0 0 1 14.816 2.848z" fill="#FF7878" ></path></symbol><symbol id="icon-a-045_dianzan-23" viewBox="0 0 1024 1024"><path d="M205.615 290.036a193 193 0 0 1 272.944 0L785.443 596.92 555.506 826.857a60.82 60.82 0 0 1-86.013 0L205.615 562.98a193 193 0 0 1 0-272.943z" fill="#FE3F6A" ></path><path d="M819.39 290.03a193 193 0 0 1 0 272.944L555.51 826.852a60.82 60.82 0 0 1-86.012 0L239.562 596.915 546.446 290.03a193 193 0 0 1 272.943 0z" fill="#FC8FA9" ></path><path d="M512.5 324L239.56 596.91 469.5 826.85a60.81 60.81 0 0 0 86 0l229.94-229.94z" fill="#DE1342" ></path></symbol><symbol id="icon-a-045_jiangli" viewBox="0 0 1024 1024"><path d="M513.58 446.68m-302.68 0a302.68 302.68 0 1 0 605.36 0 302.68 302.68 0 1 0-605.36 0Z" fill="#FF812C" ></path><path d="M654.81 880.77l-116.18-55.06a58.54 58.54 0 0 0-50.11 0l-116.17 55.06a31.92 31.92 0 0 1-45.53-30.83l11.6-186.14a52.35 52.35 0 0 1 52.25-49.1h245.81a52.36 52.36 0 0 1 52.26 49.1l11.6 186.14a31.92 31.92 0 0 1-45.53 30.83z" fill="#FF9C85" ></path><path d="M514.16 749.66A301.3 301.3 0 0 0 690.51 693l-1.8-28.89A52.34 52.34 0 0 0 636.46 615H390.65a52.35 52.35 0 0 0-52.26 49.1l-1.75 28a301.32 301.32 0 0 0 177.52 57.56zM533 330.07l16.62 33.67a21.62 21.62 0 0 0 16.29 11.83L603 381a21.63 21.63 0 0 1 12 36.89l-26.89 26.21a21.67 21.67 0 0 0-6.22 19.15l6.35 37A21.63 21.63 0 0 1 556.88 523l-33.24-17.47a21.59 21.59 0 0 0-20.13 0L470.28 523a21.63 21.63 0 0 1-31.38-22.8l6.34-37a21.61 21.61 0 0 0-6.24-19.13l-26.89-26.21a21.63 21.63 0 0 1 12-36.89l37.16-5.4a21.63 21.63 0 0 0 16.28-11.83l16.62-33.67a21.63 21.63 0 0 1 38.83 0z" fill="#E55C00" ></path></symbol><symbol id="icon-a-045_zhaopian" viewBox="0 0 1024 1024"><path d="M408.49 332.05L144.85 779.1A25.69 25.69 0 0 0 167 817.84h527.26a25.69 25.69 0 0 0 22.13-38.74l-263.64-447a25.69 25.69 0 0 0-44.26-0.05z" fill="#1C95FF" ></path><path d="M697.33 545.92L562.42 779.45A25.7 25.7 0 0 0 584.67 818h269.82a25.69 25.69 0 0 0 22.24-38.55L741.82 545.92a25.69 25.69 0 0 0-44.49 0z" fill="#3BDBFF" ></path><path d="M716.39 779.26l-77.67-131.72-76.3 132.07A25.69 25.69 0 0 0 581.93 818h112.33a25.69 25.69 0 0 0 22.13-38.74z" fill="#0F6AFF" ></path><path d="M715 338m-60 0a60 60 0 1 0 120 0 60 60 0 1 0-120 0Z" fill="#3BDBFF" ></path></symbol><symbol id="icon-fenxiang" viewBox="0 0 1024 1024"><path d="M489.386667 105.386667l22.613333-22.613334 22.613333 22.613334 192 192 22.613334 22.613333-45.226667 45.226667-22.613333-22.613334-137.386667-137.386666V704h-64V205.226667L342.613333 342.613333l-22.613333 22.613334L274.773333 320l22.613334-22.613333 192-192zM192 832V416H128V896h768V416h-64v416h-640z" fill="#29506C" ></path></symbol><symbol id="icon-wenbenbianji" viewBox="0 0 1024 1024"><path d="M160 272A112 112 0 0 1 272 160h480a112 112 0 0 1 112 112v480a112 112 0 0 1-112 112H272a112 112 0 0 1-112-112V272zM272 96A176 176 0 0 0 96 272v480a176 176 0 0 0 176 176h480a176 176 0 0 0 176-176V272a176 176 0 0 0-176-176H272z m421.162667 170.325333a55.978667 55.978667 0 0 0-79.189334 0l-174.421333 174.464-95.701333 95.658667-11.946667 11.946667-6.186667 6.186666-2.133333 8.405334-34.56 132.949333-13.653333 52.736 52.693333-13.696 132.906667-34.56 8.448-2.133333 6.144-6.186667 11.946666-11.946667 95.701334-95.701333 174.464-174.421333a56.021333 56.021333 0 0 0 0-79.189334l-22.613334 22.613334 22.613334-22.613334-64.512-64.512z m-39.594667 39.594667l16.768-16.768-16.768 16.768-5.632 5.674667 5.632-5.674667z m-168.746667 180.096l168.746667-168.746667 53.162667 53.162667-168.746667 168.746667 20.906667 20.906666-20.906667-20.906666-95.701333 95.701333-5.802667 5.802667-71.808 18.645333 18.645333-71.808 5.802667-5.802667 95.701333-95.701333z" fill="#29506C" ></path></symbol><symbol id="icon-bianji" viewBox="0 0 1024 1024"><path d="M680.917333 105.386667l-22.613333-22.613334-22.613333 22.613334L196.778667 544.213333l-9.386667 9.386667v191.573333h191.530667l9.386666-9.386666L827.178667 296.917333l22.613333-22.613333-22.613333-22.613333-146.261334-146.346667zM251.434667 681.130667v-101.034667l406.869333-406.826667 101.034667 101.034667-406.869334 406.826667H251.434667zM170.666667 891.434667h682.666666v-64H170.666667v64z" fill="#29506C" ></path></symbol><symbol id="icon-jinggao" viewBox="0 0 1024 1024"><path d="M512 597.333333a42.666667 42.666667 0 0 1-42.666667-42.666666v-128a42.666667 42.666667 0 1 1 85.333334 0v128a42.666667 42.666667 0 0 1-42.666667 42.666666z" fill="#000000" ></path><path d="M448 704a64 64 0 1 1 128 0 64 64 0 0 1-128 0z" fill="#000000" ></path><path d="M436.48 137.194667c32-60.8 119.04-60.8 151.04 0l355.989333 676.394666c29.909333 56.832-11.306667 125.077333-75.52 125.077334H156.010667c-64.213333 0-105.429333-68.266667-75.52-125.077334L436.48 137.194667zM867.989333 853.333333L512 176.938667 156.010667 853.333333h711.978666z" fill="#000000" ></path></symbol><symbol id="icon-shezhi" viewBox="0 0 1024 1024"><path d="M512 170.666667a42.666667 42.666667 0 0 0-42.666667 42.666666c0 72.192-87.296 108.373333-138.346666 57.301334a42.666667 42.666667 0 1 0-60.352 60.352C321.706667 382.037333 285.525333 469.333333 213.333333 469.333333a42.666667 42.666667 0 1 0 0 85.333334c72.213333 0 108.373333 87.296 57.301334 138.346666a42.666667 42.666667 0 0 0 60.352 60.352C382.037333 702.293333 469.333333 738.453333 469.333333 810.666667a42.666667 42.666667 0 1 0 85.333334 0c0-72.213333 87.296-108.373333 138.346666-57.301334a42.666667 42.666667 0 0 0 60.352-60.352C702.293333 641.962667 738.453333 554.666667 810.666667 554.666667a42.666667 42.666667 0 1 0 0-85.333334c-72.192 0-108.373333-87.296-57.301334-138.346666a42.666667 42.666667 0 1 0-60.352-60.352C641.962667 321.706667 554.666667 285.525333 554.666667 213.333333a42.666667 42.666667 0 0 0-42.666667-42.666666z m-127.658667 33.152a128 128 0 0 1 255.317334 0 128 128 0 0 1 180.522666 180.522666 128 128 0 0 1 0 255.317334 128 128 0 0 1-180.522666 180.522666 128 128 0 0 1-255.317334 0 128 128 0 0 1-180.522666-180.522666 128 128 0 0 1 0-255.317334 128 128 0 0 1 180.522666-180.522666z" fill="#000000" ></path><path d="M512 426.666667a85.333333 85.333333 0 1 0 0 170.666666 85.333333 85.333333 0 0 0 0-170.666666z m-120.682667-35.349334a170.666667 170.666667 0 1 1 241.365334 241.386667 170.666667 170.666667 0 0 1-241.365334-241.386667z" fill="#000000" ></path></symbol><symbol id="icon-shoucang" viewBox="0 0 1024 1024"><path d="M512 106.666667a42.666667 42.666667 0 0 1 38.165333 23.594666l110.037334 220.053334 241.92 35.2a42.666667 42.666667 0 0 1 23.68 72.768l-176.106667 171.690666 39.616 242.069334a42.666667 42.666667 0 0 1-62.101333 44.586666L512 802.432l-215.210667 114.197333a42.666667 42.666667 0 0 1-62.08-44.586666l39.594667-242.069334-176.085333-171.690666a42.666667 42.666667 0 0 1 23.637333-72.768l241.941333-35.2 110.037334-220.053334A42.666667 42.666667 0 0 1 512.021333 106.666667z m0 138.069333l-81.834667 163.669333a42.666667 42.666667 0 0 1-32.021333 23.146667l-178.474667 25.962667 130.133334 126.869333a42.666667 42.666667 0 0 1 12.309333 37.44L332.8 800.917333l159.210667-84.48a42.666667 42.666667 0 0 1 40 0l159.189333 84.48-29.312-179.093333a42.666667 42.666667 0 0 1 12.330667-37.44l130.133333-126.869333-178.496-25.962667a42.666667 42.666667 0 0 1-32-23.146667L512 244.736z" fill="#000000" ></path></symbol><symbol id="icon-xiazai" viewBox="0 0 1024 1024"><path d="M512 85.333333a42.666667 42.666667 0 0 1 42.666667 42.666667v451.669333l97.834666-97.834666a42.666667 42.666667 0 1 1 60.330667 60.330666l-170.666667 170.666667a42.666667 42.666667 0 0 1-60.330666 0l-170.666667-170.666667a42.666667 42.666667 0 1 1 60.330667-60.330666L469.333333 579.669333V128a42.666667 42.666667 0 0 1 42.666667-42.666667zM213.333333 725.333333a42.666667 42.666667 0 0 1 42.666667 42.666667v85.333333h512v-85.333333a42.666667 42.666667 0 1 1 85.333333 0v85.333333a85.333333 85.333333 0 0 1-85.333333 85.333334H256a85.333333 85.333333 0 0 1-85.333333-85.333334v-85.333333a42.666667 42.666667 0 0 1 42.666666-42.666667z" fill="#000000" ></path></symbol><symbol id="icon-yuanquanwancheng" viewBox="0 0 1024 1024"><path d="M512 170.666667C323.477333 170.666667 170.666667 323.477333 170.666667 512s152.810667 341.333333 341.333333 341.333333 341.333333-152.810667 341.333333-341.333333S700.522667 170.666667 512 170.666667zM85.333333 512C85.333333 276.352 276.352 85.333333 512 85.333333s426.666667 191.018667 426.666667 426.666667-191.018667 426.666667-426.666667 426.666667S85.333333 747.648 85.333333 512z m625.685334-138.56a42.666667 42.666667 0 0 1 3.541333 60.245333l-227.562667 256a42.666667 42.666667 0 0 1-63.786666 0l-113.770667-128a42.666667 42.666667 0 1 1 63.786667-56.704l81.877333 92.138667 195.669333-220.138667a42.666667 42.666667 0 0 1 60.245334-3.541333z" fill="#000000" ></path></symbol><symbol id="icon-checkzhengque" viewBox="0 0 1024 1024"><path d="M881.685333 224.106667a42.666667 42.666667 0 0 1 3.541334 60.245333l-455.104 512a42.666667 42.666667 0 0 1-63.786667 0l-227.562667-256a42.666667 42.666667 0 1 1 63.786667-56.704l195.669333 220.138667L821.44 227.626667a42.666667 42.666667 0 0 1 60.245333-3.541334z" fill="#000000" ></path></symbol><symbol id="icon-imagezhaopian" viewBox="0 0 1024 1024"><path d="M128 213.333333a85.333333 85.333333 0 0 1 85.333333-85.333333h597.333334a85.333333 85.333333 0 0 1 85.333333 85.333333v597.333334a85.333333 85.333333 0 0 1-85.333333 85.333333H213.333333a85.333333 85.333333 0 0 1-85.333333-85.333333V213.333333z m682.666667 0H213.333333v597.333334h597.333334V213.333333z" fill="#000000" ></path><path d="M357.333333 436.010667a42.666667 42.666667 0 0 1 53.333334 0l183.509333 146.816 58.325333-58.325334a42.666667 42.666667 0 0 1 60.330667 0l170.666667 170.666667a42.666667 42.666667 0 1 1-60.330667 60.330667L682.666667 614.997333l-55.168 55.168a42.666667 42.666667 0 0 1-56.810667 3.157334l-186.688-149.333334-186.666667 149.333334a42.666667 42.666667 0 1 1-53.333333-66.645334l213.333333-170.666666z" fill="#000000" ></path><path d="M725.333333 362.666667a64 64 0 1 1-128 0 64 64 0 0 1 128 0z" fill="#000000" ></path></symbol><symbol id="icon-a-bianzu49" viewBox="0 0 1024 1024"><path d="M269.226667 853.333333c83.626667 46.336 166.272 69.546667 247.893333 69.546667 81.664 0 172.117333-23.210667 271.36-69.546667-73.685333 113.792-164.138667 170.666667-271.36 170.666667-107.178667 0-189.824-56.874667-247.893333-170.666667z" fill="#FFE206" ></path><path d="M277.333333 128m362.666667 0l0 0q362.666667 0 362.666667 362.666667l0 0q0 362.666667-362.666667 362.666666l0 0q-362.666667 0-362.666667-362.666666l0 0q0-362.666667 362.666667-362.666667Z" fill="#51E6F9" ></path><path d="M427.690667 0v447.488c0 11.776 9.6 21.333333 21.376 21.333333H874.666667C853.205333 684.757333 670.890667 853.333333 449.066667 853.333333 212.906667 853.333333 21.333333 662.058667 21.333333 426.112 21.333333 197.376 201.472 11.221333 427.690667 0z m69.888 0C711.338667 11.221333 874.666667 174.848 874.666667 403.84h-334.421334a42.666667 42.666667 0 0 1-42.666666-42.666667z" fill="#186FE8" opacity=".803" ></path></symbol><symbol id="icon-a-bianzu67" viewBox="0 0 1024 1024"><path d="M198.570667 853.333333c83.626667 46.336 166.272 69.546667 247.893333 69.546667 81.621333 0 172.074667-23.210667 271.36-69.546667-73.728 113.792-164.138667 170.666667-271.36 170.666667-107.221333 0-189.866667-56.874667-247.893333-170.666667z" fill="#FFE206" ></path><path d="M578.261333 128a343.594667 343.594667 0 0 1 292.821334 523.392l52.138666 55.893333 57.173334 58.709334c30.336 30.421333 29.653333 80.128-1.92 109.738666-30.08 28.16-77.354667 26.666667-106.496-2.56l-106.368-113.536A343.594667 343.594667 0 1 1 578.261333 128z" fill="#51E6F9" ></path><path d="M823.594667 675.285333l1.024 0.554667 66.730666 68.48a89.173333 89.173333 0 0 1-2.218666 128c-35.114667 32.896-90.282667 31.146667-124.288-2.901333l-65.962667-67.754667a2.005333 2.005333 0 0 1 0.298667-2.986667 449.152 449.152 0 0 0 122.453333-122.581333 2.005333 2.005333 0 0 1 2.986667-0.256zM422.186667 0a400.853333 400.853333 0 1 1-0.042667 801.706667 400.853333 400.853333 0 0 1 0-801.706667z" fill="#186FE8" opacity=".803" ></path></symbol><symbol id="icon-a-ziyuan4" viewBox="0 0 1024 1024"><path d="M729.063702 86.354853h-30.098332V41.043181c0-22.655836-18.387345-41.043181-41.043181-41.043181s-41.043181 18.387345-41.043181 41.043181v45.311672H407.120992V41.043181C407.120992 18.387345 388.733647 0 366.077811 0s-41.043181 18.387345-41.043181 41.043181v45.311672H294.936298c-138.45233 0-251.731509 113.279179-251.73151 251.731509v434.127405c0 138.45233 113.279179 251.731509 251.73151 251.731509h434.127404c138.45233 0 251.731509-113.279179 251.73151-251.731509V338.086362c0-138.45233-113.279179-251.731509-251.73151-251.731509zM125.29115 772.268491V338.086362c0-93.523728 76.121419-169.645147 169.645148-169.645148h30.098332v11.601539c0 22.655836 18.387345 41.043181 41.043181 41.043181s41.043181-18.387345 41.043181-41.043181v-11.601539h209.758016v11.601539c0 22.655836 18.387345 41.043181 41.043181 41.043181s41.043181-18.387345 41.043181-41.043181v-11.601539h30.098332c93.523728 0 169.645147 76.121419 169.645148 169.645148v293.978623c-130.243694 5.746045-234.383925 113.443352-234.383925 245.055152 0 21.944421 3.009833 43.724669 8.755879 64.738777H294.936298c-93.523728 0-169.645147-76.121419-169.645148-169.645147z m633.378367 167.018384a163.647371 163.647371 0 0 1-12.25823-62.112014c0-86.354853 67.365541-157.222745 152.297563-162.859342v57.952972c0 83.454468-60.579735 152.954254-140.039333 167.018384z"  ></path><path d="M683.47841 424.277041c0-22.655836-18.387345-41.043181-41.043181-41.04318H381.564771c-22.655836 0-41.043181 18.387345-41.043181 41.04318s18.387345 41.043181 41.043181 41.043181h89.364686v220.702865c0 22.655836 18.387345 41.043181 41.043181 41.043181s41.043181-18.387345 41.043181-41.043181V465.320222h89.364685c22.655836 0 41.043181-18.387345 41.043181-41.043181z"  ></path></symbol><symbol id="icon-a-ziyuan7" viewBox="0 0 1076 1024"><path d="M51.65456 231.963411h137.470003v18.457897c0 60.745763 49.450632 110.196395 110.196395 110.196394h100.003228c60.745763 0 110.196395-49.450632 110.196395-110.196394v-18.457897h515.374765c28.513317 0 51.65456-23.141243 51.65456-51.65456s-23.141243-51.65456-51.65456-51.65456H509.520581V110.196395c0-60.814635-49.450632-110.196395-110.196395-110.196395H299.320958c-60.745763 0-110.196395 49.450632-110.196395 110.196395v18.457896H51.65456c-28.513317 0-51.65456 23.141243-51.65456 51.65456s23.141243 51.65456 51.65456 51.65456zM292.433683 110.196395c0-3.719128 3.237019-6.887275 6.887275-6.887275h100.003228c3.650256 0 6.887275 3.237019 6.887275 6.887275v140.224913c0 3.719128-3.237019 6.887275-6.887275 6.887274H299.320958c-3.650256 0-6.887275-3.237019-6.887275-6.887274V110.196395zM1024.895346 460.34544h-137.470003v-18.457896c0-60.745763-49.450632-110.196395-110.196395-110.196395H677.22572c-60.745763 0-110.196395 49.450632-110.196395 110.196395v18.457896H51.65456c-28.513317 0-51.65456 23.141243-51.65456 51.65456s23.141243 51.65456 51.65456 51.65456h515.374765v18.457896c0 60.745763 49.450632 110.196395 110.196395 110.196395h100.003228c60.745763 0 110.196395-49.450632 110.196395-110.196395v-18.457896h137.470003c28.513317 0 51.65456-23.141243 51.65456-51.65456s-23.141243-51.65456-51.65456-51.65456z m-240.779123 121.767016c0 3.719128-3.237019 6.887275-6.887275 6.887275H677.22572c-3.650256 0-6.887275-3.237019-6.887275-6.887275V441.887544c0-3.719128 3.237019-6.887275 6.887275-6.887275h100.003228c3.650256 0 6.887275 3.237019 6.887275 6.887275v140.224912zM1024.895346 791.967716H509.520581v-18.457896c0-60.745763-49.450632-110.196395-110.196395-110.196395H299.320958c-60.745763 0-110.196395 49.450632-110.196395 110.196395v18.457896H51.65456c-28.513317 0-51.65456 23.141243-51.65456 51.65456s23.141243 51.65456 51.65456 51.65456h137.470003v18.457896c0 60.745763 49.450632 110.196395 110.196395 110.196395h100.003228c60.745763 0 110.196395-49.450632 110.196395-110.196395v-18.457896h515.374765c28.513317 0 51.65456-23.141243 51.65456-51.65456s-23.141243-51.65456-51.65456-51.65456z m-618.683885 121.767016c0 3.719128-3.237019 6.887275-6.887275 6.887275H299.320958c-3.650256 0-6.887275-3.237019-6.887275-6.887275v-140.224912c0-3.719128 3.237019-6.887275 6.887275-6.887275h100.003228c3.650256 0 6.887275 3.237019 6.887275 6.887275v140.224912z"  ></path></symbol><symbol id="icon-tuozhuai" viewBox="0 0 1024 1024"><path d="M1009.140569 481.100584l-157.049056-126.283955c-25.901501-20.86824-64.470985-2.375247-64.470985 30.878209v95.518853H554.676681v-244.876634h83.529513c33.253455 0 51.746448-38.51293 30.878208-64.470985L542.857001 14.817016c-15.834979-19.73717-45.921438-19.73717-61.756417 0L354.816629 171.866072c-20.86824 25.901501-2.375247 64.470985 30.878209 64.470985h95.518853v244.876634h-244.876634V385.694838c0-33.253455-38.51293-51.746448-64.470985-30.878209L14.817016 481.100584c-19.73717 15.834979-19.73717 45.921438 0 61.756417l157.049056 126.283955c25.901501 20.86824 64.470985 2.375247 64.470985-30.878209V554.733235h244.876634v232.943847H385.694838c-33.253455 0-51.746448 38.51293-30.878209 64.470984l126.283955 157.049057c15.834979 19.73717 45.921438 19.73717 61.756417 0l126.283955-157.049057c20.86824-25.901501 2.375247-64.470985-30.878209-64.470984H554.733235V554.733235h232.943847v83.529512c0 33.253455 38.51293 51.746448 64.470984 30.878209l157.049057-126.283955c19.73717-15.834979 19.73717-45.921438 0-61.756417z"  ></path></symbol><symbol id="icon-xuanzhong" viewBox="0 0 1024 1024"><path d="M733.469767 1024H290.530233C130.309953 1024 0 893.690047 0 733.469767V290.530233C0 130.309953 130.309953 0 290.530233 0H733.469767c160.220279 0 290.530233 130.309953 290.530233 290.530233V733.469767c0 160.220279-130.309953 290.530233-290.530233 290.530233zM290.530233 66.67907C167.078698 66.67907 66.67907 167.078698 66.67907 290.530233V733.469767c0 123.451535 100.399628 223.851163 223.851163 223.851163H733.469767c123.451535 0 223.851163-100.399628 223.851163-223.851163V290.530233C957.32093 167.078698 856.921302 66.67907 733.469767 66.67907H290.530233z"  ></path></symbol><symbol id="icon-a-xuanzhongmian" viewBox="0 0 1024 1024"><path d="M733.469767 0H290.530233C130.309953 0 0 130.309953 0 290.530233V733.469767c0 160.220279 130.309953 290.530233 290.530233 290.530233H733.469767c160.220279 0 290.530233-130.309953 290.530233-290.530233V290.530233C1024 130.309953 893.690047 0 733.469767 0zM464.943628 741.566512L225.089488 518.858419l60.392186-48.008931 138.59721 101.066419s158.219907-173.079814 351.779721-289.577674l23.147162 27.433674s-220.326698 186.701395-334.062139 431.699349z"  ></path></symbol><symbol id="icon-shangchuan" viewBox="0 0 1501 1024"><path d="M1205.169231 363.362462C1157.986462 153.442462 969.806769 0 750.670769 0S343.355077 153.442462 296.172308 363.362462C129.969231 380.928 0 522.003692 0 692.775385 0 875.441231 148.558769 1024 331.224615 1024h64.118154a51.2 51.2 0 1 0 0-102.4h-64.118154C205.036308 921.6 102.4 818.963692 102.4 692.775385S205.036308 463.950769 331.224615 463.950769c1.339077 0 2.678154 0 4.096 0.078769l49.073231 1.417847 5.907692-46.001231C413.380923 238.670769 568.32 102.4 750.749538 102.4s337.368615 136.270769 360.448 317.046154l5.907693 46.001231 49.073231-1.417847c1.339077 0 2.678154-0.078769 4.096-0.078769 126.188308 0 228.824615 102.636308 228.824615 228.824616S1296.462769 921.6 1170.274462 921.6h-64.669539a51.2 51.2 0 1 0 0 102.4h64.669539c182.665846 0 331.224615-148.558769 331.224615-331.224615 0-170.771692-129.969231-311.847385-296.172308-329.412923z"  ></path><path d="M791.000615 518.065231c-4.253538-4.253538-9.058462-7.561846-14.178461-10.003693-7.640615-4.489846-16.462769-7.168-25.993846-7.168-8.979692 0-17.486769 2.363077-24.812308 6.459077-5.671385 2.520615-11.027692 5.986462-15.753846 10.712616L523.657846 704.669538a51.152738 51.152738 0 0 0 36.233846 87.355077c13.154462 0 26.230154-4.962462 36.233846-14.966153L699.707077 673.476923v294.518154a51.2 51.2 0 1 0 102.4 0V673.870769l103.187692 103.187693c10.003692 10.003692 23.079385 14.966154 36.233846 14.966153s26.230154-4.962462 36.233847-14.966153a51.152738 51.152738 0 0 0 0-72.388924l-186.604308-186.604307z"  ></path></symbol></svg>',function(c){var a=(a=document.getElementsByTagName("script"))[a.length-1],l=a.getAttribute("data-injectcss"),a=a.getAttribute("data-disable-injectsvg");if(!a){var h,t,p,z,i,M=function(a,l){l.parentNode.insertBefore(a,l)};if(l&&!c.__iconfont__svg__cssinject__){c.__iconfont__svg__cssinject__=!0;try{document.write("<style>.svgfont {display: inline-block;width: 1em;height: 1em;fill: currentColor;vertical-align: -0.1em;font-size:16px;}</style>")}catch(a){console&&console.log(a)}}h=function(){var a,l=document.createElement("div");l.innerHTML=c._iconfont_svg_string_4455139,(l=l.getElementsByTagName("svg")[0])&&(l.setAttribute("aria-hidden","true"),l.style.position="absolute",l.style.width=0,l.style.height=0,l.style.overflow="hidden",l=l,(a=document.body).firstChild?M(l,a.firstChild):a.appendChild(l))},document.addEventListener?~["complete","loaded","interactive"].indexOf(document.readyState)?setTimeout(h,0):(t=function(){document.removeEventListener("DOMContentLoaded",t,!1),h()},document.addEventListener("DOMContentLoaded",t,!1)):document.attachEvent&&(p=h,z=c.document,i=!1,f(),z.onreadystatechange=function(){"complete"==z.readyState&&(z.onreadystatechange=null,d())})}function d(){i||(i=!0,p())}function f(){try{z.documentElement.doScroll("left")}catch(a){return void setTimeout(f,50)}d()}}(window);]]></content>
      
    </entry>
    
    
  
</search>
