<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>MySQL笔记_6 | Sangs Blog</title><meta name="author" content="Sangs"><meta name="copyright" content="Sangs"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="语句耗时  如果select长时间不返回，使用show processlist查看当前语句处于什么状态  比如MDL写锁阻塞了别的session的读 可以查询是什么session阻塞，但是在MySQL启动时需要设置performance_schema &#x3D; ON，这样会有10%的性能损失      sys.schema_table_lock_waits，查询这张表可以找到导致阻塞的processid">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL笔记_6">
<meta property="og:url" content="https://sangs3112.github.io/posts/ce24a37f.html">
<meta property="og:site_name" content="Sangs Blog">
<meta property="og:description" content="语句耗时  如果select长时间不返回，使用show processlist查看当前语句处于什么状态  比如MDL写锁阻塞了别的session的读 可以查询是什么session阻塞，但是在MySQL启动时需要设置performance_schema &#x3D; ON，这样会有10%的性能损失      sys.schema_table_lock_waits，查询这张表可以找到导致阻塞的processid">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://sangs3112.github.io/img/avatar.png">
<meta property="article:published_time" content="2024-12-07T01:49:37.185Z">
<meta property="article:modified_time" content="2024-12-07T01:49:37.185Z">
<meta property="article:author" content="Sangs">
<meta property="article:tag" content="MySQL">
<meta property="article:tag" content="主从延迟解决">
<meta property="article:tag" content="幻读">
<meta property="article:tag" content="死锁">
<meta property="article:tag" content="加锁判断">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://sangs3112.github.io/img/avatar.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://sangs3112.github.io/posts/ce24a37f.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><meta name="google-site-verification" content="https://github.com/Sangs3112/Sangs3112.github.io/blob/master/googlea12c1ab75804fd8f.html"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'MySQL笔记_6',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-12-07 09:49:37'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><meta name="referrer" content="no-referrer" /><!-- hexo injector head_end start --><link rel="stylesheet" href="https://unpkg.zhimg.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.1.1"><link rel="alternate" href="/atom.xml" title="Sangs Blog" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">31</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">59</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw fas fa-home faa-tada"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><i class="fa-fw fas fa-folder-open faa-tada"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/tags/"><i class="fa-fw fas fa-tags faa-tada"></i><span> 标签</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Sangs Blog"><span class="site-name">Sangs Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw fas fa-home faa-tada"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><i class="fa-fw fas fa-folder-open faa-tada"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/tags/"><i class="fa-fw fas fa-tags faa-tada"></i><span> 标签</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">MySQL笔记_6</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-12-07T01:49:37.185Z" title="发表于 2024-12-07 09:49:37">2024-12-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-12-07T01:49:37.185Z" title="更新于 2024-12-07 09:49:37">2024-12-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/MySQL/">MySQL</a></span></div><div class="meta-secondline"></div></div></div><article class="post-content" id="article-container"><h1>语句耗时</h1>
<ol>
<li>如果<code>select</code>长时间不返回，使用<code>show processlist</code>查看当前语句处于什么状态
<ul>
<li>比如<code>MDL</code>写锁阻塞了别的<code>session</code>的读</li>
<li>可以查询是什么<code>session</code>阻塞，但是在<code>MySQL</code>启动时需要设置<code>performance_schema = ON</code>，这样会有<code>10%</code>的性能损失</li>
</ul>
</li>
</ol>
<ul>
<li>
<p><code>sys.schema_table_lock_waits</code>，查询这张表可以找到导致阻塞的<code>processid</code>，<code>kill</code>掉即可</p>
</li>
<li>
<p>还有可能被<code>flush</code>阻塞了，一般<code>flush</code>的两个语句是<code>flush table t with read lock</code>锁表<code>t</code>，<code>flush tables with read lock</code>锁所有的表，本身刷脏页的速度很快，但是可能<code>flush</code>命令被别的<code>session</code>阻塞了</p>
</li>
<li>
<p>或者别的线程占用写锁，那么申请<code>lock in share mode</code>的读锁就会被阻塞。通过查找<code>sys.innodb_lock_waits</code>表即可</p>
</li>
<li>
<p>如果在<code>RR</code>场景下，或者在一个事务中，使用<code>select</code>，如果此时别的<code>session</code>有一个<code>update</code>语句，<code>update</code>了一百万次，那么自己的<code>select</code>语句就会特别慢，因为是一致性读，会存在非常大的<code>undolog</code>需要不断查找，而如果使用<code>select in lock share mode</code>，就是当前读，速度就会很快。</p>
</li>
</ul>
<h1>幻读</h1>
<ol>
<li><code>RR</code>下，普通查询是快照读，幻读只有在当前读的环境下才会出现，因为快照读不会看到别人提交的数据。并且，如果别人修改了一行，在当前读的两次查询中，第二次查询才读到，那不是幻读。幻读只有是读到别人新插入的行</li>
</ol>
<ul>
<li>
<p>幻读会破坏加锁的语义，因为先对d=5的行加锁，在别的<code>session</code>中<code>insert</code>了一条d=5，a=1的行，并修改a=1的行将b改成2，这样的话，也就是修改了d=5的行，破坏了最初对d=5的行加锁的语义</p>
</li>
<li>
<p>幻读 + statement格式的<code>binlog</code>会导致数据不一致性，因为<code>binlog</code>是在<code>commit</code>的时候才会记录，</p>
</li>
<li>
<p>即便给所有的行都加上锁，也无法解决幻读的问题，因为原本不存在的行，无法加锁，所以即便给所有的行都加锁，也没有办法阻止插入新的行</p>
</li>
<li>
<p>所以需要加上间隙锁，在值和值的中间加锁，避免插入新的值</p>
</li>
<li>
<p>解决幻读，需要加行锁和间隙锁(<code>gap lock</code>，开区间)</p>
</li>
<li>
<p>行锁 + 间隙锁 = <code>next-key lock</code> (临键锁，左开右闭)</p>
</li>
</ul>
<h2 id="死锁">死锁</h2>
<ol>
<li>如果对不存在的一行加锁，比如id=9，不存在<br>
<code>select * from t where id = 9 for update</code>
<ul>
<li>那么本来应该加行锁+间隙锁，但是因为id=9不存在，所以只会加间隙锁</li>
</ul>
</li>
<li>本来<code>select for update</code>是两个排他锁，但是因为不存在这一行，所以两个<code>session</code>都可以对<code>id=9</code>这一行使用<code>select for update</code>，因为都是间隙锁，所以不会冲突</li>
<li>此时<code>session B</code>判断不存在这一行，尝试添加<code>id=9</code>的记录，但是因为<code>session A</code>中有间隙锁，所以被阻塞</li>
<li><code>session A</code>也判断不存在这一行，尝试添加<code>id=9</code>的记录，但是因为<code>session B</code>中存在间隙锁，所以被阻塞，导致死锁</li>
</ol>
<ul>
<li>所以<code>RR</code>会导致死锁，因为只有<code>RR</code>才有间隙锁，一般会设置为<code>RC + row</code>格式的<code>binlog</code>，这样可以解决死锁，并且不会出现数据日志不一致问题</li>
<li>一般在金融等，或者表备份的时候，才是<code>RR</code></li>
</ul>
<h1>加锁</h1>
<ol>
<li>加锁的基本单位是<code>next-key lock</code>，前开后闭</li>
<li>查找中访问的对象才会加锁</li>
<li>索引上等值查询，唯一索引的时候<code>next-key lock</code> 退化为行锁</li>
<li>等值查询，最右边的值不满足等值查询的时候，退化为间隙锁</li>
<li>唯一索引上范围查询会找到不满足条件的第一个值</li>
</ol>
<p>现在一张表，字段是<code>id，c, d</code>，<code>c</code>上有普通索引，<code>id</code>是主键</p>
<ul>
<li>内含数据<code>(0, 0, 0)(5, 5, 5)(10, 10, 10)(15, 15, 15)(20, 20, 20)(25, 25, 25)</code></li>
</ul>
<h2 id="举例1-等值查询间隙锁">举例1 - 等值查询间隙锁</h2>
<table>
<thead>
<tr>
<th style="text-align:center">sessionA</th>
<th style="text-align:center">session B</th>
<th style="text-align:center">session C</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">begin;</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">update t set d = d + 1 where id = 7;</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">insert into t values(8, 8, 8);</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">update t set d = d + 1 where id = 10;</td>
</tr>
</tbody>
</table>
<ul>
<li>对于<code>session A</code>表中没有<code>id=7</code>的行，加锁单位是临键锁，前开后闭，所以范围是<code>(5, 10]</code></li>
<li>id=7是等值查询，找到最后边的值10，不满足等值条件，所以退化为间隙锁，加锁范围就是<code>(5, 10)</code></li>
<li><code>session B</code>插入id=8就会被阻塞，但是<code>session C</code>插入id=10不会被锁</li>
</ul>
<h2 id="举例2-非唯一索引等值查询">举例2 - 非唯一索引等值查询</h2>
<table>
<thead>
<tr>
<th style="text-align:center">sessionA</th>
<th style="text-align:center">session B</th>
<th style="text-align:center">session C</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">begin;</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">select id from t where c = 5 lock in share mode;</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">update t set d = d + 1 where id = 5;</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">insert into t values(7, 7, 7);</td>
</tr>
</tbody>
</table>
<ul>
<li>加临键锁，对<code>(0, 5]</code></li>
<li>c是普通索引，所以会访问到右边第一个不满足的值为止，也就是查询到10， 所以<code>(5, 10]</code>加临键锁</li>
<li>c=5是等值查询，最右边一个值10不满足等值条件，退化为间隙锁<code>(5, 10)</code></li>
<li>访问到的对象才会加锁，覆盖索引不需要访问主键，所以主键索引不需要加锁，因此<code>session B</code>可以完成，<code>session C</code>插入<code>(7, 7, 7)</code>会被阻塞</li>
<li><code>lock in share mode</code>只会锁覆盖索引，但是<code>for update</code>会判断你要更新，就会给主键索引上满足条件加行锁</li>
</ul>
<h2 id="举例3-主键索引范围查询">举例3 - 主键索引范围查询</h2>
<table>
<thead>
<tr>
<th style="text-align:center">sessionA</th>
<th style="text-align:center">session B</th>
<th style="text-align:center">session C</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">begin;</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">select * from t where id &gt;= 10 and id &lt; 11 for update;</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">insert into t values(8, 8, 8);</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">insert into t values(13, 13, 13);</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">update t set d = d + 1 where id = 15;</td>
</tr>
</tbody>
</table>
<ul>
<li>先找到<code>id = 10</code>，<code>next-key lock (5, 10]</code>，但是唯一索引会退化为行锁</li>
<li>但是范围查找，找到id=15停止，所以会有临键锁<code>(10, 15]</code></li>
<li>所以B插入<code>(8, 8, 8)</code>可以通过，插入<code>(13, 13, 13)</code>被阻塞；C更新15也被阻塞</li>
</ul>
<h2 id="举例4-非唯一索引范围查询">举例4 - 非唯一索引范围查询</h2>
<table>
<thead>
<tr>
<th style="text-align:center">sessionA</th>
<th style="text-align:center">session B</th>
<th style="text-align:center">session C</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">begin;</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">select * from t where c &gt;= 10 and c &lt; 11 for update;</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">insert into t values(8, 8, 8);</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">update t set d = d + 1 where c = 15;</td>
</tr>
</tbody>
</table>
<ul>
<li>查找c = 10的时候，临键锁<code>(5, 10]</code>，不是唯一索引，不会退化为行锁</li>
<li><code>session A</code>加上了两个临键锁<code>(5, 10]</code>和<code>(10, 15]</code></li>
<li>B插入<code>(8, 8, 8)</code>阻塞</li>
</ul>
<h2 id="举例5-唯一索引范围查询bug">举例5 - 唯一索引范围查询bug</h2>
<table>
<thead>
<tr>
<th style="text-align:center">sessionA</th>
<th style="text-align:center">session B</th>
<th style="text-align:center">session C</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">begin;</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">select * from t where id &gt; 10 and id &lt;= 15 for update;</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">update t set d = d + 1 where id = 20;</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">insert into t values(16, 16, 16);</td>
</tr>
</tbody>
</table>
<ul>
<li>A是范围查询，索引id加到<code>(10, 15]</code>临键锁，id是唯一索引，所以判断到id=15结束</li>
<li>但是会访问到第一个不满足条件的值为止，所以会找到id=20，范围查询，所以会加上<code>(15, 20]</code>的临键锁</li>
<li>因此B更新20会阻塞，C插入16也会阻塞</li>
</ul>
<h2 id="举例6-非唯一索引存在等值">举例6 - 非唯一索引存在等值</h2>
<p>比如同时有两行c=10，分别是<code>(10, 10, 10)</code>，和<code>(30, 10, 30)</code></p>
<ul>
<li>非唯一索引上包含主键值，所以不会重复</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">sessionA</th>
<th style="text-align:center">session B</th>
<th style="text-align:center">session C</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">begin;</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">delete from t where c = 10;</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">insert into t values(12, 12, 12);</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">update t set d = d + 1 where c = 15;</td>
</tr>
</tbody>
</table>
<ul>
<li>A遍历找到第一个c=10的记录，所以临键锁加在<code>(5 5, 10 10]</code>上</li>
<li>A向右查找，碰到第一个不满足条件的行，也就是<code>15 15</code>停止，等值查询，退化为<code>10 10</code>到<code>15 15</code>的行锁</li>
<li>所以最后是<code>(5 5, 10 10]</code>临键锁，<code>(10 10, 15 15)</code>行锁，因此B插入12会被阻止，C修改15会通过</li>
</ul>
<h2 id="举例7-limit加锁">举例7 - limit加锁</h2>
<table>
<thead>
<tr>
<th style="text-align:center">sessionA</th>
<th style="text-align:center">session B</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">begin;</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">delete from t where c = 10 limit 2;</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">insert into t values(12, 12, 12);</td>
</tr>
</tbody>
</table>
<ul>
<li>因为有<code>limit 2</code>，所以遍历到<code>10 30</code>后，就已经满足两条了，循环结束</li>
<li>A加锁范围就是<code>(5 5, 10 10]</code>临键锁<code>(10 10, 10 30]</code>临键锁</li>
<li>B插入12通过</li>
<li>所以删除的时候可以加<code>limit</code>，限制删除的条数，操作更安全。
<ul>
<li>但是唯一索引上删除不需要，因为唯一索引本身就只加行锁</li>
<li>可能更适合普通索引，但是数据是唯一的情况</li>
</ul>
</li>
</ul>
<h2 id="举例8-死锁">举例8 - 死锁</h2>
<table>
<thead>
<tr>
<th style="text-align:center">sessionA</th>
<th style="text-align:center">session B</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">begin;</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">select id from t where c = 10 lock in share mode;</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">update t set d = d + 1 where c = 10;</td>
</tr>
<tr>
<td style="text-align:center">insert into t values (8, 8, 8)</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<ul>
<li>A在c上加了<code>(5, 10]</code>临键锁和<code>(10, 15)</code>间隙锁</li>
<li>B要在c上加<code>(5, 10]</code>临键锁，所以等待A释放</li>
<li>A 想插入8，需要加锁，等待B释放，死锁</li>
<li>最后B回滚</li>
<li>B的临键锁没有申请成功，但是B加锁<code>(5, 10]</code>先加间隙锁，加锁成功，再加c=10的行锁，阻塞，两段执行</li>
</ul>
<h2 id="总结">总结</h2>
<ul>
<li>RR才有间隙锁，并且两阶段提交，事务<code>commit</code>了，锁释放</li>
<li>RC没有间隙锁，并且语句执行完就会释放不满足条件的行的行锁</li>
<li>RC在外键也会有间隙锁</li>
</ul>
<h1>优化</h1>
<ul>
<li><code>show variables like '%connections%;查看max_connections</code>，也就是最大连接数，超过最大连接数的就会被阻止，最大连接数不是越大越好。</li>
</ul>
<ol>
<li>处理掉占用连接但是没有工作的线程
<ul>
<li><code>show variables like 'wait_timeout';</code>查看超时时间，超过时间以后就会断开连接</li>
<li>可以使用<code>kill connection + id</code>，但是这样客户端不会马上知道，只有在发起下一个请求以后才会报错，就变成了<code>MySQL</code>一直都没有恢复，但是再次 调用接口就可以访问了</li>
</ul>
</li>
<li>减少连接消耗
<ul>
<li>用<code>–skip-grant-tables</code>跳过权限验证，但是<strong>风险极高，不建议使用</strong>，找回密码可以用</li>
<li><strong>8.0版本</strong>如果使用跳过权限验证，会同时<code>--skip-networking</code>打开这个，保证数据库只有本地访问</li>
</ul>
</li>
<li>性能问题导致短链接增加
<ul>
<li>慢查询
<ul>
<li>索引没设计好
<ul>
<li><strong>5.6版本后</strong>可以使用<code>Online DDL</code>创建索引，<code>alert table</code>即可</li>
<li>如果一主一备，在从库处理，<code>set sql_log_bin=off</code>，不写<code>binlog</code>，加索引</li>
<li>主备切换</li>
<li>再在从库<code>set sql_log_bin=off</code>，加索引</li>
</ul>
</li>
<li>语句有问题
<ul>
<li>使用存储过程<code>query_rewrite</code>重写某一个语句</li>
</ul>
</li>
<li>选错索引
<ul>
<li>使用<code>query_rewrite</code>加上索引即可，或者语句加索引</li>
</ul>
</li>
<li>可以在上线前处理好，上线前将<code>slow log</code>打开，<code>long_query_time=0</code>记录查询语句</li>
<li>测试表模拟线上数据，回归测试</li>
<li>留意<code>row_examined</code>数据</li>
<li>全量回归测试可以使用开源工具<code>pt-query-digest</code></li>
</ul>
</li>
<li><code>QPS</code>暴增
<ul>
<li>如果是全新业务有<code>bug</code>，下掉业务，数据库端去除白名单</li>
<li>新功能是单独数据库用户，删除用户，断开现有连接</li>
<li>如果和现有业务部署在一起，查询重写功能重写语句，压力最大的<code>SQL</code>直接<code>select 1</code>返回
<ul>
<li>但是会有误伤，如果别的业务也用了这个SQL，或者这个语句还有别的用处，都会导致其他业务失败</li>
</ul>
</li>
</ul>
</li>
<li>更新语句</li>
</ul>
</li>
</ol>
<h1>数据更新</h1>
<ul>
<li>
<p><code>binlog</code>在事务执行时写入<code>binlog cache</code>，事务提交时写入<code>binlog</code>，清空<code>cache</code></p>
</li>
<li>
<p><code>binlog_cache_size</code>控制<code>cache</code>大小，超过大小的暂时写入磁盘</p>
</li>
<li>
<p>多个线程有自己的<code>binlog cache</code>，但是共用一个<code>binlog</code></p>
</li>
<li>
<p><code>write</code>是写入<code>cache</code>，速度快，<code>fsync</code>是写<code>binlog</code>文件，<code>sync_binlog</code>参数控制时机</p>
<ul>
<li><code>sync_binlog = 0</code>，每次提交只<code>write</code>，不<code>fsync</code></li>
<li><code>sync_binlog = 1</code>每次提交都会<code>fsync</code></li>
<li><code>sync_binlog = N</code>(<code>N &gt; 1</code>)，每次都<code>write</code>，累计<code>N</code>个事务再<code>fsync</code></li>
<li>IO非常大的话，可以适当调大这个值，<code>100 - 1000</code>，但是如果重启了，就会丢失N条<code>binlog</code>，如果容错率很低，不能设置为1</li>
</ul>
</li>
<li>
<p><code>redo log</code>三种状态，分别是<code>redo log buffer</code>，<code>write</code>到<code>page cache</code>，没有持久化和<code>fsync</code>到磁盘，<code>innodb_flush_log_at_trx_commit</code>控制</p>
<ul>
<li><code>= 0</code> 表示每次都只保存再<code>buffer</code>中</li>
<li><code>= 1</code> 表示每次提交都持久化到磁盘</li>
<li><code>= 2</code> 表示每次提交都<code>write</code>到<code>page cache</code></li>
<li><code>InnoDB</code>后台线程每隔1s都会将<code>redo log buffer</code>中的内容<code>write</code>到<code>pagecache</code>再<code>fsync</code>到磁盘，所有的线程共用一个<code>redo log buffer</code>，与<code>binlog</code>不同，所以没有提交的事务的<code>redo log</code>，也有可能被持久化到磁盘</li>
<li>同样，如果<code>redo log buffer</code>占用<code>innodb_log_buffer_size</code>即将到达一半，就会触发主动写盘，但是只<code>write</code>，没有<code>fysnc</code></li>
<li>如果并行事务，并且<code>innodb_flush_log_at_trx_commit=1</code>，那么别的事务提交的时候，会把自己没有提交的<code>redo log</code> 持久化到磁盘</li>
<li>如果=1，那么<code>prepare</code>阶段就会持久化一次，所以只需要每隔1s的刷盘，崩溃恢复的逻辑，只需要<code>binlog</code>写入磁盘，<code>redo log prepare write</code>了，就不需要<code>fsync</code>了</li>
<li>如果<code>sync_binlog=1， innodb_flush_log_at_trx_commit=1</code>，那么事务提交前，现需要等两次刷盘，一次是<code>redo log</code>的<code>prepare</code>，一次是<code>binlog</code></li>
<li>也就是如果<code>MySQL``TPS</code>两万，就会有四万次写磁盘，所以使用了组提交的方法减少写盘。</li>
</ul>
</li>
<li>
<p>日志逻辑序列号是<code>LSN</code>，单调递增，对应<code>redo log</code>的写入点，写入长度为<code>len</code>，那么<code>LSN + len</code>，可以避免多次重复提交<code>redo log</code></p>
<ul>
<li>比如三个事务同时在<code>redo log buffer</code>中，事务1写盘的时候，会带上事务23写盘，这样<code>LSN</code>之前的事务都完成了写盘，只需要看<code>LSN</code>后的事务即可</li>
<li><code>binlog</code>也是有组提交，但是效果不如<code>redo log</code>，因为<code>redo log</code>时间较短，所以<code>binlog</code>等不到那么多</li>
</ul>
</li>
</ul>
<ol>
<li>设置<code>binlog_group_commit_sync_delay</code>和<code>binlog_group_commit_sync_no_delay_count</code>，满足一个即可，减少<code>binlog</code>的写盘次数，故意等待时间，跟<code>sync_binlog</code>不同，<code>sync</code>是没有写盘就<code>commit</code>事务，但是这两个参数是直到写盘了，才<code>commit</code>事务，会增加响应时间，但是不会像<code>sync</code>一样丢数据
<ul>
<li><code>innodb_flush_log_at_trx_commit</code>不建议为0，这样<code>redo log</code>只会在内存中，宕机了会丢数据</li>
<li><code>innodb_flush_log_at_trx_commit</code>设置成2，性能差不多，只有在主机关机才会丢数据，如果服务宕机，重启以后数据还在</li>
</ul>
</li>
</ol>
<ul>
<li>
<p>binlog不能中断，必须连续写，所以每个线程一个<code>binlog cache</code>，不然主从不一致；<code>redo log</code>甚至可以跟着别的线程一块写，所以都是一个<code>redo log buffer</code></p>
</li>
<li>
<p>所以可以<code>sync_binlog=1,innodb_flush_log_at_trx_commit=2</code>,这样<code>redo log</code>如果丢失了，就通过<code>binlog</code>恢复就可以</p>
</li>
<li>
<p>一般设置非双一，就是<code>innodb_flush_log_at_trx_commit=2</code>、<code>sync_binlog=1000</code></p>
<ul>
<li>业务高峰期，会有预案主库改写为非双1</li>
<li>从库延迟，为了让从库赶上主库，减少<code>binlog</code>生成频率，赶上了可以改回来</li>
<li>用备份恢复主库的副本，也就是使用<code>binlog</code>的时候</li>
<li>批量导入数据也可以修改，不然<code>binlog=row</code>产生内容太多</li>
</ul>
</li>
<li>
<p>主从首先保证了最终一致性，只要主库正确提交，就有<code>binlog</code>，那么从库正常就会重放<code>binlog</code></p>
</li>
<li>
<p>主从延迟就是从库执行完的时间点-主库执行完的时间点</p>
</li>
<li>
<p>从库上执行<code>show slave status</code>，可以看到<code>seconds_behind_master</code>，表示延迟了多少</p>
</li>
<li>
<p>主从延迟最主要是从库消费<code>relay log</code>的速度比主库生成<code>binlog</code>的速度更慢</p>
</li>
<li>
<p>主从延迟来源</p>
<ul>
<li>从库性能比主库机器性能差(但是现在一般不会)</li>
<li>从库压力大，CPU资源占用较多，导致重放<code>relay log</code>速度变慢
<ul>
<li>一主多从，让多个从库分担压力</li>
<li><code>binlog</code>输出到外部，比如<code>Hadoop</code>，让外部提供查询能力</li>
</ul>
</li>
<li>大事务，比如一个事务再主库上执行了十分钟，就延迟了十分钟</li>
<li>大表上<code>DDL</code></li>
</ul>
</li>
</ul>
<h2 id="主从复制">主从复制</h2>
<ol>
<li>5.6版本之前，支持单线程，但是会导致应用日志较慢，造成延迟</li>
<li>多线程就是拆<code>sql thread</code>为多个线程<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/sang3112/blog_imgs/raw/master/MySQL/45_sqlthread.png" alt="45_sqlthread">
<ul>
<li>比如<code>coordinator</code>就是原来的<code>sql thread</code>，但是不更新了，只是负责读中转日志，并分发日志，<code>work</code>线程才更新日志，<code>worker</code>线程个数根据<code>slave_parallel_workers</code>决定，一般32核设置8-16即可，</li>
<li><code>coordinator</code>分发规则：
<ul>
<li>不能更新覆盖，同一行的两个事务必须在同一个<code>worker</code>中</li>
<li>不能拆分事务，同一个事务必须在同一个<code>worker</code>中</li>
</ul>
</li>
</ul>
</li>
<li>按表分发策略
<ul>
<li>如果两个事务更新不同的表，就可以分发到不同的<code>worker</code>中</li>
<li>如果事务跨表，需要将两张表一起考虑</li>
<li>每个<code>worker</code>中对应一张<code>hash</code>表，保存当前<code>worker</code>中正在执行的事务里面涉及的表，值是多少个事务在更新这个表</li>
<li>如果<code>coordinator</code>收到事务T，判断其中修改的表
<ul>
<li>没有<code>worker</code>中包含这些表，那就分给最空闲的<code>worker</code></li>
<li>如果跟多于一个<code>worker</code>冲突，就等待</li>
<li>如果只跟一个<code>worker</code>冲突，那就分给这个<code>worker</code></li>
</ul>
</li>
<li>所以如果热点表，就变成了单线程，如果负载均衡，就很好解决问题</li>
</ul>
</li>
<li>按行分发策略
<ul>
<li>需要<code>binlog = row</code></li>
<li>必须有主键，不能有外键</li>
<li>但是对于大事务，耗费内存，耗费CPU资源更大</li>
</ul>
</li>
<li>5.6版本，按库分发并行</li>
<li>5.7版本<code>slave-parallel-type</code>控制并行策略，配置为<code>DATABASE</code>就是按库并行，配置<code>LOGICAL_CLOCK</code>
<ul>
<li>同处于<code>prepare</code>的事务，备库可以并行</li>
<li>处于<code>prepare</code>和<code>commit</code>的事务可以并行</li>
</ul>
</li>
</ol>
<p>一主多从基本架构<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/sang3112/blog_imgs/raw/master/MySQL/45_ms.png" alt="45_ms"></p>
<ol>
<li>主库负责写入和一部分读，从库负责读<br>
切换主库的时候需要找同步位点，5.6版本使用<code>GTID</code>，全局事务ID，在事务提交时生成<br>
两个部分，格式为<code>server_uuid:gno</code>
<ul>
<li><code>server_uuid</code>是实例启动产生的，全局唯一</li>
<li><code>gno</code>是整数，初始值为1，每次提交事务的时候分配给这个事务，就加1</li>
<li>启动<code>GTID</code>在启动时加上参数<code>gtid_mode=on</code> 和 <code>enforce_gtid_consistency=on</code>即可<br>
使用基于<code>GTID</code>的主备切换，就不需要指定位点，因为位点是不精确的。所以建议使用基于<code>GTID</code>的主从复制</li>
</ul>
</li>
</ol>
<h3 id="主从延迟怎么解决">主从延迟怎么解决</h3>
<ol>
<li>
<p>强制走主库方案；</p>
<ul>
<li>比如交易平台，卖家发布商品以后，马上返回主页面，看商品是否发布成功，这个就强制走主库，因为需要拿到最新的结果</li>
<li>如果是买家，晚几秒看到商品也可以接受，就走从库</li>
</ul>
</li>
<li>
<p><code>sleep</code>方案</p>
<ul>
<li><code>sleep(1)</code>大部分同步1s内能搞定，但是不太稳妥</li>
</ul>
</li>
<li>
<p>判断主备无延迟方案</p>
<ol>
<li><code>show slave status中的seconds_behind_master</code>是否等于0
<ul>
<li>单位是秒，如果精度不够，可以使用位点和<code>GTID</code></li>
</ul>
</li>
<li><code>Master_Log_File</code>和<code>Read_Master_Log_Pos</code>表示读到主库的最新位点<br>
<code>Relay_Master_Log_File</code>和<code>Exec_Master_Log_Pos</code>表示备库执行的最新位点<br>
如果<code>Master_Log_File=Relay_Master_Log_File&amp;&amp;Read_Master_Log_Pos=Exec_Master_Log_Pos</code>表示日志同步完成</li>
<li><code>GTID</code>中<br>
<code>Auto_Position=1</code>表示主备使用了<code>GTID</code>协议<br>
<code>Retrieved_Gtid_Set</code>是备库收到的所有日志<code>GTID</code>集合<br>
<code>Executed_Gtid_Set</code>是备库已经执行完的<code>GTID</code>集合<br>
如果两个集合相同，则日志同步完成</li>
<li>但是上面的方法是判断备库收到的<code>binlog</code>已经执行完了，但是实际上可能主库有<code>binlog</code>，但是备库还没有收到，这时需要使用半同步复制</li>
<li>业务高峰期，主库位点和<code>GTID</code>更新很快，位点判断就会一直不成立，那么从库就一直都无法响应</li>
</ol>
</li>
<li>
<p>配合<code>semi-sync</code>方案</p>
<ul>
<li>牺牲一定可用性，保持一致性</li>
<li>但是因为半同步只要一个从库同步就返回<code>ack</code>，实际上请求可能打到别的没有同步的从库上</li>
<li>所以半同步配合位点方案，会有问题
<ul>
<li>一主多从，会有过期读的问题</li>
<li>如果一直有延迟，就一直无法<code>select</code>，但是实际上不需要等待到完全没有延迟，而是只要一个事务完成以后，<code>select</code>到哪个事务即可，不需要等待其他事务也同步完</li>
</ul>
</li>
</ul>
</li>
<li>
<p>等主库位点方案</p>
<ul>
<li><code>select master_pos_wait(file, pos[, timeout]);</code>
<ul>
<li><code>file pos</code>是主库上的文件名和位置</li>
<li>从库上执行</li>
<li><code>timeout</code>可选，表示超时</li>
<li>返回一个正整数<code>M</code>，表示命令开始执行，到应用完<code>file</code>和<code>pos</code>表示的<code>binlog</code>位置，一共执行了多少个事务</li>
<li>如果备库挂了，那就返回<code>NULL</code></li>
<li>如果超时，返回<code>-1</code></li>
<li>如果执行时，已经执行过这个位置了，返回0</li>
</ul>
</li>
<li>具体流程
<ul>
<li>一个事务执行完，马上在主库上执行<code>show master status</code>得到主库执行到的<code>File</code>和<code>Pos</code>(不需要完全精确)</li>
<li>选一个从库查询</li>
<li>从库上执行<code>select master_pos_wait(File, Pos, 1);</code></li>
<li>如果返回&gt;=0，则再这个从库上执行查询语句</li>
<li>否则就去主库查询</li>
</ul>
</li>
<li>所以如果不允许过期读的情况出现，那么就超时放弃，或者转到主库查询，并做限流</li>
</ul>
</li>
<li>
<p>等 <code>GTID</code> 方案</p>
<ul>
<li><code>WAIT_FOR_EXECUTED_GTID_SET(gtid_set[, timeout])</code>，超时时间默认为0，如果为0，表示一直等待
<ul>
<li>语句作用：等待，直到这个库执行的事务包含传入的<code>gtid_set</code>，返回0</li>
<li>超时返回1</li>
</ul>
</li>
<li>5.7版本后，不需要主动执行<code>show master status</code>，而是更新以后返回事务的<code>GTID</code>，减少一次查询
<ul>
<li><code>session_track_gtids = OWN_GTID</code></li>
<li>通过API从<code>mysql_session_track_get_first</code>解析<code>GTID</code>即可</li>
</ul>
</li>
<li>具体流程
<ul>
<li>事务完成，接受到事务的<code>GTID，gtid1</code></li>
<li>选一个从库查询，执行<code>WAIT_FOR_EXECUTED_GTID_SET(gtid1, 1)</code></li>
<li>返回0就在这个从库查询</li>
<li>否则去主库查询</li>
</ul>
</li>
</ul>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://sangs3112.github.io">Sangs</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://sangs3112.github.io/posts/ce24a37f.html">https://sangs3112.github.io/posts/ce24a37f.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://sangs3112.github.io" target="_blank">Sangs Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/MySQL/">MySQL</a><a class="post-meta__tags" href="/tags/%E4%B8%BB%E4%BB%8E%E5%BB%B6%E8%BF%9F%E8%A7%A3%E5%86%B3/">主从延迟解决</a><a class="post-meta__tags" href="/tags/%E5%B9%BB%E8%AF%BB/">幻读</a><a class="post-meta__tags" href="/tags/%E6%AD%BB%E9%94%81/">死锁</a><a class="post-meta__tags" href="/tags/%E5%8A%A0%E9%94%81%E5%88%A4%E6%96%AD/">加锁判断</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/posts/b92393e9.html" title="MySQL笔记_7"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MySQL笔记_7</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Sangs</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">31</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">59</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Sangs3112" target="_blank" title="Github"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-fill"></use></svg></a><a class="social-icon" href="mailto:Sangs3112@163.com" target="_blank" title="Email"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-002_youxiang"></use></svg></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">语句耗时</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">幻读</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">2.1.</span> <span class="toc-text">死锁</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">加锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B1-%E7%AD%89%E5%80%BC%E6%9F%A5%E8%AF%A2%E9%97%B4%E9%9A%99%E9%94%81"><span class="toc-number">3.1.</span> <span class="toc-text">举例1 - 等值查询间隙锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B2-%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%AD%89%E5%80%BC%E6%9F%A5%E8%AF%A2"><span class="toc-number">3.2.</span> <span class="toc-text">举例2 - 非唯一索引等值查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B3-%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2"><span class="toc-number">3.3.</span> <span class="toc-text">举例3 - 主键索引范围查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B4-%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2"><span class="toc-number">3.4.</span> <span class="toc-text">举例4 - 非唯一索引范围查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B5-%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2bug"><span class="toc-number">3.5.</span> <span class="toc-text">举例5 - 唯一索引范围查询bug</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B6-%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E5%AD%98%E5%9C%A8%E7%AD%89%E5%80%BC"><span class="toc-number">3.6.</span> <span class="toc-text">举例6 - 非唯一索引存在等值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B7-limit%E5%8A%A0%E9%94%81"><span class="toc-number">3.7.</span> <span class="toc-text">举例7 - limit加锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B8-%E6%AD%BB%E9%94%81"><span class="toc-number">3.8.</span> <span class="toc-text">举例8 - 死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.9.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">优化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">数据更新</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">5.1.</span> <span class="toc-text">主从复制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%BB%B6%E8%BF%9F%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><span class="toc-number">5.1.1.</span> <span class="toc-text">主从延迟怎么解决</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/ce24a37f.html" title="MySQL笔记_6">MySQL笔记_6</a><time datetime="2024-12-07T01:49:37.185Z" title="发表于 2024-12-07 09:49:37">2024-12-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/b92393e9.html" title="MySQL笔记_7">MySQL笔记_7</a><time datetime="2024-12-07T01:49:37.185Z" title="发表于 2024-12-07 09:49:37">2024-12-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/f86b96e2.html" title="Go笔记_0">Go笔记_0</a><time datetime="2024-12-07T01:49:37.181Z" title="发表于 2024-12-07 09:49:37">2024-12-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/8f6ca674.html" title="Go笔记_1">Go笔记_1</a><time datetime="2024-12-07T01:49:37.181Z" title="发表于 2024-12-07 09:49:37">2024-12-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/faad89a5.html" title="Java笔记_7">Java笔记_7</a><time datetime="2024-12-01T10:21:00.000Z" title="发表于 2024-12-01 18:21:00">2024-12-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.8/dist/lazyload.iife.min.js"></script><div class="js-pjax"></div><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="Hexo" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/Sangs3112" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="/js/ali_font.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('article-sort-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__slideInRight');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --></body></html>