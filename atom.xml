<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sangs Blog</title>
  
  
  <link href="https://sangs3112.github.io/atom.xml" rel="self"/>
  
  <link href="https://sangs3112.github.io/"/>
  <updated>2024-03-13T07:15:25.593Z</updated>
  <id>https://sangs3112.github.io/</id>
  
  <author>
    <name>Sangs</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL笔记_2</title>
    <link href="https://sangs3112.github.io/posts/c9496766.html"/>
    <id>https://sangs3112.github.io/posts/c9496766.html</id>
    <published>2024-03-13T02:21:17.000Z</published>
    <updated>2024-03-13T07:15:25.593Z</updated>
    
    <content type="html"><![CDATA[<h1>索引</h1><div class="note info flat"><ul><li>高效获取数据的<strong>有序</strong>数据结构</li><li>提高检索效率，降低IO成本。</li><li>索引列对数据进行<strong>排序</strong>，降低排序成本，减少CPU的消耗</li><li>但是需要占用一些空间，提高查询效率有时候会降低更新表的速度，比如增删改。但是实际上增删改比例较少。</li></ul></div><table><thead><tr><th style="text-align:center">索引结构</th><th style="text-align:center">描述</th><th style="text-align:center"><code>InnoDB</code></th><th style="text-align:center"><code>MyISAM</code></th><th style="text-align:center"><code>Memory</code></th></tr></thead><tbody><tr><td style="text-align:center">B+树索引</td><td style="text-align:center">最常见的索引类型，大部分引擎都支持</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">Hash索引</td><td style="text-align:center">底层使用哈希表实现，只能精确匹配索引列的查询才有效，不支持范围查询</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">R-tree(空间索引)</td><td style="text-align:center">是<code>MyISAM</code>引擎的一个特殊索引类型，用于地理空间数据类型，使用较少</td><td style="text-align:center">-</td><td style="text-align:center">支持</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">Full-text(全文索引)</td><td style="text-align:center">通过建立倒排索引，快速匹配文档的方式，类似于<code>Lucene, Solr, ES</code></td><td style="text-align:center">5.6版本后支持</td><td style="text-align:center">支持</td><td style="text-align:center">-</td></tr></tbody></table><h2 id="B-树">B+树</h2><ul><li><p>B+树的<strong>所有元素都在叶子节点处</strong>，非叶子节点只用于索引，存储都在叶子节点处，<strong>所有叶子节点形成了一个单向链表</strong>。<br><img src="https://gitee.com/sang3112/blog_imgs/raw/d97d1acffa4285fae00105cf631f50575b612f38/MySQL/B+tree.png" alt="B+tree"></p></li><li><p><code>MySQL</code>对B+树进行优化，在原来的B+树基础上，增加了一个指向相邻叶子节点的链表指针，形成了带顺序指针的B+树，提高区间访问性能。<br><img src="https://gitee.com/sang3112/blog_imgs/raw/d97d1acffa4285fae00105cf631f50575b612f38/MySQL/MySQLB+tree.png" alt="MySQLB+tree"></p></li></ul><h3 id="InnoDB为何使用B-树索引，没有选择哈希索引、二叉树或者红黑树索引？"><code>InnoDB</code>为何使用B+树索引，没有选择哈希索引、二叉树或者红黑树索引？</h3><ol><li>如果是二叉树，顺序插入最后会形成链表，搜索性能很低，红黑树可以解决</li><li>但是红黑树本质上还是二叉树，<strong>自平衡二叉树</strong>，某些场景下层级太多了</li><li>B+树相对于二叉树层级更少，搜索效率更高，这也是B树的优点</li><li>但是B树无论叶子还是非叶子节点，都会保存数据，最终导致一页中存储的键值减少，指针也减少。如果要保存大量的数据，只能增加树的高度，导致性能降低。</li><li>对于B+树，找什么都去叶子节点中，所以搜索效率稳定</li><li><code>MySQL</code>中B+树的叶子节点形成了双向链表，便于范围搜索</li><li>哈希索引<strong>不支持</strong>排序和范围匹配，只能等值匹配。</li><li><code>InnoDB</code>也有自适应哈希功能，有的条件下会<strong>自动</strong>将B+树索引转换为哈希索引。(这点在后面会介绍)</li></ol><h2 id="索引分类">索引分类</h2><table><thead><tr><th style="text-align:center">分类</th><th style="text-align:center">含义</th><th style="text-align:center">特点</th><th style="text-align:center">关键字</th></tr></thead><tbody><tr><td style="text-align:center">主键索引</td><td style="text-align:center">针对于表中主键创建的索引</td><td style="text-align:center">默认自动创建，只能有一个</td><td style="text-align:center"><code>PRIMARY</code></td></tr><tr><td style="text-align:center">唯一索引</td><td style="text-align:center">避免同表某数据列中的值重复</td><td style="text-align:center">可以多个</td><td style="text-align:center"><code>UNIQUE</code></td></tr><tr><td style="text-align:center">常规索引</td><td style="text-align:center">快速定位特定数据</td><td style="text-align:center">可以多个</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">全文索引</td><td style="text-align:center">查找文本中关键词，而不是比较索引值</td><td style="text-align:center">可以多个</td><td style="text-align:center"><code>FULLTEXT</code></td></tr></tbody></table><h3 id="按存储形式分类">按<strong>存储形式</strong>分类</h3><table><thead><tr><th style="text-align:center">分类</th><th style="text-align:center">含义</th><th style="text-align:center">特点</th></tr></thead><tbody><tr><td style="text-align:center">聚集索引</td><td style="text-align:center">数据和索引放在一块，索引结构的叶子节点保存了行数据</td><td style="text-align:center">必须有且只有一个</td></tr><tr><td style="text-align:center">二级索引</td><td style="text-align:center">将数据和索引分开存储，索引结构的叶子节点关联的是对应的主键</td><td style="text-align:center">可以多个</td></tr></tbody></table><div class="note info flat"><ul><li>如果存在主键，则主键索引就是聚集索引</li><li>如果没有主键，则<strong>第一个</strong>唯一索引就是聚集索引</li><li>没有主键索引和聚集索引的话，则<code>InnoDB</code>会自动生成一个<code>rowid</code>作为隐藏的聚集索引</li></ul></div><div class="note info flat"><ul><li>聚集索引下面挂的是一整行的数据，二级索引下面挂的是主键</li><li>回表查询: 先走二级索引找到对应的主键，然后再从聚集索引找到需要的数据</li></ul></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">10</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name<span class="operator">=</span>&quot;A&quot;;</span><br><span class="line"># 其中 id 为主键，name也有对应的索引</span><br><span class="line"># 前者性能更高，因为不需要回表查询了，可以直接通过聚集索引找到数据</span><br></pre></td></tr></table></figure><h3 id="InnoDB主键索引中B-树高度为多少？"><code>InnoDB</code>主键索引中B+树高度为多少？</h3><ol><li>假设一行数据为1K，一页中存储16行，<code>InnoDB</code>指针占用6B，主键即使为<code>BIGINT</code>，占用8B</li><li>如果树高为2，假设有n个键，就有n+1个指针，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>∗</mo><mn>8</mn><mo>+</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>∗</mo><mn>6</mn><mo>=</mo><mn>16</mn><mo>∗</mo><mn>1024</mn></mrow><annotation encoding="application/x-tex">n * 8 + (n + 1) * 6 = 16 * 1024</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4653em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">16</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1024</span></span></span></span>计算得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≈</mo><mn>1170</mn></mrow><annotation encoding="application/x-tex">n \approx 1170</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4831em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1170</span></span></span></span></li><li>所以一个节点下面最多1171个指针，一个指针指向下面的子节点，一个子节点表示一个页，最多可以存16行数据。所以如果B+树高2，能够存储数据量为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1171</mn><mo>∗</mo><mn>16</mn><mo>=</mo><mn>18736</mn></mrow><annotation encoding="application/x-tex">1171 * 16 = 18736</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1171</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">16</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">18736</span></span></span></span></li><li>如果树高为3，则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1171</mn><mo>∗</mo><mn>1171</mn><mo>∗</mo><mn>16</mn><mo>=</mo><mn>21939856</mn></mrow><annotation encoding="application/x-tex">1171 * 1171 * 16 = 21939856</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1171</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1171</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">16</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">21939856</span></span></span></span>，所以即使存储两千多万条数据，树结构也只有三层</li></ol><h2 id="索引增删查">索引增删查</h2><h3 id="创建索引">创建索引</h3><p><code>create [unique | fulltext] index 索引名 on 表名 (索引关联字段1, 索引关联字段2, ...);</code></p><div class="note info flat"><ul><li>如果一个索引只关联了一个字段，则称为单列索引</li><li>如果关联了多个字段，则称为联合索引</li></ul></div><h3 id="删除索引">删除索引</h3><p><code>drop index 索引名 on 表名;</code></p><h3 id="查看索引">查看索引</h3><p><code>show index from 表名;</code></p><h2 id="性能分析">性能分析</h2><h3 id="执行频率">执行频率</h3><ul><li><code>show [session | global] status;</code>查看服务器状态信息</li><li><code>show global status like 'Com_______';</code>查看当前数据库的<code>insert, update, delete, select</code>的访问频次 (Com后面是7个下划线)</li></ul><h3 id="慢查询日志">慢查询日志</h3><ul><li>慢查询日志记录了所有执行时间超过指定参数(<code>long_query_time</code>单位: 秒，默认为10秒)的所有语句的日志</li><li><code>show variables like 'slow_query_log';</code>查看慢查询日志是否开启，默认是关闭状态<ul><li>需要在<code>/etc/my.cnf</code>中配置慢查询日志开关，表示超过200ms就是慢查询了<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slow_query_log=1</span><br><span class="line">long_query_time=0.2</span><br></pre></td></tr></table></figure></li></ul></li><li>慢查询日志存放在<code>var/log/mysql/mysql_slow.log</code></li></ul><h3 id="语句耗时">语句耗时</h3><ul><li><code>show profiles;</code>可以查看SQL语句耗时，<code>select @@have_profiling;</code>可以查看当前<code>MySQL</code>是否支持</li><li>确认支持后，还需要查看是否开启了<code>select @@profiling;</code>使用<code>set @@profiling=1</code>开启</li><li>开启后，执行完命令可以使用<code>show profiles;</code>查看一条指令的耗时情况</li><li><code>show profile for query query_id</code>可以查看一条<code>query_id</code>的查询指令的耗时细节</li><li><code>show profile cpu for query query_id</code>可以查看指定指令的CPU耗时细节</li></ul><h3 id="执行计划">执行计划</h3><ul><li>在任意<code>select</code>之前加上<code>explain</code>或者<code>desc</code>就可以查看执行计划<ul><li><code>id</code>: <code>select</code>查询的序列号，表示执行顺序，<code>id</code>相同，从上到下执行；<code>id</code>不同，越大越早执行</li><li><code>select_type</code>: 表示<code>select</code>类型，常见有:<ul><li><code>simple</code>: 简单单表查询</li><li><code>primary</code>: 最外层的主查询</li><li><code>union</code>: 联合查询中的第二个查询</li><li><code>subquery</code>: <code>select/where</code>后的子查询</li></ul></li><li><code>type</code>: 表示连接类型，性能由好到差分别为<code>null, system, const, eq_ref, ref, range, index, all</code><ul><li><code>null</code>: 查询时不访问任何表，比如<code>select 'A';</code></li><li><code>system</code>: 访问系统表</li><li><code>const</code>: 根据主键、唯一索引访问</li><li><code>ref</code>: 根据非唯一索引访问</li><li><code>range</code>: 非唯一索引，但是范围匹配，比如<code>age &gt; 18</code></li><li><code>index</code>: 虽然使用了索引，但是是所有的索引草庙，性能也低</li><li><code>all</code>: 全表扫描，性能最低</li></ul></li><li><code>extra</code>:<ul><li><code>using index condition</code>: 查找使用了索引，但是<strong>需要回表</strong>查询</li><li><code>using where; using index</code>: 查找使用了索引，但是需要的数据在索引列中都能找到，<strong>不需要回表</strong></li></ul></li><li><code>possible_key</code>: 表示这表中可能用到的索引，一个或多个</li><li><code>key</code>: 表示实际用到的索引，<code>null</code>表示没有用到索引</li><li><code>key_len</code>: 表示索引中使用的字节数，是索引字段的最大长度，不是实际使用的长度，不损失精度的前提下越短越好</li><li><code>rows</code>: 表示查询的行数，只是预估值，不是精确值</li><li><code>filtered</code>: 表示查询返回行数占总读取行数的百分比，越大越好</li></ul></li></ul><h2 id="最左前缀法则"><strong>最左前缀法则</strong></h2><ul><li>如果有联合索引，查询从索引的最左列开始，不跳过中间的列。如果跳过某一列，则所有后面的字段都失效</li><li>如果没有索引最左边的列，则索引失效</li><li>只需要<code>where</code>条件有最左边的列即可，只要存在就行，跟在<code>where</code>中的位置无关</li><li>联合索引中出现了范围查询<code>&gt;, &lt;</code>，则右边的索引失效<ul><li><code>select * from user where profession='A' and age &gt; 30 and status='0';</code>则<code>stauts</code>失效</li><li>如果是<code>&gt;=, &lt;=</code> 则不会产生影响，所以尽量少用<code>&gt;, &lt;</code></li></ul></li></ul><h2 id="索引失效">索引失效</h2><div class="note info flat"><ol><li><p>如果在索引列上进行运算，则索引失效</p><ul><li><code>select * from user where phone='12312312312';</code> 走单列索引，<code>type=const</code></li><li><code>select * from user where substring(phone, 10, 2)='15';</code> 走全表扫描，<code>type=all</code></li></ul></li><li><p>字符串不加引号索引就会失效</p><ul><li><code>select * from user where phone=12312312312;</code> 走的是全表扫描，因为没有添加引号</li></ul></li><li><p>仅仅使用尾部模糊匹配，索引不会失效；只要有头部模糊匹配，索引会失效</p><ul><li><code>select * from user where profession like '软件%';</code> 走索引，<code>type=range</code></li><li><code>select * from user where profession like '%软件';</code> 不走索引，<code>type=all</code></li><li><strong>大数据量一定要规避模糊匹配前面加上%的情况</strong></li></ul></li><li><p>使用<code>or</code>分割的条件，只有两侧都有索引，索引才会生效，不然不会生效</p></li><li><p>如果<code>MySQL</code>评估使用索引比全表扫描还要慢，就不会用索引</p><ul><li>比如范围匹配或者判断空或非空，满足要求的条件是表中的绝大部分数据，则不会使用索引，直接走全表扫描了</li></ul></li></ol></div><h2 id="SQL提示"><code>SQL</code>提示</h2><ul><li>一个查询能满足多个索引的时候，<code>MySQL</code>会自动选择一个索引</li><li>可以给<code>MySQL</code>提示，要求选择哪个索引进行查找，从而达到优化的目的</li><li><code>use / ignore / force index;</code> 告诉<code>MySQL</code>使用哪个索引，不使用哪个索引</li><li><code>use index</code>是一个建议，<code>MySQL</code>未必接受；<code>force index</code>是强制<code>MySQL</code>使用这个索引</li></ul><h3 id="如果MySQL取错索引，应该如何操作？">如果<code>MySQL</code>取错索引，应该如何操作？</h3><ol><li>使用<code>use / ignore / force index;</code> 让<code>MySQL</code>使用某个索引</li><li>修改<code>SQL</code>语句，诱导<code>MySQL</code>选择某个索引</li><li>建立合适的索引，删除无效的索引</li></ol><h2 id="覆盖索引">覆盖索引</h2><ul><li>尽量使用覆盖索引，而不用<code>select *</code></li><li>覆盖索引就是查询使用了索引，并且查询的结果返回的列在该索引中能够全部找到，这样不需要回表</li></ul><h2 id="前缀索引">前缀索引</h2><ul><li>如果需要索引很长的字符串，可以使用前缀索引，或者使用<code>ES</code>实现</li><li><code>create index idx_xxx on 表名(字段名(n));</code> 建立前缀索引，<code>n</code>表示要提取这个字段中的前<code>n</code>个字符构建索引</li><li><code>n</code>是前缀长度，可以根据索引<strong>选择性</strong>决定，选择性是<strong>不重复的索引值</strong>(基数)与<strong>数据表的记录总数</strong>的比值。<ul><li>选择性越高，查询效率越高</li><li>唯一索引的选择性就是1，是最高的索引选择性，性能也是最好的<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> email) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> <span class="keyword">user</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="built_in">substring</span>(email, <span class="number">1</span>, <span class="number">5</span>)) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>前缀索引不支持覆盖索引，所以一定会回表</strong></li></ul><h2 id="单列索引-VS-联合索引">单列索引 VS 联合索引</h2><ol><li>如果<code>where</code>有两个部分，分别都只有单列索引，这时候第一个条件会走单列索引，第二个条件不会走索引<br><code>select id, phone, name from user where phone='12312312312' and name='123';</code> 此时只有<code>phone</code>走单列索引，<code>name</code>没有走索引，导致最终回表</li><li>如果这时候有两个部分的单列索引，以及两个部分的联合索引，简单的使用<code>where</code>，依然是只有第一部分使用单列索引。因此需要指定使用联合索引才行</li><li>如果涉及多个查询条件，推荐使用联合索引</li></ol><h2 id="索引设计原则">索引设计原则</h2><ol><li>数据量较大(&gt; 100万)，查询频繁的表需要涉及索引。如果只插入，不查询，就不用建立索引</li><li>针对常常作为查询条件<code>where</code>，排序<code>order by</code>，分组<code>group by</code>这几个字段建立索引</li><li>建立索引使用区分度高的列作为索引，尽量建立唯一索引。如果是性别，状态这种字段没有必要建立索引</li><li>字符串较长考虑使用前缀索引</li><li>尽量使用联合索引，减少单列索引，以达到使用覆盖索引，避免回表</li><li>控制索引的数量，索引越多，增删改的效率越低</li><li>索引列不能存储<code>NULL</code>，建表的时候使用<code>NOT NULL</code>约束，可以更有效的使用索引</li></ol><h2 id="例子">例子:</h2><div class="note info flat"><p>索引命名规范: <code>idx_表名_字段名</code><br>创建联合索引对字段顺序有要求</p></div><ol><li><code>name</code>是姓名字段，可能重复: <code>create index idx_user_name on user(name);</code> 创建常规索引</li><li><code>phone</code>是手机号，非空，唯一，创建索引: <code>create unique index idx_user_phone on user(phone);</code> 创建唯一索引</li><li>为<code>profession, age, status</code>创建索引: <code>create index idx_user_pro_age_status on user(profession, age, status);</code> 创建联合索引</li><li>为<code>email</code>创建合适的索引: <code>create index idx_user_email on user(email);</code> 创建常规索引</li><li>一张表四个字段<code>(id, username, password, status)</code>如何优化<code>select id, username, password from user where username='a';</code>:<ul><li>建立<code>username, password</code>联合索引，并且<code>username</code>放在第一个，从而满足最左前缀法则，可以避免回表</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;索引&lt;/h1&gt;
&lt;div class=&quot;note info flat&quot;&gt;&lt;ul&gt;
&lt;li&gt;高效获取数据的&lt;strong&gt;有序&lt;/strong&gt;数据结构&lt;/li&gt;
&lt;li&gt;提高检索效率，降低IO成本。&lt;/li&gt;
&lt;li&gt;索引列对数据进行&lt;strong&gt;排序&lt;/strong&gt;</summary>
      
    
    
    
    <category term="MySQL" scheme="https://sangs3112.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://sangs3112.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL笔记_1</title>
    <link href="https://sangs3112.github.io/posts/504036dc.html"/>
    <id>https://sangs3112.github.io/posts/504036dc.html</id>
    <published>2024-03-11T16:15:13.000Z</published>
    <updated>2024-03-13T07:15:25.593Z</updated>
    
    <content type="html"><![CDATA[<h1>函数</h1><h2 id="字符串函数">字符串函数</h2><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">CONCAT(S1, S2, …, Sn)</td><td style="text-align:center">字符串拼接，将S1, S2, …, Sn拼接陈一个字符串</td></tr><tr><td style="text-align:center">LOWER(str)</td><td style="text-align:center">将字符串转为小写</td></tr><tr><td style="text-align:center">UPPER(str)</td><td style="text-align:center">将字符串转为大写</td></tr><tr><td style="text-align:center">LPAD(str, n, pad)</td><td style="text-align:center">左填充，用字符串pad对str的左边进行填充，达到长度n</td></tr><tr><td style="text-align:center">RPAD(str, n, pad)</td><td style="text-align:center">右填充，用字符串pad对str的右边进行填充，达到长度n</td></tr><tr><td style="text-align:center">TRIM(str)</td><td style="text-align:center">去掉字符串头部和尾部的空格</td></tr><tr><td style="text-align:center">SUBSTRING(str, start, len)</td><td style="text-align:center">返回从字符串str的start位置起的len个长度的字符串</td></tr></tbody></table><div class="note info flat"><ul><li><code>trim</code>不能去除中间的空格</li><li><code>substring</code>的<code>start</code>从1开始，不是0</li><li><code>substring()</code>可以只输入两个参数，表示从<code>start</code>的位置截取到字符串末尾</li><li><code>start</code>参数可以为负，如果是负数，则自动忽略<code>len</code>参数，表示截取最后几个字符</li><li><code>lpad</code>和<code>rpad</code>如果输入的字符串过长，超过了第二个参数n，则自动变为<strong>从左往右</strong>的n个字符</li></ul></div><h2 id="数值函数">数值函数</h2><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">CEIL(x)</td><td style="text-align:center">向上取整</td></tr><tr><td style="text-align:center">FLOOR(x)</td><td style="text-align:center">向下取整</td></tr><tr><td style="text-align:center">MOD(x,y)</td><td style="text-align:center">取<code>x/y</code>的模</td></tr><tr><td style="text-align:center">RAND()</td><td style="text-align:center">返回0~1内随机数</td></tr><tr><td style="text-align:center">ROUND(x, y)</td><td style="text-align:center">x四舍五入，并保留y位小数</td></tr></tbody></table><h2 id="日期函数">日期函数</h2><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">CURDTE()</td><td style="text-align:center">返回当前日期</td></tr><tr><td style="text-align:center">CURTIME()</td><td style="text-align:center">返回当前时间</td></tr><tr><td style="text-align:center">NOW()</td><td style="text-align:center">返回当前日期和时间</td></tr><tr><td style="text-align:center">YEAR(date)</td><td style="text-align:center">获取指定date的年份</td></tr><tr><td style="text-align:center">MONTH(date)</td><td style="text-align:center">获取指定date的月份</td></tr><tr><td style="text-align:center">DAY(date)</td><td style="text-align:center">获取指定date的日期</td></tr><tr><td style="text-align:center">DATE_ADD(date, INTERVAL expr, type)</td><td style="text-align:center">在date后的日期加上时间长度</td></tr><tr><td style="text-align:center">DATEDIFF(date1, date2)</td><td style="text-align:center">返回起始时间date1和结束时间date2之间的天数</td></tr></tbody></table><div class="note info flat"><p><code>date_add(date, interval expr, type);</code>中，<code>interval</code>是固定的。</p></div><h2 id="流程控制函数">流程控制函数</h2><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">IF(value, t, f)</td><td style="text-align:center">如果value为true，则返回t，否则返回f</td></tr><tr><td style="text-align:center">IFNULL(value1, value2)</td><td style="text-align:center">如果value1<strong>不为空</strong>，则返回value1，否则返回value2</td></tr><tr><td style="text-align:center">CASE WHEN [val1] THEN [res1] … ELSE [default] END</td><td style="text-align:center">如果val1为true，返回res1，…，否则返回default</td></tr><tr><td style="text-align:center">CASE [expr] WHEN [val1] THEN [res1] … ELSE [default] END</td><td style="text-align:center">如果expr值等于val1，返回res1，…，否则返回default</td></tr></tbody></table><div class="note info flat"><ul><li><code>ifnull('OK', 'D');</code> 返回’OK’</li><li><code>ifnull('', 'D');</code> 返回’’</li><li><code>ifnull(null, 'D');</code> 返回’D’</li></ul></div><h1>约束</h1><table><thead><tr><th style="text-align:center">关键字</th><th style="text-align:center">约束</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">NOT NULL</td><td style="text-align:center">非空约束</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">UNIQUE</td><td style="text-align:center">唯一约束</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">PRIMARY KEY</td><td style="text-align:center">主键约束</td><td style="text-align:center">一行数据的唯一标识，非空且唯一</td></tr><tr><td style="text-align:center">DEFAULT</td><td style="text-align:center">默认约束</td><td style="text-align:center">保存数据时，未指定某个字段，则使用默认值</td></tr><tr><td style="text-align:center">CHECK</td><td style="text-align:center">检查约束</td><td style="text-align:center">保证字段值满足某条件</td></tr><tr><td style="text-align:center">FOREIGN KEY</td><td style="text-align:center">外键约束</td><td style="text-align:center">让两张表的数据建立连接，保证数据的完整性和一致性</td></tr></tbody></table><table><thead><tr><th style="text-align:center">删除/更新行为</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">NOT ACTION</td><td style="text-align:center">在父表中删除/更新对应的记录时，首先检查该记录是否有外键，如果有则不允许删除/更新。(与RESTRICT一致)</td></tr><tr><td style="text-align:center">RESTRICT</td><td style="text-align:center">在父表中删除/更新对应记录时，首先检查该记录是否有外键，如果有则不允许删除/更新。(与NOT ACTION一致)</td></tr><tr><td style="text-align:center">CASCADE</td><td style="text-align:center">在父表中删除/更新对应记录时，首先检查该记录是否有外键，如果有，则也删除/更新外键在子表中的记录</td></tr><tr><td style="text-align:center">SET NULL</td><td style="text-align:center">在父表中删除对应记录时，检查该记录是否有对应外键，如果有则设置子表中该外键的值为NULL(这要求该外键允许为NULL)</td></tr><tr><td style="text-align:center">SET DEFAULT</td><td style="text-align:center">父表有变更时，子表将外键列设为一个默认值 (InnoDB不支持)</td></tr></tbody></table><div class="note info flat"><ul><li>自增 <code>auto_increment</code></li><li>外键约束一般不使用</li><li>添加外键约束: <code>alter table 表名 add constraint 外键名 foreign key (外键字段名) references 主表(主表列名);</code>括号是必须要有的</li><li>删除外键约束: <code>alter table 表名 drop foreign key 外键名;</code></li><li>设置外键在删除/更新都是级联的: <code>alter table 表名 add constraint 外键名 foreign key (外键字段) references 主表(主表列名) on update cascade on delete cascade;</code></li></ul></div><h1>多表查询</h1><table><thead><tr><th style="text-align:center">关系</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">一对多</td><td style="text-align:center">多的一方建立外键，指向一，比如员工和部门</td></tr><tr><td style="text-align:center">多对多</td><td style="text-align:center">建立中间表，包含两个外键，分别关联二者主键，比如学生课程</td></tr><tr><td style="text-align:center">一对一</td><td style="text-align:center">随便在一个表中建立外键，主要用于单表拆分，对外建需要设置唯一约束</td></tr></tbody></table><h2 id="内连接">内连接:</h2><ul><li>隐式内连接: <code>select 字段列表 from A, B where 条件;</code></li><li>显式内连接: <code>select 字段列表 from A [inner] join B on 条件;</code></li></ul><div class="note info flat"><ul><li><code>inner</code>可以省略</li><li>查询AB交集，查询不到某张表的<code>NULL</code></li></ul></div><h2 id="外连接">外连接:</h2><ul><li>左外连接:  <code>select 字段列表 from A left [outer] join B on 条件;</code></li><li>右外连接:  <code>select 字段列表 from A right [outer] join B on 条件;</code></li></ul><div class="note info flat"><ul><li>外连接<strong>可以</strong>查找出<code>NULL</code></li><li>左外连接查找左表中所有数据以及两个表的交集</li><li>右外连接查找右表中所有数据以及两个表的交集</li></ul></div><h2 id="自连接">自连接:</h2><p><code>select 字段列表 from A 别名A join A 别名B on 条件;</code></p><div class="note info flat"><ul><li>当前表和自身进行连接查询，自连接需要使用表别名</li></ul></div><h2 id="联合查询">联合查询:</h2><p><code>select 字段列表 from A ... union [all] select 字段列表 from B;</code></p><div class="note info flat"><ul><li>联合查询是将多次查询结果合并起来，形成新查询结果集</li><li><code>all</code>将查询结果合并，如果不使用<code>all</code>，则会去重</li><li>两个不同的<code>select</code>中字段列表必须保持一致</li></ul></div><h2 id="子查询">子查询:</h2><p><code>select * from A where c1 = (select c1 from B);</code></p><div class="note info flat"><ul><li>子查询内部可以使用<code>insert/delete/update/select</code></li><li>标量子查询，列子查询，行子查询，表子查询，分别表示子查询返回的结果数量是一个值，一列，一行，还是一个表</li><li><code>where/from/select</code>之后都可以出现子查询</li><li>列子查询中<code>any</code>与<code>some</code>等价，都表示其中任意一个满足即可</li></ul></div><h2 id="例子">例子:</h2><ol><li>查询员工姓名，年龄，职位，部门信息(隐式内连接): <code>select e.name, e.age e.job d.name from emp e, dept d where e.dept_id = d.id;</code></li><li>查询年龄小于30的员工的姓名年龄，职位，部门信息(显式内连接): <code>select e.name, e.age, e.job d.name from emp e join dept d on e.dept_id = d.id where e.age &lt; 30;</code></li><li>查询拥有员工的部门id和部门名称: <code>select distinct d.id, d.name from emp e, dept d where e.dept_id = d.id;</code> (内连接求交集)</li><li>查询所有年龄大于40的员工，及其归属的部门名称，如果员工没有分配部门，也需要展示: <code>select e.*, d.name from emp e left join dept d on e.dept_id = d.id where e.age &gt; 40;</code></li><li>查询所有员工的工资等级: <code>select e.*, s.grade from emp e, salgrade s where e.salary &gt;= s.losal and e.salary &lt;= s.hisal;</code></li><li>查询研发部所有员工的信息以及工资等级: <code>select e.*, s.grade from emp e, salgrade s, dept d where e.dept_id = d.id and (e.salary between s.losal and s.hisal) and d.name = '研发';</code></li><li>查询研发部员工的平均工资: <code>select avg(e.salary) from emp e, dept d where e.dept_id = d.id and d.name = '研发';</code></li><li>查询工资比A高的员工信息: <code>select * from emp where salary &gt; (select salary from emp where name = 'A';</code></li><li>查询比平均工资高的员工信息: <code>select * from emp where salary &gt; (select avg(salary) from emp);</code></li><li>查询低于本部门平均工资的员工: <code>select * from emp e2 where e2.salary &lt; (select avg(e1.salary) from emp e1 where e1.dept_id = d2.dept_id);</code></li><li>查询所有部门信息，并统计部门员工人数: <code>select d.id , d.name, (select count(*) from emp e where e.dept_id = d.id) '人数' from dept d;</code></li><li>查询所有学生的选课情况，展示出学生名称，学号，课程名称: <code>select s.name, s.no, c.name from student s, student_course sc, course c where s.id = sc.studentid and sc.courseid = c.id;</code></li></ol><h1>事务</h1><div class="note info flat"><ul><li>MySQL事务默认自动提交，执行一条DML语句，会立刻隐式提交事务</li><li><code>select @@autocommit;</code>查看当前事务是否自动提交，如果为1，则表示自动提交</li><li><code>set @@autocommit=0;</code>设置手动提交，需要手动写<code>commit</code>才会提交事务</li><li>出错可以使用<code>rollback;</code>回滚事务</li><li>开启事务<code>start transaction</code>或者<code>begin</code>，这样不需要修改<code>@@autocommit</code></li></ul></div><h2 id="四大特性-ACID">四大特性 <strong>ACID</strong></h2><ul><li>原子性: 事务是不可分割的最小单元，要么全部成功，要么全部失败</li><li>一致性: 事务完成时，所有数据都需要保持一致状态</li><li>隔离性: 数据库提供隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</li><li>持久性: 事务一旦提交或者回滚，对数据库中的数据改变就是永久的</li></ul><h2 id="并发问题与隔离级别">并发问题与隔离级别</h2><h3 id="并发问题">并发问题</h3><ul><li>脏读: 一个事务读到另一个事务还没有提交的数据</li><li>不可重复读: 一个事务先后读取同一条记录，但是两次读取的数据不同</li><li>幻读: 一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现数据已经存在</li></ul><h3 id="隔离级别">隔离级别</h3><table><thead><tr><th style="text-align:center">隔离级别</th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th style="text-align:center">幻读</th></tr></thead><tbody><tr><td style="text-align:center">Read Uncommitted</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">Read Committed</td><td style="text-align:center">解决</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">Repeatable Read (默认)</td><td style="text-align:center">解决</td><td style="text-align:center">解决</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">Serializable</td><td style="text-align:center">解决</td><td style="text-align:center">解决</td><td style="text-align:center">解决</td></tr></tbody></table><div class="note info flat"><ul><li>读未提交的隔离级别下，三种并发问题都有可能出现</li><li>可重复读是MySQL的默认配置，Orical是读可提交</li><li>串行化，性能最差，隔离级别最高，失去并发能力</li><li><code>select @@transaction_isolation;</code>查看事务的隔离级别</li><li><code>set [session|global] transaction isolation level {read uncommitted | read committed | repeatable read | serializable}</code> <code>session</code>表示对当前会话窗口有效，<code>global</code>是对所有窗口有效</li><li>尽管相比于默认的可重复读，读提交不能解决不可重复读的问题，但是可重复读这一隔离级别在并发时会导致死锁，未来打算放一篇专门的笔记分析。</li></ul></div><h1>体系结构</h1><ul><li>连接层: 最上层，客户端和链接服务，链接处理、授权认证、相关安全方案。服务器安全接入每个客户端并验证它所具有的操作权限</li><li>服务层: 完成大多数的核心服务功能，比如SQL接口，完成缓存查询，SQL分析和优化，内置函数执行。所有跨存储引擎的功能也在这层实现，比如过程，函数</li><li>引擎层: 负责MySQL的数据存储和提取，服务器通过API和存储引擎进行通信，不同的存储引擎具有不同功能</li><li>存储层: 将数据存储在文件系统之上，完成与存储引擎的交互</li></ul><div class="note info flat"><ul><li>索引是在存储引擎层实现的</li><li>存储引擎基于表的，不是基于库的，所以存储引擎也被称为表类型</li><li>创建表的时候指定存储引擎，<code>show engines;</code>显示当前支持的存储引擎</li><li>MySQL早期存储引擎为<code>MyISAM</code>，<code>5.5</code>版本后替换为<code>InnoDB</code></li></ul></div><p><img src="https://gitee.com/sang3112/blog_imgs/raw/master/MySQL/InnoDB.png" alt="InnoDB"></p><div class="note info flat"><ul><li><code>page</code>是磁盘操作的最小单元，大小固定为16K;<code>extent</code>区域大小固定为1M，也就是一个区中包含64个页</li></ul></div><h2 id="MyISAM-VS-InnoDB-VS-Memory"><code>MyISAM</code> VS <code>InnoDB</code> VS <code>Memory</code></h2><ul><li><code>MyISAM</code>不支持事务，不支持外键，支持表锁而不支持行锁，访问速度快</li><li><code>InnoDB</code>支持事务，支持外键保证完整性和一致性，支持行锁，提高并发性能。</li><li><code>MyISAM</code>涉及三个格式: <code>MYD MYI sdi</code>分别存储数据 索引和表结构</li><li><code>InnoDB</code>对应文件是<code>表名.idb</code>，每张表都会存储表结构(早期为<code>frm</code>,8.0版本后改为<code>sdi</code>)、数据和索引。<code>innodb_file_per_table</code>是一个开关，表名是否每张表都对应一个表空间文件<code>idb</code></li><li><code>Memory</code> 数据只在内存中，只能临时存储，或作为缓存使用，支持<code>hash</code>索引，只有<code>sdi</code>文件，存储表结构</li></ul><div class="note info flat"><ul><li>如果数据除了插入和查询以外，还包含很多更新、删除操作，那么选择<code>InnoDB</code>可以保证数据一致性</li><li>应用以读和插入操作为主，很少的更新和删除操作，并且给对事物完整性，并发性要求不高，就使用<code>MyISAM</code></li><li><code>Memory</code>将所有数据保存在内存中，访问速度快，通常用于临时表和缓存。但是对表大小有限制，并且无法保障安全性，(不如用<code>Redis</code>)</li></ul></div><table><thead><tr><th style="text-align:center">特点</th><th style="text-align:center">InnoDB</th><th style="text-align:center">MyISAM</th><th style="text-align:center">Memory</th></tr></thead><tbody><tr><td style="text-align:center">存储限制</td><td style="text-align:center">64TB</td><td style="text-align:center">4GB</td><td style="text-align:center">16MB</td></tr><tr><td style="text-align:center">事务安全</td><td style="text-align:center">支持</td><td style="text-align:center">无</td><td style="text-align:center">无</td></tr><tr><td style="text-align:center">锁</td><td style="text-align:center">行锁</td><td style="text-align:center">表锁</td><td style="text-align:center">表锁</td></tr><tr><td style="text-align:center">B+树索引</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">Hash索引</td><td style="text-align:center">无</td><td style="text-align:center">无</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">全文索引</td><td style="text-align:center">支持(5.6)版本后</td><td style="text-align:center">支持</td><td style="text-align:center">无</td></tr><tr><td style="text-align:center">空间使用</td><td style="text-align:center">高</td><td style="text-align:center">低</td><td style="text-align:center">N/A</td></tr><tr><td style="text-align:center">内存使用</td><td style="text-align:center">高</td><td style="text-align:center">低</td><td style="text-align:center">中等</td></tr><tr><td style="text-align:center">批量插入速度</td><td style="text-align:center">低</td><td style="text-align:center">高</td><td style="text-align:center">高</td></tr><tr><td style="text-align:center">支持外键</td><td style="text-align:center">支持</td><td style="text-align:center">无</td><td style="text-align:center">无</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;函数&lt;/h1&gt;
&lt;h2 id=&quot;字符串函数&quot;&gt;字符串函数&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;函数&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;功能&lt;/th&gt;
&lt;/tr&gt;</summary>
      
    
    
    
    <category term="MySQL" scheme="https://sangs3112.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://sangs3112.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL笔记_0</title>
    <link href="https://sangs3112.github.io/posts/fae54f81.html"/>
    <id>https://sangs3112.github.io/posts/fae54f81.html</id>
    <published>2024-03-10T07:05:56.000Z</published>
    <updated>2024-03-13T07:15:25.593Z</updated>
    
    <content type="html"><![CDATA[<h1>创建数据库</h1><h2 id="字符集选择-utf8mb4">字符集选择: <code>utf8mb4</code></h2><ul><li><code>Unicode</code>编码，也称作统一码，万国码。如：<code>utf8, utf16, utf32</code></li><li><code>utf8mb4</code>兼容<code>utf8</code>，并且可以表示更多的字符。具体来说:  <div class="note default flat"><p><code>Unicode</code>中的第<code>1-126</code>行是<code>utf8</code>的区域，<code>utf8mb4</code>同样兼容这一片区域，剩下<code>126</code>行以下的部分是<code>utf8mb4</code>扩充区域。</p></div></li><li>一般不选择<code>utf8</code>，因为其占用三个字节；而实际上很多内容，比如表情，就需要四字节空间，所以一般使用<code>utf8mb4</code></li></ul><h2 id="排序规则选择：">排序规则选择：</h2><ul><li>对于<code>utf8mb4</code>而言，常用的排序规则有<code>utf8mb4_unicode_ci</code>，<code>utf8mb4_general_ci</code>，<code>utf8mb4_bin</code></li></ul><table><thead><tr><th style="text-align:center"><code>utf8mb4_unicode_ci</code></th><th style="text-align:center"><code>utf8mb4_general_ci</code></th><th style="text-align:center"><code>utf8mb4_bin</code></th></tr></thead><tbody><tr><td style="text-align:center"><strong>基于标准的Unicode</strong>规则来排序和比较</td><td style="text-align:center">没有实现Unicode排序规则</td><td style="text-align:center">将字符串的每个字符用二进制数据编译存储</td></tr><tr><td style="text-align:center">各语言<strong>精确排序</strong></td><td style="text-align:center">在某些特殊语言字符集，排序结果可能不一致</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>不区分大小写</strong></td><td style="text-align:center"><strong>不区分大小写</strong></td><td style="text-align:center"><strong>区分大小写</strong></td></tr><tr><td style="text-align:center">为了能够处理特殊字符，实现了略微复杂的排序算法</td><td style="text-align:center">比较和排序的时候更快</td><td style="text-align:center"> </td></tr></tbody></table><h1><code>SQL</code>分类</h1><table><thead><tr><th style="text-align:center">分类</th><th style="text-align:center">全称</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">DDL</td><td style="text-align:center">Data Definition Language</td><td style="text-align:center">数据定义语言，定义数据库、表、字段</td></tr><tr><td style="text-align:center">DML</td><td style="text-align:center">Data Manipulation Language</td><td style="text-align:center">数据操作语言，对数据<strong>增删改</strong></td></tr><tr><td style="text-align:center">DQL</td><td style="text-align:center">Data Query Language</td><td style="text-align:center">数据查询语言，<strong>查</strong></td></tr><tr><td style="text-align:center">DCL</td><td style="text-align:center">Data Control Language</td><td style="text-align:center">数据控制语言，创建数据库用户，设置访问权限</td></tr></tbody></table><h2 id="DDL"><code>DDL</code></h2><h3 id="查">查</h3><ul><li><p>查询<strong>所有</strong>数据库: <code>show databases;</code></p></li><li><p>查询当前数据库: <code>select database();</code></p></li><li><p>查询当前数据库中<strong>所有</strong>的表: <code>show tables;</code></p></li><li><p>查询表结构: <code>desc 表名;</code></p></li><li><p>查询建表语句: <code>show create table 表名;</code></p></li></ul><h3 id="增">增</h3><ul><li><p>创建数据库: <code>create database [if not exists] 数据库名 [default charset 字符集] [collate 排序规则];</code></p></li><li><p>创建表: <code>create table 表名 (字段名 字段类型 [comment '字段注释'], 字段名 字段类型 [comment '字段注释'], ...) [comment '表注释'];</code></p></li><li><p>添加表字段: <code>alter table 表名 add 字段名 类型 [comment '字段注释'];</code></p></li></ul><h3 id="删">删</h3><ul><li><p>删除数据库: <code>drop database [if exists] 数据库名;</code></p></li><li><p>删除表: <code>drop table [if exists] 表名;</code></p></li><li><p>删除并重新创建表: <code>truncate table 表名;</code></p></li><li><p>删除字段: <code>alter table 表名 drop 字段名;</code></p></li></ul><h3 id="改">改</h3><ul><li><p>修改表名: <code>alter table 表名 rename to 新表名;</code></p></li><li><p>修改字段数据类型: <code>alter table 表名 modify 字段名 新类型;</code></p></li><li><p>修改字段名和数据类型: <code>alter table 表名 change 原字段名 新字段名 类型 [comment '字段注释'];</code></p></li></ul><h3 id="类型">类型</h3><table>    <tr>        <th>分类</th><th>类型</th><th>大小</th><th>有符号范围</th><th>无符号范围</th><th>描述</th>    </tr>    <tr>        <td rowspan="8">数值</td>        <td>TINYINT</td><td>1B</td><td>(-128, 127)</td><td>(0, 255)</td><td></td>    </tr>    <tr>        <td>SMALLINT</td><td>2B</td><td>(-32768, 32767)</td><td>(0, 65535)</td><td></td>    </tr>    <tr>        <td>MIDIUMINT</td><td>3B</td><td>(-8388608, 8388607)</td><td>(0, 16777215)</td><td></td>    </tr>    <tr>        <td>INT or INTEGER</td><td>4B</td><td>(-2147483648, 2147483647)</td><td>(0, 4294967295)</td><td></td>    </tr>    <tr>        <td>BIGINT</td><td>8B</td><td>(-2^63, 2^63 - 1)</td><td>(0, 2^64 - 1)</td><td></td>    </tr>    <tr>        <td>FLOAT</td><td>4B</td><td>(-3.4028E+38, 3.4028E+38)</td><td>0 and (1.17549E-38, 3.4028E+38)</td><td></td>    </tr>    <tr>        <td>DOUBLE</td><td>8B</td><td>(-1.79769E+308, 1.79769E+308)</td><td>0 and (2.22507E-308, 1.79769E+308)</td><td></td>    </tr>    <tr>        <td>DECIMAL</td><td></td><td>由M(精度),D(标度)决定</td><td>由M(精度),D(标度)决定</td><td>精确定点数</td>    </tr></table><table>    <tr>        <th>分类</th><th>类型</th><th>大小</th><th>描述</th>    </tr>    <tr>        <td rowspan="10">字符串</td>        <td>CHAR</td><td>(0, 255B)</td><td>定长字符串</td>    </tr>    <tr>        <td>VARCHAR</td><td>(0, 65535B)</td><td>变长字符串</td>    </tr>    <tr>        <td>TINYBLOB</td><td>(0, 255B)</td><td>不超过255个字符的二进制数据</td>    </tr>    <tr>        <td>TINYTEXT</td><td>(0, 255B)</td><td>短文本</td>    </tr>    <tr>        <td>BLOB</td><td>(0, 65535B)</td><td>二进制长文本</td>    </tr>    <tr>        <td>TEXT</td><td>(0, 65535B)</td><td>长文本</td>    </tr>    <tr>        <td>MEDIUMBLOB</td><td>(0, 16777215B)</td><td></td>    </tr>    <tr>        <td>MEDIUMTEXT</td><td>(0, 16777251B)</td><td></td>    </tr>    <tr>        <td>LONGBLOB</td><td>(0, 4294967295B)</td><td></td>    </tr>    <tr>        <td>LONGTEXT</td><td>(0, 4294967295B)</td><td></td>    </tr></table><table>    <tr>        <th>分类</th><th>类型</th><th>大小</th><th>范围</th>    </tr>    <tr>        <td rowspan="5">日期</td>        <td>DATE</td><td>3B</td><td>1000-01-01至9999-12-31</td>    </tr>    <tr>        <td>TIME</td><td>3B</td><td>-838:59:59至838:59:59</td>    </tr>    <tr>        <td>YEAR</td><td>1B</td><td>1901至2155</td>    </tr>    <tr>        <td>DATETIME</td><td>8B</td><td>1000-01-01 00:00:00至9999-12-31 23:59:59</td>    </tr>    <tr>        <td>TIMESTAMP</td><td>4B</td><td>1970-01-01 00:00:01至2038-01-19 03:14:07</td>    </tr></table><div class="note info flat"><ul><li>存储年龄，使用<code>tinyint unsigned</code>，不能写<code>unsigned tinyint</code></li><li>存分数，一位小数，存储钱数，可以使用<code>decimal(4,1)</code>，表示最多四位，小数在最后一位之前</li><li><code>char(10)</code>定长为10，性能好，存储性别可以使用<code>char(1)</code></li><li><code>varchar(10)</code>不定长，性能差一些</li><li><code>timestamp</code>最大时间到2038，所以一般不用</li><li>记录生日使用<code>date</code></li></ul></div><h2 id="DML"><code>DML</code></h2><h3 id="增-2">增</h3><ul><li><p>给指定字段添加数据: <code>insert into 表名 (字段1, 字段2) values (值1, 值2);</code></p></li><li><p>给所有字段添加数据: <code>insert into 表名 values (值1, 值2, ...);</code></p></li><li><p>批量添加数据:</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名 (字段<span class="number">1</span>, 字段<span class="number">2</span>) <span class="keyword">values</span> (值<span class="number">1</span>, 值<span class="number">2</span>), (值<span class="number">3</span>, 值<span class="number">4</span>), ...</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名 <span class="keyword">values</span> (值<span class="number">1</span>, 值<span class="number">2</span>, 值<span class="number">3</span>, 值<span class="number">4</span>, ...), ... </span><br></pre></td></tr></table></figure><ul><li>插入数据为字符串或者日期类型，应使用引号，否则不会走索引</li></ul><h3 id="删-2">删</h3><ul><li>删除数据: <code>delete from 表名 [where 条件];</code></li></ul><h3 id="改-2">改</h3><ul><li>修改数据: <code>update 表名 set 字段1=值1, 字段2=值2,..., [where 条件];</code></li></ul><h2 id="DQL"><code>DQL</code></h2><ul><li><p>查询语句: <code>select 字段列表 from 表名列表 [where 条件] [group by 分组字段列表] [having 分组后过滤条件列表] [order by 排序字段列表] [limit 分页参数];</code></p></li><li><p>查询时可以设置别名: <code>select 字段1 as 别名1, 字段2 as 别名2;</code></p></li><li><p>查询去重: <code>select distinct 字段列表 from 表名;</code></p></li><li><p>条件查询:</p></li></ul><table><thead><tr><th style="text-align:center">比较运算符</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>&lt;&gt; or !=</code></td><td style="text-align:center">不等于</td></tr><tr><td style="text-align:center"><code>BETWEEN...AND...</code></td><td style="text-align:center">在某个范围内,包含边界。一定要写<code>between min and max</code> 写反了查不到值</td></tr><tr><td style="text-align:center"><code>IN(...)</code></td><td style="text-align:center">在列表中多选一</td></tr><tr><td style="text-align:center"><code>LIKE</code></td><td style="text-align:center">模糊匹配(<code>_</code>匹配单个字符, <code>%</code>匹配任意个字符)</td></tr><tr><td style="text-align:center"><code>IS NULL</code></td><td style="text-align:center">为空</td></tr></tbody></table><ul><li><p>聚合函数 <code>count, max, min, avg, sum</code>:</p><ul><li>作用于某一列，所有<code>null</code>不参与聚合函数计算</li><li><code>where</code>是分组之前过滤，在聚合函数之前执行，因此<strong>不能</strong>使用聚合函数；<code>having</code>是分组之后过滤，聚合函数在<code>having</code>之前已经执行了，因此<strong>可以</strong>使用聚合函数</li><li>分组查询一般查询分组之后的字段和聚合函数，其他没有意义</li></ul></li><li><p>排序 <code>order by 字段1 排序方式1, 字段2 排序方式2</code>:</p><ul><li>升序<code>asc</code>，降序<code>desc</code>，默认为升序</li></ul></li><li><p>分页查询 <code>limit 起始索引, 查询记录数</code>:</p><ul><li>起始索引从0开始，起始索引 = (查询页码 - 1) * 每页记录个数</li><li>分页查询是数据库的<strong>方言</strong>，不同数据库关键字不同，MySQL中使用<code>limit</code>，如果查询第一页的数据，则起始索引可以省略</li></ul></li></ul><h3 id="DQL执行顺序"><code>DQL</code>执行顺序:</h3><ul><li><code>from, where, group by, having, select, order by, limit</code></li><li>首先执行<code>from</code>找到表名，然后执行<code>where</code>判断条件，再<code>group by</code>分组和<code>having</code>，再<code>select</code>选择字段列表，最后<code>order by</code>排序和<code>limit</code>分页</li></ul><h2 id="DCL"><code>DCL</code></h2><h3 id="查-2">查</h3><ul><li>查询用户: <code>use mysql; select * from user;</code></li></ul><div class="note info flat"><p>用户信息都存放在<code>mysql</code>系统数据库中</p></div><ul><li>查询用户权限: <code>show grants for '用户名'@'主机名';</code></li></ul><h3 id="增-3">增</h3><ul><li>创建用户: <code>create user '用户名'@'主机名' identified by '密码';</code></li></ul><div class="note info flat"><p>如果需要该用户可以在任意主机上访问该数据库，需要将主机名修改为<code>%</code>即可</p></div><h3 id="删-3">删</h3><ul><li>删除用户: <code>drop user '用户名'@'主机名';</code></li></ul><h3 id="改-3">改</h3><ul><li><p>修改密码: <code>alter user '用户名'@'主机名' identified with mysql_native_password by '新密码';</code></p></li><li><p>授权: <code>grant 权限列表 on 数据库名.表名 to '用户名'@'表名'</code>;</p></li><li><p>撤销权限: <code>revoke 权限列表 on 数据库名.表名 from '用户名'@'表名';</code></p></li></ul><div class="note info flat"><p><code>'用户名'@'表名'</code> 中间不能存在空格</p></div><table><thead><tr><th style="text-align:center">权限</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">ALL, ALL PRIVILEGES</td><td style="text-align:center">所有权限</td></tr><tr><td style="text-align:center">SELECT</td><td style="text-align:center">查询数据</td></tr><tr><td style="text-align:center">INSERT</td><td style="text-align:center">插入数据</td></tr><tr><td style="text-align:center">UPDATE</td><td style="text-align:center">修改数据</td></tr><tr><td style="text-align:center">DELETE</td><td style="text-align:center">删除数据</td></tr><tr><td style="text-align:center">ALTER</td><td style="text-align:center">修改表</td></tr><tr><td style="text-align:center">DROP</td><td style="text-align:center">删除数据库/表/视图</td></tr><tr><td style="text-align:center">CREATE</td><td style="text-align:center">创建数据库/表</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;创建数据库&lt;/h1&gt;
&lt;h2 id=&quot;字符集选择-utf8mb4&quot;&gt;字符集选择: &lt;code&gt;utf8mb4&lt;/code&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Unicode&lt;/code&gt;编码，也称作统一码，万国码。如：&lt;code&gt;utf8, utf16, utf32</summary>
      
    
    
    
    <category term="MySQL" scheme="https://sangs3112.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://sangs3112.github.io/tags/MySQL/"/>
    
  </entry>
  
</feed>
