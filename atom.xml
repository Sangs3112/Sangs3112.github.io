<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sangs Blog</title>
  
  
  <link href="https://sangs3112.github.io/atom.xml" rel="self"/>
  
  <link href="https://sangs3112.github.io/"/>
  <updated>2024-07-23T17:18:51.906Z</updated>
  <id>https://sangs3112.github.io/</id>
  
  <author>
    <name>Sangs</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go笔记_0</title>
    <link href="https://sangs3112.github.io/posts/f86b96e2.html"/>
    <id>https://sangs3112.github.io/posts/f86b96e2.html</id>
    <published>2024-07-23T17:18:51.906Z</published>
    <updated>2024-07-23T17:18:51.906Z</updated>
    
    <content type="html"><![CDATA[<h1><code>GOROOT</code> VS <code>GOPATH</code> VS <code>GOBIN</code> VS <code>GOPROXY</code></h1><ul><li><code>GOROOT</code>: Go语言安装路径</li><li><code>GOPATH</code>: 若干工作区目录的路径。是我们自己定义的工作空间  <div class="note info flat"><ul><li><code>GO1.8</code>版本之后，开发包安装完成后会自动设置一个<code>GOPATH</code>目录，</li><li><code>GO1.14</code>版本之后，推荐使用<code>Go Module</code>模式，不一定非要将代码写在<code>GOPATH</code>目录下，也不需要自己配置<code>GOPATH</code></li></ul></div></li><li><code>GOBIN</code>: GO程序生成的可执行文件的路径</li><li><code>GOPROXY</code>: 默认为<code>GOPROXY=https://proxy.golang.org,direct</code>，修改为<code>GOPROXY=https://goproxy.cn,direct</code></li></ul><h1>跨平台编译</h1><h2 id="Windows-编译-LINUX或者OSX">Windows 编译 LINUX或者OSX</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SET CGO_ENABLED=0   // 禁用CGO</span><br><span class="line">SET GOOS=linux      // 目标平台, [windows, linux, darwin]</span><br><span class="line">SET GOARCH=amd64    // 目标处理器架构</span><br><span class="line">go build</span><br></pre></td></tr></table></figure><h2 id="LINUX-或者-OSX-编译其他环境">LINUX 或者 OSX 编译其他环境</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGO_ENABLED=0 GOOS=linux|darwin|windows GOARCH=amd64 go build</span><br></pre></td></tr></table></figure><div class="note info flat"><ul><li>只有Windows 需要在cmd窗口中运行<code>SET</code>命令</li></ul></div><h1>编写测试</h1><div class="note info flat"><ol><li>有一个程序名为<code>xxx.go</code>，则其测试程序应该名为<code>xxx_test.go</code></li><li>测试函数的命名以<code>Test</code>开始，例如<code>Testxxx()</code></li><li>测试函数只能有一个参数<code>t *testing.T</code>，参数<code>t</code>是测试的<code>hook</code>，测试失败时可以执行<code>t.Fail()</code>等操作</li></ol></div><h2 id="举例">举例</h2><ul><li>有一个<code>main</code>函数，打印<code>Hello world</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Hello</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Hello world&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">fmt.Println(Hello())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>则对应的测试代码应该为</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello_test.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestHello</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">got := Hello()</span><br><span class="line">want := <span class="string">&quot;Hello world&quot;</span></span><br><span class="line"><span class="keyword">if</span> got != want&#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;got &#x27;%q&#x27; want &#x27;%q&#x27;&quot;</span>, got, want)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在终端直接执行<code>go test</code>命令即可进行测试，如果文件名错误，会报错:<code>?       gogo    [no test files]</code></li></ul><h2 id="重构-t-Helper">重构 <code>t.Helper()</code></h2><p>现在有这两个文件<code>hello.go, hellotest.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> helloPrefix = <span class="string">&quot;Hello &quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Hello</span><span class="params">(name <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> helloPrefix + name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">fmt.Println(Hello(<span class="string">&quot;world&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestHello</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">assertCorrectMessage := <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T, got, want <span class="type">string</span>)</span></span>&#123;</span><br><span class="line">t.Helper()</span><br><span class="line"><span class="keyword">if</span> got != want&#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;got &#x27;%q&#x27; want &#x27;%q&#x27;&quot;</span>, got, want)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 成功</span></span><br><span class="line">t.Run(<span class="string">&quot;saying hello to people&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">got := Hello(<span class="string">&quot;chris&quot;</span>)</span><br><span class="line">want := <span class="string">&quot;Hello chris&quot;</span></span><br><span class="line">assertCorrectMessage(t, got, want)</span><br><span class="line">&#125;)</span><br><span class="line">    <span class="comment">// 失败</span></span><br><span class="line">t.Run(<span class="string">&quot;say hello world when an empty string is supplied&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">got := Hello(<span class="string">&quot;&quot;</span>)</span><br><span class="line">want := <span class="string">&quot;Hello world&quot;</span></span><br><span class="line">assertCorrectMessage(t, got, want)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>将断言单独作为一个函数，由两个子测试进行调用。</li><li>第一个子测试能通过，第二个子测试失败</li><li><code>t.Helper()</code>告诉测试套件这个函数是一个辅助函数，这样测试失败时报告的行号将在函数调用中，而不是在辅助函数内部。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不添加t.Helper()的输出</span></span><br><span class="line">--- FAIL: TestHello (0.00s)</span><br><span class="line">    --- FAIL: TestHello/say_hello_world_when_an_empty_string_is_supplied (0.00s)</span><br><span class="line">        hello_test.go:15: got &#x27;&quot;Hello &quot;&#x27; want &#x27;&quot;Hello world&quot;&#x27; # 断言函数处的行号，但是具体不知道是哪个测试用例出错</span><br><span class="line">FAIL</span><br><span class="line">exit status 1</span><br><span class="line">FAIL    gogo    0.001s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加t.Helper()的输出</span></span><br><span class="line">--- FAIL: TestHello (0.00s)</span><br><span class="line">    --- FAIL: TestHello/say_hello_world_when_an_empty_string_is_supplied (0.00s)</span><br><span class="line">        hello_test.go:28: got &#x27;&quot;Hello &quot;&#x27; want &#x27;&quot;Hello world&quot;&#x27; # 具体测试用例内部的行号</span><br><span class="line">FAIL</span><br><span class="line">exit status 1</span><br><span class="line">FAIL    gogo    0.001s</span><br></pre></td></tr></table></figure><h2 id="命名返回值">命名返回值</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Hello</span><span class="params">(name <span class="type">string</span>, language <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> name == <span class="string">&quot;&quot;</span>&#123;</span><br><span class="line">        name = <span class="string">&quot;world&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> greetingPrefix(language) + name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greetingPrefix</span><span class="params">(language <span class="type">string</span>)</span></span> (prefix <span class="type">string</span>)&#123;</span><br><span class="line">    <span class="keyword">switch</span> language &#123;</span><br><span class="line">        <span class="keyword">case</span> french:</span><br><span class="line">            prefix = frenchHelloPrefix</span><br><span class="line">        <span class="keyword">case</span> spanish:</span><br><span class="line">            prefix = spanishHelloPrefix</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            prefix = englishHelloPrefix</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在函数签名中，使用了命名返回值<code>prefix string</code><ul><li>会自动创建一个名为<code>prefix</code>的变量，并且分配零值，即如果是<code>int</code>，则<code>prefix=0</code>，如果是<code>string</code>，则<code>prefix=&quot;&quot;</code></li><li>会在<code>Go Doc</code>中显示，代码更加清晰</li><li>只需要直接写<code>return</code>即可，不需要<code>return prefix</code></li></ul></li><li>函数如果是小写字母开头，则是私有函数；如果是大写字母开头，则是公共函数</li></ul><h2 id="示例">示例</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// integer.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Add takes two integers and returns the sum of them</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info flat"><ul><li><code>Add</code>函数有两个相同类型的参数，所以可以直接写成<code>x, y int</code></li><li>添加的函数注释<code>Add takes two integers and returns the sum of them</code>会放在Go Doc中</li></ul></div><ul><li>添加示例函数，示例函数同样会更新在Go Doc中，可以反映出代码的实际功能</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// integer_test.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleAdd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sum := Add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    fmt.Println(sum)</span><br><span class="line">    <span class="comment">// Output: 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info flat"><ul><li><code>// Output: 3</code>实际上是<code>ExampleAdd()</code>这个函数的期望输出，如果写5，表明希望1 + 2 = 5，会返回测试失败</li><li>这个语法不能在别的测试中使用，只有<code>Examplexxx()</code>中可以使用</li><li>使用<code>go test -v</code>可以输出每个测试用例的通过情况，以及整体的通过情况，输出结果如下</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">=== RUN   TestAdd</span><br><span class="line">--- PASS: TestAdd (0.00s)</span><br><span class="line">=== RUN   ExampleAdd</span><br><span class="line">--- PASS: ExampleAdd (0.00s)</span><br><span class="line">PASS</span><br><span class="line">ok      integer 0.001s</span><br></pre></td></tr></table></figure></div><h2 id="基准测试">基准测试</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iter.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Repeat</span><span class="params">(a <span class="type">string</span>)</span></span> <span class="type">string</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> repeat <span class="type">string</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++&#123;</span><br><span class="line">        repeat += a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> repeat</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编写基准测试</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iter_test.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkRepeat</span><span class="params">(b *testing.B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++&#123;</span><br><span class="line">        Repeat(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info flat"><ul><li><code>testing.B</code>可以访问隐性命名<code>b.N</code>，表示这个代码的运行次数，并记录时间</li><li>测试框架会选择<code>b.N</code></li><li>使用<code>go test -bench=.</code>来运行基准测试，如果在<code>Windows</code>中则使用<code>go test -bench=&quot;.&quot;</code></li><li>如果直接使用<code>go test [-v]</code>不会运行基准测试</li><li>使用<code>go test -cover</code>查看覆盖率</li></ul></div><h1>数组 VS 切片</h1><ul><li><code>numbers := [5]int&#123;1,2,3,4,5&#125;</code></li><li><code>numbers := [...]int&#123;1,2,3,4,5&#125;</code></li><li>遍历数组的两个方式</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, number := <span class="keyword">range</span> numbers&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// range返回索引和值，使用空白标志符来忽略索引</span></span><br></pre></td></tr></table></figure><div class="note info flat"><ul><li>数组传参，比如需要传入<code>numbers</code>，参数类型应该为<code>numbers [5]int</code></li><li>此时如果传入一个<code>[4]int</code>传入函数，不能通过编译，因为会判定为不同的类型</li><li>所以导致数组没什么用，一般用切片<code>slice</code>，尺寸不固定</li><li>切片就是在声明的时候不指定长度，也就是<code>mySlice := []int{1,2,3}</code>，而不是<code>mySlice := [3]int{1,2,3}</code></li><li>参数是可变数量的切片时，应该写<code>numbers ... []int</code></li><li>不能对切片使用等于号，简单的方法是使用<code>reflect.DeepEqual</code>，用于判断两个变量是否相等</li><li>但是<code>reflect.DeepEqual</code>不是类型安全的，甚至可以比较<code>slice</code>和<code>string</code>。</li><li>使用<code>make</code>创建切片可以指定容量和长度，创建的新切片中所有元素均为<strong>0</strong></li></ul></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;code&gt;GOROOT&lt;/code&gt; VS &lt;code&gt;GOPATH&lt;/code&gt; VS &lt;code&gt;GOBIN&lt;/code&gt; VS &lt;code&gt;GOPROXY&lt;/code&gt;&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;GOROOT&lt;/code&gt;: Go语言安装路径&lt;/li</summary>
      
    
    
    
    <category term="Go" scheme="https://sangs3112.github.io/categories/Go/"/>
    
    
    <category term="Go" scheme="https://sangs3112.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go笔记_1</title>
    <link href="https://sangs3112.github.io/posts/8f6ca674.html"/>
    <id>https://sangs3112.github.io/posts/8f6ca674.html</id>
    <published>2024-07-23T17:18:51.906Z</published>
    <updated>2024-07-23T17:18:51.906Z</updated>
    
    <content type="html"><![CDATA[<h1>方法</h1><div class="note info flat"><ul><li>Go语言中只有不同的<code>package</code>中可以有相同函数名的函数，尽管参数不同，但是如果函数名相同就不能出现在相同的包中(函数重载Go语言没有)</li><li>方法需要通过一个特定的实例调用，比如<code>t.Errorf()</code>，这里的<code>Errorf</code>就是一个方法，通过实例<code>t</code>调用</li><li>函数可以随便调用，没有限制</li></ul></div><h1>接口</h1><ul><li>接口让函数接受不同类型的参数并创造类型安全并且高解耦的代码</li><li>Go语言中 interface resolution 是隐式的。如果传入的类型匹配接口需要的，则编译正确。</li><li>函数实现因此不需要关心参数是什么类型的，只需要声明一个接口，辅助函数就可以从具体类型解耦而只关心本身需要做的工作</li></ul><h1>表格驱动测试</h1><ul><li>如果需要测试一个接口的不同实现，或者传入的数据有很多不同的测试需求，则可以使用表格驱动测试</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestArea</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">areaTests := []<span class="keyword">struct</span>&#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">shape Shape</span><br><span class="line">want <span class="type">float64</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">&#123;name: <span class="string">&quot;Rec&quot;</span>, shape: Rec&#123;Width: <span class="number">12</span>, Height: <span class="number">6</span>&#125;, want: <span class="number">72.0</span>&#125;,</span><br><span class="line">&#123;name: <span class="string">&quot;Circle&quot;</span>, shape: Circle&#123;<span class="number">10</span>&#125;, want: <span class="number">314.15926</span>&#125;,</span><br><span class="line">&#123;name: <span class="string">&quot;Tri&quot;</span>, shape: Tri&#123;<span class="number">12</span>, <span class="number">6</span>&#125;, want: <span class="number">361.0</span>&#125;, </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, tt := <span class="keyword">range</span> areaTests&#123;</span><br><span class="line">got := tt.shape.Area()</span><br><span class="line">want := tt.want</span><br><span class="line"><span class="keyword">if</span> got != want&#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;%#v got &#x27;%.2f&#x27;, want &#x27;%.2f&#x27;&quot;</span>, tt.shape, got, want)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info flat"><ul><li>创建了一个匿名结构体，里面有shape和want，放在一个[]struct切片中</li><li>然后使用两个测试用例填充这个切片</li><li>Go中调用一个函数或者方法的时候，参数会被复制</li><li>使用指针解决这个问题，指向某个值，然后修改</li></ul></div><h1>map</h1><ul><li>Map是引用类型的，拥有对底层数据结构的引用</li><li>因此，Map可以是nil指，如果使用一个nil的map，那么会得到一个nil指针异常，导致程序终止</li><li>永远不要初始化一个空的map变量，比如:<code>var m map[string]string</code></li><li>可以用如下两种方式初始化空的map:</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dict = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;&#125;</span><br><span class="line">dict = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br></pre></td></tr></table></figure><ul><li>上述两种方法绝对不会出现nil指针异常</li></ul><h1>依赖注入</h1><ul><li><code>fmt.Fprintf</code>接受一个<code>Writer</code>参数，将字符串传递过去。</li><li><code>fmt.Printf</code>是标准的默认输出</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// di.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Greet</span><span class="params">(writer io.Writer, name <span class="type">string</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// fmt.Printf(&quot;Hello, %s&quot;, name)</span></span><br><span class="line">fmt.Fprintf(writer, <span class="string">&quot;Hello, %s&quot;</span>, name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Greet(os.Stdout, <span class="string">&quot;Elodie&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// di_test.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bytes&quot;</span></span><br><span class="line"><span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGreet</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">buffer := bytes.Buffer&#123;&#125; <span class="comment">// 注入依赖</span></span><br><span class="line">Greet(&amp;buffer, <span class="string">&quot;Chris&quot;</span>)</span><br><span class="line">got := buffer.String()</span><br><span class="line">want := <span class="string">&quot;Hello, Chris&quot;</span></span><br><span class="line"><span class="keyword">if</span> got != want &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;got %s want %s&quot;</span>, got, want)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info flat"><ul><li>Go中可以使用反引号创建字符串，允许将字符串中的东西放在新的一行，比如<br>`<br>3<br>1<br>2<br>`</li></ul></div><ul><li><p>Go中不会阻塞的操作在成为goroutine的单独进程中运行。使用go关键字声明</p></li><li><p><code>go test -race</code>可以发现<code>goroutine</code>中的竞争条件，比如可能多个进程同时写一个<code>map</code>，但是一次执行并不会触发这种现象。</p></li><li><p>可以通过<code>channels</code>协调<code>goroutine</code>解决数据竞争问题。</p></li><li><p>比如原本需要将多个进程的数据写入<code>map</code>中，现在可以使用<code>channel &lt;- data</code>，将数据发送到<code>channel</code>中，然后再使用<code>for</code>循环，将数据保存保存在新的map中，这样不会产生数据竞争的问题。<code>result := &lt;- channel</code></p></li><li><p>在函数调用之前加上<code>defer</code>前缀会在包含他的函数结束时调用它。</p><ul><li>有时候需要清理资源，比如在函数结束时关闭一个文件，或者关闭一个服务器，但是要把它放在创建服务器语句附近，以便函数内后面的代码仍然可以使用这个服务器，就可以使用<code>defer</code>，等到函数执行完再调用</li></ul></li></ul><h1>进程同步</h1><ul><li><code>select</code>可以轻易实现进程同步</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Racer</span> <span class="params">(a, b <span class="type">string</span>)</span></span> (winner <span class="type">string</span>, err <span class="type">error</span>)&#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;- ping(a):</span><br><span class="line"><span class="keyword">return</span> a, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> &lt;- ping(b):</span><br><span class="line"><span class="keyword">return</span> b, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> M- time.After(<span class="number">10</span> *time.Second):</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span>, fmt.Errorf(<span class="string">&quot;timed out waiting for %s and %s&quot;</span>, a, b)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ping</span><span class="params">(url <span class="type">string</span>)</span></span> <span class="keyword">chan</span> <span class="type">bool</span>&#123;</span><br><span class="line">ch := <span class="built_in">make</span> (<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">http.Get(url)</span><br><span class="line">ch &lt;- <span class="literal">true</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果是<code>v := &lt;- ch</code>等待值发送给<code>channel</code>，则这是一个阻塞调用，因为需要等待值返回</li><li><code>select</code>允许多个<code>channel</code>等待，第一个发送值的<code>channel</code>胜出。</li><li>使用<code>select</code>时，<code>time.After</code>是一个很好用的函数，因为<code>channel</code>可能永远不会返回一个值，那就有可能不会返回，因此使用<code>time.After</code>设置超时时间</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">t.Run(<span class="string">&quot;returns an error if a server doesn&#x27;t respond within 10s&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    serverA := makeDelayedServer(<span class="number">11</span> * time.Second)</span><br><span class="line">    serverB := makeDelayedServer(<span class="number">12</span> * time.Second)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> serverA.Close()</span><br><span class="line">    <span class="keyword">defer</span> serverB.Close()</span><br><span class="line"></span><br><span class="line">    _, err := Racer(serverA.URL, serverB.URL)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        t.Error(<span class="string">&quot;expected an error but didn&#x27;t get one&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1>反射</h1><blockquote><p>编写函数 <code>walk(x interface&#123;&#125;, fn func(string))</code>，参数为结构体x，并对 x 中的所有字符串字段调用 fn 函数</p></blockquote><ul><li>反射提供了程序检查自身结构体的能力。</li><li>允许使用类型<code>interface&#123;&#125;</code>，代表任意类型。但是这样市区了对类型安全的检查，编译器不会再检查类型</li><li>除非真的需要，否则不要使用反射</li><li>如果想要实现多态，可以考虑围绕接口实现。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;方法&lt;/h1&gt;
&lt;div class=&quot;note info flat&quot;&gt;&lt;ul&gt;
&lt;li&gt;Go语言中只有不同的&lt;code&gt;package&lt;/code&gt;中可以有相同函数名的函数，尽管参数不同，但是如果函数名相同就不能出现在相同的包中(函数重载Go语言没有)&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    <category term="Go" scheme="https://sangs3112.github.io/categories/Go/"/>
    
    
    <category term="Go" scheme="https://sangs3112.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>设计模式笔记_1</title>
    <link href="https://sangs3112.github.io/posts/b406aa8c.html"/>
    <id>https://sangs3112.github.io/posts/b406aa8c.html</id>
    <published>2024-05-04T06:37:35.000Z</published>
    <updated>2024-07-23T17:18:51.906Z</updated>
    
    <content type="html"><![CDATA[<h1>简单工厂模式</h1><blockquote><p>需要实例化谁,以后可能会添加实例化的对象,就要用一个单独的类来做这个创造实例的过程,就是<strong>工厂</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Operation.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Operation</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">getResult</span><span class="params">(<span class="type">double</span> numberA, <span class="type">double</span> numberB, String operation)</span>&#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span> (operation) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                ans = numberA + numberB;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                ans = numberA - numberB;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                ans = numberA * numberB;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                ans = numberA / numberB;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;not support operation&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info flat"><p>问题:</p><ol><li>如果需要增加函数,就需要添加新的<code>case</code>,有可能会改变原有的函数;</li><li>如果代码只需要调用除法,却需要编译其他的加,减,乘函数<br>解决办法:<br>实现一个运算抽象类,都有一个方法<code>getResult()</code>,用来得到结果.然后加减乘除都写成运算类的子类</li></ol></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Operation.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Operation</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getResult</span><span class="params">(<span class="type">double</span> numberA, <span class="type">double</span> numberB)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0d</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Add</span> <span class="keyword">extends</span> <span class="title class_">Operation</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getResult</span><span class="params">(<span class="type">double</span> numberA, <span class="type">double</span> numberB)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numberA + numberB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sub.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Operation</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getResult</span><span class="params">(<span class="type">double</span> numberA, <span class="type">double</span> numberB)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numberA - numberB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mul.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mul</span> <span class="keyword">extends</span> <span class="title class_">Operation</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getResult</span><span class="params">(<span class="type">double</span> numberA, <span class="type">double</span> numberB)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numberA * numberB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Div.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Div</span> <span class="keyword">extends</span> <span class="title class_">Operation</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getResult</span><span class="params">(<span class="type">double</span> numberA, <span class="type">double</span> numberB)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numberB == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;除数不能为0&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArithmeticException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numberA / numberB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OperationFactory.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperationFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Operation <span class="title function_">createOperation</span><span class="params">(String opertaion)</span>&#123;</span><br><span class="line">        <span class="type">Operation</span> <span class="variable">oper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (opertaion) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                oper = <span class="keyword">new</span> <span class="title class_">Add</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                oper = <span class="keyword">new</span> <span class="title class_">Sub</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                oper = <span class="keyword">new</span> <span class="title class_">Mul</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                oper = <span class="keyword">new</span> <span class="title class_">Div</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;we didnt implement this operation&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> oper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="type">Operation</span> <span class="variable">oper</span> <span class="operator">=</span> OperationFactory.createOperation(flag);</span><br><span class="line"><span class="type">double</span> <span class="variable">ans</span> <span class="operator">=</span> oper.getResult(a, b);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/sang3112/blog_imgs/raw/master/DesignPattern/SFP.png" alt="SFP"></p><div class="note info flat"><p>三个角色:</p><ol><li>抽象类: 定义所有支持算法的公共接口,比如运算抽象类</li><li>具体算法类: 具体的算法,比如加减乘除运算类</li><li>简单工厂类: 用来维护对运算类的应用</li></ol><ul><li>可以将类类比为产品,使用者在不清楚类生产的具体过程的情况下,可以使用不同的产品.</li></ul></div><h1>策略模式</h1><blockquote><p>定义算法家族,分别封装,让他们之间可以相互替换.这样可以保证算法的变化不会影响到客户<br>一系列算法都完成相同的工作,只是实现不同,可以以相同的方式调用所有的算法,减少耦合.<br>只需要在不同的时间应用不同的业务规则,就可以考虑使用策略模式进行处理</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CashSuper.java</span></span><br><span class="line"><span class="comment">// 收费抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CashSuper</span> &#123;</span><br><span class="line">    <span class="comment">// 收费的抽象方法,参数为单价和数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">acceptCash</span><span class="params">(<span class="type">double</span> price, <span class="type">int</span> num)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CashNormal.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CashNormal</span> <span class="keyword">extends</span> <span class="title class_">CashSuper</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">acceptCash</span><span class="params">(<span class="type">double</span> price, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> price * num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CashRebate.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CashRebate</span> <span class="keyword">extends</span> <span class="title class_">CashSuper</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> <span class="variable">moneyRebate</span> <span class="operator">=</span> <span class="number">1d</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CashRebate</span><span class="params">(<span class="type">double</span> moneyRebate)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.moneyRebate = moneyRebate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">acceptCash</span><span class="params">(<span class="type">double</span> price, <span class="type">int</span> num)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price * num * moneyRebate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CashReturn.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CashReturn</span> <span class="keyword">extends</span> <span class="title class_">CashSuper</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> <span class="variable">moneyCondition</span> <span class="operator">=</span> <span class="number">0d</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> <span class="variable">moneyReturn</span> <span class="operator">=</span> <span class="number">0d</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CashReturn</span><span class="params">(<span class="type">double</span> moneyCondition, <span class="type">double</span> moneyReturn)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.moneyCondition = moneyCondition;</span><br><span class="line">        <span class="built_in">this</span>.moneyReturn = moneyReturn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">acceptCash</span><span class="params">(<span class="type">double</span> price, <span class="type">int</span> num)</span>&#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">ans</span> <span class="operator">=</span> price * num;</span><br><span class="line">        <span class="keyword">if</span> (moneyCondition &gt; <span class="number">0</span> &amp;&amp; ans &gt;= moneyCondition)&#123;</span><br><span class="line">            ans -= Math.floor(ans / moneyCondition) * moneyReturn;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CashContext.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CashContext</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> CashSuper cs;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CashContext</span><span class="params">(CashSuper cs)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.cs = cs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getResult</span><span class="params">(<span class="type">double</span> price, <span class="type">int</span> num)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cs.acceptCash(price, num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;输入策略: 1 - 正常收费; 2 - 打八折; 3 - 打七折; 4 - 满300减100&quot;</span>);</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">discount</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;输入产品的单价:&quot;</span>);</span><br><span class="line">        <span class="type">double</span> <span class="variable">price</span> <span class="operator">=</span> in.nextDouble();</span><br><span class="line">        System.out.println(<span class="string">&quot;输入产品的数量:&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">        in.close();</span><br><span class="line">        <span class="type">CashContext</span> <span class="variable">cs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (discount) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                cs = <span class="keyword">new</span> <span class="title class_">CashContext</span>(<span class="keyword">new</span> <span class="title class_">CashNormal</span>());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                cs = <span class="keyword">new</span> <span class="title class_">CashContext</span>(<span class="keyword">new</span> <span class="title class_">CashRebate</span>(<span class="number">0.8d</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                cs = <span class="keyword">new</span> <span class="title class_">CashContext</span>(<span class="keyword">new</span> <span class="title class_">CashRebate</span>(<span class="number">0.7d</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                cs = <span class="keyword">new</span> <span class="title class_">CashContext</span>(<span class="keyword">new</span> <span class="title class_">CashReturn</span>(<span class="number">300d</span>, <span class="number">100d</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;we dont support this strategy&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> <span class="variable">totalPrice</span> <span class="operator">=</span> cs.getResult(price, num);</span><br><span class="line">        System.out.println(totalPrice);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>策略模式,使用<code>CashContext</code>计算不同策略下的收费及结果,但是会发现在<code>Main</code>中进行了判断需要使用哪一个策略</li><li>可以使用工厂模式+策略模式的方法进行调整</li></ul><h2 id="策略-工厂模式">策略 + 工厂模式</h2><blockquote><p>只需要将<code>Main</code>中的<code>switch</code>部分移动到<code>CashContext</code>中即可</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CashContext.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CashContext</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> CashSuper cs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CashContext</span><span class="params">(<span class="type">int</span> discount)</span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (discount) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                cs = <span class="keyword">new</span> <span class="title class_">CashNormal</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                cs = <span class="keyword">new</span> <span class="title class_">CashRebate</span>(<span class="number">0.8d</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                cs = <span class="keyword">new</span> <span class="title class_">CashRebate</span>(<span class="number">0.7d</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                cs = <span class="keyword">new</span> <span class="title class_">CashReturn</span>(<span class="number">300d</span>, <span class="number">100d</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;we dont support this strategy&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getResult</span><span class="params">(<span class="type">double</span> price, <span class="type">int</span> num)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cs.acceptCash(price, num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在导航中,不同的路径规划算法,比如步行,骑行,搭乘公共交通的,开车的.主要导航类的主要工作是渲染路径,不会在意算法生成的路径,因此可以将路径规划算法使用策略模式进行封装,方便交互</p></blockquote><p><img src="https://gitee.com/sang3112/blog_imgs/raw/master/DesignPattern/SP.png" alt="SP"></p><ul><li>策略模式不适合算法极少变化的场景,这样会使得程序整体变得复杂</li><li>同时要求客户知晓策略的不同</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;简单工厂模式&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;需要实例化谁,以后可能会添加实例化的对象,就要用一个单独的类来做这个创造实例的过程,就是&lt;strong&gt;工厂&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight j</summary>
      
    
    
    
    <category term="DesignPattern" scheme="https://sangs3112.github.io/categories/DesignPattern/"/>
    
    
    <category term="DesignPattern" scheme="https://sangs3112.github.io/tags/DesignPattern/"/>
    
    <category term="简单工厂模式" scheme="https://sangs3112.github.io/tags/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="策略模式" scheme="https://sangs3112.github.io/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式笔记_0</title>
    <link href="https://sangs3112.github.io/posts/c3019a1a.html"/>
    <id>https://sangs3112.github.io/posts/c3019a1a.html</id>
    <published>2024-05-03T06:37:35.000Z</published>
    <updated>2024-07-23T17:18:51.906Z</updated>
    
    <content type="html"><![CDATA[<h1>单一职责原则 <code>SRP</code></h1><blockquote><p>一个类应该只有一个更改它的原因,也就是这个类只有一个职责</p></blockquote><ul><li>每个类的职责都有清晰明确的定义</li><li>一个类的修改只对自身有影响,对其他类没有影响</li></ul><h1>开闭原则 <code>OCP</code></h1><blockquote><p>软件实体(类 模块 函数)应该可以扩展,但是不能修改.对于扩展是开放的,对于修改是封闭的.<br>对于要怎讲爱新功能或者需要调整的改动,应该扩展新的代码而不是修改原有的代码.</p></blockquote><ul><li>对程序中频繁变化的部分抽象</li><li>不要刻意的对每一个部分都进行抽象,拒绝不成熟的抽象,这和抽象本身一样重要.</li></ul><h1>依赖倒置原则 <code>DIP</code></h1><blockquote><p>程序不应该依赖细节,细节应该依赖于抽象. 针对接口编程 而不是针对实现编程</p></blockquote><ul><li>使用接口或者抽象类的目的是制定好规范,不涉及任何具体的操作,把细节任务交给实现类去完成</li><li>让程序中所有的依赖关系都终止于抽象类或者接口</li><li>高层模块不应该依赖底层模块,二者都应该依赖抽象</li><li>抽象不应该依赖细节,细节应该依赖抽象</li></ul><h1>里氏替换原则 <code>LSP</code></h1><blockquote><p>一个软件实体如果适用于父类,必定适用于子类,并且察觉不出子类和父类的区别,也就是子类必须能够替换父类</p></blockquote><ul><li>父类一般使用抽象类或者接口</li><li>抽象类定义公共对象和状态;接口定义公共行为</li><li>子类通过继承父类和接口进行扩展</li><li>子类的方法参数类型 返回值类型 异常 都应该跟父类相匹配;子类不应该强加参数条件限制;子类不能修改父类的私有成员</li></ul><h1>迪米特原则 <code>LoD</code></h1><blockquote><p>最小知识原则.如果两个类不必彼此互相通信,那么这两个类就不应该发生直接的相互作用;如果其中一个类需要调用另一个类的某一个方法,则可以通过第三者转发这个调用</p></blockquote><ul><li>类设计上,每一个类都应该尽量降低成员的访问权限,不要让别的类知道字段或行为就不要公开</li><li>类之间不建立联系,而是通过中间类来中转</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;单一职责原则 &lt;code&gt;SRP&lt;/code&gt;&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;一个类应该只有一个更改它的原因,也就是这个类只有一个职责&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;每个类的职责都有清晰明确的定义&lt;/li&gt;
&lt;li&gt;一个类的修改只对自身</summary>
      
    
    
    
    <category term="DesignPattern" scheme="https://sangs3112.github.io/categories/DesignPattern/"/>
    
    
    <category term="DesignPattern" scheme="https://sangs3112.github.io/tags/DesignPattern/"/>
    
    <category term="设计原则" scheme="https://sangs3112.github.io/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>Java笔记_4</title>
    <link href="https://sangs3112.github.io/posts/63a4d81f.html"/>
    <id>https://sangs3112.github.io/posts/63a4d81f.html</id>
    <published>2024-04-22T06:37:35.000Z</published>
    <updated>2024-07-23T17:18:51.906Z</updated>
    
    <content type="html"><![CDATA[<h1>垃圾回收算法(四种)</h1><div class="note info flat"><ul><li>垃圾回收需要找到内存中存活的对象</li><li>还需要释放不再存活的对象，使程序可以再次利用这部分空间</li></ul></div><ol><li>标记-清除算法</li><li>复制算法</li><li>标记-整理算法</li><li>分代GC</li></ol><div class="note info flat"><ul><li><p>垃圾回收会有单独的<code>GC</code>线程来完成，但是不管哪一种<code>GC</code>算法，都会有部分阶段需要停止所有用户线程，称之为<code>Stop The World</code>，简称<code>STW</code>，如果<code>STW</code>的时间过长，则会影响用户使用</p></li><li><p>为什么一定需要<code>STW</code>?</p><ul><li>分析工作必须在能够确保一致性的快照中进行</li><li>一致性指整个分析期间系统被冻结在某个时间点上</li><li>如果分析过程中对象的引用关系还在不断地变化,那么分析的准确性就没有办法保证</li><li>如果不暂停业务线程的话,在垃圾回收期间新创建的对象会被错误的回收,这是因为业务陈晓晨和垃圾回收线程都是并行执行的</li></ul></li><li><p>评价标准:</p><ol><li><strong>吞吐量</strong>：CPU用于执行用户代码的时间与CPU总执行时间的比值，吞吐量=执行用户代码的时间/(执行用户代码的时间+<code>GC</code>时间)，吞吐量越高表示垃圾回收效率越高</li><li><strong>最大暂停时间</strong>：垃圾回收过程中<code>STW</code>时间的最大值，越小越好</li><li><strong>堆使用效率</strong>：不同垃圾回收算法，堆内存使用效率不同。比如标记清除算法，可以完整的使用堆内存，复制算法会将堆内存一分为二，每次只能使用一半内存。从堆使用效率上来说，标记清除算法要优于复制算法</li></ol></li><li><p>三者不可兼得，堆内存越大，最大暂停时间就越大，减少最大暂停时间，就会降低吞吐量</p></li></ul></div><h2 id="标记-清除算法">标记-清除算法</h2><blockquote><p>两个阶段</p><ol><li>标记阶段，将所有存活对象标记，使用可达性算法，从<code>GC Root</code>开始通过引用链遍历出所有的存活对象</li><li>清除阶段，从内存中删除没有被标记，也就是非存活对象</li></ol></blockquote><div class="note info flat"><ul><li>优点：实现简单，只需要在第一阶段维护每个对象的标志位，第二阶段删除即可</li><li>缺点：<ol><li><strong>碎片化问题</strong>：内存是连续的，所以对象被删除之后，内存中可能会出现很多细小的可用内存单元。如果我们需要一个比较大的空间，这些内存单元会无法进行分配</li><li><strong>分配速度比较慢</strong>：因为内存碎片存在，需要维护一个空闲链表，有可能发生每次遍历链表的最后才能获得合适的内存空间</li></ol></li></ul></div><h2 id="复制算法">复制算法</h2><blockquote><p>核心思想</p><ol><li>准备两块空间<code>From</code>和<code>To</code>空间，每次在对象分配阶段，只能使用其中一块空间(<code>From</code>空间)</li><li><code>GC</code>阶段，将<code>From</code>中存活的对象复制到<code>To</code>空间中</li><li>将两块空间的名字互换，也就是<code>From</code>和<code>To</code>互换名字，因为只有<code>From</code>空间存储对象</li></ol></blockquote><div class="note info flat"><ul><li>完整复制算法<ol><li>将堆内存分隔成两块<code>From</code>空间和<code>To</code>空间，对象分配阶段，创建对象</li><li><code>GC</code>阶段开始，将<code>GC Root</code>搬运到<code>To</code>空间</li><li>将<code>GC Root</code>关联的对象，搬运到<code>To</code>空间，<code>From</code>空间剩下的是没有被<code>GC Root</code>关联的对象了</li><li>清理<code>From</code>空间，并把名称互换</li></ol></li><li>优点：<ol><li>吞吐量高，只需要遍历一次存活对象复制到<code>To</code>空间即可，比标记-整理算法少了一次遍历过程。但是性能比标记-清除算法低，因为标记-清除算法不需要进行对象的移动</li><li>不会出现碎片化的问题，复制算法复制后有序排列对象，所以不会出现内存碎片</li></ol></li><li>缺点：每次只能用一半的堆内存，让一半的空间来创建对象使用</li></ul></div><h2 id="标记-整理算法-标记-压缩算法">标记-整理算法(标记-压缩算法)</h2><blockquote><p>对标记-清理算法中容易产生内存碎片的问题的一种解决方案<br>两个阶段</p><ol><li>标记阶段，将所有的存活对象标记，使用可达性分析算法，从<code>GC Root</code>开始通过引用链遍历出所有存活对象</li><li>整理阶段，将存活对象移动到堆的一端，清理掉非存活对象的内存空间</li></ol></blockquote><div class="note info flat"><ul><li>优点：<ol><li>内存使用率高，整个堆内存都可以使用，复制算法只能用半个堆内存</li><li>不会出现碎片化的问题，整理阶段可以将对象往内存的一侧进行移动，剩下的空间都是可以分配对象的有效空间</li></ol></li><li>缺点：整理阶段的效率不高，整理算法有很多，比如<code>Lisp2</code>整理算法需要对整个堆中的对象搜索三次，整体性能不佳。可以通过<code>Two-Finger</code>，表格算法，<code>ImmixGC</code>等高效的整理算法优化这个阶段的性能</li></ul></div><h2 id="分代GC-Generational-GC">分代<code>GC</code>(<code>Generational GC</code>)</h2><blockquote><p>分代垃圾回收将整个内存区域划分为年轻代(<code>Young</code> 区，新生代)和老年代(<code>Old</code> 区)<br>年轻代存放存活时间比较短的对象，老年代存放存活时间比较长的对象<br>年轻代中有<code>Eden</code>区，<code>Survivor</code>区(<code>S0,S1</code>)<br><code>JDK8</code>中，添加<code>-XX:+UserSerialGC</code>参数使用分代回收的垃圾回收器，运行程序，使用<code>Arthas</code>中的<code>memory</code>命令可以查看三个区域的内存情况，分别是<code>eden_space, survivio_space, tenured_gen</code>，就是伊甸园区，幸存者区，老年代</p></blockquote><div class="note info flat"><ul><li><code>-Xmn</code>：设置新生代的大小，也就是伊甸园区和幸存者区的大小</li><li><code>-XX:SurvivorRatio</code>伊甸园区和幸存区的比例，默认为8。新生代1G内存，伊甸园区就是800MB，<code>S0</code>和<code>S1</code>各100MB</li><li><code>-XX:+PrintGCDetails verbose:gc</code>打印GC日志，前者打印信息详细一些，后者简单一些。</li><li>老年代大小就是堆大小与新生代大小的差</li></ul></div><ul><li>使用分代回收时，创建出来的对象首先放入<code>Eden</code>伊甸园区，如果对象在<code>Eden</code>区越来越多，直到<code>Eden</code>区满，新创建的对象无法放入，就会触发年轻代<code>GC</code>，称为<code>Minor GC</code>或者<code>Young GC</code>，<code>Minor GC</code>会把需要<code>Eden</code>中和<code>From</code>需要回收的对象回收，把没有回收的对象放在<code>To</code>区域中<ul><li>所以<code>Minor GC</code>就是一个复制算法，初始<code>S0</code>是<code>From</code>，<code>S1</code>是<code>To</code>，接下来<code>S0</code>变成了<code>To</code>,<code>S1</code>变成了<code>From</code></li><li>当<code>Eden</code>再次满时，此时会回收<code>Eden</code>区和<code>S1From</code>中的对象，，并把<code>Eden, From</code>中的剩余的对象放在<code>S0</code>中</li></ul></li><li>每次<code>Minor GC</code> 都会为对象记录他的年龄，初始值为0，每次GC完都要加1</li><li>年龄到达15以后(15是最大值)，默认值和垃圾回收器有关，对象就会<strong>晋升</strong>到老年代</li><li>老年代空间不足，无法放入新的对象时，先会尝试<code>Minor GC</code>(为了尽量避免对象放入老年代，比如新生代中年龄都是2或者3，只是被占用满了，需要将对象放在老年代中，如果新生代空间没有满，也可以不用放入老年代，所以先进行<code>Minor GC</code>，尽量避免对象放入老年代)，如果还是不足，就会触发<code>Full GC</code>，对整个堆进行垃圾回收<ul><li>如果<code>Full GC</code>没有释放足够的老年代的空间，就会产生<code>OutOfMemory</code>错误</li></ul></li></ul><div class="note info flat"><ul><li>为什么分代<code>GC</code>要把堆分成年轻代和老年代</li></ul><blockquote><p>系统中的大部分对象，都是创建出来以后不再使用可以被回收，比如用户获取订单数据，订单数据返回给用户之后就可以释放了<br>老年代中会存放长期存活的对象，比如<code>Spring</code>中的大部分<code>bean</code>对象，在程序启动之后就不会被回收了<br>在虚拟机的默认设置中，新生代的大小要远小于老年代的大小</p></blockquote><ol><li>可以通过调整新生代和老年代的比例来适应不同类型的应用程序，提高内存的利用率和性能。比如一个用户很多的网站，有很多人需要访问订单数据，那如果新生代较小，则会有很多年龄较小的对象进入老年代，导致<code>gc</code>时间延长，此时可以将新生代的内存区调大一些，直接可以通过<code>Minor GC</code>回收</li><li>新生代和老年代可以使用不同的垃圾回收算法，新生代一般使用复制算法，减少内存碎片；老年代可以使用标记-清除或者标记-整理算法，由程序员自己调整(因为老年代空间比较大，使用了复制算法就只能使用一半空间了，就不合理了)，标记清除算法效率较高，但是会有内存碎片，而标记整理算法没有内存碎片，但是<code>STW</code>较长</li><li>分代设计中允许只回收新生代<code>Minor GC</code>，如果能满足对象分配的要求就不需要堆整个堆进行回收了，<code>STW</code>时间减少(最核心)，尽可能做<code>Minor GC</code>，减少<code>Full GC</code></li></ol></div><h1>垃圾回收器</h1><ul><li>垃圾回收器是垃圾回收算法的具体实现，由于垃圾回收器分为年轻代和老年代，所以出了G1之外的其他垃圾回收器必须成对使用<br><img src="https://gitee.com/sang3112/blog_imgs/raw/6d55251373589f7b63584fece6808ec3cbcdad27/Java/GC.png" alt="GC"></li></ul><blockquote><p>年轻代的<code>Serial</code>以及老年代的<code>Serial Old</code><br>年轻代的<code>ParNew</code>以及老年代的<code>CMS</code><br>年轻代的<code>Parallel Scavenge</code>以及老年代的<code>Parallel Old</code><br>G1可以同时控制年轻代和老年代(<code>JDK9</code>之后主流推荐)<br><code>JDK9</code>废弃了年轻代的<code>Serial</code>以及老年代的<code>CMS</code>；年轻代的<code>ParNew</code>以及老年代的<code>Serial Old</code><br><code>JDK14</code>中废弃了<code>Parallel Scavenge</code>以及老年代的<code>Serial Old</code>(为什么？)</p></blockquote><h2 id="Serial垃圾回收器-年轻代"><code>Serial</code>垃圾回收器-年轻代</h2><blockquote><p><strong>单线程串行</strong>回收年轻代的垃圾回收器<br><img src="https://gitee.com/sang3112/blog_imgs/raw/6d55251373589f7b63584fece6808ec3cbcdad27/Java/Serial.png" alt="Serial"></p></blockquote><ul><li>回收年轻代，使用复制算法</li><li>优点：单CPU处理器下吞吐量出色</li><li>缺点：多CPU下吞吐量不如其他垃圾回收器，堆偏大会让用户线程处于长时间等待(因为回收的时候只有单线程进行<code>GC</code>)</li><li>适合<code>Java</code>编写的客户端程序，或者硬件配置有限的场景</li></ul><h2 id="SerialOld垃圾回收器-老年代"><code>SerialOld</code>垃圾回收器-老年代</h2><blockquote><p><strong>单线程串行回收</strong>，是<code>Serial</code>的老年代版本</p></blockquote><ul><li><code>-XX:+UseSerialGC</code> 新生代、老年代都使用串行回收器</li><li>回收老年代，使用标记-整理算法</li><li>优缺点跟<code>Serial</code>算法相同</li><li>一般配合<code>Serial</code>使用，或者在特殊情况下调用<code>CMS</code>使用，实际使用不多，一般在<code>CPU</code>资源比较匮乏的时候使用</li></ul><h2 id="ParNew垃圾回收器-年轻代"><code>ParNew</code>垃圾回收器-年轻代</h2><blockquote><p>本质上就是对<code>Serial</code>在多线程CPU下的优化，使用多线程进行垃圾回收<br><img src="https://gitee.com/sang3112/blog_imgs/raw/6d55251373589f7b63584fece6808ec3cbcdad27/Java/ParNew.png" alt="ParNew"><br><code>-XX:+UseParNewGC</code>新生代使用<code>ParNew</code>回收器，老年代使用串行回收器</p></blockquote><ul><li>回收年轻代，使用复制算法</li><li>优点：多CPU处理器下停顿时间较短</li><li>缺点：吞吐量和停顿时间不如<code>G1</code>，所以在<code>JDK9</code>之后不建议使用</li><li>适合<code>JDK8</code>以及之前的版本中，与<code>CMS</code>老年代垃圾回收器配合使用</li></ul><h2 id="CMS-Concurrent-Mark-Sweep-垃圾回收器-老年代"><code>CMS(Concurrent Mark Sweep)</code>垃圾回收器-老年代</h2><blockquote><p>关注的是系统的<strong>暂停时间</strong>，允许用户线程和垃圾回收线程在某些步骤中同时执行，减少用户线程的等待<br><code>-XX:+UseConcMarkSweepGC</code><br><img src="https://gitee.com/sang3112/blog_imgs/raw/6d55251373589f7b63584fece6808ec3cbcdad27/Java/CMS.png" alt="CMS"></p></blockquote><ul><li>使用标记-清除算法回收老年代</li><li>优点：系统由于垃圾回收停顿时间较短，所以用户体验好</li><li>缺点：内存碎片问题，退化问题(会退化为<code>Serial Old</code>单线程)，浮动垃圾问题</li><li>适合大型互联网系统中，用户请求数据量大，频率高的场景，比如订单接口，商品接口等</li></ul><div class="note info flat"><p><code>CMS</code>执行步骤</p><ol><li>初始标记，用极短的时间标记出<code>GC Roots</code>能够直接关联到的对象</li><li>并发标记，标记所有的对象，用户线程不需要暂停</li><li>重新标记，由于并发标记阶段有些对象会发生变化，存在错标和漏标的情况，需要重新标记(这也是<code>STW</code>的原因)</li><li>并发清理，清理死亡对象，用户线程不需要暂停(会有浮动垃圾,不能完全垃圾回收)</li></ol><blockquote><p>只有初始标记和重新标记两个阶段用户线程需要暂停，但是这两个线程执行时间较短，是并发执行的，所以<code>STW</code>较短</p></blockquote><ul><li><code>CMS</code>问题<ol><li>使用标记-清除算法，会有大量内存碎片，在<code>Full GC</code>时进行碎片整理，导致用户线程暂停，可以使用<code>-XX:CMSFullGCsBeforeCompation=N</code>(默认为0)调整<code>N</code>次<code>Full GC</code>之后再整理</li><li>无法处理在并发清理过程中产生的<strong>浮动垃圾</strong>，不能做到完全的垃圾回收, 也就是在并发清理阶段，如果用户产生了对象，并且很快就失效了，则不能在并发清理阶段被回收</li><li>如果老年代内存不足无法分配对象，<code>CMS</code>就会退化为<code>Serial Old</code>单线程回收老年代</li></ol></li></ul></div><h2 id="Parallel-Scavenge垃圾回收器-年轻代"><code>Parallel Scavenge</code>垃圾回收器-年轻代</h2><ul><li>是<code>JDK8</code>默认的垃圾回收器，多线程并行回收，关注系统的吞吐量，具备自动调整堆内存大小的特点</li><li>年轻代的复制算法</li><li>优点：吞吐量高，手动可控，为了提高吞吐量，虚拟机会动态调整堆的参数(不需要关注最大堆内存，年轻代的大小了)</li><li>缺点：不能保证单次的停顿时间(可以设置最大单次暂停时间)</li><li>适合后台任务，不需要与用户进行交互，并且容易产生大量的对象，比如大数据的处理，大文件的导出</li></ul><blockquote><p>允许手动设置最大暂停时间和吞吐量，官方建议<strong>不要设置堆内存的最大值</strong>，垃圾回收器会根据最大暂停时间和吞吐量自动调整内存大小<br>最大暂停时间<code>-XX:MaxGCPauseMillis=n</code>设置每次垃圾回收时的最大停顿毫秒数<br>吞吐量<code>-XX:GCTimeRatio=n</code>设置吞吐量为n，也就是用户线程执行时间=n/(n+1)<br>自动调整内存大小<code>-XX:+UseAdaptiveSizePolicy</code>设置可以让垃圾回收器根据吞吐量和最大停顿毫秒数自动调整内存大小<br>实际上，当我们把最大暂停时间减小的时候，垃圾回收器会主动减少堆内存，从而减少最大暂停时间<br><img src="https://gitee.com/sang3112/blog_imgs/raw/6d55251373589f7b63584fece6808ec3cbcdad27/Java/PS.png" alt="PS"></p></blockquote><h2 id="Parallel-Old垃圾回收器-老年代"><code>Parallel Old</code>垃圾回收器-老年代</h2><ul><li>是<code>PS</code>收集器的老年代版本，利用多线程并发收集</li><li><code>-XX:+UseParallelGC</code>或者<code>-XX:+UseParallelOldGC</code>可以使用<code>PS + PO</code>这种组合</li><li>回收老年代的标记-整理算法，(<code>Arthas</code>上面显示<code>MarkSweep</code>也就是标记清除，这是因为老年代垃圾回收器不会单独使用标记清除算法，官方没有将整理放上来，所以显示<code>MarkSweep</code>，包括<code>CMS</code>用的也不是单纯的标记清除算法)</li><li>优点：并发收集，在多核CPU下效率较高</li><li>缺点：暂停时间较长</li><li>适合与<code>PS</code>一起使用</li></ul><h2 id="G1垃圾回收器"><code>G1</code>垃圾回收器</h2><blockquote><p><code>JDK9</code>之后默认使用<code>G1</code>垃圾回收器，<code>PS</code>关注吞吐量，允许用户设置最大暂停时间，但是会减少年轻代的可用空间大小<br><code>CMS</code>关注暂停时间，但是吞吐量方面会有下降<br><code>G1</code>设计目标就是将上述两种垃圾回收器的优点融合：</p><ol><li>支持巨大的堆空间回收，具有较高的吞吐量</li><li>支持多CPU并行垃圾回收</li><li>允许用户设置最大暂停时间<br>所以强烈建议使用<code>G1</code>垃圾回收器</li></ol></blockquote><h3 id="内存结构">内存结构</h3><ul><li><code>G1</code>之前的垃圾回收器，一般内存结构是连续的<br><img src="https://gitee.com/sang3112/blog_imgs/raw/6d55251373589f7b63584fece6808ec3cbcdad27/Java/beforeg1.png" alt="beforeg1"></li><li><code>G1</code>将整个堆划分为多个大小相等的区域，称为区<code>Region</code>，区域不要求连续，分为<code>eden, Survivor, Old</code>区。<code>Region</code>的大小通过堆空间大小/2048计算得到，也可以通过<code>-XX:G1HeapRegionSize=32m</code>指定(<code>region</code>大小为32M)，<code>Region size</code>必须是2的指数幂，取值范围从1M到32M</li></ul><h3 id="垃圾回收方式">垃圾回收方式</h3><ol><li>年轻代回收(<code>Young GC</code>)</li><li>混合回收(<code>Mixed GC</code>)(回收年轻代加上老年代)</li></ol><h3 id="年轻代回收-YoungGC">年轻代回收(<code>YoungGC</code>)</h3><blockquote><p>回收<code>Eden</code>区和<code>Survivor</code>区中不再使用的对象，会导致<code>STW</code>，<code>G1</code>会尽可能的保证暂停时间，可以通过<code>-XX:MaxGCPauseMillis=n</code>(默认为200)设置最大暂停时间的毫秒数</p></blockquote><ol><li>新创建的对象放在<code>Eden</code>区，如果<code>Eden + Survivor</code>超过年轻代区的60%，就会判断年轻代空间不足，无法分配对象的时候会执行<code>Young GC</code></li><li>标记处<code>Eden</code>和<code>Survivor</code>区域中的存活对象</li><li>根据最大暂停时间选择某些区域将存活对象复制到一个新的<code>Survivor</code>区域，并且年龄+1，并清空这些区域(所以使用了复制方法，不会产生内存碎片)</li></ol><blockquote><p>进行<code>Young GC</code>的时候会记录每次垃圾回收的<code>Eden</code>区域和<code>Survivor</code>区域的<strong>平均耗时</strong>，从而作为下次回收时的参考依据，这样就可以根据配置的最大暂停时间计算出本次回收最多能回收多少个<code>Region</code>区域了<br>比如<code>-XX:MaxGCPauseMillis=n</code>(默认为200)，每个<code>Region</code>回收耗时40ms，所以这次最多只能回收4个<code>Region</code></p></blockquote><ol start="4"><li>后面如果再发生<code>Young GC</code>，步骤相同，只是<code>Survivor</code>会搬运到另一个<code>Survivor</code>区</li></ol><blockquote><p>如果一个对象年龄达到阈值(默认是15)，就会被放入老年代</p></blockquote><ol start="5"><li>如果部分对象大小超过<code>Region</code>的一半，那么就会直接放到老年代中，称为<code>Humongous</code>区(巨大的)。</li></ol><blockquote><p>比如堆内存4G，每个<code>Region</code>2M，只要一个对象超过1M，就会被放入<code>Humongous</code>区中，如果对象过大，就会横跨多个<code>Region</code></p></blockquote><ol start="6"><li>多次回收之后，会有很多老年代区，如果达到阈值(<code>-XX:InitiatingHeapOccupancyPercent</code>)占用总堆空间的默认的45%，就会触发<code>Mixed GC</code>，回收所有年轻代和部分老年代对象以及大对象区，采用复制算法完成</li></ol><h3 id="混合回收-Mixed-GC">混合回收(<code>Mixed GC</code>)</h3><blockquote><p>分为初始标记<code>Initial Mark</code>，并发标记<code>Concurrent Mark</code>，最终标记<code>Remark</code>或者<code>Finalize Marking</code>，并发清理(<code>Cleanup</code>)<br><code>G1</code>对老年代的清理会选择存活度最低的区域来进行回收，可以保证回收效率最高，也就是<code>G1</code>的由来(判断哪个区域存活对象最少，就优先清除哪个区域)<br><img src="https://gitee.com/sang3112/blog_imgs/raw/6d55251373589f7b63584fece6808ec3cbcdad27/Java/G1old.png" alt="G1old"></p></blockquote><ul><li>初始标记：标记<code>GC Roots</code>引用的对象为存活，并行执行，暂停用户线程，速度较快</li><li>并发标记：将第一步中标记对象的引用对象标记为存活，和用户线程一起执行(可能会出现错标漏标)</li><li>最终标记：标记一些引用改变漏标的对象，不管新创建、不再关联的对象(但是上一步，有些对象不再使用了，<code>G1</code>不再处理)</li><li>并发复制清理：使用复制算法，将存活对象复制到别的<code>Region</code>中，不会产生内存碎片</li></ul><div class="note info flat"><ul><li>如果清理过程中没有足够的空<code>Region</code>存放转移的对象，就会出现<code>Full GC</code>，单线程执行标记-整理算法，此时会导致用户线程暂停。所以尽量保证堆中有一定的空间</li></ul></div><blockquote><p><code>-XX:+UseG1GC</code>，打开<code>G1</code>的开关，<code>JDK9</code>之后不需要打开<br><code>-XX:MaxGCPauseMillis=n</code>设置最大暂停时间</p></blockquote><ul><li>使用<strong>复制算法</strong>回收年轻代+老年代</li><li>优点：<ol><li>对较大的堆如果超过6G对回收时，延迟也可控</li><li>不会产生内存碎片</li><li>并发标记的<code>SATB</code>算法效率高</li></ol></li><li>缺点：<code>JDK8</code>之前还不够成熟</li></ul><h2 id="总结">总结</h2><ul><li>组合</li></ul><ol><li><code>JDK8</code>以及之前：<code>ParNew + CMS</code>(关注暂停时间); <code>PS + PO</code>(关注吞吐量); <code>G1</code>(<code>JDK8</code>之前不建议使用，较大堆并且关注暂停时间)</li><li><code>JDK9</code>之后，使用<code>G1</code></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;垃圾回收算法(四种)&lt;/h1&gt;
&lt;div class=&quot;note info flat&quot;&gt;&lt;ul&gt;
&lt;li&gt;垃圾回收需要找到内存中存活的对象&lt;/li&gt;
&lt;li&gt;还需要释放不再存活的对象，使程序可以再次利用这部分空间&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;标记</summary>
      
    
    
    
    <category term="Java" scheme="https://sangs3112.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://sangs3112.github.io/tags/Java/"/>
    
    <category term="垃圾回收算法" scheme="https://sangs3112.github.io/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"/>
    
    <category term="垃圾回收器" scheme="https://sangs3112.github.io/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Java笔记_3</title>
    <link href="https://sangs3112.github.io/posts/fdc04dbc.html"/>
    <id>https://sangs3112.github.io/posts/fdc04dbc.html</id>
    <published>2024-04-21T06:37:35.000Z</published>
    <updated>2024-07-23T17:18:51.906Z</updated>
    
    <content type="html"><![CDATA[<h1>垃圾回收器</h1><blockquote><p>主要负责在<strong>堆</strong>上进行内存回收</p></blockquote><ul><li>自动垃圾回收可以降低实现难度，降低回收bug的可能性</li><li>但是程序员无法控制内存回收的及时性, 也无法完全避免内存溢出</li></ul><h2 id="应用场景">应用场景</h2><ol><li>解决系统僵死(因为频繁的垃圾回收)</li><li>性能优化</li><li>常见垃圾回收，四种引用等</li></ol><h2 id="方法区回收">方法区回收</h2><blockquote><p>线程不共享的程序计数器和<code>Java</code>虚拟机栈以及本地方法栈，都只需要等待线程销毁自己就销毁了，不需要垃圾回收</p></blockquote><h3 id="方法区回收的条件-三个">方法区回收的条件(三个)</h3><blockquote><p>方法区中的类不再使用，即可被回收</p></blockquote><ol><li>类的<strong>所有实例</strong>都已经被回收了，在堆中不存在任何该类的实例对象以及子类对象 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = loader.loadClass(<span class="string">&quot;类的全限定名&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">o = <span class="literal">null</span>; <span class="comment">// 此时对象o不再使用，就可以让gc自动回收clazz类</span></span><br></pre></td></tr></table></figure></li><li>加载该类的类加载器已经被回收了 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">URLClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URLClassLoader</span>(<span class="keyword">new</span> <span class="title class_">URL</span>[]&#123;<span class="keyword">new</span> <span class="title class_">URL</span>(spec:<span class="string">&quot;路径&quot;</span>)&#125;);</span><br><span class="line">loader = <span class="literal">null</span>; </span><br></pre></td></tr></table></figure></li><li>该类对应的<code>java.lang.Class</code>对象没有任何地方被引用 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = loader.loadClass(<span class="string">&quot;类的全限定名&quot;</span>);</span><br><span class="line">clazz = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>使用<code>System.gc()</code>可以手动触发垃圾回收</p></blockquote><div class="note info flat"><ul><li>开发过程中此类场景出现较少，主要在<code>OSGI, JSP</code>的热部署等场景中</li><li>每个<code>jsp</code>文件对应一个类加载器，一个<code>jsp</code>文件被修改了，直接写在这个<code>jsp</code>类加载器，创建新的类加载器，重新加载<code>jsp</code>文件</li></ul></div><h2 id="堆回收">堆回收</h2><blockquote><p>堆上的对象主要看是否还被<strong>引用</strong>，如果被引用，说明不能回收</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Demo</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">        d = <span class="literal">null</span>; <span class="comment">// 此时没有引用，可以被回收</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceCounting</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        <span class="type">B</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        a1.b = b1;</span><br><span class="line">        b1.a = a1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// A实例要回收，需要消除两个引用关系，分别是栈中a1对对象的引用，以及B对象中b1.a对对象的引用</span></span><br><span class="line">    <span class="comment">// a1 = null;</span></span><br><span class="line">    <span class="comment">// b1.a = null;</span></span><br><span class="line"><span class="comment">// 如果单纯的执行a1 = null; b1 = null; A和B对象也可以被回收，因为方法里面没有办法访问到AB对象了</span></span><br></pre></td></tr></table></figure><div class="note info flat"><ul><li>如果想要查看垃圾回收的信息，可以使用<code>-verbose:gc</code></li></ul></div><h2 id="判断堆上的对象是否被引用-两种方法">判断堆上的对象是否被引用(两种方法)</h2><ol><li><strong>引用计数法</strong>：每个对象维护一个计数器，初始值为0，对象被引用就加1，取消引用就减1<ul><li>缺点:</li></ul><blockquote><p>引用和取消引用需要维护计数器，对性能有一定影响<br>循环引用，比如A引用B，B引用A，就会导致对象无法回收(上面的例子如果用引用计数法，就无法回收了)</p></blockquote></li><li>可达性分析法(<code>Java</code>使用，性能更高，解决了循环引用的问题)<ul><li>可达性分析算法将对象分为两类: 垃圾回收的根对象(<code>GC Root</code>)；普通对象，对象与对象之间存在引用关系</li><li><code>GC Root</code>对象一般不可以被回收，<code>JVM</code>也会维护一个<code>GC Root</code>对象列表</li><li>每次从某个<code>GC Root</code>遍历引用链，如果某个普通对象可以从<code>GC Root</code>到达，说明不可被回收<br><img src="https://gitee.com/sang3112/blog_imgs/raw/6d55251373589f7b63584fece6808ec3cbcdad27/Java/achieve.png" alt="achieve"></li></ul></li></ol><div class="note info flat"><p>什么样的对象可以作为<code>GC Root</code>对象</p><ol><li>线程<code>Thread</code>对象，引用线程栈帧中的方法参数、局部变量等</li><li>系统类加载器加载的<code>java.lang.Class</code>对象，引用类中的静态变量 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceCounting</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">A</span> <span class="variable">a2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// sun.misc.Launcher是一个GC Root对象，可以找到应用程序类加载器，以及扩展类加载器。</span></span><br><span class="line"><span class="comment">// 自定义的ReferenceCounting是由应用程序类加载器加载的，所以可以由GC Root找到</span></span><br><span class="line"><span class="comment">// a2 引用了A，所以GC Root可以找到a2，所以不会回收</span></span><br></pre></td></tr></table></figure></li><li>监视器对象，用来保存同步锁<code>synchronized</code>关键字持有的对象<br><code>synchronized(Reference.class)</code> 只要这个关系建立起来，监视器对象就可以找到<code>ReferenceCounting</code>，就无法回收</li><li>本地方法调用时使用的全局对象(不需要程序员过多关注)</li></ol></div><ul><li>通过<code>Arthas</code>以及<code>eclise MAT(Memory Analyzer)</code>工具可以查看<code>GC Root</code></li><li><code>Arthas</code>使用<code>heapdump &lt;dir/文件名.hprof&gt;</code>命令将堆内存快照保存到本地磁盘中</li><li>使用<code>MAT</code>工具打开堆内存的快照文件</li><li>使用<code>GC Roots</code>功能查看所有的<code>GC Root</code></li></ul><h3 id="对象引用-五种">对象引用(五种)</h3><blockquote><p>强引用，软引用，弱引用，虚引用，终结器引用</p></blockquote><ol><li><p>强引用</p><blockquote><p>可达性算法中的对象引用一般指强引用，就是<code>GC Root</code>对象对普通对象有引用关系，那么普通对象就不会被回收</p></blockquote></li><li><p>软引用</p><blockquote><p>如果一个对象只有软引用关联到它，如果程序内存不足，则会将软引用进行回收<br><code>JDK1.2</code>提供<code>SoftReference</code>实现软引用，经常用于缓存中<br>因此使用软引用应该创建两个对象，一个是<code>SoftReference</code>对象，引用真正使用的对象，而<code>SoftReference</code>本身应该被<code>Gc Root</code>引用，保证可以找到</p></blockquote> <div class="note info flat"><p>软引用的执行过程</p><ol><li>对象使用软引用包装起来，<code>new SoftReference&lt;对象类型&gt;(对象);</code></li><li>内存不足时，<code>JVM</code>进行垃圾回收</li><li>垃圾回收仍然不能解决内存不足的问题，回收软引用中的对象</li><li>如果依然内存不足，会抛出<code>OutOfMemory</code>异常</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">100</span>];</span><br><span class="line">SoftReference&lt;<span class="type">byte</span>[]&gt; softReference = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;<span class="type">byte</span>[]&gt;(bytes);</span><br><span class="line"><span class="comment">// 这段代码将100M的数据放在软引用中</span></span><br></pre></td></tr></table></figure><ul><li><code>Java</code>中的<code>Caffeine</code>可以在创建缓存的过程中将缓存对象设置成<code>softValues()</code>也就是软引用</li></ul></div> <div class="note info flat"><ul><li>软引用中的对象如果内存不足会被回收，<code>SoftReference</code>对象本身也需要被回收，但是<code>SoftReference</code>一旦被回收了，就无法知道其引用的对象是否真的被回收了，所以<code>SoftReference</code>提供了一套<strong>队列机制</strong>来进行判断:<ol><li>软引用创建时，通过构造器传入引用队列(程序员自定义)</li><li>软引用中包含对象被回收时，该软引用对象会被放入引用队列</li><li>通过代码遍历引用队列，将<code>SoftReference</code>的强引用删除</li></ol></li></ul></div><ul><li>软引用可以继承<code>SoftReference</code>类的方式来实现，<code>SoftReference</code>类就是一个软引用对象，通过构造器传入软引用包含的对象，以及引用队列</li><li>使用软引用实现学生数据的缓存，软引用如果被回收了，则要清理<code>HashMap</code>中的<code>key</code><br><img src="https://gitee.com/sang3112/blog_imgs/raw/6d55251373589f7b63584fece6808ec3cbcdad27/Java/stucac.png" alt="stucache"></li></ul> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentCache</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">StudentCache</span> <span class="variable">cache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StudentCache</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; ; ++ i)&#123;</span><br><span class="line">            StudentCache.getInstance().cacheStudent(<span class="keyword">new</span> <span class="title class_">Student</span>(i, String.valueOf(i)))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, StudentRef&gt; StudentRefs; <span class="comment">// 用于Cache内容的存储</span></span><br><span class="line">    <span class="keyword">private</span> ReferenceQueue&lt;Student&gt; q; <span class="comment">// 垃圾Reference队列</span></span><br><span class="line">    <span class="comment">// 继承SoftReference，每个实例都具有一个可识别的标识</span></span><br><span class="line">    <span class="comment">// 并且标识与在HashMap中的key相同</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">StudentRef</span> <span class="keyword">extends</span> <span class="title class_">SoftReference</span>&lt;Student&gt;&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">_key</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">StudentRef</span><span class="params">(Student em, ReferenceQueue&lt;Student&gt; q)</span>&#123;</span><br><span class="line">            <span class="built_in">super</span>(em, q); <span class="comment">// 调用父类的构造方法</span></span><br><span class="line">            _key = em.getId();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造一个缓存器实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">StudentCache</span><span class="params">()</span>&#123;</span><br><span class="line">        StudentRefs = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, StudentRef&gt;();</span><br><span class="line">        q = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;Student&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取得缓存器实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StudentCache <span class="title function_">getInstance</span><span class="params">()</span> &#123;<span class="keyword">return</span> cache;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以软引用的方式对一个Student对象的实例进行引用并保存该引用(放入缓存)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">cacheStudent</span><span class="params">(Student em)</span>&#123;</span><br><span class="line">        cleanCache(); <span class="comment">// 清除垃圾引用</span></span><br><span class="line">        <span class="type">StudentRef</span> <span class="variable">ref</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StudentRef</span>(em, q);</span><br><span class="line">        StudentRefs.put(em.getId(), ref);</span><br><span class="line">        System.out.println(StudentRefs.size());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 依据指定的ID，重新获取相应的Student对象的实例</span></span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">getStudent</span><span class="params">(Integer id)</span>&#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">em</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 缓存中是否有该Student实例的软引用，如果有就从软引用中获得</span></span><br><span class="line">        <span class="keyword">if</span> (StudentRefs.containsKey(id))&#123;</span><br><span class="line">            <span class="type">StudentRef</span> <span class="variable">ref</span> <span class="operator">=</span> StudentRefs.get(id);</span><br><span class="line">            em = ref.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有这个软引用，或者这个软引用得到的实例为空，则重新构建一个实例，保存对这个实例的软引用</span></span><br><span class="line">        <span class="keyword">if</span> (em == <span class="literal">null</span>)&#123;</span><br><span class="line">            em = <span class="keyword">new</span> <span class="title class_">Student</span>(id, String.valueOf(id));</span><br><span class="line">            System.out.println(<span class="string">&quot;Retrieve From StudentInfoCenter. ID = &quot;</span> + id);</span><br><span class="line">            <span class="built_in">this</span>.cacheStudent(em);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> em;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除那些软引用的所有Student对象已经被回收的StudentRef对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">cleanCache</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">StudenRef</span> <span class="variable">ref</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>((ref = (StudentRef)q.poll() != <span class="literal">null</span>))&#123;</span><br><span class="line">            StudentRefs.remove(ref._key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> id, String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;<span class="keyword">return</span> id;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;<span class="built_in">this</span>.id = id;&#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;<span class="keyword">return</span> name;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;<span class="built_in">this</span>.name = name;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>弱引用</p><blockquote><p>关联的对象在垃圾回收时，不管内存够不够，都会被直接回收<br><code>JDK1.2</code>版本之后提供了<code>WeakReference</code>类来实现弱引用，主要用在<code>ThreadLoacl</code>中，弱引用本身也可以使用引用队列回收<br>除了<code>ThreadLocal</code>以外，基本上不会使用这个，<code>Caffeine</code>中也有弱引用的实现，但是一般不用</p></blockquote></li><li><p>虚引用(幽灵引用，幻影引用)</p><blockquote><p>在常规开发中<strong>不会</strong>使用<br>不能通过虚引用对象获取包含的对象，唯一的用途是当对象被垃圾回收器回收时可以接收到对应的通知<br>使用<code>PhantomReference</code>实现了虚引用<br>直接内存为了及时知道直接内存中的对象不再使用，从而回收内存，就会用虚引用实现<code>Cleaner</code>类(解决了直接内存中内存的释放问题)</p></blockquote></li><li><p>终结器引用</p><blockquote><p>在常规开发中不会使用<br>对象需要被回收的时候，终结器引用会关联对象并且放在<code>Finalizer</code>类中的引用队列，由一条<code>FinalizerThread</code>线程从队列中获取对象，然后执行对象的<code>finalize</code>方法(这个方法实际上重写了<code>Object</code>中的方法，作用是回收对象时做一些收尾的工作)，在对象第二次被回收时，该对象才会被真正的回收。这个过程中<code>finalize</code>方法再将自身对象使用强引用关联上，但是不建议这么做，因为这个<code>finalize</code>方法什么时候调用，甚至可能不调用，都是<code>GC</code>决定的，不是程序员决定的。(不管是实现自救，也就是用强引用关联；还是实现清理工作都是不合适的，所以基本不会用)</p></blockquote></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;垃圾回收器&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;主要负责在&lt;strong&gt;堆&lt;/strong&gt;上进行内存回收&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;自动垃圾回收可以降低实现难度，降低回收bug的可能性&lt;/li&gt;
&lt;li&gt;但是程序员无法控制内存回收的及</summary>
      
    
    
    
    <category term="Java" scheme="https://sangs3112.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://sangs3112.github.io/tags/Java/"/>
    
    <category term="方法区 堆的垃圾回收" scheme="https://sangs3112.github.io/tags/%E6%96%B9%E6%B3%95%E5%8C%BA-%E5%A0%86%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
    <category term="五种引用关系" scheme="https://sangs3112.github.io/tags/%E4%BA%94%E7%A7%8D%E5%BC%95%E7%94%A8%E5%85%B3%E7%B3%BB/"/>
    
  </entry>
  
  <entry>
    <title>Java笔记_2</title>
    <link href="https://sangs3112.github.io/posts/8ac77d2a.html"/>
    <id>https://sangs3112.github.io/posts/8ac77d2a.html</id>
    <published>2024-04-20T06:37:35.000Z</published>
    <updated>2024-07-23T17:18:51.906Z</updated>
    
    <content type="html"><![CDATA[<h1>运行时数据区</h1><h2 id="分类">分类</h2><ol><li>线程不共享：程序计数器、<code>Java</code>虚拟机栈、本地方法栈</li><li>线程共享：方法区、堆区</li></ol><h2 id="程序计数器">程序计数器</h2><blockquote><p><code>Program Counter Register</code>，也叫做<code>PC</code>寄存器，每个线程会通过程序计数器记录当前<strong>要执行</strong>的字节码指令的地址</p></blockquote><h3 id="作用">作用</h3><ol><li>控制程序指令的执行，比如跳转，分支，异常</li><li>多线程情况下<code>JVM</code>通过程序计数器记录CPU切换前执行到哪一句，切换回来后执行并继续解释运行</li></ol><div class="note info flat"><p>程序计数器会产生内存溢出的问题吗</p><ul><li>内存溢出指在使用某一块内存区域时，存放的数据需要占用的内存大小超过了虚拟机能够提供的内存上限</li><li>每个线程只存储一个固定长度的内存地址，<code>PC</code>不会产生内存溢出</li><li><code>PC</code>不用程序员修改</li></ul></div><h2 id="Java虚拟机栈"><code>Java</code>虚拟机栈</h2><blockquote><p>先进后出(<code>FILO</code>)，每个方法调用一个栈帧来保存</p></blockquote><ul><li><code>Java</code>虚拟机栈随着线程的创建而创建，线程销毁则栈回收，由于方法可能会在不同的线程中执行，所以每个线程都有自己的虚拟机栈</li></ul><h3 id="栈帧组成">栈帧组成</h3><blockquote><p>局部变量表，操作数栈，帧数据</p></blockquote><ol><li>局部变量表：方法执行过程中存放所有的局部变量，与字节码局部变量表不太一样</li></ol><blockquote><p>栈帧中的局部变量表是一个数组，每一个位置成为槽<code>slot</code>，<code>long, double</code>占用两个槽，其他类型占用一个槽<br>实例方法中的序号为<code>0</code>的位置存放的是<code>this</code>，指的是当前调用方法的对象，运行时会在内存中存放实例对象的地址<br>方法参数也会保存在局部变量表中，顺序与参数定义顺序一致<br>所以局部变量表保存了实例方法的<code>this</code>对象，方法的参数，方法体中声明的局部变量。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> m)</span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 占用了6个槽，为了节省空间，槽是可以复用的，一旦某个局部变量不再生效，则当前的槽可以再次使用</span></span><br><span class="line"><span class="comment">// ab在代码块中，代码块结束以后，ab就释放了</span></span><br></pre></td></tr></table></figure><ol start="2"><li>操作数栈：存放中间数据的一块区域，如果一条指令将一个值压入操作数栈，则后面的指令可以弹出并使用该值</li></ol><blockquote><p><strong>编译期</strong>就可以确定操作数栈的最大深度，从而在执行时正确分配内存大小</p></blockquote><ol start="3"><li>帧数据：包含动态链接，方法出口，异常表的引用</li></ol><blockquote><p>动态链接保存的是符号引用到运行时常量池中内存地址的映射关系(比如引用其他类)<br>方法出口：方法在正确或异常结束时，栈帧会被弹出，PC应该指向那个<strong>上一个栈帧中的下一条指令的地址</strong>，所以在当前栈帧中，需要存储此方法的出口的地址<br>异常表引用：存放代码中的异常处理信息，包含异常捕获的生效范围以及异常发生以后跳转到的字节码指令位置</p></blockquote><div class="note info flat"><p>栈内存溢出</p><ul><li>如果栈帧过多，占用内存超过栈内存可以分配的最大大小以后就会出现内存溢出</li><li>会报<code>StackOverflowError</code>错误</li><li>比如递归的时候没有设置递归出口，则会内存溢出</li></ul><p>设置栈内存</p><ul><li>通过参数<code>-Xss&lt;值&gt;</code>设置虚拟机栈大小，单位是[字节，必须是1024的倍数，默认] [k或者K] [m或者M] [g或者G]</li><li>也可以用<code>-XX:ThreadStackSize=&lt;大小&gt;</code>，但是比较复杂</li><li><code>HotSpot JVM</code>对栈的大小的最大值和最小值有要求，超过范围会自动调整</li><li>局部变量过多，操作数栈深度过大也会影响栈内存大小</li><li>可以手动指定<code>-Xss256k</code>节省内存</li></ul></div><h2 id="本地方法栈">本地方法栈</h2><blockquote><p><code>Java</code>虚拟机栈存储了<code>Java</code>方法调用时的栈帧，本地方法栈存储的是本地方法的栈帧，用<code>cpp</code>编写的</p></blockquote><ul><li>在<code>Hotspot</code>虚拟机中，<code>Java</code>虚拟机栈和本地方法栈实现上用了同一个栈空间，本地方法栈会在栈内存上生成一个栈帧，临时保存方法参数的同时,方便出现异常时也把本地方法的栈信息打印出来</li></ul><h2 id="堆">堆</h2><blockquote><p>堆内存是最大的内存区域，<strong>创建出来的对象都在堆上</strong><br>栈上的局部变量表中可以存放堆上对象的引用，静态变量也可以存放堆对象的引用，通过静态变量可以实现对象在线程之间共享</p></blockquote><div class="note info flat"><p>堆内存溢出</p><ul><li>堆内存大小有上限，如果一直向堆中放入对象达到上限后，就会抛出<code>OutOfMemory</code>错误</li><li>有三个需要关注的值: <code>used, total, max</code>，在<code>Arthas</code>中可以使用<code>dashbord -i </code> 或者 <code>memory</code>命令查看<ul><li><code>used</code>：当前已经使用的堆内存</li><li><code>total</code>：<code>Java</code>虚拟机已经分配的可用堆内存</li><li><code>max</code>：是可以分配的最大堆内存</li><li><code>total</code>内存不足的时候，<code>Java</code>会扩大<code>total</code>，直到达到<code>max</code>为止</li></ul><blockquote><p>但是，<strong>不是</strong>在<code>total = used = max</code>的时候堆内存溢出，这是因为有垃圾回收器存在的原因</p></blockquote><ul><li>默认情况下，<code>max</code>默认是系统内存的<code>1/4</code>，<code>total</code>默认是系统内存的<code>1/64</code>，实际应用中需要单独设置</li><li><code>-Xmx值 -Xms值</code>，分别表示<code>max</code>和<code>total</code>的大小，<code>max</code>必须大于<code>2MB</code>，<code>total</code>必须大于<code>1MB</code></li><li>但是实际上<code>Arthas</code>堆内存显示的比实际上分配的要小一点，这是因为使用了<code>JMX</code>技术，与垃圾回收器有关，计算的是可以<strong>分配对象的内存，而不是整个内存</strong></li><li>一般设置的时候，将<code>total</code>设置成<code>max</code>相同的大小，减少申请内存和压缩内存的开销。</li></ul></li></ul></div><h2 id="方法区">方法区</h2><blockquote><p>存放基础信息的位置(类的元信息，运行时常量池，字符串常量池)，线程共享，是一个虚拟概念</p></blockquote><ul><li>用来存放每个类的基本信息(元信息)，一般称为<code>InstanceKlass</code>对象，在类的加载阶段完成</li><li>还用来存放了字节码中的运行时常量池，通过<strong>编号查表</strong>的方式找到常量，称为<strong>静态常量池</strong>。常量池<strong>加载</strong>到内存中之后，可以通过内地址快读定位到常量池中的内容，就是<strong>运行时常量池</strong>。</li></ul><h3 id="JDK7以及之前"><code>JDK7</code>以及之前</h3><ul><li>方法区存放在<strong>堆的永久代空间</strong>，堆的大小由虚拟机参数控制</li><li>在<code>Arthas</code>中可以看见<code>ps_perm_gen</code>就是永久代，因为在堆上，所以设置了<code>max</code>，存储空间大小有限制</li></ul><h3 id="JDK8以及之后"><code>JDK8</code>以及之后</h3><ul><li>方法区存放在<strong>元空间</strong>中，位于<strong>操作系统内存</strong>中，独立于<code>JVM</code>内存之外，默认情况下只要不超过操作系统上限，可以一直分配</li><li>在<code>Arthas</code>中可以看见<code>metaspace</code>，就是元空间，<code>max=-1</code>，表示没有上限，只要不超过操作系统的上限即可。</li></ul><div class="note info flat"><p>方法区溢出</p><ul><li><code>JDK7</code>在堆上，十几万个类会出现错误。<code>JDK8</code>运行上百万次，不会出现错误。</li><li><code>JDK7</code>方法区存储在堆区中的永久代空间，可以设置<code>-XX:MaxPermSize=值</code>来控制</li><li><code>JDK8</code>方法区位于元空间中，默认不超过操作系统上限即可，同样可以使用<code>-XX:MaxMetaspaceSize=值</code>设置元空间大小<ul><li>启动程序的时候最好设置元空间的最大大小，没有特殊情况设置成<code>256M</code>，以免占用其他程序的内存，能够容纳三十多万个类的加载</li></ul></li></ul></div><h3 id="字符串常量池">字符串常量池</h3><blockquote><p>存储代码中定义的常量字符串内容，比如<code>&quot;123&quot;</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译成字节码以后，&quot;abc&quot;会加入到静态常量池中</span></span><br><span class="line"><span class="comment">// s1通过new创建，所以&quot;abc&quot;放在堆内存中，由s1保存</span></span><br><span class="line"><span class="comment">// s2没有使用new，所以s2存放的是字符串常量池中的&quot;abc&quot;</span></span><br><span class="line"><span class="comment">// 所以最后打印s1 == s2两个地址不同，返回false</span></span><br></pre></td></tr></table></figure><div class="note info flat"><ul><li>早期的设计中，字符串常量池是运行时常量池的一部分，存储位置相同。后续将字符串常量池和运行时常量池进行拆分</li><li><code>JDK7</code>之前，运行时常量池包含字符串常量池，都在永久代中</li><li><code>JDK7</code>版本的时候，字符串常量池从方法区拿到了堆中，运行时常量池剩下的东西还在永久代中</li><li><code>JDK8</code>之后，没有永久代了，所以运行时常量池在元空间中，而字符串常量池仍然在堆中</li></ul></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;2&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;12&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> a + b;</span><br><span class="line">    System.out.println(c == d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译成字节码以后，字符串常量池中会有&quot;1&quot;, &quot;2&quot;, &quot;12&quot;</span></span><br><span class="line"><span class="comment">// c指向的是字符串常量池中的&quot;12&quot;</span></span><br><span class="line"><span class="comment">// d 中的 + 变成了使用StringBuilder方法进行连接</span></span><br><span class="line"><span class="comment">// d指向的是堆内存中的&quot;12&quot;</span></span><br><span class="line"><span class="comment">// 所以是false</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;2&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;12&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span> + <span class="string">&quot;2&quot;</span>;</span><br><span class="line">    System.out.println(c == d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此时cd都是在字符串常量池中</span></span><br><span class="line"><span class="comment">// 所以返回true</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>().append(<span class="string">&quot;think&quot;</span>).append(<span class="string">&quot;123&quot;</span>).toString();</span><br><span class="line">    System.out.println(s1.intern() == s1);</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>().append(<span class="string">&quot;ja&quot;</span>).append(<span class="string">&quot;va&quot;</span>).toString();</span><br><span class="line">    System.out.println(s2.inter() == s2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// String.intern()是手动将字符串放在字符串常量池中</span></span><br><span class="line"><span class="comment">// 比如多次输入，每次Scanner.next().intern()，如果有两次输入相同的字符串，就可以减少存储的消耗，只需要往字符串常量池中存储一份字符串即可</span></span><br><span class="line"><span class="comment">// JDK6这个版本中，intern()会把第一次遇到的字符串实例复制到永久代字符串常量池中，返回的也是永久代字符串实例的引用。JVM启动时会把java加入到常量池中</span></span><br><span class="line">    <span class="comment">// 所以JDK6中，s1.intern()方法在字符串常量池中，s1在堆上，返回false</span></span><br><span class="line">    <span class="comment">// s2.intern()在字符串常量池中，s2在堆上，所以返回false</span></span><br><span class="line"><span class="comment">// JDK7之后的版本，由于字符串常量池在堆上，所以intern()方法会把第一次遇到的字符串引用放在字符串常量池中</span></span><br><span class="line">     <span class="comment">// s1.intern()返回的就是s1在堆上的引用，也就是地址，所以返回true</span></span><br><span class="line">     <span class="comment">// s2.intern()由于java已经在字符串常量池中有了，所以s2.intern()是字符串常量池中的地址，s2是堆中的地址，因此返回false</span></span><br></pre></td></tr></table></figure><div class="note info flat"><p>静态变量存储在哪里？</p><ul><li><code>JDK6</code>以及之前，静态变量存储在方法区中，也就是永久代中</li><li><code>JDK7</code>以及之后的版本中，静态变量存储在<code>Class</code>对象中，脱离了永久代。</li></ul></div><h2 id="直接内存">直接内存</h2><blockquote><p>不属于<code>Java</code>运行时的内存区域，在<code>JDK1.4</code>中引入了<code>NIO</code>机制，使用了直接内存，比如<code>Netty</code>网络框架</p></blockquote><ul><li><p>直接内存解决两个问题</p><ol><li><code>Java</code>堆中的对象如果不再使用要回收，回收时会影响对象的创建和使用</li><li><code>IO</code>操作比如读文件，需要先把文件读入直接内存(缓冲区)，然后再把数据复制到<code>Java</code>堆中</li></ol></li><li><p>现在直接放入直接内存即可，同时<code>Java</code>堆上维护直接内存的引用，减少了数据复制的开销，写文件也是同样的思路</p></li><li><p>所以现在不需要从直接内存上复制到堆中了，减少回收对象的影响，提升读写文件的效率</p></li><li><p>可以使用<code>ByteBuffer</code>在直接内存上创建数据，在<code>Arthas</code>中的<code>memory</code>可以查看<code>direct</code>部分的相关信息</p><ul><li><code>ByteBuffer directBuffer = ByteBuffer.allocateDirect(size);</code></li></ul></li></ul><div class="note info flat"><p>直接内存存在溢出现象</p><ul><li><code>-XX:MaxDirectMemorySize=值</code>修改直接内存的大小，如果不设置这个参数，则会自动选择最大分配的大小</li><li>如果底层使用了<code>NIO</code>，则需要设置这个参数；如果没有用到直接内存，也可以不设置这个参数</li><li>具体设置的大小需要进行压力测试以后，确定最大内存</li></ul></div><h2 id="总结">总结</h2><ol><li>运行时数据区分为了哪几个部分，每个部分的作用是什么</li></ol><ul><li>程序计数器，<code>Java</code>虚拟机栈，本地方法栈。线程不共享，每个线程有一块独立的区域<ul><li>程序计数器，记录当前要执行的字节码指令的地址，不会出现内存溢出的问题</li><li>Java虚拟机栈和本地方法栈。每个方法的调用会使用一个栈帧来保存数据，会内存溢出，一般因为递归没有出口</li></ul></li><li>方法区，堆。线程共享的<ul><li>堆中存放创建的对象，最容易内存溢出，与垃圾回收有关</li><li>方法区存放类的元信息，以及常量池，会出现内存溢出</li></ul></li></ul><ol start="2"><li>不同<code>JDK</code>版本之间运行时区域的区别是什么</li></ol><ul><li><code>JDK6</code>方法区放在堆里面，称为永久代，字符串常量池放在方法区中</li><li><code>JDK7</code>字符串常量池从方法区中独立，放在了堆上</li><li><code>JDK8</code>字符串常量池依然在堆里面，但是方法区称为元空间，从堆中独立</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;运行时数据区&lt;/h1&gt;
&lt;h2 id=&quot;分类&quot;&gt;分类&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;线程不共享：程序计数器、&lt;code&gt;Java&lt;/code&gt;虚拟机栈、本地方法栈&lt;/li&gt;
&lt;li&gt;线程共享：方法区、堆区&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;程序计数器&quot;&gt;程序计数器&lt;/h</summary>
      
    
    
    
    <category term="Java" scheme="https://sangs3112.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://sangs3112.github.io/tags/Java/"/>
    
    <category term="运行时数据区" scheme="https://sangs3112.github.io/tags/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Java笔记_1</title>
    <link href="https://sangs3112.github.io/posts/13ce2c90.html"/>
    <id>https://sangs3112.github.io/posts/13ce2c90.html</id>
    <published>2024-04-19T06:37:35.000Z</published>
    <updated>2024-07-23T17:18:51.906Z</updated>
    
    <content type="html"><![CDATA[<h1>类加载器</h1><ul><li>类加载器(<code>ClassLoader</code>)是<code>JVM</code>给应用程序实现类和接口字节码数据的技术</li><li>本地接口<code>JNI</code>允许<code>Java</code>调用其他语言编写的方法，在<code>hotspot</code>类加载器中，主要用于调用<code>JVM</code>中使用<code>CPP</code>编写的方法</li></ul><h2 id="应用">应用</h2><ol><li><code>SPI</code>机制</li><li>类的热部署</li><li><code>Tomcat</code>类的隔离</li><li>类的双亲委派机制(怎么打破双亲委派机制)</li><li>自定义类加载器</li><li>使用<code>Arthas</code>不停机解决线上故障</li></ol><h2 id="分类">分类</h2><ol><li><code>Java</code>代码中实现的 or <code>JDK</code>默认提供或者自定义的，所有实现的类加载器都需要继承抽象类<code>ClassLoader</code></li><li><code>JVM</code>底层源码实现的，跟虚拟机实现语言一致，比如<code>Hotspot</code>使用<code>cpp</code>实现。作用是加载运行时的基础类，保证运行中基础类可以被正确的加载，比如<code>java.lang.String</code>，确保可靠性</li></ol><h3 id="JDK8之前"><code>JDK8</code>之前</h3><ul><li><code>JVM</code>底层实现的类加载器，<strong>启动类加载器</strong><code>Bootstrap</code>，加载<code>Java</code>中<strong>最核心</strong>的类，在<code>jre/lib</code>目录下的所有类文件，比如<code>rt.jar, tools.jar, resources.jar</code></li></ul><div class="note info flat"><ul><li>如果打印看到类加载器为<code>null</code>，则就是启动类加载器。因为为了安全性考虑，不允许在代码中获得启动类加载器。</li><li>用户自己如果写了一些底层的<code>jar</code>包可以由启动类加载器加载，有两种方式<ol><li>放在<code>jre/lib</code>目录下(但是不推荐这么做)</li><li>使用<code>-Xbootclasspath/a:&lt;jar包目录&gt;/&lt;jar包名&gt;</code>进行扩展</li></ol></li></ul></div><ul><li><code>Java</code>代码中实现了<strong>扩展类加载器</strong><code>Extension</code>，允许扩展<code>Java</code>中比较通用的类；<strong>应用程序类加载器</strong><code>Application</code>，加载应用使用的类，比如由第三方<code>jar</code>包引入的类。<ul><li>源码都位于<code>sun.misc.Launcher</code>中，是一个静态内部类，继承自<code>URLClassLoader</code>，可以通过目录或指定<code>jar</code>包将字节码文件加载到内存中</li><li><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Java/extends.png" alt="extends"></li><li>扩展类加载器<code>Extension ClassLoader</code>默认加载<code>jre/lib/ext</code>下的类文件<ol><li>所以同样可以将自定义的<code>jar</code>包放在<code>jre/lib/ext</code>目录下(但是不推荐)</li><li>使用<code>-Djava.ext.dirs=&lt;jar包目录&gt;</code>进行扩展，会覆盖原始目录，<code>windows</code>上可以使用分号分隔，<code>macos</code>或者<code>linux</code>上使用冒号分隔，追加上原始目录</li></ol></li><li>应用程序类加载器<code>Application</code>加载<code>classpath</code>下的类文件，项目中的类或者是第三方依赖中的类</li></ul></li><li><code>Arthas</code>中使用<code>classloader</code>命令可以查看<ul><li><code>classloader -l</code>查看所有类加载器的哈希值</li><li><code>classloader -c &lt;hash&gt;</code>其中<code>&lt;hash&gt;</code>表示某一个类加载器的哈希值，就可以把所有加载的<code>jar</code>包都打印出来，</li><li>可以看到扩展类加载器加载的都是扩展类加载器的<code>jar</code>包，但是应用程序类加载器加载了不止<code>maven</code>第三方<code>jar</code>包，还加载了扩展类加载器，以及启动类加载器加载的<code>jar</code>包的内容，这是因为双亲委派机制</li></ul></li></ul><h1>双亲委派机制</h1><blockquote><p>解决了一个类到底由谁来加载的问题</p></blockquote><h2 id="作用">作用</h2><ol><li>保证类加载的安全性，避免恶意代码替换<code>JDK</code>的核心类库，确保核心类库的<strong>完整性</strong>和<strong>安全性</strong></li><li>避免重复加载</li></ol><h2 id="含义">含义</h2><ul><li>一个类加载器接收到加载类的任务时，会自底向上查找是否加载过，再自顶向下加载。自顶向下依次是启动类加载器，扩展类加载器，应用程序类加载器。<ul><li>先自底向上查找一个类是否被加载过<ul><li>如果已经加载过，则这个类的加载任务就结束了</li><li>如果没有加载过，则会自顶向下逐个加载</li></ul></li><li>双亲委派机制就是向上查找和向下加载的过程<ul><li>比如一个定义的类A，先由应用程序类加载器查找，没有加载过则再由扩展类加载器查找，没有加载过则再由启动类加载器进行查找，如果启动类加载器加载过了，则加载过程结束</li><li>比如一个类B，没有被三个类加载器加载，则由启动类加载器加载，查看加载路径，发现不在启动类加载器的加载路径中，则会由扩展类加载器尝试加载，判断路径</li></ul></li><li>所以向上查找的过程避免了重复加载，向下加载的过程起到了加载优先级的作用</li></ul></li></ul><div class="note info flat"><ol><li>如果一个类重复出现在三个类加载器的加载位置处，则由谁来加载？<ul><li>根据双亲委派机制，应该是由启动类加载器加载的，因为他的优先级是最高的</li></ul></li><li><code>String</code>类能否被覆盖，如果自定义了一个<code>java.lang.String</code>类，那么这个类是否会被加载<ul><li>启动类加载器在向上查找阶段已经会发现<code>rt.jar</code>包中的<code>String</code>类已经加载过了，所以不会加载自定义的<code>String</code>类，会返回已经加载过的<code>String</code>类</li></ul></li><li>如何使用代码主动加载一个类(两种方法)<ul><li>使用<code>Class.forName()</code>，使用当前类的类加载器去加载指定的类</li><li>通过<code>getClassLoader()</code>获取到类加载器，通过类加载器的<code>loadClass()</code>方法指定某个类加载器的加载，这种方式更加明确一些，比如:  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取main方法所在类的类加载器，应用程序类加载器</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> D.class.getClassLoader();</span><br><span class="line">System.out.println(cl);</span><br><span class="line"><span class="comment">// 使用应用程序类加载器加载指定的类</span></span><br><span class="line">Class&lt;?&gt; clazz = cl.loadClass(<span class="string">&quot;类名&quot;</span>);</span><br><span class="line">System.out.println(clazz.getClassLoader());</span><br></pre></td></tr></table></figure></li></ul></li></ol><ul><li>每一个类加载器都有一个父类加载器，在代码中都是<code>parent</code>，类型是<code>ClassLoader</code>，比如应用程序类加载器的<code>parent=扩展类加载器</code>，但是扩展类加载器的<code>parent=null</code>，这是因为启动类加载器是无法获得的，所以是<code>null</code><ul><li><code>Arthas</code>使用<code>classloader -t</code>查看父子关系</li></ul></li></ul><ol start="4"><li>如果一个类无法被三个类加载器加载呢？<ul><li>会报<strong>类无法找到</strong>的错误</li></ul></li></ol></div><h2 id="总结-类的双亲委派机制是什么">总结-类的双亲委派机制是什么</h2><ol><li>类加载器加载某个类的时候，会自底向上向父类查找是否加载过，如果加载过就直接返回，如果一直到最顶层的类加载器都没有加载，再由自顶向下进行加载</li><li>应用程序类加载器的父类加载器是扩展类加载器，扩展类加载器的父类加载器是启动类加载器</li><li>双亲委派机制的好处有两点:<ul><li>避免恶意代码替换<code>JDK</code>中核心类库，比如<code>java.lang.String</code>，确保安全性，完整性</li><li>避免重复加载类</li></ul></li></ol><h2 id="打破双亲委派机制">打破双亲委派机制</h2><ol><li>自定义类加载器</li><li>线程上下文类加载器</li><li><code>Osgi</code>框架的类加载器</li></ol><h3 id="场景">场景</h3><ul><li>有两个<code>Web</code>应用，都具有一个名为<code>MyServlet</code>的类，只有名字相同，内容不同。<code>Tomcat</code>想去加载这两个类，这两个类都位于<code>classpath</code>上，应用1的类可以正常加载，但是应用2的类，<code>Tomcat</code>无法加载，因为这个时候<code>MyServlet</code>类已经存在了。这样只能加载一个类</li><li>实际上<code>Tomcat</code>对每个应用都有一个类加载器，这样就不会走双亲委派机制。应用1和应用2都加载自己的类，因此实现了使用自定义类加载器打破双亲委派机制，实现应用类的隔离</li></ul><h3 id="自定义类加载器">自定义类加载器</h3><ul><li><code>ClassLoader</code>中包含了四个核心方法，双亲委派机制的核心代码在<code>loadClass</code>方法中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) </span><br><span class="line"><span class="comment">// 类加载的入口，提供了双亲委派机制，内部会调用findClass</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) </span><br><span class="line"><span class="comment">// 抽象类，加载字节码二进制信息的核心方法，由类加载器子类实现，获取二进制数据调用defineClass</span></span><br><span class="line"><span class="comment">// 比如URLClassLoader会根据文件路径获取类文件中的二进制数据</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass (String name, <span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len) </span><br><span class="line"><span class="comment">// 调用了虚拟机底层的方法，做一些类名的校验，将字节码信息加载到虚拟机内存当中</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">resolveClass</span><span class="params">(Class&lt;?&gt; c)</span> </span><br><span class="line"><span class="comment">// 执行类生命周期的连接阶段</span></span><br></pre></td></tr></table></figure><ul><li>双亲委派机制</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parent == null 说明父类加载器是启动类加载器，直接调用findBootstrapClassOrNull</span></span><br><span class="line"><span class="comment">// 否则调用父类加载器的加载方法</span></span><br><span class="line"><span class="keyword">if</span> (parent != <span class="literal">null</span>)&#123;</span><br><span class="line">    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    c = findBootstrapClassOrNull(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父类加载器不行的话，就自己加载</span></span><br><span class="line"><span class="keyword">if</span> (c == <span class="literal">null</span>) c = findClass(name);</span><br></pre></td></tr></table></figure><ul><li>自定义的类加载器，如果不手动指定父类加载器，则默认指向应用程序类加载器</li><li>两个自定义类加载器，加载相同的限定名的类，是否会冲突？<ul><li>不会冲突，只有<strong>相同的类加载器+相同的类限定名</strong>才会被认为是同一个类，在<code>Arthas</code>中使用<code>sc -d 类名</code>可以查看具体情况</li></ul></li><li>为了实现多种不同的渠道加载字节码的方式，不应该打破双亲委派机制，应该重写<code>findClass</code>方法</li></ul><h3 id="线程上下文类加载器">线程上下文类加载器</h3><blockquote><p>以<code>JDBC</code>为例，使用了<code>DriverManager</code>来管理项目中引入的不同数据库的驱动，比如<code>MySQL</code>驱动，或者<code>Oracle</code>驱动</p></blockquote><ul><li><code>DriverManager</code>类位于<code>rt.jar</code>中，所以由<strong>启动类加载器加载</strong></li><li>但是不同数据库的驱动是在用户的<code>jar</code>包中，由<strong>应用程序类加载器加载</strong>，因此违反了双亲委派机制</li><li>所以在初始化<code>DriverManager</code>时，通过<code>SPI</code>机制加载<code>jar</code>包中的<code>MySQL</code>驱动</li><li><code>SPI</code>利用了线程上下文类加载器(应用程序类加载器)加载类并创建对象<br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Java/spi.png" alt="spi"></li></ul><h2 id="DriverManager如何知道驱动类已经引入"><code>DriverManager</code>如何知道驱动类已经引入</h2><blockquote><p><code>SPI(Service Provider Interface)</code>机制，是<code>JDK</code>内置的服务提供发现机制，类似于<code>Spring</code>的依赖注入</p></blockquote><h3 id="SPI原理"><code>SPI</code>原理</h3><ol><li>在<code>ClassPath</code>路径下的<code>META-INF/services</code>目录中，以接口的全限定名来命名文件，对应的文件里面写了接口的实现</li><li>使用<code>ServiceLoader</code>类加载实现类,<code>ServiceLoader&lt;Driver&gt; lD = ServiceLoader.load(Driver.class);</code>获取<code>Driver</code>对象</li></ol><h3 id="SPI如何获取应用程序类加载器"><code>SPI</code>如何获取应用程序类加载器</h3><blockquote><p>使用了线程上下文中保存的类加载器进行类的加载，一般是应用程序类加载器</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; ServiceLoader&lt;S&gt; <span class="title function_">load</span><span class="params">(Class&lt;S&gt; service)</span>&#123;</span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();  </span><br><span class="line">    <span class="keyword">return</span> ServiceLoader.load(service, cl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li><p>在《深入理解Java虚拟机》一书中认为<code>JDBC</code>打破了双亲委派机制，因为由启动类加载器加载的类，委派应用程序类加载器去加载类的方式打破了双亲委派机制。</p></li><li><p>也有一种说法，认为<code>JDBC</code>没有打破双亲委派机制，因为单独的启动类加载器在<code>DriverManager</code>加载完了之后，通过<strong>初始化阶段</strong>触发了驱动类的加载，依然遵循的是双亲委派机制。因为驱动类加载器自底向上查找后，再自顶向下进行判断，发现启动类加载器和扩展类加载器都无法加载，所以由应用程序类加载器进行加载，这个过程也没有打破双亲委派机制。这两个类加载器都没有重写<code>loadClass</code>方法，打破双亲委派机制的唯一方法就是重写<code>loadClass</code>方法</p></li></ul></blockquote><h3 id="OSGI模块化"><code>OSGI</code>模块化</h3><blockquote><p><code>JDK9</code>之后有另一种模块化方法，因此不再使用了。<code>OSGI</code>也使用了类加载器实现了热部署的功能，即在服务不停止的情况下，动态更新字节码文件到内存中。现在可以使用<code>Arthas</code>实现热部署，本质上还是类加载器</p></blockquote><ul><li><code>Arthas</code>不停机解决线上问题</li></ul><ol><li>出问题服务器上部署一个<code>Arthas</code></li><li><code>jad --source-only &lt;类全限定名&gt; &gt; &lt;dir/文件名.java&gt;</code>： <code>jad</code>命令反编译，用其他编译器，比如<code>vim</code>来修改源代码</li><li><code>mc -c &lt;类加载器的hash&gt; &lt;dir/文件名.java&gt; -d &lt;输出目录&gt;</code>： <code>mc</code>命令用来编译修改过的代码<ul><li>这里的类加载器的<code>hash</code>可以使用<code>sc -d &lt;对应的类名&gt;</code>来查看</li></ul></li><li><code>retransform class</code>文件所在的&lt;目录/xxx.class&gt;：用<code>retransform</code>命令加载新的字节码</li></ol><div class="note info flat"><p>注意事项:</p><ol><li>如果程序重启，则字节码文件会恢复，因为只是通过<code>retransform</code>这个命令将字节码文件放在了内存中。因此要将字节码文件放在<code>jar</code>包中进行更新</li><li>使用<code>retransform</code>不能添加方法或者字段，也不能更新正在执行中的方法</li></ol></div><h1><code>JDK9</code>之后</h1><blockquote><p>引入了<code>module</code>概念</p></blockquote><ol><li>启动类加载器由<code>Java</code>编写了，不再由<code>CPP</code>编写，位于<code>jdk.internal.loader.ClassLoaders</code>类中。<ul><li><code>Java</code>中的<code>BootClassLoader</code>继承自<code>BuiltinClassLoader</code>实现从模块中找到要加载的字节码资源文件</li><li>但是启动类加载器依然无法通过<code>Java</code>代码获取，这是为了保证统一，所以返回的内容依然是<code>null</code></li><li><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Java/891.png" alt="891"></li></ul></li><li>扩展类加载器被替换成了平台类加载器(<code>Platform ClassLoader</code>)<ul><li>平台类加载器遵循模块化方式加载字节码文件，所以继承关系从<code>URLClassLoader</code>变成了<code>BuiltinClassLoader</code>，实现了从模块中加载字节码文件</li><li>平台类加载器的存在更多是为了与老版本兼容，自身没啥特殊的逻辑。如果使用了模块化的思想，平台类加载器基本上就不需要了</li><li><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Java/892.png" alt="892"></li></ul></li></ol><h1>总结</h1><ol><li>类加载器的作用<ul><li>类加载器(<code>CLassLoader</code>)负责在类加载的过程中的字节码获取并加载到内存，通过加载字节码数据放入内存转换成<code>byte[]</code>，接下来调用虚拟机底层方法将<code>byte[]</code>转换成方法区和堆中的数据</li></ul></li><li>有几种类加载器<ul><li>启动类加载器<code>Bootstrap</code> 加载核心类</li><li>扩展类加载器<code>Extension</code> 加载扩展类</li><li>应用程序类加载器<code>Application</code> 加载应用<code>classpath</code>中的类</li><li>自定义类加载器，重写<code>findClass</code>方法</li><li><code>JDK9</code>之后从扩展类加载器变成了平台类加载器<br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Java/cl.png" alt="cl"></li></ul></li><li>什么是双亲委派机制<ul><li>每个<code>Java</code>实现的类加载器中保存了一个成员变量叫做父 类加载器，自底向上查找是否加载过，再自顶向下加载，避免核心类被应用程序重写覆盖的问题，提升安全性</li></ul></li><li>如何打破双亲委派机制<ul><li>重写<code>loadClass</code>方法</li><li><code>JNDI, JDBC, JCE, JBI</code>等框架使用了<code>SPI</code> + 线程上下文类加载器</li><li><code>OSGI</code>实现了一整套类加载逻辑，允许同级类加载器之间互相调用</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;类加载器&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;类加载器(&lt;code&gt;ClassLoader&lt;/code&gt;)是&lt;code&gt;JVM&lt;/code&gt;给应用程序实现类和接口字节码数据的技术&lt;/li&gt;
&lt;li&gt;本地接口&lt;code&gt;JNI&lt;/code&gt;允许&lt;code&gt;Java&lt;/code&gt;调用</summary>
      
    
    
    
    <category term="Java" scheme="https://sangs3112.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://sangs3112.github.io/tags/Java/"/>
    
    <category term="类加载器" scheme="https://sangs3112.github.io/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    
    <category term="双亲委派机制" scheme="https://sangs3112.github.io/tags/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Java笔记_0</title>
    <link href="https://sangs3112.github.io/posts/64c91c06.html"/>
    <id>https://sangs3112.github.io/posts/64c91c06.html</id>
    <published>2024-04-18T06:37:35.000Z</published>
    <updated>2024-07-23T17:18:51.906Z</updated>
    
    <content type="html"><![CDATA[<h1>面向对象的特性</h1><h2 id="封装">封装</h2><h2 id="继承">继承</h2><ul><li>实现了<code>IS-A</code>的关系，子类可以获得父类<strong>非</strong><code>private</code>的属性和方法</li><li>应该要遵循里氏替换原则</li></ul><div class="note info flat"><ul><li>里氏替换原则：子类必须能够替换掉所有的父类对象，父类引用指向子类对象称为<strong>向上转型</strong></li></ul></div><h3 id="举例">举例</h3><ul><li><code>Cat</code>和<code>Animal</code>就是一种<code>IS-A</code>关系，所以<code>Cat</code>可以继承<code>Animal</code>，并且获得<code>Animal</code>的所有非<code>private</code>的属性和方法</li><li><code>Cat</code>可以当做<code>Animal</code>使用，所以<code>Animal</code>可以引用<code>Cat</code>对象：<code>Animal a = new Cat()</code>，这就是向上转型</li></ul><h2 id="多态">多态</h2><ul><li>分为编译时多态和运行时多态</li></ul><div class="note info flat"><ul><li>编译时多态：指方法的<strong>重载</strong></li><li>运行时多态：指对象引用的具体类型在运行期间才能确定<ul><li>运行时多态具有三个条件：继承、覆盖(重写)、向上转型</li></ul></li></ul></div><h1>JVM</h1><h2 id="功能">功能</h2><ol><li>解释运行：<code>javac</code>编译源代码，得到<code>class</code>字节码，<code>JVM</code>将其<strong>实时</strong>解释成机器码，让计算机执行，这是为了实现跨平台</li><li>内存管理：自动为对象方法分配内存，自动垃圾回收不再使用的对象</li><li>即时编译<code>JIT</code>：对热点代码进行优化，提升执行效率</li></ol><h2 id="组成">组成</h2><ol><li>类加载器</li><li>运行时数据区域(<code>JVM</code>管理的内存)</li><li>执行引擎(即编译器，解释器，垃圾回收等)</li><li>本地接口</li></ol><h1>字节码文件</h1><ul><li><code>jclasslib</code>可以打开字节码文件<code>.class</code></li><li><code>javap -v 路径名/类名.class &gt; 输出文件</code>命令同样可以反编译<code>.class</code>文件，并输出到指定文件中</li><li><code>jar -xvf</code>可以解压<code>jar</code>包</li><li><code>Arthas</code>可以使用<code>java -jar arthas-boot.jar</code>命令启动<ul><li><code>dashbord -i &lt;time (ms)&gt; -n &lt;num&gt;</code> 可以查看服务器各项指标，<code>-i</code>后面指定刷新的时间(<code>ms</code>)，<code>-n</code>后面指定刷新的次数</li><li><code>dump -d &lt;dir&gt; 包名.类名</code> 可以将指定类名的字节码文件导出到指定的<code>dir</code>中</li><li><code>jad 包名.类名</code> 可以将字节码反编译成源代码，然后可以确定代码是否可以满足要求。比如可以确定版本</li></ul></li></ul><h2 id="组成-2">组成</h2><ol><li><strong>基本信息</strong>：魔数，版本号，访问标识(<code>public final</code>)，父类和接口</li><li><strong>常量池</strong>：字符串常量，类或接口名、字段名，主要在字节码指令中使用</li><li><strong>字段</strong>：类或者接口声明的字段信息</li><li><strong>方法</strong>：类或者接口声明的方法信息</li><li><strong>属性</strong>：类的属性，比如源码的文件名，内部类的列表</li></ol><div class="note info flat"><ul><li>字节码文件，文件头是<code>0xCAFEBABE</code>，这个就是魔数</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>主版本号</mtext><mo>−</mo><mn>44</mn></mrow><annotation encoding="application/x-tex">主版本号 - 44</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord cjk_fallback">主版本号</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">44</span></span></span></span> 就是1.2版本之后的大版本计算方法，比如52是JDK8，主版本号为61则是JDK17</li><li>常量池作用：避免相同的内容重复定义，节省空间<ul><li>符号引用：字节码指令通过编号引用到常量池的过程</li></ul></li><li>方法：<ul><li><code>iconst_&lt;i&gt;</code> 就是将<code>i</code>放在操作数栈中</li><li><code>istore_&lt;i&gt;</code> 将操作数栈中的数字放到局部变量表的<code>i</code>号位置</li><li><code>iload_&lt;i&gt;</code> 将局部变量表中的数据<strong>复制</strong>一份放到操作数栈中</li><li><code>iadd</code> 将操作数栈顶的两个数字相加，只保留一个数据</li><li><code>iinc &lt;i&gt; by &lt;j&gt;</code> 将局部变量表中的<code>i</code>号位置的元素加<code>j</code>，直接在局部变量表上操作</li><li>局部变量数组表就是一个数组，存放所有的局部变量，并且位置<code>0</code>是<code>args</code>参数</li></ul></li></ul></div><h2 id="i-i-1-VS-i-VS-i-1-VS-i"><code>i = i + 1</code> VS <code>i ++</code> VS <code>i += 1</code> VS <code>++ i</code></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">iconst_0</span><br><span class="line">istore_1</span><br><span class="line">iconst_0</span><br><span class="line">istore_2</span><br><span class="line">iconst_0</span><br><span class="line">istore_3</span><br><span class="line">iconst_0</span><br><span class="line">istore 4</span><br><span class="line">iinc 1 by 1</span><br><span class="line">iinc 2 by 1</span><br><span class="line">iinc 3 by 1</span><br><span class="line">iload 4</span><br><span class="line">iconst_1</span><br><span class="line">iadd</span><br><span class="line">istore 4</span><br><span class="line">return</span><br></pre></td></tr></table></figure><ul><li>除了<code>i = i + 1</code>以外，都只需要一条指令<code>iinc 1 by 1</code>，即可完成自增操作</li><li><code>i = i + 1</code>需要四条指令才能完成，即<code>12~15</code></li></ul><h1>类的生命周期</h1><ol><li>加载</li><li>连接<ol><li>验证</li><li>准备</li><li>解析</li></ol></li><li>初始化</li><li>使用 (<code>new</code>)</li><li>卸载 (<code>GC</code>)</li></ol><h2 id="加载">加载</h2><ol><li><strong>类加载器</strong>根据<strong>类的全限定名</strong>通过不同的渠道以<strong>二进制流</strong>的方式获取字节码信息</li><li>类加载器加载完类以后，会将字节码信息保存到内存的<strong>方法区</strong>中</li><li>生成一个<code>InstanceKlass</code>对象，保存所有类的信息，包含特定功能比如多态的信息(虚方法表)</li><li>在<strong>堆区</strong>中生成一份与方法区数据类似的<code>java.lang.Class</code>对象，为了在Java代码中获取类的信息以及存储静态字段的数据(JDK8之后放在堆区)</li></ol><div class="note info flat"><p>为什么需要分别在<strong>方法区</strong>和<strong>堆区</strong>中同时保留两份代码？</p><ul><li>方法区中的<code>InstanceKlass</code>对象是用<code>cpp</code>编写的，<code>Java</code>不能直接操作，所以要在堆区放一个<code>Java</code>编写的<code>java.lang.Class</code></li><li>堆区的字段少于方法区的字段，因为方法区中有<strong>虚方法表</strong>，开发者不需要用，因此开辟了一块堆区，只包含了方法的内容，开发者只能访问堆区，提升安全性</li></ul></div><ul><li><code>JDK</code>自带<code>hsdb</code>工具可以查看<code>JVM</code>的内存信息，<code>hsdb</code>位于安装目录下的<code>lib/sa-jdi.jar</code>中</li><li><code>java -cp sa-jdi.jar sun.jvm.hotspot.HSDB</code>用于启动<code>hsdb</code>工具，启动后需要输入进程号，可以通过<code>jps</code>命令查找</li></ul><h2 id="连接">连接</h2><h3 id="验证">验证</h3><ol><li>验证内容是否满足<code>JVM</code>规范，比如文件头是否满足<code>CAFEBABE</code>，主次版本号是否满足要求</li><li>验证元信息，比如类必须要有父类，<code>super</code>不能为空</li><li>验证程序语义是否正确，不能跳转到不正确的位置</li><li>符号引用验证，比如是否访问了其他类中的<code>private</code>方法</li></ol><div class="note info flat"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查版本号是否满足要求</span></span><br><span class="line"><span class="comment">// 检查版本号的具体逻辑：</span></span><br><span class="line">    <span class="comment">// 主版本号不能高于运行环境主版本号;</span></span><br><span class="line">    <span class="comment">// 如果主版本号相同，那么副版本号也不能超过</span></span><br><span class="line"><span class="keyword">return</span> (major &gt;= JAVA_MIN_SUPPORTED_VERSION) </span><br><span class="line">    &amp;&amp; (major &lt;= max_version) </span><br><span class="line">    &amp;&amp; ((major != max_version) || (minor &lt;= JAVA_MAX_SUPPORTED_MINOR_VERSION));</span><br><span class="line"><span class="comment">// major 主版本号</span></span><br><span class="line"><span class="comment">// minor 副版本号</span></span><br><span class="line"><span class="comment">// JAVA_MIN_SUPPORTED_VERSION 支持的最低版本号，jdk8是45 表示jdk1.0</span></span><br><span class="line"><span class="comment">// max_version 支持的最高版本号，jdk8是52</span></span><br><span class="line"><span class="comment">// JAVA_MAX_SUPPORTED_MINOR_VERSION 支持的最高副版本号，jdk8未使用，为0</span></span><br></pre></td></tr></table></figure></div><h3 id="准备">准备</h3><ul><li>给<strong>静态变量</strong>分配内存和设置<strong>初始值</strong></li></ul><div class="note info flat"><ul><li>设置初始值是所有的变量都赋值为<code>0</code>，或者<code>null</code>，或者<code>'\u0000'</code></li><li>只有用<code>final</code>修饰的变量，会将其直接赋值为定义的值，因为<code>final</code>的值不会修改了</li></ul></div><h3 id="解析">解析</h3><ul><li>将符号引用替换为直接引用，<strong>就是使用地址替换编号</strong></li></ul><h2 id="初始化">初始化</h2><ul><li><code>public static int v = 1;</code>这句代码在<strong>连接准备</strong>阶段会将<code>v = 0</code>，然后在<strong>初始化</strong>阶段会<code>v = 1</code></li><li>初始化阶段就是执行<strong>静态代码块</strong>中的代码，为<strong>静态变量</strong>赋值，执行字节码文件中<code>clinit</code>部分的字节码指令</li><li><code>putstatic</code> 从操作数栈中获取值，设置<strong>静态变量</strong></li><li><code>clinit</code>方法执行顺序跟<code>Java</code>中的编写顺序一样</li><li>使用<code>-XX:+TraceClassLoading</code>参数可以打印出加载并初始化的类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">D</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        v = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这段代码最终的v=1，因为v是static变量，所以在连接准备阶段v=0</span></span><br><span class="line"><span class="comment">// 经过初始化阶段，v首先经过静态代码块，v=2</span></span><br><span class="line"><span class="comment">// 然后v经过静态设置，v=1</span></span><br></pre></td></tr></table></figure><div class="note info flat"><p><strong>触发</strong>初始化：</p><ol><li>访问一个类的<strong>静态变量</strong>或者<strong>静态方法</strong>，如果变量是<code>final</code>修饰的并且等号右边是<strong>常量</strong>，则不会触发初始化(在准备阶段就已经完成赋值了)</li><li>调用<code>Class.forName(String className)</code>，如果只传入类名，那么会<strong>默认</strong>进行初始化，也可以传入参数指定不初始化</li><li><code>new</code>一个类的对象</li><li>执行<code>main</code>方法的<strong>当前类</strong></li></ol></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Test1</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Test1</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;D&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出DACBCB </span></span><br><span class="line"><span class="comment">// main方法执行之前，首先会执行static静态代码块，因此输出D</span></span><br><span class="line"><span class="comment">// 然后执行main函数，输出A</span></span><br><span class="line"><span class="comment">// 接下来调用构造方法，但是字节码中构造代码块比构造函数先执行，所以输出CB</span></span><br><span class="line"><span class="comment">// 调用了两次构造方法，因此输出CBCB</span></span><br></pre></td></tr></table></figure><div class="note info flat"><p><strong>不触发</strong>初始化：</p><ol><li><strong>没有</strong>静态代码块，并且<strong>没有</strong>静态变量赋值语句</li><li><strong>有</strong>静态变量声明，但是<strong>没有</strong>赋值语句</li><li>静态变量使用<code>final</code>关键字，等号右边是常量，会在<strong>准备阶段</strong>直接进行赋值，则不会有初始化</li></ol></div><ul><li>直接访问父类的静态变量，<strong>不会</strong>触发子类的初始化</li><li>子类的初始化<code>clinit</code>调用之前，会先调用父类的<code>clinit</code>初始化方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">B</span>(); <span class="comment">// 如果有这个new B()，则会初始化B，就会优先初始化父类，</span></span><br><span class="line">        <span class="comment">// 如果没有new B()，则直接调访问父类的静态变量。</span></span><br><span class="line">        System.out.println(B.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        a = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果有new B(), 输出2</span></span><br><span class="line"><span class="comment">// 如果没有new B(), 输出0</span></span><br></pre></td></tr></table></figure><div class="note info flat"><ul><li>访问父类的静态变量不需要初始化子类，初始化子类之前一定会初始化父类</li></ul></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        A[] arr = <span class="keyword">new</span> <span class="title class_">A</span>[<span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AAA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出空</span></span><br><span class="line"><span class="comment">// 数组的创建不会导致数组元素中的类初始化</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(A.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Integer.valueOf(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AAA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AAA 1</span></span><br><span class="line"><span class="comment">// final修饰的变量，如果等号右边需要执行指令才能得出结果，则会执行clinit初始化</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;面向对象的特性&lt;/h1&gt;
&lt;h2 id=&quot;封装&quot;&gt;封装&lt;/h2&gt;
&lt;h2 id=&quot;继承&quot;&gt;继承&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;实现了&lt;code&gt;IS-A&lt;/code&gt;的关系，子类可以获得父类&lt;strong&gt;非&lt;/strong&gt;&lt;code&gt;private&lt;/code&gt;的属性和</summary>
      
    
    
    
    <category term="Java" scheme="https://sangs3112.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://sangs3112.github.io/tags/Java/"/>
    
    <category term="面向对象的特性" scheme="https://sangs3112.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E6%80%A7/"/>
    
    <category term="JVM" scheme="https://sangs3112.github.io/tags/JVM/"/>
    
    <category term="类的生命周期" scheme="https://sangs3112.github.io/tags/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes笔记_0</title>
    <link href="https://sangs3112.github.io/posts/64a0ba43.html"/>
    <id>https://sangs3112.github.io/posts/64a0ba43.html</id>
    <published>2024-04-05T12:25:31.000Z</published>
    <updated>2024-07-23T17:18:51.906Z</updated>
    
    <content type="html"><![CDATA[<h1>架构</h1><p>一个<code>Kubernetes</code>集群至少包含一个控制平面，以及一个或多个工作节点</p><h2 id="控制平面">控制平面</h2><p><img src="https://gitee.com/sang3112/blog_imgs/raw/a76c53b22b402ccf7186b9efa53546500f90932e/Kubernetes/controlplane.png" alt="controlplane"></p><ul><li>负责管理工作节点和维护集群状态，所有任务的分配都来自控制平面</li><li>为集群做出去全局决策，比如资源的调度、检测和响应集群事件</li></ul><h3 id="kube-apiserver"><code>kube-apiserver</code></h3><ul><li>如果与<code>Kubernetes</code>集群进行交互，需要通过API</li><li><code>apiserver</code>是<code>Kubernetes</code>控制平面的前端，用于处理内部和外部请求</li></ul><h3 id="kube-scheduler"><code>kube-scheduler</code></h3><ul><li>集群状态是否良好，如果需要创建新的容器，需要将他们放在哪里，由调度程序关注</li><li><code>scheduler</code>调度程序考虑容器集的资源需求，比如<code>CPU</code>或者内存，以及集群的运行状态，然后将容器集安排到适当的计算节点</li></ul><h3 id="kube-controller-manager"><code>kube-controller-manager</code></h3><ul><li>控制器负责实际运行集群，<code>controller-manager</code>控制器管理器将多个控制器功能合并，降低了程序的复杂性</li></ul><div class="note info flat"><p><code>controller-manager</code>包含以下控制器:</p><ol><li>节点控制器(<code>Node Controller</code>): 负责在节点出现故障时进行通知和响应</li><li>任务控制器(<code>Job Controller</code>): 检测代表一次性任务的<code>Job</code>对象，然后创建<code>Pods</code>来运行这些任务直到完成</li><li>端点控制器(<code>Endpoints Controller</code>): 填充端点<code>Endpoints</code>对象，即加入<code>Service</code>和<code>Pod</code></li><li>服务账户和令牌控制器(<code>Service Account &amp; Token Controllers</code>): 为新的命名空间创建默认账户和<code>API</code>访问令牌</li></ol></div><h3 id="etcd"><code>etcd</code></h3><ul><li>键值对数据库，存储配置数据和集群状态信息</li></ul><h3 id="可选组件cloud-controller-manager">可选组件<code>cloud-controller-manager</code></h3><ul><li>云控制管理器，允许将集群了解到云提供商的<code>API</code>之上，将该云平台交互的组件与自己的集群交互组件分离开。如果在自己的环境中运行<code>Kubernetes</code>或者在本地计算机中运行学习环境，则所部署的集群不需要有云控制管理器</li></ul><h3 id="各组件之间的关系">各组件之间的关系</h3><p><img src="https://gitee.com/sang3112/blog_imgs/raw/a76c53b22b402ccf7186b9efa53546500f90932e/Kubernetes/relationship.png" alt="relationship"></p><h2 id="工作节点">工作节点</h2><ul><li>负责执行由控制平面分配的请求任务，运行实际的应用和工作负载</li></ul><h3 id="Node组件"><code>Node</code>组件</h3><p><img src="https://gitee.com/sang3112/blog_imgs/raw/a76c53b22b402ccf7186b9efa53546500f90932e/Kubernetes/node.png" alt="node"></p><ul><li>节点组件会在每个工作节点上运行，负责维护运行的<code>Pod</code>并提供<code>Kubernetes</code>运行环境</li></ul><h1><code>Pod</code></h1><ul><li><code>Pod</code>是包含一个或者多个容器的容器组，是<code>Kubernetes</code>中创建和管理的最小对象</li></ul><h2 id="特点">特点</h2><ol><li>是<code>Kubernetes</code>的最小调度单位(原子单元)，<code>Kubernetes</code>直接管理<code>Pod</code>而不是容器</li><li>同一个<code>Pod</code>中的容器总是会被自动安排到集群中的同一个节点(物理机或者虚拟机上)，并且<strong>一起调度</strong></li><li><code>Pod</code>可以理解为运行特定应用的<strong>逻辑主机</strong>，容器共享存储、网络和配置声明(比如资源限制)</li><li>每个<code>Pod</code>有唯一的<code>IP</code>地址，<code>IP</code>地址分配给<code>Pod</code>，在同一个<code>Pod</code>内，所有容器共享一个<code>IP</code>地址和端口空间，<code>Pod</code>内的容器可以使用<code>localhost</code>相互通信</li></ol><h2 id="创建和管理">创建和管理</h2><ol><li>创建<code>Pod</code>: <code>kubectl run &lt;Pod名称&gt; --imgae=&lt;容器镜像&gt;</code><ul><li>执行一次性任务，退出<code>Pod</code>时自动删除容器: <code>kubectl run &lt;Pod名称&gt; --image=&lt;容器镜像&gt; -it --rm</code></li></ul></li><li>查看容器状态: <code>kubectl get pod</code><ul><li>显示详细<code>Pod</code>信息: <code>kubectl get pod -owide</code></li></ul></li><li>查看<code>Pod</code>运行日志: <code>kubectl logs -f &lt;Pod名称&gt;</code></li><li>查看<code>Pod</code>的一些信息: <code>kubesctl describe pod &lt;Pod名称&gt;</code><ul><li>创建分为四个步骤<ol><li>分配节点 <code>Successfully assigned default/Pod名称 to k8s-worker2</code></li><li>拉取镜像 <code>Container image &quot;容器镜像&quot; already present on machine</code></li><li>创建容器 <code>Created container Pod名称</code></li><li>启动容器 <code>Started container Pod名称</code></li></ol></li></ul></li><li>进入<code>Pod</code>容器: <code>kubectl exec -it Pod名称 -- /bin/bash</code></li><li>删除容器: <code>kubectl delete pod Pod名称</code></li></ol><h1><code>Deployment</code>部署和<code>ReplicaSet</code>副本集</h1><ul><li><code>Deployment</code>是对<code>ReplicaSet</code>和<code>Pod</code>的更高级别的抽象，使<code>Pod</code>拥有多副本，自愈，扩缩容，滚动升级等能力</li><li><code>ReplicaSet</code>副本集是一个<code>Pod</code>的集合，设置运行<code>Pod</code>的数量，确保任何时间都有指定数量的<code>Pod</code>副本在运行。</li></ul><div class="note info flat"><ul><li>通常，我们不直接使用<code>ReplicaSet</code>，而是在<code>Deployment</code>中声明</li></ul></div><ul><li>创建<code>Deployment</code>: <code>kubectl create deployment &lt;部署名称&gt; --imgae=&lt;镜像名称&gt; --replicas=&lt;副本数量&gt;</code><ul><li><code>Deployment</code>通过副本集控制<code>Pod</code>的数量</li><li>如果手动删除一个<code>Pod</code>，副本集会自动生成一个新的<code>Pod</code>，维持副本数量不变。这就是自愈</li></ul></li><li>查看<code>Deployment</code>状态: <code>kubectl get deploy</code></li></ul><h2 id="缩放">缩放</h2><ul><li>查看副本集: <code>kubectl get replicaSet</code><ul><li>查看副本集缩放过程: <code>kubectl get replicaSet --watch</code></li></ul></li></ul><h3 id="手动缩放">手动缩放</h3><ul><li>手动修改<code>Deployment</code>中的副本集数量: <code>kubectl scale deploy &lt;部署名称&gt; --replicas=&lt;新的副本数量&gt;</code></li></ul><h3 id="自动缩放">自动缩放</h3><ul><li><code>kubectl autoscale deployment/&lt;部署名称&gt; --min=&lt;最小副本数&gt; --max=&lt;最大副本数&gt; --cpu-percent=75</code><ul><li><code>--cpu-percent=75</code>是使得自动缩放保持所有的<code>Pod</code>的平均cpu占用维持在75%以下</li></ul></li><li>查看自动缩放: <code>kubectl get hpa</code></li><li>删除自动缩放: <code>kubectl delete hpa &lt;部署名称&gt;</code></li></ul><h2 id="滚动更新">滚动更新</h2><ul><li>滚动更新部署版本: <code>kubectl set image deploy/部署名称 容器名=镜像版本</code></li><li>如果一个<code>Deployment</code>中有三个<code>Pod</code>，运行滚动更新命令时，会创建一个新的副本集。<ul><li>当新的副本集有一个<code>Pod</code>就绪了，就会下线旧副本集中的一个<code>Pod</code>，直到旧副本集中所有的<code>Pod</code>均下线</li></ul></li><li>版本回滚:<ul><li>查看历史版本: <code>kubectl rollout history deploy/部署名称</code></li><li>查看历史版本详情: <code>kubectl rollout history deploy/部署名称 --revision=版本号</code></li><li>回滚到指定的版本: <code>kubectl rollout  undo deploy/部署名称 --to-revision=版本号</code></li></ul></li></ul><h1>Service</h1><ul><li>将一组<code>Pods</code>上的应用程序公开为网路服务的抽象方法</li><li>将一组<code>Pod</code>提供相同的<code>DNS</code>名，并进行负载均衡</li><li><code>Kubernetes</code>为<code>Pod</code>提供分配了<code>IP</code>地址，但是<code>IP</code>地址可能发生变化，集群内的容器可以通过<code>service</code>名称访问服务，不需要担心<code>Pod</code>的<code>IP</code>发生变化</li></ul><div class="note info flat"><p><code>Service</code>定义的抽象:</p><ul><li>逻辑上一组可以互相替换的<code>Pod</code>，通常称为微服务</li><li><code>Service</code>对应的<code>Pod</code>集合通过选择符关联</li><li>在一个<code>Service</code>上运行了三个<code>Nginx</code>副本，副本之间可以相互替换，我们不需要关心它调用了哪一个<code>Nginx</code>，也不需要关注<code>Pod</code>的运行装填，只需要调用这个服务就可以了</li></ul></div><ul><li>将部署公开为服务: <code>kubectl expose deploy/部署名称 --name=服务名称 --port=服务端口 --target-port=对应pod端口</code></li></ul><h2 id="ServiceType"><code>ServiceType</code></h2><h3 id="ClusterIP-默认"><code>ClusterIP</code>(默认)</h3><ul><li>将服务公开在集群内部，<code>Kubernetes</code>会给服务分配一个集群内部的<code>IP</code>，集群内的所有主机都可以通过这个<code>Cluster-IP</code>访问服务。集群内部的<code>Pod</code>可以通过<code>Service</code>名称访问服务。</li></ul><h3 id="NodePort"><code>NodePort</code></h3><ul><li>通过每个节点的主机和静态端口(<code>NodePort</code>)暴露服务，集群外部的主机可以使用节点<code>IP</code>和<code>NodePort</code>访问服务</li></ul><h3 id="ExternalName"><code>ExternalName</code></h3><ul><li>将集群外部的网络引入集群内部</li></ul><h3 id="LoadBalancer"><code>LoadBalancer</code></h3><ul><li>使用云提供商的负载均衡器向外部暴露服务</li></ul><div class="note info flat"><p>使用<code>--type=NodePort</code>即可，本地集群不需要使用<code>LoadBalancer</code></p></div><p><img src="https://gitee.com/sang3112/blog_imgs/raw/a76c53b22b402ccf7186b9efa53546500f90932e/Kubernetes/port.png" alt="port"></p><h1>命名空间</h1><ul><li>一种资源隔离机制，将同一个集群中的资源划分为互相隔离的组。命名空间可以在多个用户之间划分集群资源(通过资源配额)</li><li>比如可以设置开发、测试、生产多个命名空间</li><li>同一个命名空间内资源名称唯一，跨命名空间时没有这个要求</li><li>命名空间作用域仅仅针对带有名字空间的对象，比如<code>Deployment、Service</code>等</li><li>作用域对集群访问对象不适用，比如<code>StorageClass、Node、PersistentVolume</code>等</li><li>查看命名空间: <code>kubectl get namespace</code><ul><li><code>Kubernetes</code>默认创建四个命名空间:</li><li><code>default</code>: 默认命名空间，不可删除，没有指定命名空间的对象都会分配到这里</li><li><code>kube-system</code>: 系统对象(控制平面和<code>Node</code>组件)使用的命名空间</li><li><code>kube-public</code>: 自动创建的公共命名空间，所有用户(包括没有身份验证的用户)都可以读取，将集群中公用的可见和可读的资源放在这个空间中</li><li><code>kube-node-lease</code>: 租约(<code>Lease</code>)对象使用的命名空间。每个节点都有一个关联的<code>Lease</code>对象，<code>Lease</code>是一种轻量级的资源，通过发送心跳，检测集群中的每个节点是否发生故障<ul><li>查看<code>lease</code>对象: <code>kubectl get lease -A</code></li></ul></li></ul></li><li>查看指定命名空间的<code>Pod</code>: <code>kubectl get pod -n=命名空间名称</code></li><li>创建命名空间: <code>kubectl create ns 命名空间名称</code></li><li>运行容器指定命名空间: <code>kubectl run pod名称 --image=镜像名称 -n=命名空间名称</code></li><li>修改默认命名空间的名称(<code>default</code>): <code>kubectl config set-context $(kubectl config current-context) --namespace=新的名称</code></li><li>删除命名空间: <code>kubectl delete ns 命名空间名称</code><ul><li>删除命名空间会删除其中所有内容，如果有些对象无法被删除(对象处于错误状态，或者对象资源被占用)，则命名空间也无法被删除。需要手动删除对象以后才能删除命名空间</li></ul></li></ul><h1>管理对象</h1><h2 id="命令行指令">命令行指令</h2><ul><li>使用<code>kubectl</code>创建和管理<code>Kubernetes</code>对象。简单高效，但是功能有限，不适合复杂场景，不容易追溯操作，用于开发和调试。</li></ul><h2 id="声明式配置">声明式配置</h2><ul><li><code>Kubernetes</code>使用<code>yaml</code>文件描述<code>Kubernetes</code>对象，学习难度大并且配置麻烦，但是操作留痕，适合操作复杂的对象，多用于生产。</li><li>使用命令行指令，无法指定<code>NodePort</code>端口，是随机生成的。但是<code>yaml</code>文件中可以指定<code>NodePort</code></li></ul><h2 id="常用命令缩写">常用命令缩写</h2><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">缩写</th><th style="text-align:center">Kind</th></tr></thead><tbody><tr><td style="text-align:center">namespace</td><td style="text-align:center">ns</td><td style="text-align:center">Namespace</td></tr><tr><td style="text-align:center">nodes</td><td style="text-align:center">no</td><td style="text-align:center">Node</td></tr><tr><td style="text-align:center">pods</td><td style="text-align:center">po</td><td style="text-align:center">Pod</td></tr><tr><td style="text-align:center">services</td><td style="text-align:center">svc</td><td style="text-align:center">Service</td></tr><tr><td style="text-align:center">deployment</td><td style="text-align:center">deploy</td><td style="text-align:center">Deployment</td></tr><tr><td style="text-align:center">replicasets</td><td style="text-align:center">rs</td><td style="text-align:center">ReplicaSet</td></tr><tr><td style="text-align:center">statefulsets</td><td style="text-align:center">sts</td><td style="text-align:center">StatefulSet</td></tr></tbody></table><h2 id="使用yaml文件配置KUbernetes对象">使用<code>yaml</code>文件配置<code>KUbernetes</code>对象</h2><ul><li><code>apiVersion</code>: <code>Kubernetes API</code>版本</li><li><code>kind</code>: 对象类别，比如<code>Pod、Deployment、Service、ReplicaSet</code>等</li><li><code>metadata</code>: 描述对象的元数据，包括一个<code>name</code>字符串，<code>UID</code>(系统自动生成)和可选的<code>namespace</code></li><li><code>spec</code>: 对象的配置</li></ul><div class="note info flat"><p><code>yaml</code>内容在官网都可以找到</p></div><ul><li>使<code>yaml</code>文件生效: <code>kubectl apply -f xxx.yaml</code></li><li>删除<code>yaml</code>文件: <code>kubectl delete -f xxx.yaml</code></li></ul><h2 id="标签">标签</h2><ul><li>附加在对象<code>Pod</code>上的键值对，用于补充对象的描述信息。标签使用户可以以松散的方式管理对象映射，不需要客户端存储这些映射。</li><li>格式<ul><li>键:<ul><li>前缀(可选) / 名称(必须)</li></ul></li><li>有效的名称和值:<ul><li>字符数量小于等于63</li><li>如果不为空，以字母和数字字符开头结尾</li><li>包含破折号-，下划线_，点和字母或者数字</li></ul></li></ul></li><li>查看所有<code>Pod</code>的标签: <code>kubectl get pod --show-labels</code><ul><li>查看指定<code>Pod</code>的标签: <code>kubectl get pod -l &quot;指定的Pod描述&quot;</code></li></ul></li></ul><h2 id="选择器">选择器</h2><ul><li>标签通常配合选择器使用，标签选择器可以识别一组对象，标签不支持唯一性</li><li>标签选择器最常见的用法是为<code>Service</code>选择一组<code>Pod</code>作为后端</li><li>标签选择运算，基于等值的和基于集合的<ul><li>多个条件使用逗号分割，相当于<code>AND</code></li><li>基于等值的直接使用键值对即可</li><li>基于集合的可以使用<code>IN, NOT IN</code></li></ul></li></ul><h1>容器运行时接口(<code>CRI</code>)</h1><ul><li><code>Kubelet</code>运行在每个节点上，用于管理和维护<code>Pod</code>和容器的状态</li><li>容器运行时接口是<code>Kubelet</code>和容器运行时之间通信的主要协议，将<code>Kubelet</code>于容器运行时解耦，实现了<code>CRI</code>接口的容器引擎，都可以所谓<code>Kubernetes</code>的容器运行时。</li><li><code>Docker</code>没有实现<code>CRI</code>接口，<code>Kubernetes</code>使用<code>dockershim</code>来兼容<code>docker</code></li><li><code>crictl</code>是一个兼容<code>CRI</code>的容器运行时命令，跟<code>docker</code>命令一个样，可以用来检查和调试底层的运行时容器<ul><li>比<code>docker</code>命令稍微少一些，比如无法实现导入导出</li><li>因此导入导出使用<code>ctr</code>命令，也只用来导入导出，因为<code>ctr</code>也不是很好用<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker pull alpine:3.15 </span><br><span class="line">docker save apline:3.15 &gt; alpine-3.15.tar # 保存成tar</span><br><span class="line">ctr -n k8s.io images import alpine-3.15.tar --platform linux/amd64 # 导入镜像</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">kubernetes 中所有的镜像都在k8s.io这个命名空间中</span></span><br><span class="line">ctr -n k8s.io images export alpine.tar docker.io/library/alpine:3.15 --platform linux/amd64 # 导出镜像</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1>金丝雀发布(<code>canary deployment</code>)</h1><ul><li>生产环境中小范围部署新的应用代码，一旦应用签署发布，只有少数用户被路由到他，最大限度降低影响。如果没有错误发生，则将新版本逐渐推广到整个基础设施</li><li>默认的金丝雀发布有一定的局限<ul><li>不能根据用户的注册时间、地区等请求中的内容属性进行流量分配</li><li>同一个用户如果多次调用该<code>Service</code>，可能第一次请求到了旧版本的<code>Pod</code>，第二次请求到了新版本的<code>Pod</code></li><li>因为<code>Kubernetes Service</code>只在<code>TCP</code>层面解决负载均衡问题，不对请求响应的消息内容做任何解析和识别，如果更完善的实现金丝雀日发布，可以考虑<code>Istio</code>灰度发布</li></ul></li></ul><h1>搭建<code>MySQL</code></h1><h2 id="创建mysql-pod-yaml">创建<code>mysql-pod.yaml</code></h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mysql-pod</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">mysql</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:5.7</span></span><br><span class="line">    <span class="attr">env:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_ROOT_PASSWORD</span></span><br><span class="line">        <span class="attr">value:</span> <span class="string">&quot;123456&quot;</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/var/lib/mysql</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">data-volume</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">data-volume</span></span><br><span class="line">      <span class="attr">hostPath:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/home/mysql/data</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">Directory</span></span><br></pre></td></tr></table></figure><h2 id="挂载数据卷">挂载数据卷</h2><ul><li><code>hostPath</code>卷: 将主机节点上的文件或目录挂在到<code>Pod</code>中</li></ul><table><thead><tr><th style="text-align:center">type</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">DirectoryOrCreate</td><td style="text-align:center">目录不存在则自动创建</td></tr><tr><td style="text-align:center">Directory</td><td style="text-align:center">挂载已经存在的目录，不存在会报错</td></tr><tr><td style="text-align:center">FileOrCreate</td><td style="text-align:center">文件不存在则自动创建，不会自动创建文件的父目录，必须确保文件路径存在</td></tr><tr><td style="text-align:center">File</td><td style="text-align:center">挂载已经存在的文件，不存在会报错</td></tr><tr><td style="text-align:center">Socket</td><td style="text-align:center">挂在UNIX套接字，比如挂载/var/run/docker.sock 进程</td></tr></tbody></table><h2 id="ConfigMap"><code>ConfigMap</code></h2><ul><li><code>Docker</code>中可以使用绑定挂载的方式将配置文件挂载到容器里，但是在<code>Kubernetes</code>集群中，容器可能被调度到任意的节点中，配置文件需要能在集群的任意节点上访问、分发和更新</li><li><code>ConfigMap</code>用来在etcd中保存非加密的数据，一般用来保存配置文件<ul><li>可以用作环境变量，命令行参数或者存储卷</li><li>将配置信息与容器镜像解耦，便于配置的修改</li><li>在设计上不是用来保存大量数据的</li><li>保存的数据不能超过1MB</li><li>超出这个限制，需要考虑存储卷或者访问文件存储服务</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;架构&lt;/h1&gt;
&lt;p&gt;一个&lt;code&gt;Kubernetes&lt;/code&gt;集群至少包含一个控制平面，以及一个或多个工作节点&lt;/p&gt;
&lt;h2 id=&quot;控制平面&quot;&gt;控制平面&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/sang3112/blog_im</summary>
      
    
    
    
    <category term="Kubernetes" scheme="https://sangs3112.github.io/categories/Kubernetes/"/>
    
    
    <category term="Kubernetes" scheme="https://sangs3112.github.io/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Kafka笔记_1</title>
    <link href="https://sangs3112.github.io/posts/afe3e258.html"/>
    <id>https://sangs3112.github.io/posts/afe3e258.html</id>
    <published>2024-04-05T09:05:56.000Z</published>
    <updated>2024-07-23T17:18:51.906Z</updated>
    
    <content type="html"><![CDATA[<h1>消费</h1><ul><li><code>watermark</code>水位线以下的数据是消费者可以消费的数据</li></ul><h2 id="消费者组中的消费者和分区之间的分配关系">消费者组中的消费者和分区之间的分配关系</h2><ol><li>同一个消费者组中的消费者都订阅同一个主题，所以消费者组中的多个消费者可以共同消费同一个主题中的所有数据</li><li>为了避免数据被重复消费，所以主题一个分区的数据只能被组中的一个消费者消费，所以两个消费者不能同时消费一个分区的数据。但是一个消费者可以同时消费多个分区的数据。</li></ol><h2 id="消费者分区分配策略-4种">消费者分区分配策略(4种)</h2><div class="note info flat"><ul><li>具体的分配策略实际上是由消费者组中的<code>Leader</code>决定的，<code>Leader</code>就是群主，是第一个加入消费者组的消费者</li><li>消费者加入群组时，发送一个<code>JoinGroup</code>，群主负责给每一个消费者分配一个分区</li></ul></div><h3 id="轮询分配策略-RoundRobinAssignor">轮询分配策略(<code>RoundRobinAssignor</code>)</h3><ul><li>每个消费者组中的消费者都含有一个自动生成的<code>UUID</code>作为<code>memberid</code></li><li>轮询策略会将每个消费者按照<code>memberid</code>进行排序，所有<code>member</code>消费的主题分区根据主题名称进行排序</li><li>将主题分区轮询分配给对应的订阅用户，未订阅当前轮询主题的消费者会跳过<br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Kafka/RRA1.png" alt="RRA1"><br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Kafka/RRA2.png" alt="RRA2"><br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Kafka/RRA3.png" alt="RRA3"><br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Kafka/RRA4.png" alt="RRA4"></li></ul><h3 id="范围分配策略-RangeAssignor">范围分配策略(<code>RangeAssignor</code>)</h3><ul><li>每个<code>Topic</code>的<code>partition</code>数计算出每个消费者应该分配的分区数量，分配原则就是一个主题的分区尽可能平分，如果不能平均分配，则按照顺序向前补齐。</li></ul><div class="note default flat"><ul><li>假设目前有五个分区分给两个消费者，<code>5 / 2 = 2, 5 % 2 = 1</code>。则剩下一个分区补在第一个消费者中，则分配结果为<code>[123][45]</code></li><li>假设目前有五个分区分配给三个消费者，<code>5 / 3 = 1, 5 % 3 = 2</code>，最后分配结果是<code>[12][34][5]</code></li><li>范围分配策略针对单个<code>Topic</code>的情况下比较均衡，如果多个<code>Topic</code>，则<code>member</code>靠前的排序可能比靠后的排序负载多很多，也不够理想</li></ul></div><p><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Kafka/RA1.png" alt="RA1"></p><h3 id="粘性分区-StickyAssignor">粘性分区(<code>StickyAssignor</code>)</h3><ul><li>第一次分配后，每个组成员都保留分配给自己的分区信息。如果消费者加入或者退出，则进行分区再分配时(一般是消费者退出45s以后，才会进行再分配，因为又要考虑可能恢复的情况)，尽可能保证消费者原有分区不变，重新对加入或者退出消费者的分区进行分配。<br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Kafka/SA1.png" alt="SA1"><br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Kafka/SA2.png" alt="SA2"></li></ul><h3 id="优化的粘性分配策略-CooperativeStickyAssignor">优化的粘性分配策略(<code>CooperativeStickyAssignor</code>)</h3><ul><li>前三种分配策略在进行重分配的时候使用的是<code>EAGER</code>协议，让当前的所有消费者放弃当前分区，关闭连接，资源清理，重新加入组和等待分配策略，效率较低</li><li>从2.4版本开始，粘性分配策略的基础上，优化了重分配的过程，使用的是<code>COOPERATIVE</code>协议。粘性分区分配策略分配的会更加均匀和高效一些</li><li><code>COOPERATIVE</code>协议将一次全局重平衡，改成每个小规模的重平衡，直到最终收敛平衡的过程</li></ul><div class="note info flat"><ul><li><code>Kafka</code>消费者默认的分区分配就是<code>RangeAssignor</code>(第一次分区分配)，<code>CooperativeStickyAssinor</code>(后续的分区分配)</li></ul></div><h1>集群的脑裂问题</h1><ul><li>首先<code>ZooKeeper</code>具有三个<code>Broker</code>，其中有一个<code>Controller</code>，由<code>Broker1</code>创建的</li><li>但是此时网络不稳定，<code>Broker1</code>掉线了。<code>ZooKeeper</code>中的<code>Controller</code>临时节点被删除了，同时选举了<code>Broker3</code>作为新的<code>Controller</code>，创建了新的临时节点</li><li>此时<code>Broker1</code>恢复了链接，由于是<code>Broker3</code>创建了<code>Controller</code>。所以<code>Broker3</code>才是真正的管理者</li><li>但是<code>Broker1</code>此时仍然认为自己是管理者，两个<code>Broker</code>都会向<code>Broker2</code>同步消息，<code>Broker2</code>不知道应该同步谁的消息，这就是脑裂问题</li></ul><h2 id="解决">解决</h2><ul><li><code>ZooKeeper</code>引入了<code>epoch</code>纪元，有一个<code>controller_epoch</code>(不是临时节点)，记录的是当前的<code>controller</code>是出现的第几个<code>controller</code>。这样<code>Broker2</code>就可以判断出最新的管理者是谁，从而完成同步消息</li></ul><h1>总结</h1><h2 id="Kafka组件">Kafka组件</h2><ul><li>通信用组件 <code>SocketServer</code>，<code>NetworkClient</code>，生产者中的缓冲区, <code>ZooKeeper</code>等等</li></ul><h2 id="LSO、LEO、HW含义"><code>LSO、LEO、HW</code>含义</h2><ol><li><code>LSO (Log Start Offset, Log Stable Offset)</code><ul><li>第一个是数据文件的起始偏移量</li><li>第二个表示的位移值是用来判断事务型消费者的可见性，就是事务的隔离级别<ul><li>一个是<code>read_committed</code>, 另一个是<code>read_uncommitted</code>，如果没有使用事务，则这个偏移量没有意义</li></ul></li></ul></li><li><code>LEO (Log End Offset)</code> 下一个要写入的数据偏移量，<strong>是不存在的</strong>。水位线靠这个推动增长</li><li><code>HW</code> 高水位线的意思，是<code>Kafka</code>为了数据一致性增加的一种数据隔离方式，消费者只能消费到小于高水位线的数据</li></ol><h2 id="Controller选举如何实现"><code>Controller</code>选举如何实现</h2><ul><li><code>Kafka</code>在4.0版本以后，将会完全抛弃<code>ZooKeeper</code>，现在<code>Controller</code>选举还是依赖<code>ZooKeeper</code>实现的，所有的<code>Broker</code>都会监听<code>ZooKeeper</code>中的一个<code>Controller</code>临时节点。如果没有创建，则<code>Broker</code>会申请创建，创建成功，则该<code>Broker</code>就是集群的<code>Controller</code>。一旦失去和<code>ZooKeeper</code>的通信，临时节点就会消失，就会重新进行选举，并且<code>Controller纪元</code>就会更新</li></ul><h2 id="AR-ISR-OSR的含义"><code>AR ISR OSR</code>的含义</h2><ol><li><code>AR</code> 是分区的所有副本集合</li><li><code>ISR</code> 是正在同步数据的副本列表，列表的第一个就是分区的<code>Leader</code>副本，其他就是<code>Follower</code>副本</li><li><code>OSR</code> 就是没有处于同步数据的副本列表，一旦副本拉去数据满足了特定的条件。则<code>OSR</code>会移除并增加到<code>ISR</code>中。同样如果副本没有拉取数据满足特定的条件，就会从<code>ISR</code>中移除，放到<code>OSR</code>中。这些就是<code>ISR</code>列表的收缩和扩张，权衡数据的可靠性和性能之间的关系</li></ol><h2 id="Producer消息重复或者消息丢失的原因"><code>Producer</code>消息重复或者消息丢失的原因</h2><ul><li>主要就是<code>Kafka</code>为了提高数据可靠性提供的重试机制，数据一旦发送失败了，数据就丢失了</li><li>数据重复，恰恰是因为开启重试机制以后，如果网络阻塞或者不稳定，导致数据需要重新发送，数据就有可能会重复</li><li>幂等性操作要求必须开启<strong>重试功能和</strong><code>ACKS = -1</code>，这样可以确保数据不会丢失<ul><li><code>Kafka</code>提供幂等性操作只能保证同一个生产者会话中同一个分区中的数据不会重复，一旦数据发送过程中，生产者对象重启，幂等性操作失效，此时需要使用事务功能解决跨会话的幂等性操作，但是跨分区的幂等性操作是无法实现的。</li></ul></li></ul><h2 id="Consumer消息重复或消息丢失的原因"><code>Consumer</code>消息重复或消息丢失的原因</h2><ul><li>是消费者提交偏移量的问题，消费者为了防止意外情况下，重启后不知道从哪里开始消费，会每5s自动保存偏移量，但是这种自动保存偏移量的操作是基于时间的，一旦未到达时间，消费者重启了，那么消费者可能重复消费数据</li><li><code>Kafka</code>提供自动保存偏移量的功能的同时，也提供了手动保存偏移量的两种方式，一个同步提交，另一个是异步提交。本质上都是提交一批数据的最后一个偏移的值，但是可能会出现，偏移量已经提交完毕了，但是拉取的数据还没有处理完毕，消费者重启了，此时有些数据就无法消费到，造成了数据丢失</li></ul><h2 id="Kafka数据如何保证有序"><code>Kafka</code>数据如何保证有序</h2><ul><li>有序需要考虑<strong>生产有序，存储有序和消费有序</strong>。</li><li><strong>生产有序</strong> 就是生产者对象需要给数据增加序列号，用于标记数据的顺序，在服务端进行缓存数据的比对，一旦发现数据是乱序的，就需要让生产者客户端进行数据排序，然后重新发送数据，从而保证数据的有序。不过这里缓存的比对，最多只能有5条数据的比对，所以生产者客户端需要配置<strong>在途请求缓冲区的请求队列</strong>数据设置成5，否则数据依然可能乱序。因为服务端的缓存数据是以分区为单位的，所以需要生产者客户端将数据发送到一个分区中，如果数据发送到多个分区中，无法保证顺序，这就是生产有序的意思</li><li><strong>存储有序</strong> <code>Kafka</code>的服务端获取数据以后会将数据顺序写入日志文件，保证了存储有序，也只能保证一个分区的数据有序</li><li><strong>消费有序</strong> <code>Kafka</code>在存储数据时会给数据增加一个访问的偏移量值，消费者只能按照偏移量的方式顺序访问，并且一个分区的数据只能被消费者组中的一个消费者消费，那么按照偏移量方式读取的数据就不会出现乱序的情况，从而实现消费有序</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;消费&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;watermark&lt;/code&gt;水位线以下的数据是消费者可以消费的数据&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;消费者组中的消费者和分区之间的分配关系&quot;&gt;消费者组中的消费者和分区之间的分配关系&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;同一个</summary>
      
    
    
    
    <category term="Kafka" scheme="https://sangs3112.github.io/categories/Kafka/"/>
    
    
    <category term="Kafka" scheme="https://sangs3112.github.io/tags/Kafka/"/>
    
    <category term="消费者分区分配策略" scheme="https://sangs3112.github.io/tags/%E6%B6%88%E8%B4%B9%E8%80%85%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/"/>
    
    <category term="集群脑裂" scheme="https://sangs3112.github.io/tags/%E9%9B%86%E7%BE%A4%E8%84%91%E8%A3%82/"/>
    
  </entry>
  
  <entry>
    <title>Kafka笔记_0</title>
    <link href="https://sangs3112.github.io/posts/d8e4d2ce.html"/>
    <id>https://sangs3112.github.io/posts/d8e4d2ce.html</id>
    <published>2024-04-04T07:05:56.000Z</published>
    <updated>2024-07-23T17:18:51.906Z</updated>
    
    <content type="html"><![CDATA[<h1>消费模式</h1><h2 id="点对点模式-P2P">点对点模式(<code>P2P</code>)</h2><ul><li>队列中<strong>只有一个消费者</strong>可以消费数据，用后即销毁，因此数据有且只有一次消费。</li><li>适合用于<strong>短信业务</strong>，发送一次，消费一次。  <div class="note info flat"><p>特点:<br>- 每个消息只有一个接收者<br>- 发送和接收之间没有依赖，发送者成功发送消息后，不管接收有没有运行，都可以再次发送消息<br>- 接收者在成功接收后需要向队列应答成功，以便消息队列删除当前消息</p></div><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Kafka/p2p.png" alt="p2p"></li></ul><h2 id="发布订阅模式-PS">发布订阅模式(<code>PS</code>)</h2><ul><li>数据会在队列中存储<strong>7天</strong>，每个订阅都可以消费到相应的数据，可以<strong>重复进行</strong>消费数据。</li><li>大部分都是发布订阅模式。  <div class="note info flat"><p>特点:<br>- 每个消息有多个订阅者<br>- 发布者和订阅者之间有时间上的依赖性。针对某个<code>Topic</code>的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息<br>- 为了消费消息，订阅者需要提前订阅该角色主题，并保持在线运行</p></div><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Kafka/ps.png" alt="ps"></li></ul><h1>基础架构</h1><div class="note info flat"><ul><li><code>Kafka</code><strong>不是主从集群</strong>，因此每一个节点都可以是主节点，如果一个节点宕机了，那么其他的节点可以被选举为主节点</li><li><code>Kafka</code>中每一个节点都称为<code>Broker</code>，每个节点都存在一个<code>Kafka_controller</code>组件</li><li>但是只有一台节点的<code>controller</code>组件是活跃状态，其他都是<code>standby</code>状态</li><li>主节点宕机时，从节点通过<code>ZooKeeper</code>进行集群选举，得到新的主节点</li></ul></div><h1><code>Feed</code>流实现方案</h1><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">拉模式</th><th style="text-align:center">推模式</th><th style="text-align:center">推拉结合</th></tr></thead><tbody><tr><td style="text-align:center">写比例</td><td style="text-align:center">低</td><td style="text-align:center">高</td><td style="text-align:center">中</td></tr><tr><td style="text-align:center">读比例</td><td style="text-align:center">高</td><td style="text-align:center">低</td><td style="text-align:center">中</td></tr><tr><td style="text-align:center">用户读取延迟</td><td style="text-align:center">高</td><td style="text-align:center">低</td><td style="text-align:center">低</td></tr><tr><td style="text-align:center">实现难度</td><td style="text-align:center">复杂</td><td style="text-align:center">简单</td><td style="text-align:center">很复杂</td></tr><tr><td style="text-align:center">使用场景</td><td style="text-align:center">较少使用</td><td style="text-align:center">用户量少，没有大V</td><td style="text-align:center">过千万的用户量，有大V</td></tr></tbody></table><h1>消息队列应用</h1><h2 id="线程与线程之间的数据交互">线程与线程之间的数据交互</h2><div class="note info flat"><ul><li>栈内存是<strong>线程独享</strong>的，堆内存是共享的</li></ul></div><p><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Kafka/threaddata.png" alt="threaddata"></p><h2 id="进程与进程之间的数据交互">进程与进程之间的数据交互</h2><div class="note info flat"><ul><li>进程有自己独立的内存，<strong>无法</strong>通过堆内存共享数据</li></ul></div><p><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Kafka/processdata.png" alt="processdata"></p><h2 id="传统数据交互的问题">传统数据交互的问题</h2><ul><li>如果线程1发送数据的速度是<code>50 条/s</code>，但是线程2处理数据的速度是<code>30 条/s</code>，就会导致<strong>每秒有20条数据</strong>积压在内存中，最后导致内存溢出，服务终止</li><li>如果放在磁盘文件中，磁盘文件也是有上限的，并且速度较慢</li></ul><h2 id="消息中间件">消息中间件</h2><ul><li>进程之间直接进行交互，可以在进程之间添加一个缓冲区，用于解耦合</li><li>发送数据的进程只需要考虑往缓冲区中存放数据，也就是<strong>消息中间件</strong>，从而实现降低系统之间的耦合性</li><li>消息一般包含<strong>消息头，消息属性和消息主体内容</strong><br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Kafka/JMS.png" alt="JMS"></li></ul><h1><code>Kafka</code>基本概念</h1><h2 id="基本命令参数">基本命令参数</h2><div class="note info flat"><ul><li>连接<code>Kafka</code>必须要的参数: <code>--bootstrap-server ip:port(9092)</code> <code>9092</code>是<code>Kafka</code>默认的端口号</li><li><code>Kafka</code>创建新<code>topic</code>需要在后面跟上: <code>--topic 主题名 --create</code></li><li>查看<code>topic</code>: <code>--list</code></li><li>查看某个具体的<code>topic</code>: <code>--topic 主题名 --describe</code></li><li>修改<code>topic</code>: <code>--topic 主题名 --alter --修改的内容</code></li><li>删除<code>topic</code>: <code>--topic 主题名 --delete</code></li></ul></div><h2 id="单节点架构">单节点架构</h2><p><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Kafka/kafka.png" alt="kafka"></p><ul><li>消息称为<code>record</code></li><li><code>App</code>通过调用<code>Kafka</code>的接口实现生产和消费，会将数据保存到<code>.log</code>文件中，增加标记<code>offset</code>，固定顺序</li></ul><h2 id="集群架构">集群架构</h2><p><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Kafka/arch.png" alt="arch"></p><div class="note default flat"><ul><li>中间单个节点容易成为性能瓶颈，如果宕机，则数据无法访问</li><li>两种方式解决: 1. 横向扩展 2. 纵向扩展</li></ul></div><h3 id="横向扩展">横向扩展</h3><ul><li>增加服务节点，搭建集群，降低单点故障带来的问题<br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Kafka/horizontal.png" alt="horizontal">  <div class="note info flat"><ul><li>在<strong>一定程度上缓解</strong>，不是真正完全解决，因为主题在指定的<code>Broker</code>上，所以依然必须要访问某一个特定的<code>Broker</code></li><li>因此真正解决需要将一个<code>topic</code>分成多个部分，所有生产数据可以指向不同的<code>Broker</code>，但是都是同一个<code>topic</code></li></ul></div></li></ul><h3 id="纵向扩展">纵向扩展</h3><ul><li>增加系统的资源配置，更快的网络，更大的硬盘  <div class="note info flat"><ul><li><code>topic</code>是一个整体，但是划分了不同的数据块<ul><li>通过添加不同的编号，即为不同的分区(<code>partition</code>)</li><li>生产者就可以将数据发向不同的<code>partition</code>，消费者可以消费同一个<code>topic</code>不同的<code>partition</code></li></ul></li><li><code>Kafka</code>设置了消费者组<code>Consumer Group</code>，专门用来消费不同<code>partition</code>的消息，这样避免发送多次消费请求</li></ul></div></li><li>为了数据的可靠性，可以将数据进行备份，但是<code>Kafka</code>没有备份的概念，只有<strong>副本</strong>的概念。</li><li>多个副本同时只有一个能进行读写操作，称为<code>Leader</code>副本，其他副本称为<code>Follower</code>副本</li><li><strong>副本个数不应该超过broker数量 - 1</strong></li></ul><p><code>Kafka</code>有一个管理的<code>Broker</code>，称为控制器(<code>Controller</code>)</p><div class="note info flat"><p>如果<code>Controller</code>宕机了，如何解决</p><ol><li>给<code>Controller</code>添加备份</li><li>每一个<code>Broker</code>都可以做备份，如果<code>Controller</code>宕机了，则会使用<code>ZooKeeper</code>选取一个新的<code>Controller</code></li></ol></div><p><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Kafka/jiqun.png" alt="jiqun"></p><div class="note default flat"><p><code>ZooKeeper</code>选举流程</p><ol><li><code>ZooKeeper</code>首先没有任何的节点，启动<code>Broker1</code>，则会产生临时节点<code>Controller</code>，<code>id=1</code></li><li>然后启动<code>Broker2</code>和<code>Broker3</code>后，不能再产生临时节点，就会创建一个监听器，监听节点的变化</li><li><code>Controller</code>失去连接了以后，监听器就会发生作用，选举出新的<code>Controller</code></li></ol></div><h1><code>Broker</code>启动流程</h1><h2 id="Broker1启动流程"><code>Broker1</code>启动流程</h2><ol><li>在<code>ZooKeeper</code>注册<code>Broker</code>节点，创建临时节点<code>ids</code></li><li>监听<code>/controller</code>节点</li><li>注册<code>/controller</code>节点</li><li>注册成功，选举称为<code>Controller</code>，监听临时节点<code>/brokers/ids</code>，从而可以对后面加入的节点进行响应</li></ol><h2 id="Broker2启动流程"><code>Broker2</code>启动流程</h2><ol><li>在<code>ZooKeeper</code>注册<code>Broker</code>节点，在<code>ids</code>里面创建临时节点2</li><li>监听<code>/controller</code>临时节点</li><li>注册<code>/controller</code>临时节点，因为<code>ZooKeeper</code>中已经存在<code>Controller</code>，所以不会注册成功</li><li>通知集群变化</li><li>连接<code>Broker</code>，发送集群的相关数据</li></ol><h2 id="Broker3启动流程"><code>Broker3</code>启动流程:</h2><ol><li>注册<code>Broker</code>节点，在<code>ids</code>里面创建临时节点3</li><li>监听<code>/controller</code>临时节点</li><li>注册<code>/controller</code>临时节点，注册不成功</li><li>通知集群变化</li><li>连接<strong>所有的<code>Broker</code></strong>，发送集群的相关信息</li></ol><h2 id="删除Controller节点-宕机">删除<code>Controller</code>节点(宕机):</h2><ol><li>由监听器通知节点删除</li><li>注册<code>Controller</code>临时节点，只有一个节点能注册成功</li><li>增加<code>ids</code>监听器，删除曾经的<code>Controller</code>监听器</li><li>连接所有的<code>Broker</code>，发送集群的相关数据</li></ol><h2 id="底层实现">底层实现</h2><ol><li><code>Broker</code>和<code>ZooKeeper</code>之间的通信: 节点带有<code>ZooKeeperClient</code>实现通信</li><li><code>Controller</code>和<code>Broker</code>之间的通信: <code>NIO</code>的<code>Channel, Buffer, Selector, SelectionKey</code></li></ol><h1>生产</h1><h2 id="创建主题">创建主题</h2><ul><li>生产消息的时候如果不存在对应的主题，<code>Kafka</code>会自动创建主题(可以通过配置关闭)</li><li>要关注每个<code>Broker</code>中的<code>Leader</code>的数量，平衡分配会更合理一些</li><li><code>Kafka</code>默认的副本分配未必是平均分配，所以只能尽可能的合理分配，也可以自己指定副本的分配方案</li></ul><h2 id="分区计算">分区计算</h2><ol><li>如果发送消息中指定了分区编号，则会直接向分区中发送消息，并且不会检查分区编号是否有问题。如果写了一个不存在的编号，则消息一直阻塞</li><li>自定义分区器实现<code>Partitioner</code>，会检查编号是否小于0，但是过大依然不会检查</li><li>把<code>key</code>做了一个非哈希散列算法<code>murmur2</code>，取余分区数量，得到的结果就是分区编号。所以指定的<code>key</code>主要用来做分区计算的</li></ol><div class="note info flat"><ul><li>为了节省网络资源消耗，设计了<code>RecordAccumulator</code>数据收集器，将多个消息一起发送，而不是简单的一条一条发送</li><li>数据收集器内部都是一些批次对象，如果批次对象的容量足够，则会自动往里面<code>append</code>数据</li><li>如果批次对象的容量不够了，则会将批次对象锁定关闭，不再接收新的数据，开启一个新的批次对象，用于接收数据</li><li>批次对象中有一个<code>16K</code>的阈值，不是不能超过<code>16K</code>，而是超过<code>16K</code>再关闭</li></ul></div><p><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Kafka/produce.png" alt="produce"></p><h2 id="应答处理-三个级别">应答处理(三个级别)</h2><ol><li><code>ACKS = 0</code>: 优先考虑数据传送效率，数据是否真的发送过去是不关心的。假设网络是没有任何问题的，发送完一条数据立马发送下一条</li><li><code>ACKS = 1</code>: 可靠性和发送效率折中，<code>Leader</code>保存数据到磁盘后，就响应发送成功。但是如果<code>Leader</code>宕机了，<code>Follower</code>没有来得及备份，则数据无法访问</li><li><code>ACKS = -1 or ALL</code>: 优先考虑数据的安全性，<code>Leader</code> 和 <code>Follower</code>把数据都保存了，然后才响应发送成功，效率很低</li></ol><ul><li>这里的<code>Follower</code>是<code>ISR</code>中的所有副本，而不是本身的所有副本</li></ul><h2 id="重试机制Retry">重试机制<code>Retry</code></h2><ul><li><code>ACKS = 1</code>: 如果一个数据，从主线程出发到<code>Buffer</code>缓冲区后到<code>Sender</code>线程中，发送到<code>NetworkClient</code>网络客户端，再发送到<code>SocketServer</code>服务器。如果这个时候数据没有到<code>ReplicaManager</code>，<code>Leader</code>宕机，则无法进行副本保存。此时<code>NetworkClient</code>客户端有一份数据，<code>SocketServer</code>有一份数据，但是由于宕机，导致<code>SocketServer</code>的数据丢失，没有保存则不会有响应，此时会有超时时间。如果超时了会进行<code>Retry</code>。<ol><li>将<code>NetworkClient</code>的数据重新传送到<code>Buffer</code>中，再经过<code>Sender</code>线程，再回到<code>NetworkClient</code>进行发送</li><li>默认是不断重试，重试次数是整型的最大值</li></ol></li></ul><h3 id="重试机制的问题-重复和乱序">重试机制的问题(重复和乱序)</h3><ol><li>数据重试机制可能会导致数据重复(超时时间过少导致的)</li><li><code>Buffer</code>有三条数据，被网络客户端发送到<code>Broker</code>中，生产者可同时处理五个请求，所以三个数据可以一起处理。<ul><li>但是如果三条数据中有一条处理失败了，则会重新发送那一条数据，但是此时会导致乱序问题</li></ul></li></ol><h3 id="如何解决重复和乱序-幂等性">如何解决重复和乱序(幂等性)</h3><ul><li>开启幂等性: 配置<code>ENABLE_IDEMPOTENCE_CONFIG</code>(默认不启用)</li></ul><div class="note default flat"><p>开启幂等性要求</p><ul><li><code>ACKS = -1</code></li><li>开启重试机制</li><li>在途请求缓冲区不能超过5(默认就是5)</li></ul></div><ul><li>给数据开启<strong>唯一</strong>的标识，包括两个部分，分别是<strong>生产者ID，数据的顺序号</strong><ul><li><p>不同的<code>partition</code>数据可能有相同的标号，但是同一个<code>partition</code>内序号一定是唯一的</p></li><li><p>所以幂等性只能保证<strong>对同一个</strong><code>partition</code>起作用</p></li><li><p><code>Broker</code>可以保存生产者状态，里面只有五条数据。如果是同一个<code>Producer</code>，同一个<code>partition</code>，就可以对比唯一标识判断数据是否<strong>重复</strong></p></li><li><p><strong>乱序</strong>是判断当前的序号是否连续</p><ul><li>如果6失效了，会尝试将7插入进去，发现前面是5后面是7，不连续，则6和7都会重发</li><li>如果5后面的6正常，则会将1弹出后，再将6传入，保证数据按序输出</li><li>这个队列的大小为五，所以要求在途请求缓冲区不能超过5</li></ul><div class="note default flat"><p>幂等性跨会话问题</p><ul><li>生产者ID是随机生成的，如果生产者重启了，则生产者ID也会发生改变。此时比对序号的操作时会发现比对不成功</li><li>可以通过<strong>事务</strong>解决</li><li>数据唯一标识中添加事务ID，事务是基于幂等性操作，保证一次提交。因此事务可以解决跨会话的幂等性问题，但是<strong>不能解决跨分区</strong>的问题</li></ul></div></li></ul></li></ul><h2 id="数据传输语义">数据传输语义</h2><table><thead><tr><th style="text-align:center">数据传输语义</th><th style="text-align:center">含义</th><th style="text-align:center">场景</th></tr></thead><tbody><tr><td style="text-align:center">at most once</td><td style="text-align:center">最多一次，不管是否能够接收到，数据最多传输一次，可能丢失</td><td style="text-align:center">Socket ACK = 0</td></tr><tr><td style="text-align:center">at least once</td><td style="text-align:center">最少一次，数据不会丢失，如果接收不到，则继续发送直到接收，可能会出现数据重复</td><td style="text-align:center">ACK = 1</td></tr><tr><td style="text-align:center">exactly once</td><td style="text-align:center">精准一次，消息只会传送一次，不会丢也不会重复</td><td style="text-align:center">幂等 + 事务 + ACK = 1</td></tr></tbody></table><h2 id="事务流程">事务流程</h2><p><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Kafka/tx.png" alt="tx"></p><h2 id="文件存储类型">文件存储类型</h2><ul><li>数据写入<code>Leader</code>节点时，<strong>不会</strong>立即将数据写入磁盘文件中，因为这样效率太低了。</li><li><code>Kafka</code>将一个文件切分成一个一个文件段。当大于<code>1G</code>时，就会产生一个新的文件段。</li><li>如果一份数据超过7天，也会生成一个新的文件段</li><li><code>.log</code>就是数据的日志文件，当前文件中起始偏移量</li><li><code>.index</code>偏移量索引文件，将偏移量与文件中的数据的具体位置进行关联，称之为<strong>稀疏索引文件</strong></li><li><code>.timeindex</code>保存时间戳和数据偏移量之间的关系</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;消费模式&lt;/h1&gt;
&lt;h2 id=&quot;点对点模式-P2P&quot;&gt;点对点模式(&lt;code&gt;P2P&lt;/code&gt;)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;队列中&lt;strong&gt;只有一个消费者&lt;/strong&gt;可以消费数据，用后即销毁，因此数据有且只有一次消费。&lt;/li&gt;
&lt;li&gt;适合用于&lt;s</summary>
      
    
    
    
    <category term="Kafka" scheme="https://sangs3112.github.io/categories/Kafka/"/>
    
    
    <category term="Kafka" scheme="https://sangs3112.github.io/tags/Kafka/"/>
    
    <category term="应答处理机制" scheme="https://sangs3112.github.io/tags/%E5%BA%94%E7%AD%94%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    
    <category term="重试机制" scheme="https://sangs3112.github.io/tags/%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6/"/>
    
    <category term="幂等性" scheme="https://sangs3112.github.io/tags/%E5%B9%82%E7%AD%89%E6%80%A7/"/>
    
    <category term="事务流程" scheme="https://sangs3112.github.io/tags/%E4%BA%8B%E5%8A%A1%E6%B5%81%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Redis笔记_5</title>
    <link href="https://sangs3112.github.io/posts/46b5b207.html"/>
    <id>https://sangs3112.github.io/posts/46b5b207.html</id>
    <published>2024-03-25T11:51:15.000Z</published>
    <updated>2024-07-23T17:18:51.910Z</updated>
    
    <content type="html"><![CDATA[<h1><code>QuickList</code></h1><div class="note info flat"><ul><li><code>ZipList</code>虽然节省内存，但是申请的是<strong>连续的空间</strong>，如果内存占用较多，内存申请效率很低；<ul><li>这时候需要限制<code>ZipList</code>的长度或者<code>entry</code>大小；</li><li>也可以创建多个<code>ZipList</code>分片存储数据</li><li>但是拆分后比较分散，不方便管理和查找，所以引入了<code>QuickList</code></li></ul></li></ul></div><ul><li><code>QuickList</code>本质上是一个<strong>双端链表</strong>，其中的每一个节点都是<code>ZipList</code><br><img src="https://gitee.com/sang3112/blog_imgs/raw/1ac80c3030f37c5d649c32e7e65c57937283ef7a/Redis/QuickList.png" alt="QuickList"></li><li>为了避免<code>QuickList</code>中每个<code>ZipList</code>的<code>entry</code>过多，可以配置<code>list-max-ziplist-size</code>来进行限制<ul><li>如果为正，表示<code>ZipList</code>的允许的<code>entry</code>最大个数</li><li>如果为负，表示<code>ZipList</code>的最大内存大小，共五种情况<table><thead><tr><th style="text-align:center">情况</th><th style="text-align:center">内存占用</th></tr></thead><tbody><tr><td style="text-align:center">-1</td><td style="text-align:center">&lt;= 4KB</td></tr><tr><td style="text-align:center">-2(默认)</td><td style="text-align:center">&lt;= 8KB</td></tr><tr><td style="text-align:center">-3</td><td style="text-align:center">&lt;= 16KB</td></tr><tr><td style="text-align:center">-4</td><td style="text-align:center">&lt;= 32KB</td></tr><tr><td style="text-align:center">-5</td><td style="text-align:center">&lt;= 64KB</td></tr></tbody></table></li></ul></li><li><code>QuickList</code>同时可以对节点<code>ZipList</code>进行压缩，通过配置<code>list-compress-depth</code>控制。因为链表一般都是<strong>首尾访问较多</strong>，所以<strong>首尾不压缩</strong>。<table><thead><tr><th style="text-align:center">情况</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">不压缩</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">表示<code>QuickList</code>首尾各有一个节点不压缩，中间节点压缩</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">表示<code>QuickList</code>首尾各有两个节点不压缩，中间节点压缩</td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">… 以此类推</td></tr></tbody></table></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span>&#123;</span></span><br><span class="line">    <span class="comment">// 头节点</span></span><br><span class="line">    quickliskNode *head;</span><br><span class="line">    <span class="comment">// 尾节点</span></span><br><span class="line">    quicklistNode *tail;</span><br><span class="line">    <span class="comment">// 所有ziplist的entry数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> count;</span><br><span class="line">    <span class="comment">// ziplists总数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line">    <span class="comment">// ziplist的entry上限，默认为-2</span></span><br><span class="line">    <span class="type">int</span> fill : QL_RILL_BITS;</span><br><span class="line">    <span class="comment">// 首尾不压缩节点数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> compress : QL_COMP_BITS;</span><br><span class="line">    <span class="comment">// 内存重新分配时的书签数量以及数组，一般用不到</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> bookmark_count : QL_BM_BITS;</span><br><span class="line">    quicklistBookmark bookmarks[];</span><br><span class="line">&#125; quicklist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 前一个节点指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="comment">// 后一个</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">// 当前节点</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *zl;</span><br><span class="line">    <span class="comment">// 当前节点的ZipList的entry个数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count : <span class="number">16</span>;</span><br><span class="line">    <span class="comment">// 编码方式: 1, ZipList; 2, lzf压缩模式</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> encoding : <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 数据容器类型(预留): 1, 其他; 2, ZipList</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> container : <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 是否被解压缩: 1, 被解压，需要重新压缩</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> recomress : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> attempted_compress : <span class="number">1</span>; <span class="comment">// 测试用</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> extra : <span class="number">10</span>; <span class="comment">// 预留字段</span></span><br><span class="line">&#125; quicklistNode;</span><br></pre></td></tr></table></figure><div class="note info flat"><p>特点:</p><ol><li>节点为<code>ZipList</code>的双端链表</li><li>解决传统链表内存占用问题</li><li>控制<code>ZipList</code>大小，解决连续内存空间申请效率问题</li><li>中间节点可以压缩，进一步节省内存</li></ol></div><h1><code>SkipList</code></h1><ul><li>是一个链表，但是<ul><li><p>元素<strong>升序</strong>排列</p></li><li><p>包含多级指针，指针跨度不同</p></li><li><p>最多允许<strong>32级</strong>指针</p><p><img src="https://gitee.com/sang3112/blog_imgs/raw/1ac80c3030f37c5d649c32e7e65c57937283ef7a/Redis/skiplist.png" alt="skiplist"></p></li></ul></li></ul><div class="note info flat"><p>特点:</p><ol><li>一个双向链表，每个节点包含<code>score</code>和<code>ele</code>值</li><li>节点按照<code>score</code>值排序，如果相同则按照<code>ele</code>字典排序</li><li>每个节点可以包含多层指针，层数是<code>1~32</code>的随机数</li><li>不同层指针到下一个节点的跨度不同，层级越高，跨度越大</li><li>增删改查的效率与红黑树基本一致，实现更简单</li></ol></div><h1><code>RedisObject</code></h1><ul><li><p><strong>任意</strong>的数据类型的键和值都会被封装成<code>RedisObject</code></p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span>&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> type : <span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> encoding : <span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> lru : LRU_BITS;</span><br><span class="line">    <span class="type">int</span> refcount;</span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><ul><li><p><code>type</code>: 对象类型，分别是<code>string、hash、list、set、zset</code>，占用<code>4bits</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> OBJ_STRING 0</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> OBJ_LIST 1</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> OBJ_SET 2</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> OBJ_ZSET 3</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> OBJ_HASH 4</span></span><br></pre></td></tr></table></figure></li><li><p><code>encoding</code>: 底层11种编码方式，占用<code>4bits</code></p><table><thead><tr><th style="text-align:center">编号</th><th style="text-align:center">编码方式</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">OBJ_ENCODING_RAW</td><td style="text-align:center">raw编码动态字符串</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">OBJ_ENCODING_INT</td><td style="text-align:center">long类型整数字符串</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">OBJ_ENCODING_HT</td><td style="text-align:center">哈希表(字典dict)</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">OBJ_ENCODING_ZIPMAP</td><td style="text-align:center">废弃</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">OBJ_ENCODING_LINKEDLIST</td><td style="text-align:center">双端列表</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">OBJ_ENCODING_ZIPLIST</td><td style="text-align:center">压缩列表</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">OBJ_ENCODING_INTSET</td><td style="text-align:center">整数集合</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">OBJ_ENCODING_SKIPLIST</td><td style="text-align:center">跳表</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">OBJ_ENCODING_EMBSTR</td><td style="text-align:center">embstr动态字符串</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">OBJ_ENCODING_QUICKLIST</td><td style="text-align:center">快速列表</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">OBJ_ENCODING_STREAM</td><td style="text-align:center">stream流</td></tr></tbody></table><ul><li>数据类型对应的编码方式<table><thead><tr><th style="text-align:center">数据类型</th><th style="text-align:center">编码方式</th></tr></thead><tbody><tr><td style="text-align:center">OBJ_STRING</td><td style="text-align:center">int, embstr, raw</td></tr><tr><td style="text-align:center">OBJ_LIST</td><td style="text-align:center">LinkedList和ZipList(3.2版本前)；QuickList(3.2版本后)</td></tr><tr><td style="text-align:center">OBJ_SET</td><td style="text-align:center">intset，HT</td></tr><tr><td style="text-align:center">OBJ_ZSET</td><td style="text-align:center">ZipList, HT, SkipList</td></tr><tr><td style="text-align:center">OBJ_HASH</td><td style="text-align:center">ZipList, HT</td></tr></tbody></table></li></ul></li><li><p><code>lru</code>: 该对象最后一次被访问的时间，占用<code>24bits</code></p></li><li><p><code>refcount</code>: 对象引用计数器，为0表示无人引用，可以被回收</p></li><li><p><code>*ptr</code>: 指针，指向存放实际数据的空间</p></li></ul></li></ul><h1><code>String</code></h1><ul><li>基本编码方式是<code>RAW</code>，基于<code>SDS</code>实现，上限为<code>512MB</code></li><li>如果<code>SDS</code>长度小于<code>44B</code>，则会采用<code>EMBSTR</code>编码，此时<code>objecthead</code>与<code>SDS</code>是一段连续的空间，申请内存只需要调用一次内存分配函数，效率更高</li><li>如果存储的字符串是整数值，并且大小在<code>LONG_MAX</code>范围内，则会采用<code>INT</code>编码，直接将数据保存在<code>RedisObject</code>的<code>ptr</code>指针位置，正好<code>8B</code>，就不需要<code>SDS</code>了</li></ul><p><img src="https://gitee.com/sang3112/blog_imgs/raw/1ac80c3030f37c5d649c32e7e65c57937283ef7a/Redis/string.png" alt="string"></p><h1><code>Zset</code></h1><ul><li><p>底层结构由<code>Dict</code><strong>和</strong><code>SkipList</code>实现，但是内存占用较高</p></li><li><p>所以还有第二种实现方式: 元素数量不多时，哈希表和<code>SkipList</code>优势不明显，更消耗内存，所以此时会用<code>ZipList</code>节省内存，不过需要同时满足</p><ol><li>元素数量小于<code>zset_max_ziplist_entries</code>默认<code>128</code>，如果为<code>0</code>就<strong>禁用ZipList</strong></li><li>每个元素都小于<code>zset_max_ziplist_value</code>字节，默认值<code>64</code></li></ol></li><li><p><code>ZipList</code>本身没排序功能，也没有键值对的概念，需要有<code>ZSet</code>通过编码实现</p><ul><li><code>ZipList</code>是连续内存，因此<code>score</code>和<code>ele</code>是紧挨在一起的两个<code>entry</code>，<code>element</code>在前，<code>score</code>在后</li><li><code>score</code>越小越接近队首，<code>score</code>越大越接近队尾，按照<code>score</code>升序排列</li></ul></li><li><p>两种不同的编码就涉及到编码转换，添加元素的时候会进行判断，如果是<code>ZipList</code>，就会进行判断，是否需要转换为<code>HT+SL</code></p></li></ul><h1><code>Hash</code></h1><ul><li><code>Hash</code>底层跟<code>ZSet</code>基本一致，只是排序有关的<code>SkipList</code>去掉</li><li>默认采用<code>ZipList</code>，用来节省内存。<code>ZipList</code>中相邻两个<code>entry</code>分别保存<code>field</code>和<code>value</code></li><li>数据量较大的时候，<code>Hash</code>会转换为<code>Dict</code>编码，触发条件有两个：<ul><li><code>ZipList</code>中元素数量超过了<code>hash-max-ziplist-entries</code>默认<code>512B</code></li><li><code>ZipList</code>中任意<code>entry</code>大小超过了<code>hash-max-ziplist-value</code>默认<code>64B</code></li></ul></li></ul><h1>用户空间和内核空间</h1><div class="note info flat"><ol><li>寻址空间分为两部分: 内核空间，用户空间</li><li>用户空间只能执行受限的命令(Ring3)，不能直接调用系统资源，必须通过内核提供的接口来访问</li><li>内核空间可以执行特权命令(Ring0)，调用一切系统资源</li></ol></div><h2 id="空间切换">空间切换</h2><p>为了提高IO效率，会在用户空间和内核空间都加入缓冲区</p><ul><li>写数据时，要把用户缓冲数据拷贝到内核缓冲区，然后写入设备</li><li>读数据时，要从设备读取数据到内核缓冲区，然后拷贝到用户缓冲区</li></ul><h1>IO模型(5种)</h1><h2 id="阻塞IO">阻塞IO</h2><ul><li>两个阶段都必须阻塞等待，性能差一些<br><img src="https://gitee.com/sang3112/blog_imgs/raw/1ac80c3030f37c5d649c32e7e65c57937283ef7a/Redis/blockingIO.png" alt="blockingIO"></li></ul><h2 id="非阻塞IO">非阻塞IO</h2><ul><li><code>recvfrom</code>操作会立即返回结果而不是阻塞用户进程，等待数据就绪的时候非阻塞的，实际上拷贝数据的时候还是阻塞的。</li><li>没啥用，没有提升系统性能，反而会提升CPU使用率。<br><img src="https://gitee.com/sang3112/blog_imgs/raw/1ac80c3030f37c5d649c32e7e65c57937283ef7a/Redis/noblockingio.png" alt="noblockingIO"></li></ul><div class="note info flat"><ul><li>阻塞IO和非阻塞IO都需要调用<code>recvfrom</code>来获取数据，差别在于无数据时的处理方案。</li></ul></div><h2 id="IO多路复用"><strong>IO多路复用</strong></h2><ul><li><p>如果客户端处理<code>Socket</code>请求时，单线程情况下，依次处理每一个<code>Socket</code>，如果正在处理的<code>Socket</code>恰好未就绪，数据不可读或不可写，则线程被阻塞，其他客户端<code>Socket</code>就必须等待，性能会很差。</p></li><li><p>文件描述符(<code>FD</code>): 从0开始递增的无符号整数，关联<code>Linux</code>中的一个文件</p></li><li><p>IO多路复用就是用<strong>单线程</strong>，监听多个<code>FD</code>，在某个<code>FD</code>可读可写时得到通知，避免无效等待，充分利用CPU<br><img src="https://gitee.com/sang3112/blog_imgs/raw/1ac80c3030f37c5d649c32e7e65c57937283ef7a/Redis/IOmulti.png" alt="IOmulti"></p></li><li><p>有三种监听<code>FD</code>的方式</p><ol><li><code>select</code></li><li><code>poll</code></li><li><code>epoll</code></li></ol></li><li><p><code>select</code> 和 <code>poll</code>只会通知用户进程有<code>FD</code>就绪，但是不确定是哪个<code>FD</code>，需要用户进程<strong>逐个遍历</strong><code>FD</code>确认</p></li><li><p><code>epoll</code>会在通知用户进程<code>FD</code>就绪的通知，把已经就绪的<code>FD</code>写入用户空间</p></li></ul><h3 id="select"><code>select</code></h3><div class="note info flat"><p>问题:</p><ul><li>每次执行<code>select</code>都需要将整个<code>fd_set</code>从用户空间拷贝到内核空间，<code>select</code>结束还需要再次拷贝，因此涉及<strong>两次切换，两次拷贝</strong></li><li><code>select</code>不知道是哪个<code>FD</code>就绪，需要遍历整个<code>fd_set</code></li><li><code>fd_set</code>监听的<code>FD</code>数量不能超过<code>1024</code></li></ul></div><h3 id="poll"><code>poll</code></h3><p>IO流程:</p><ol><li>创建<code>pollfd</code>数组，向其中添加关注的<code>FD</code>信息，数组大小自定义</li><li>调用<code>poll</code>函数，将<code>pollfd</code>数组拷贝到内核空间，转链表存储，无上限</li><li>内核遍历<code>FD</code>，判断是否就绪</li><li>数据就绪或超时后，拷贝<code>pollfd</code>数组到用户空间，返回就绪<code>FD</code>数量<code>n</code></li><li>用户进程判断<code>n</code>是否大于0</li><li>大于0则遍历<code>pollfd</code>数组，找到就绪的<code>FD</code></li></ol><div class="note info flat"><p><code>poll</code> VS <code>select</code>:</p><ul><li><code>select</code>模式中的<code>fd_set</code>大小固定为1024，<code>pollfd</code>在内核中采用链表，理论上没有上限</li><li>监听的<code>FD</code>越多，每次遍历的消耗的时间也越久，性能反而会下降</li></ul></div><h3 id="epoll"><code>epoll</code></h3><p>对<code>select</code> 和 <code>poll</code>的改进，提供了三个函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">rbr</span>;</span> <span class="comment">// 红黑树，记录所有监听的fd</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdlist</span>;</span><span class="comment">// 链表，记录就绪的FD</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 会在内核创建eventpoll结构体，返回对应的句柄epfd</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将一个FD添加到epoll红黑树中，并设置ep_poll_callback</span></span><br><span class="line"><span class="comment">// callback触发时，就把对应的FD添加到rdlist就绪列表中</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">int</span> epfd, <span class="comment">// epoll实例的句柄</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> op, <span class="comment">// 执行的操作，包括ADD、MOD、DEL</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> fd, <span class="comment">// 监听的FD</span></span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> epoll_event *event <span class="comment">// 监听的事件类型: 读，写，异常等</span></span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3检查rdlist列表是否为空，不为空则返回就绪的FD数量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">int</span> epfd, <span class="comment">// eventpoll实例句柄</span></span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> epoll_event *events, <span class="comment">// 空event数组，接收就绪FD</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> maxevents, <span class="comment">// events数组的最大长度</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> timeout <span class="comment">// 超时时间</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><div class="note info flat"><p>特点:</p><ul><li>基于<code>epoll</code>实例中的<strong>红黑树</strong>保存监听的<code>FD</code>，理论无上限，增删改查效率很高，性能<strong>不会</strong>随监听的<code>FD</code>数量增多而下降</li><li>每个<code>FD</code>只需要执行一次<code>epoll_ctl</code>添加到红黑树，每次<code>epoll_wait</code>无需参数，无需重复拷贝<code>FD</code>到内核</li><li>内核会将就绪的<code>FD</code>直接拷贝到用户空间的指定位置，用户进程无需遍历所有的<code>FD</code>就能知道就绪<code>FD</code>是谁</li></ul></div><h2 id="时间通知机制">时间通知机制</h2><p>有数据可读时，<code>epoll_wait</code>可以得到通知，但是通知模式有两种:</p><ul><li><code>LevelTriggered</code>(默认): <code>LT</code>, 当<code>FD</code>有数据可读，<strong>会重复通知多次</strong>，直到数据处理完成</li><li><code>EdgeTriggered</code>: <code>ET</code>, 当<code>FD</code>有数据可读，<strong>只会通知一次</strong>，不管数据是否处理完成</li></ul><p>基于<code>epoll</code>的<code>web</code>服务基本流程<br><img src="https://gitee.com/sang3112/blog_imgs/raw/1ac80c3030f37c5d649c32e7e65c57937283ef7a/Redis/webservice.png" alt="webservice"></p><h2 id="信号驱动IO">信号驱动IO</h2><ul><li>与内核寄建立<code>SIGIO</code>的信号关联并设置回调，内核有<code>FD</code>就绪，就会发出<code>SIGIO</code>信号通知用户，期间用户可以执行其他业务，无需阻塞等待。比非阻塞IO性能好一些<br><img src="https://gitee.com/sang3112/blog_imgs/raw/1ac80c3030f37c5d649c32e7e65c57937283ef7a/Redis/signalIO.png" alt="signalIO"></li></ul><div class="note info flat"><p>问题:</p><ul><li>如果有大量IO，信号较多<code>SIGIO</code>处理函数不能及时处理，可能导致信号队列溢出</li><li>内核空间与用户空间频繁信号交互性能较低</li></ul></div><h2 id="异步IO">异步IO</h2><ul><li>一二阶段都是非阻塞的，但是因为不阻塞，用户进程调用完异步API以后就可以去做其他的事情，内核等到数据拷贝到用户空间后才会递交信号，通知用户进程。</li><li>但是因为不阻塞，导致用户进程一直接收请求，IO操作较慢，所以必须要做并发访问的限流<br><img src="https://gitee.com/sang3112/blog_imgs/raw/1ac80c3030f37c5d649c32e7e65c57937283ef7a/Redis/syncIO.png" alt="syncIO"></li></ul><div class="note info flat"><ul><li>同步和异步需要看第二阶段是同步还是异步的，<strong>阻塞IO和非阻塞IO都是同步的</strong>，只有异步IO才是异步的</li></ul></div><p><img src="https://gitee.com/sang3112/blog_imgs/raw/1ac80c3030f37c5d649c32e7e65c57937283ef7a/Redis/compare.png" alt="compare"></p><h2 id="Redis网络模型"><code>Redis</code>网络模型</h2><p><code>Redis</code>是单线程还是多线程的</p><div class="note info flat"><ul><li>业务处理部分是单线程的</li><li>如果是整个<code>Redis</code>，则是多线程的<ul><li>引入了多线程异步处理一些耗时较长的任务，比如异步删除<code>BigKey</code>的命令<code>unlink</code></li><li>在核心网络模型中引入了多线程，进一步提高对于多核CPU的利用率</li></ul></li></ul></div><div class="note info flat"><p>选择单线程的原因:</p><ol><li><code>Redis</code>纯内存操作，执行速度非常快，性能瓶颈是网络延迟而不是执行速度，因此多线程不会带来巨大的性能提升</li><li>多线程会导致过多的上下文切换，带来不必要的开销</li><li>引入多线程会面临<strong>线程安全问题</strong>，必然要引入线程锁，实现复杂度更高，性能大打折扣，而且需要考虑老代码的兼容问题</li></ol></div><h1><code>RESP</code>数据类型</h1><ol><li>单行字符串: 首字节是<code>'+'</code>，后面跟上单行字符串，以<code>CRLF(&quot;\r\n&quot;)</code>结尾。但是字符串内不能带有<code>\r\n</code>这种(可以理解成是<strong>二进制不安全</strong>的)</li><li>错误: 首字节是<code>'-'</code>，与单行字符串格式一样，只是字符串是异常信息</li><li>数值: 首字节是<code>':'</code> ，后面跟数字格式的字符串，以<code>CRLF</code>结尾</li><li>多行字符串: 首字节是<code>'$'</code>，表示<strong>二进制安全</strong>的字符串，最大<code>512MB</code>，不用担心字符串内部出现<code>\r\n</code><ul><li>例如: <code>&quot;$5\r\nhello\r\n&quot;</code>，这里的<code>5</code>表示要读五个字符</li><li>如果是<code>0</code>表示空字符串<code>&quot;$0\r\n\r\n&quot;</code></li><li>如果是<code>-1</code>，表示不存在<code>&quot;$-1\r\n&quot;</code></li></ul></li><li>数组: 首字符<code>'*'</code>，后面跟上数组元素个数，再跟上元素，元素类型不限</li></ol><h1>内存回收</h1><h2 id="过期策略">过期策略</h2><ul><li><code>expire</code>对<code>key</code>设置<code>TTL</code>，超时自动释放内存</li></ul><div class="note info flat"><p><code>Redis</code>如何知道一个<code>key</code>是否过期</p><ul><li>Redis的数据库结构体中，有两个<code>dict</code>，一个用来保存<code>key-value</code>，另一个用来记录<code>key-TTL</code></li></ul></div><div class="note info flat"><p>是不是<code>TTL</code>到期就立即删除了</p><ul><li>惰性删除，不是在<code>TTL</code>到期后就立即删除了，而是在访问一个<code>key</code>(增删改查)，检查<code>key</code>的存活时间，如果已经过期了，才执行删除</li><li>周期删除，一个定时任务，周期性抽样部分过期的<code>key</code>，然后执行删除，有两种周期<ol><li><code>Redis</code>会设置一个定时任务<code>serverCron()</code>，会按照<code>server.hz</code>的频率来执行过期<code>key</code>的清理，模式为<code>SLOW</code>。(执行频率低，执行时间长)</li><li>每个事件循环前会调用<code>beforeSleep()</code>函数，执行过期<code>key</code>清理，模式为<code>FAST</code>(执行频率高，执行时间短，几十微秒)<ul><li><code>SLOW</code>模式规则<ul><li>执行频率受到<code>server.hz</code>影响，默认为10，每秒执行10次，每次100ms</li><li>执行清理耗时不超过一次执行周期的25%</li><li>逐个遍历<code>DB</code>，逐个遍历<code>DB</code>中的<code>bucket</code>，抽取20个<code>key</code>判断是否过期</li><li>如果没有达到时间上限25ms并且过期<code>key</code>比例大于10%，再进行一次抽样，否则结束</li></ul></li><li>FAST模式规则<ul><li>执行频率受到<code>beforeSleep()</code>调用频率影响，但是两次<code>FAST</code>模式间隔不超过2ms</li><li>执行清理耗时不超过1ms</li><li>逐个遍历<code>DB</code>，逐个遍历<code>DB</code>中的<code>bucket</code>，抽取20个<code>key</code>判断是否过期</li><li>如果没有达到时间上限1ms并且过期<code>key</code>比例大于10%，再进行一次抽样，否则结束</li></ul></li></ul></li></ol></li></ul></div><h2 id="淘汰策略">淘汰策略</h2><ul><li>当<code>Redis</code>内存使用达到设置的阈值时，<code>Redis</code>主动挑选部分<code>key</code>删除以释放更多内存</li><li>在处理客户端命令方法<code>processCommand()</code>中尝试做内存淘汰</li><li>删除<code>key</code>策略：<ol><li><code>noeviction</code>: 默认，不淘汰任何<code>key</code>，但是内存满时不允许写入新数据</li><li><code>volatile-ttl</code>：设置了<code>TTLkey</code>，比较<code>key</code>的剩余<code>TTL</code>值，<code>TTL</code>越小越先被淘汰</li><li><code>allkeys-random</code>: 对<strong>全体</strong><code>key</code>，随机淘汰，也就是直接从<code>db-&gt;dict</code>中随机挑选</li><li><code>volatile-random</code>: 设置了<code>TTL</code>的<code>key</code>，随机淘汰，也就是从<code>db-&gt;expires</code>中随机挑选</li><li><code>allkeys-lru</code>：最少最近使用，当前时间减去最后一次访问时间，值越大淘汰优先级越高</li><li><code>volatile-lru</code>:对设置了<code>TTL</code>的<code>key</code>，使用<code>LRU</code>算法进行淘汰</li><li><code>allkeys-lfu</code>: 最少频率使用，会统计每个<code>key</code>的访问频率，值越小淘汰优先级越高</li><li><code>volatile-lfu</code>: 对设置了<code>TTL</code>的<code>key</code>，基于<code>LFU</code>算法进行淘汰</li></ol></li></ul><div class="note info flat"><p><code>LRU, LFU</code>记录在<code>RedisObject</code>中，<code>LRU</code>以<strong>秒</strong>为单位记录最近一次访问时间，长度为<code>24bit</code><br><code>LFU</code>的高16位以<strong>分钟</strong>为单位记录最近一次访问时间，低8位记录<strong>逻辑访问次数</strong></p><ul><li>逻辑访问次数，不是每次key访问都计数，而是运算得到<ul><li>生成<code>0~1</code>之间随机数<code>R</code></li><li>计算<code>1 / (旧次数 * lfu_log_factor + 1)</code>记录为<code>P</code>，<code>lfu_log_factor</code>默认为10</li><li>如果<code>R &lt; P</code>,则计数器+ 1，最大不超过255</li><li>访问次数会随时间衰减，距离上一次访问时间间隔<code>lfu_decay_time</code>(分钟，默认1)，计数器-1</li></ul></li></ul></div><p><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Redis/expire.png" alt="expire"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;code&gt;QuickList&lt;/code&gt;&lt;/h1&gt;
&lt;div class=&quot;note info flat&quot;&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ZipList&lt;/code&gt;虽然节省内存，但是申请的是&lt;strong&gt;连续的空间&lt;/strong&gt;，如果内存占用较多，内存申请效率</summary>
      
    
    
    
    <category term="Redis" scheme="https://sangs3112.github.io/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://sangs3112.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis笔记_4</title>
    <link href="https://sangs3112.github.io/posts/31b28291.html"/>
    <id>https://sangs3112.github.io/posts/31b28291.html</id>
    <published>2024-03-23T16:11:10.000Z</published>
    <updated>2024-07-23T17:18:51.910Z</updated>
    
    <content type="html"><![CDATA[<h1>简单动态字符串<code>SDS</code></h1><div class="note info flat"><p>传统的C语言字符串存在问题:<br>1. 获取字符串长度需要通过运算<br>2. 非二进制安全，如果中间有一个<code>\0</code>则字符串直接结束了<br>3. 不可修改</p></div><p><code>set name sangs</code>: 这条命令会在底层创建两个<code>SDS</code>，分别是<code>name</code> 和 <code>sangs</code>的<code>SDS</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span>&#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> len;            <span class="comment">// buf已保存的字符串字节数，不包含结束标识</span></span><br><span class="line">    <span class="type">uint8_t</span> alloc;          <span class="comment">// buf申请的总字节数，不包含结束标识，第一次触发时，申请内存一般和len一样</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags;    <span class="comment">// 不同的SDS头类型，用来控制SDS的头大小</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><table>    <tr>        <!-- <td rowspan="">数值</td> -->        <td>len: 4</td><td>alloc: 4</td><td>flags: 1</td><td>n</td><td>a</td><td>m</td><td>e</td><td>\0</td>    </tr></table><div class="note info flat"><ul><li>由于通过<code>len</code>判断需要读取多少位，所以是<strong>二进制安全</strong>的，不会读取到一半终止</li><li>之所以叫动态字符串，是因为具备动态扩容的能力。如果要给<code>SDS</code>追加一段字符串，就会申请<strong>新的内存空间</strong>，即为<strong>内存预分配</strong><ul><li>如果<strong>新字符串长度小于</strong><code>1M</code>，则新空间为扩展后字符串长度的<code>两倍+1</code></li><li>如果<strong>新字符串长度大于</strong><code>1M</code>，则新空间为扩展后字符串长度<code>+1M+1</code></li></ul></li></ul></div><h2 id="举例">举例</h2><table>    <tr>        <td>len: 2</td><td>alloc: 2</td><td>flags: 1</td><td>h</td><td>i</td><td>\0</td>    </tr></table><table>    <tr>        <td>len: 6</td><td>alloc: 12</td><td>flags: 1</td><td>h</td><td>i</td><td>,</td><td>A</td><td>m</td><td>y</td><td>\0</td><td> </td><td> </td><td> </td><td> </td><td> </td><td> </td>    </tr></table><h2 id="优点">优点</h2><ol><li>获取字符串长度的时间复杂度为<code>O(1)</code></li><li>支持动态扩容</li><li>减少内存分配次数</li><li>二进制安全</li></ol><h1><code>IntSet</code></h1><div class="note info flat"><ul><li>是<code>set</code>集合的一种实现方式，基于<strong>整数数组</strong>实现。</li><li>长度可变</li><li><strong>有序</strong></li></ul></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typeder <span class="class"><span class="keyword">struct</span> <span class="title">intset</span>&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding;  <span class="comment">// 编码方式，支持16位，32位，64位整数</span></span><br><span class="line">    <span class="type">uint32_t</span> length;    <span class="comment">// 元素个数</span></span><br><span class="line">    <span class="type">int8_t</span> contents[];  <span class="comment">// 整数数组，保存集合数据，指针，指向数组第一个地址</span></span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure><h2 id="IntSet升级"><code>IntSet</code>升级</h2><p>假设有一个<code>IntSet</code>，元素为<code>5, 10 ,20</code>。则采用的编码为<code>INTSET_ENC_INT16</code>，每个整数占用<code>2B</code>，如果此时添加了一个数字<code>50000</code>，超过了<code>int16_t</code>的范围，则会自动升级编码方式到合适的大小</p><ul><li>升级编码为<code>INTSET_ENC_INT32</code>，每个整数占用<code>4B</code>，并按照新的编码方式以及元素个数扩容数组</li><li><strong>倒序</strong>依次将数组中的元素拷贝到扩容后的正确位置(因为正序拷贝会导致后面的数字被覆盖)</li><li>将待添加的元素放入数组末尾</li><li>将<code>IntSet</code>的<code>encoding</code>属性改为<code>INTSET_ENC_INT32</code>，修改<code>length:4</code></li></ul><h2 id="特点">特点</h2><ol><li><code>Redis</code>确保<code>IntSet</code>元素唯一有序</li><li>具备升级机制，可以节省内存空间</li><li>底层采用<strong>二分查找</strong>方式查询</li></ol><div class="note info flat"><ul><li>因为需要连续的内存空间，所以适合<strong>少量的数据</strong>，且<code>IntSet</code><strong>只能</strong>存储整数</li></ul></div><h1><code>Dict</code></h1><div class="note info flat"><ul><li>三个部分组成:<ol><li>哈希表(<code>DickHashTable</code>)</li><li>哈希节点(<code>DictEntry</code>)</li><li>字典(<code>Dict</code>)</li></ol></li></ul></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span>&#123;</span></span><br><span class="line">    dictEntry **table；     <span class="comment">// Entry指针数组，数组中保存的是指向Entry的指针</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;     <span class="comment">// 哈希表大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask; <span class="comment">// 哈希表大小的掩码，总等于size - 1</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;     <span class="comment">// Entry个数</span></span><br><span class="line">&#125; dictht;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span>&#123;</span></span><br><span class="line">    <span class="type">void</span> *key;  <span class="comment">// 键</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">    &#125; v;        <span class="comment">// 值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dcitEntry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;         <span class="comment">// dict类型，内置不同的hash函数</span></span><br><span class="line">    <span class="type">void</span> *privdata;         <span class="comment">// 私有数据，在做特殊hash运算时使用</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];           <span class="comment">// 一个Dict包含两个哈希表，其中一个是当前数据，另一个一般为空，rehash时使用</span></span><br><span class="line">    <span class="type">long</span> rehashidx;         <span class="comment">// rehash进度，-1表示未进行</span></span><br><span class="line">    <span class="type">int16_t</span> pauserehash;    <span class="comment">// rehash是否暂停，1表示暂停，0表示继续</span></span><br><span class="line">&#125;dict;</span><br></pre></td></tr></table></figure><h2 id="Dict扩容"><code>Dict</code>扩容</h2><div class="note info flat"><p>当我们向<code>Dict</code>添加键值对时，<code>Redis</code>首先根据<code>key</code>计算出<code>hash</code>值<code>h</code>，然后利用<code>h &amp; sizemask</code>来计算元素应该存储得到数组中的哪个索引位置。</p><ul><li>因为<code>sizemask</code>的大小恰好是<code>size - 1</code>，所以<code>h &amp; sizemask</code>这个与运算的结果恰好等于对<code>h</code>求余(其实就是<strong>除留余数法</strong>)</li></ul></div><ul><li>如果有<strong>同义词</strong>，则将新插入的元素接在前面，后面跟上原来的数据(这就是使用<strong>拉链法</strong>解决哈希冲突)</li><li>但是如果元素较多，冲突增多，链表过长，则查询效率会大大降低<ul><li>因此每次新增键值对会检查<strong>负载因子</strong>(使用的位置个数和总空间个数的比值)</li><li>哈希扩容:<ol><li>负载因子 &gt;= 1，并且服务器<strong>没有</strong>执行<code>BGSAVE</code>或者<code>BGREWRITEAOF</code>等后台进程</li><li>负载因子 &gt; 5</li></ol></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> _dictExpandIfNeeded (dict *d)&#123;</span><br><span class="line">    <span class="comment">// 如果正在rehash 返回OK</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) <span class="keyword">return</span> DICT_OK;</span><br><span class="line">    <span class="comment">// 如果哈希表为空，则初始化哈希表默认大小为4</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].size == <span class="number">0</span>) <span class="keyword">return</span> dictExpand(d, DICT_HT_INITIAL_SIZE);</span><br><span class="line">    <span class="comment">// 当负载因子(used / size)达到1以上，并且当前没有进行bgrewrite等子进程操作</span></span><br><span class="line">    <span class="comment">// 或者当负载因子超过5，则进行地图Expand，也就是扩容</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used &gt;= d-&gt;ht[<span class="number">0</span>].size &amp;&amp; </span><br><span class="line">        (dict_can_resize || d-&gt;ht[<span class="number">0</span>].used / d-&gt;ht[<span class="number">0</span>].size &gt; dict_force_resize_ratio))&#123;</span><br><span class="line">            <span class="comment">// 扩容大小为used + 1，底层对扩容大小判断，实际上找的是第一个大于等于used + 1的2^n</span></span><br><span class="line">            <span class="keyword">return</span> dictExpand(d, d-&gt;ht[<span class="number">0</span>].used + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Dict收缩"><code>Dict</code>收缩</h2><div class="note info flat"><ul><li>当负载因子小于<strong>0.1</strong>的时候，就会做哈希表收缩</li></ul></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_hash.c hashTypeDeleted()</span></span><br><span class="line"><span class="keyword">if</span> (dictDelete((dict*)o-&gt;ptr, field) == c_OK)&#123;</span><br><span class="line">    deleted = <span class="number">1</span></span><br><span class="line">    <span class="comment">// 删除成功后，需要检查是否重置Dict大小，如果需要则调用dictResize重置</span></span><br><span class="line">    <span class="keyword">if</span>(htNeedsResize(o-&gt;ptr)) dictResize(o-&gt;ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// server.c </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">htNeedsResize</span><span class="params">(dict *dict)</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> size, used;</span><br><span class="line">    <span class="comment">// 哈希表大小</span></span><br><span class="line">    size = dictSlots(dict);</span><br><span class="line">    <span class="comment">// entry数量</span></span><br><span class="line">    used = dictSize(dict);</span><br><span class="line">    <span class="comment">// size &gt; 4(初始大小)并且负载因此低于0.1</span></span><br><span class="line">    <span class="keyword">return</span> (size&gt;DICT_HT_INITIAL_SIZE &amp;&amp; (used*<span class="number">100</span> / size &lt; HASHTABLE_MIN_FILL));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dictResize</span><span class="params">(dict *d)</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> minimal;</span><br><span class="line">    <span class="comment">// 如果正在做bgsave或者bgrewriteof或者rehash，返回错误</span></span><br><span class="line">    <span class="keyword">if</span>(!dict_can_resize || dictIsRehashing(d)) <span class="keyword">return</span> DICT_ERR;</span><br><span class="line">    <span class="comment">// 获取used，也就是entry个数</span></span><br><span class="line">    minimal = d-&gt;ht[<span class="number">0</span>].used;</span><br><span class="line">    <span class="comment">// 如果used小于4，则重置为4</span></span><br><span class="line">    <span class="keyword">if</span>(minimal &lt; DICT_HT_INITIAL_SIZE) minimal = DICT_HT_INITIAL_SIZE;</span><br><span class="line">    <span class="comment">// 重置大小为minimal，其实是第一个大于等于minimal的2^n</span></span><br><span class="line">    <span class="keyword">return</span> dictExpand(d, minimal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="rehash"><code>rehash</code></h2><div class="note info flat"><p>无论是收缩还是扩容，都会创建新的哈希表，导致哈希表的<code>size</code>和<code>sizemask</code>变化，而<code>key</code>的查询与<code>sizemask</code>有关，因此必须对哈希表中的每一个<code>key</code>重新计算索引，插入新的哈希表，这个过程称为<code>rehash</code></p><ol><li>计算新的哈希表的<code>realeSize</code>，取决于当前做的是扩容还是收缩<ul><li>扩容，则新的<code>size</code>为第一个大于等于<code>dict.ht[0].used + 1</code>的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></li><li>收缩，则新的<code>size</code>为第一个大于等于<code>dict.ht[0].used</code>的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>(不得小于4)</li></ul></li><li>按照新的<code>realeSize</code>申请内存空间，创建<code>dictht</code>，并赋值给<code>dict.ht[1]</code></li><li>设置<code>dict.rehashidx=0</code>表示开始<code>rehash</code></li><li>将<code>dict.ht[0]</code>中的每一个<code>dictEntry</code>都<code>rehash</code>到<code>dict.ht[1]</code></li><li>将<code>dict.ht[1]</code>赋值给<code>dict.ht[0]</code>，给<code>dict.ht[1]</code>初始化为空哈希表，释放原来的<code>dict.ht[0]</code>内存</li></ol></div><h3 id="渐进式rehash">渐进式<code>rehash</code></h3><div class="note info flat"><p>但是这样做，一次完成<code>rehash</code>，则很有可能导致<strong>主线程阻塞</strong>，所以实际上是分多次进行<code>rehash</code>，称为<strong>渐进式</strong><code>rehash</code></p><ol><li>计算新的哈希表的<code>realeSize</code>，取决于当前做的是扩容还是收缩<ul><li>扩容，则新的<code>size</code>为第一个大于等于<code>dict.ht[0].used + 1</code>的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></li><li>收缩，则新的<code>size</code>为第一个大于等于<code>dict.ht[0].used</code>的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>(不得小于4)</li></ul></li><li>按照新的<code>realeSize</code>申请内存空间，创建<code>dictht</code>，并赋值给<code>dict.ht[1]</code></li><li>设置<code>dict.rehashidx=0</code>表示开始<code>rehash</code><br><s>4. 将<code>dict.ht[0]</code>中的每一个<code>dictEntry</code>都<code>rehash</code>到<code>dict.ht[1]</code></s></li><li>每次执行增删改查操作时，检查一下<code>dict.rehashidx</code>是否大于-1，如果是则将<code>dict.ht[0].table[rehashidx]</code>的<code>entry</code>链表<code>rehash</code>到<code>dict.ht[1]</code>，并且将<code>rehashidx ++</code>，直到<code>dict.ht[0]</code>的所有数据都<code>rehash</code>到<code>dict.ht[1]</code></li><li>将<code>dict.ht[1]</code>赋值给<code>dict.ht[0]</code>，给<code>dict.ht[1]</code>初始化为空哈希表，释放原来的<code>dict.ht[0]</code>内存.</li><li>将<code>rehashidx</code>赋值为-1，表示<code>rehash</code>结束</li><li>在<code>rehash</code>过程中，新增操作直接写入<code>ht[1]</code>，查询修改和删除则会在<code>dict.ht[0], dict.ht[1]</code>依次查找并执行，可以确保<code>ht[0]</code>中的数据只减不增，随着<code>rehash</code>最终为空</li></ol></div><h1><code>ZipList</code></h1><div class="note info flat"><ul><li>节省内存</li><li>一种特殊的&quot;双端链表&quot;，实际上<strong>并不是链表</strong>，只是一系列特殊编码的<strong>连续</strong>内存组成的，可以在任意一端进行压入、弹出操作，并且时间复杂度为<code>O(1)</code>的数据结构</li></ul></div><p><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Redis/ziplist.png" alt="ziplist"></p><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">类型</th><th style="text-align:center">长度</th><th style="text-align:center">用途</th></tr></thead><tbody><tr><td style="text-align:center">zlbytes</td><td style="text-align:center">uint32_t</td><td style="text-align:center">4B</td><td style="text-align:center">记录整个压缩列表占用的内存字节数</td></tr><tr><td style="text-align:center">zltail</td><td style="text-align:center">uint32_t</td><td style="text-align:center">4B</td><td style="text-align:center">记录压缩列表表尾节点距离压缩列表的起始地址有多少字节，通过这个偏移量，可以确定尾节点的位置</td></tr><tr><td style="text-align:center">zllen</td><td style="text-align:center">uint16_t</td><td style="text-align:center">2B</td><td style="text-align:center">记录压缩列表包含的节点数量，最大值为UINT16_MAX(65534)，超过这个值会记录为65535，但是节点的真实数量需要遍历整个压缩列表才能计算得出</td></tr><tr><td style="text-align:center">entry</td><td style="text-align:center">列表节点</td><td style="text-align:center">不定</td><td style="text-align:center">压缩列表包含的各个节点，节点长度由节点保存的内容决定</td></tr><tr><td style="text-align:center">zlend</td><td style="text-align:center">uint8_t</td><td style="text-align:center">1B</td><td style="text-align:center">特殊值0xff，用于标记压缩列表的末端</td></tr></tbody></table><h2 id="ZipListEntry"><code>ZipListEntry</code></h2><ul><li>每一个<code>Entry</code>内部又包含了三个部分，分别为  <table>      <tr>          <td>previous_entry_length</td><td>encoding</td><td>content</td>      </tr>  </table></li><li><code>previous_entry_length</code>: 前一个节点的长度，占<code>1 or 5</code>字节<ul><li>如果前一个节点的长度小于254，则采用<code>1B</code>来保存这个长度</li><li>如果前一个字节的长度大于254，则采用<code>5B</code>来保存这个长度，其中第一个字节为<code>0xfe</code>,后面四个字节才是真实长度数据(所以字节的长度不能太大)</li></ul></li><li><code>encoding</code>: 编码属性，记录<code>content</code>的数据类型(字符串还是整数)以及长度，占用1，2，或者5个字节</li><li><code>contents</code>: 负责保存节点的数据，可以是字符串或者整数</li><li>这样可以避免使用两个指针记录前后节点，这样需要消耗16个字节，浪费内存。</li><li>小端存储</li></ul><h2 id="Encoding编码"><code>Encoding</code>编码</h2><h3 id="字符串编码-以00-01-10开头则content为字符串">字符串编码: 以<code>00, 01, 10</code>开头则<code>content</code>为字符串</h3><table><thead><tr><th style="text-align:center">编码</th><th style="text-align:center">编码长度</th><th style="text-align:center">字符串大小</th></tr></thead><tbody><tr><td style="text-align:center">|00pppppp|</td><td style="text-align:center">1B</td><td style="text-align:center">&lt;= 63B</td></tr><tr><td style="text-align:center">|01pppppp|qqqqqqqq|</td><td style="text-align:center">2B</td><td style="text-align:center">&lt;= 16383 B</td></tr><tr><td style="text-align:center">|10000000|qqqqqqqq|rrrrrrrr|ssssssss|tttttttt|</td><td style="text-align:center">5B</td><td style="text-align:center">&lt;= 4294967295B</td></tr></tbody></table><ul><li>例如保存’ab’, ‘bc’:<br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Redis/abbc.png" alt="abbc"></li></ul><h3 id="整数编码-以11开头，则content为整数，并且encoding固定占用一个字节">整数编码: 以<code>11</code>开头，则<code>content</code>为整数，并且<code>encoding</code><strong>固定占用一个字节</strong></h3><table><thead><tr><th style="text-align:center">编码</th><th style="text-align:center">编码长度</th><th style="text-align:center">字符串大小</th></tr></thead><tbody><tr><td style="text-align:center">11000000</td><td style="text-align:center">1</td><td style="text-align:center">int16_t(2B)</td></tr><tr><td style="text-align:center">11010000</td><td style="text-align:center">1</td><td style="text-align:center">int32_t(4B)</td></tr><tr><td style="text-align:center">11100000</td><td style="text-align:center">1</td><td style="text-align:center">int64_t(8B)</td></tr><tr><td style="text-align:center">11110000</td><td style="text-align:center">1</td><td style="text-align:center">24位有符号整数(3B)</td></tr><tr><td style="text-align:center">11111110</td><td style="text-align:center">1</td><td style="text-align:center">8位有符号整数(1B)</td></tr><tr><td style="text-align:center">1111xxxx</td><td style="text-align:center">1</td><td style="text-align:center">直接在xxxx位置保存数值，范围从0001~1101，减一后结果为实际值，实际上保存了(0~12)</td></tr></tbody></table><ul><li>例如保存2, 5:<br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Redis/25.png" alt="25"></li></ul><h2 id="连锁更新问题">连锁更新问题</h2><ul><li>每个<code>entry</code>都包含<code>previous_entry_length</code>来记录上一个节点大小，长度是<code>1 or 5</code>字节<ul><li>假设有<code>N</code>个连续的，长度为<code>250~253</code>字节之间的<code>entry</code>，只需要使用<code>1B</code>即可</li><li>如果在第一个节点插入一个大小为<code>254B</code>的<code>entry</code>，就需要占用<code>5B</code>，此时导致后面的每一个<code>entry</code>大小都恰好达到了<code>254B</code>，导致了每个元素都需要改变<br>最终产生了连续多次空间扩展操作，就是<strong>连锁更新</strong>。新增，删除都有可能导致连锁更新</li></ul></li><li>因为概率很低，所以暂时还没有完全解决。目前有新的<code>listpack</code>可以在一定程度上解决<code>ZipList</code>的连锁更新问题，但是还没有完全引入</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;简单动态字符串&lt;code&gt;SDS&lt;/code&gt;&lt;/h1&gt;
&lt;div class=&quot;note info flat&quot;&gt;&lt;p&gt;传统的C语言字符串存在问题:&lt;br&gt;
1. 获取字符串长度需要通过运算&lt;br&gt;
2. 非二进制安全，如果中间有一个&lt;code&gt;&#92;0&lt;/code&gt;则字符串</summary>
      
    
    
    
    <category term="Redis" scheme="https://sangs3112.github.io/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://sangs3112.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis笔记_3</title>
    <link href="https://sangs3112.github.io/posts/afd61732.html"/>
    <id>https://sangs3112.github.io/posts/afd61732.html</id>
    <published>2024-03-23T00:16:45.000Z</published>
    <updated>2024-07-23T17:18:51.910Z</updated>
    
    <content type="html"><![CDATA[<h1>传统缓存的问题</h1><p>传统缓存策略是请求到达<code>Tomcat</code>后，先查询<code>Redis</code>，如果未命中则查询数据库:</p><ol><li>请求经过<code>Tomcat</code>处理，性能成为整个系统的瓶颈</li><li><code>Redis</code>缓存失效时，对数据库产生冲击</li></ol><p>多级缓存就是充分利用请求处理每个缓环节，分别添加缓存，减轻<code>Tomcat</code>压力，提升服务性能。</p><h1>缓存分类</h1><ol><li>分布式缓存比如<code>Redis</code>:<ul><li>优点: 存储容量更大，可靠性更好，可以在集群间共享</li><li>缺点: 访问缓存有网络开销</li><li>场景: 缓存数据量较大，可靠性要求较高，需要在集群间共享</li></ul></li><li>进程本地缓存，比如<code>HashMap、GuavaCache</code>:<ul><li>优点: 读取本地内存，没有网络开销，速度更快</li><li>缺点: 存储容量有限，可靠性较低，无法共享</li><li>场景: 性能要求较高，缓存数据量较小</li></ul></li></ol><p><img src="https://gitee.com/sang3112/blog_imgs/raw/98bb67431bb6b9cd36eece37d38e4128f45c9f77/Redis/multicache.jpg" alt="multicache"></p><h1><code>Caffeine</code></h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Cache&lt;String, String&gt; cache = Caffeine.newBuilder().build();</span><br><span class="line">cache.put(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>)</span><br><span class="line"><span class="comment">// 取数据，如果没有则返回NULL，使用较少</span></span><br><span class="line"><span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> cache.getIfPresent(<span class="string">&quot;key&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取数据，如果没有则使用第二个函数，可以查询数据库</span></span><br><span class="line"><span class="type">String</span> <span class="variable">defaultKey</span> <span class="operator">=</span> cache.get(<span class="string">&quot;key&quot;</span>, key-&gt;&#123;</span><br><span class="line">    <span class="comment">// 写查询数据库代码</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="缓存驱逐策略-三种">缓存驱逐策略(三种)</h2><ol><li>基于容量: 设置缓存数量上限<br><code>Cache&lt;String, String&gt; cache = Caffeine.newBuilder().maximumSize(1).build();</code> 设置缓存大小上限为1</li><li>基于时间: 设置缓存的有效时间<br><code>Cache&lt;String, String&gt; cache = Caffeine.newBuilder().expireAfterWrite(Duration.ofSeconds(10)).build();</code> 设置缓存有效期为10秒，从最后一次写入开始计时</li><li>基于引用: 设置缓存为软引用或弱引用，利用<code>GC</code>来回收缓存数据，<strong>性能较差，不建议使用</strong> <div class="note info flat"><ul><li>默认情况下，当一个缓存元素过期时，<code>Caffeine</code><strong>不会</strong>自动立即清理和驱逐，而是在一次读或写操作后，或者在空闲时间完成对失效数据的驱逐。</li></ul></div></li></ol><h2 id="冷启动与缓存预热">冷启动与缓存预热</h2><ul><li>冷启动: 服务刚刚启动时，<code>Redis</code>没有缓存，如果数据都在第一次查询时添加缓存，可能会给数据库带来较大的压力</li><li>缓存预热: 实际开发中，可以利用<strong>大数据统计</strong>用户访问的<strong>热点数据</strong>，项目启动时将这些<strong>热点数据</strong>提前查询并保存到<code>Redis</code>中。如果数据量较少，就直接在启动时将所有的数据都放入<code>Redis</code></li></ul><h2 id="缓存同步策略">缓存同步策略</h2><table><thead><tr><th style="text-align:center">同步策略</th><th style="text-align:center">设置有效期</th><th style="text-align:center">同步双写</th><th style="text-align:center">异步通知</th></tr></thead><tbody><tr><td style="text-align:center">含义</td><td style="text-align:center">给缓存设置有效期，到期自动删除，再次查询时更新</td><td style="text-align:center">修改数据库的同时，直接修改缓存(使用同一个事务实现)</td><td style="text-align:center">修改数据库时发送事件通知，相关服务监听通知后修改缓存数据 (常用) (MQ, Canal)</td></tr><tr><td style="text-align:center">优点</td><td style="text-align:center">简单，方便</td><td style="text-align:center">时效性强，缓存和数据库强一致性</td><td style="text-align:center">低耦合，可以同时通知多个缓存服务</td></tr><tr><td style="text-align:center">缺点</td><td style="text-align:center">时效性差，缓存过期之前可能数据不一致</td><td style="text-align:center">有代码侵入风险，耦合度高</td><td style="text-align:center">时效性一般，可能存在中间不一致状态</td></tr><tr><td style="text-align:center">使用场景</td><td style="text-align:center">更新频率较低，适合时效性要求低的业务</td><td style="text-align:center">对一致性、时效性要求较高的缓存数据</td><td style="text-align:center">时效性要求一般，有多个服务需要同步</td></tr></tbody></table><h3 id="基于MQ实现异步通知">基于<code>MQ</code>实现异步通知</h3><p><img src="https://gitee.com/sang3112/blog_imgs/raw/98bb67431bb6b9cd36eece37d38e4128f45c9f77/Redis/MQ.png" alt="MQ"></p><h3 id="基于Canal实现异步通知">基于<code>Canal</code>实现异步通知</h3><p><img src="https://gitee.com/sang3112/blog_imgs/raw/98bb67431bb6b9cd36eece37d38e4128f45c9f77/Redis/Canal.png" alt="Canal"></p><div class="note info flat"><ul><li>基于<code>Canal</code>，比<code>MQ</code>更好一些，时效性更强，监听效率更高，基于主从同步实现</li><li><code>Canal</code>把自己伪装成<code>MySQL</code>的一个<code>slave</code>，监听<code>master</code>的<code>binlog</code>变化，再把得到的变化信息通知给<code>Canal</code>客户端，完成对其他数据库的同步</li></ul></div><h1><code>Redis</code>设计</h1><h2 id="key设计"><code>key</code>设计</h2><ol><li>遵循基本格式: <code>[业务名称]:[数据名]:[id]</code></li><li>长度不要超过44Bytes</li><li>不包含特殊字符</li></ol><div class="note info flat"><ul><li>比如登录业务，保存用户信息，设计<code>key</code>就是: <code>login:user:10</code></li><li>长度越小占用的空间越少，所以<code>key</code>满足可读性，应该尽可能短</li></ul></div><div class="note info flat"><p>好处:</p><ol><li>可读性强</li><li>避免<code>key</code>冲突</li><li>方便管理</li><li>更节省内存，<code>key</code>是<code>string</code>，底层编码包含<code>int、embstr、raw</code>，其中<code>embstr</code>是一块连续空间，占用空间更少，更加紧凑。但是<code>embstr</code>需要在<code>key</code>小于44B使用</li></ol></div><h2 id="value设计"><code>value</code>设计</h2><div class="note info flat"><ul><li><code>BigKey</code>，通常以<code>Key</code>的大小和<code>Key</code>中成员的数量来总和判定，比如:<ul><li><code>Key</code>本身数据量过大，一个<code>String</code>类型的<code>Key</code>，它的值为5MB</li><li><code>Key</code>中的成员数目过多，一个<code>ZSET</code>类型的<code>Key</code>，它的成员数量为10000个</li><li><code>Key</code>中的成员数据量过大，一个<code>Hash</code>类型的<code>Key</code>，成员数量虽然只有1000个，但是这些<code>Value</code>的总大小为100MB</li></ul></li></ul></div><ul><li><p><code>BigKey</code>危害:</p><ol><li>网络阻塞: 对<code>BigKey</code>读请求，少量的<code>QPS</code>就会导致带宽使用率被占满，导致<code>Redis</code>实例，乃至物理机变慢</li><li>数据倾斜: <code>BigKey</code>所在的<code>Redis</code>实例内存使用率远超其他实例，无法使数据分片的内存资源达到均衡</li><li><code>Redis</code>阻塞: 对元素较多的<code>hash, list, zset</code>等做运算会耗时较久，使主线程阻塞</li><li><code>CPU</code>压力: 对<code>BigKey</code>的数据序列化和反序列化都会导致<code>CPU</code>的使用率飙升，影响<code>Redis</code>实例和本机其他应用</li></ol></li><li><p>如何发现<code>BigKey</code>:</p><ol><li><code>redis-cli --bigkeys</code>: 利用<code>redis-cli</code>提供的<code>--bigkeys</code>，分析所有的key，返回<code>Key</code>整体统计信息与每个数据最大的<code>Big Key</code></li><li><code>scan</code>扫描: 自己编程利用<code>scan</code>扫描<code>Redis</code>中所有的<code>Key</code>，利用<code>strlen, hlen</code>等命令判断长度，不建议使用<code>memory usage</code>，因为这个命令对<code>CPU</code>占用较高</li><li>第三方工具，比如<code>Redis-Rdb-Tools</code>分析<code>RDB</code>快照，全面分析内存使用</li><li>网络监控: 自定义工具，监控进入<code>Redis</code>网络数据，超出预警值主动告警</li></ol></li></ul><div class="note info flat"><ul><li>推荐做法<ol><li>单个<code>key</code>的<code>value</code>小于<code>10KB</code></li><li>对于集合类型的<code>Key</code>，建议元素数量小于1000</li><li>使用<code>unlink</code>异步删除<code>BIGKEY</code></li></ol></li></ul></div><h2 id="恰当的数据类型">恰当的数据类型</h2><p>存储一个<code>User</code>对象，有三种方法:</p><ol><li><p><code>Json</code>字符串</p> <table>     <tr>         <td>user:1</td><td>{"name": "Jack", "age": 21}</td>     </tr> </table><ul><li>优点: 实现简单粗暴</li><li>缺点: 数据耦合不够灵活</li></ul></li><li><p>字段打散</p> <table>     <tr>         <!-- <td rowspan="">数值</td> -->         <td>user:1:name</td><td>Jack</td>     </tr>     <tr>         <td>user:1:age</td><td>21</td>     </tr> </table><ul><li>优点: 可以灵活访问对象任意字段</li><li>缺点: 占用空间大，没有办法做统一控制</li></ul></li><li><p>hash</p> <table>     <tr>         <td rowspan="2">user:1</td>         <td>name</td><td>age</td>     </tr>     <tr>         <td>jack</td><td>21</td>     </tr> </table><ul><li>优点: 底层使用<code>ziplist</code>，占用空间小，可以灵活访问对象的任意字段</li><li>缺点: 代码相对复杂</li></ul></li></ol><div class="note info flat"><ul><li>假如有<code>hash</code>类型的<code>key</code>，其中有100万对<code>field, value</code>，其中<code>field</code>是自增id，这个<code>key</code>有什么问题，如何优化?<ul><li>存在的问题:<ol><li><code>hash</code>的<code>entry</code>数量超过500时，会使用哈希表，而不是<code>ZipList</code>，内存占用较多</li></ol></li><li>优化:<ol><li>可以通过<code>hash-max-ziplist-entries</code>配置<code>entry</code>上限，但是如果<code>entry</code>过多就会导致<code>BigKey</code>问题</li><li>拆分为<code>string</code>类型: 但是<code>string</code>底层没有太多内存优化，内存占用较多；想要批量获取这些数据比较麻烦</li><li>拆分为小的<code>hash</code>，将<code>id/100</code>作为<code>key</code>，将<code>id % 100</code>作为<code>field</code>，这样每一百个元素就是一个<code>hash</code></li></ol></li></ul></li></ul></div><div class="note info flat"><ul><li>推荐做法<ol><li>合理拆分数据，拒绝<code>BigKey</code></li><li>选择合适的数据结构</li><li><code>Hash</code>结构的<code>entry</code>数量不要超过1000</li><li>设置合理的超时时间</li></ol></li></ul></div><h2 id="批处理">批处理</h2><ul><li><p><code>Redis</code>的处理速度非常快，消耗的时间绝大部分都是在网络传输中消耗。</p></li><li><p>所以可以一次性传输多条数据，但是不能传输太多命令，否则这样单次命令占用的带宽过多，会导致网络阻塞</p></li><li><p><code>mset</code>只能处理<code>string</code>类型的，<code>hmset</code>, <code>sadd</code>都只能处理相同的<code>key</code>，所以有缺陷，因此需要实现<code>pipeline</code></p></li><li><p><code>pipeline</code>可以处理复杂类型，但是<code>pipeline</code>的多个命令之间<strong>不具备原子性</strong></p></li><li><p>如果<code>mset</code>或者<code>pipeline</code>这样的批处理需要在一次请求中携带多条命令，并且此时<code>Redis</code>是一个集群，那么批处理的多个<code>key</code>必须在同一个<code>slot</code>中，否则执行失败。</p></li></ul><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">串行命令</th><th style="text-align:center">串行slot</th><th style="text-align:center">并行slot</th><th style="text-align:center">hash_tag</th></tr></thead><tbody><tr><td style="text-align:center">实现思路</td><td style="text-align:center">for循环遍历，依次执行每个命令</td><td style="text-align:center">在客户端计算每个key的slot，将slot一致分为一组，每组都利用pipeline批处理，串行执行各组命令</td><td style="text-align:center">在客户算计算每个key的slot，每组都利用pipeline批处理，并行执行各组命令</td><td style="text-align:center">将所有的key都设置相同的hash_tag，则所有key的slot都一定相同</td></tr><tr><td style="text-align:center">耗时</td><td style="text-align:center">N次网络耗时+N次命令耗时</td><td style="text-align:center">m次网络耗时+N次命令耗时，m = key的slot个数</td><td style="text-align:center">1次网络耗时+N次命令耗时</td><td style="text-align:center">1次网络耗时+N次命令耗时</td></tr><tr><td style="text-align:center">优点</td><td style="text-align:center">实现简单</td><td style="text-align:center">耗时较短</td><td style="text-align:center">耗时非常短</td><td style="text-align:center">耗时非常短、实现简单</td></tr><tr><td style="text-align:center">缺点</td><td style="text-align:center">耗时非常久</td><td style="text-align:center">实现稍复杂，slot越多，耗时越久</td><td style="text-align:center">实现复杂(用的较多)</td><td style="text-align:center">容易出现数据倾斜(所以不怎么用，虽然性能好)</td></tr></tbody></table><h2 id="持久化配置">持久化配置</h2><ul><li>保证数据安全，但是会带来额外的开销</li></ul><div class="note info flat"><ul><li>推荐做法<ol><li><p>用来做缓存的<code>Redis</code>实例尽量不要开启持久化功能，放在一个单独实例里面，就不要开启持久化了</p></li><li><p>建议关闭<code>RDB</code>持久化功能，使用<code>AOF</code>持久化，因为<code>AOF</code>每秒刷盘</p></li><li><p>利用脚本定期在<code>slave</code>节点做<code>RDB</code>，实现数据备份。(也不建议频繁做)</p></li><li><p>设置合理的<code>rewrite</code>阈值，避免频繁的<code>bgrewrite</code></p></li><li><p>配置<code>no-appendfsync-on-rewrite=yes</code>，禁止在<code>rewrite</code>期间做<code>AOF</code>，避免因为<code>AOF</code>引起的阻塞。但是这部分期间，没有做<code>AOF</code>，所以有可能有数据的丢失，这需要看自己是关注可用性还是持久性</p></li><li><p><code>Redis</code>实例的物理机需要留足够的内存，应对<code>fork</code>和<code>rewrite</code></p></li><li><p>单个<code>Redis</code>实例内存上限不要太大，比如4G或8G，可以加快<code>fork</code>的速度，减少主从同步，数据迁移压力</p></li><li><p>不要与CPU密集型应用部署在一起，比如<code>ES</code></p></li><li><p>不要与高硬盘负载应用部署在一起，比如数据库，消息队列</p></li></ol></li></ul></div><h2 id="慢查询">慢查询</h2><ul><li>只要执行时间超时了，不管是是不是查询语句，都是慢查询</li><li><code>slowlog-log-slower-than</code>: 慢查询阈值，单位是微秒，默认是10000，建议配置成1000</li><li>慢查询会放入慢查询日志中，日志长度有上限，可以通过配置指定<code>slowlog-max-len</code>，本质是一个队列的长度，默认是129，建议配置成1000，并且需要及时处理</li><li><code>slowlog len</code>: 查询慢查询日志长度</li><li><code>slowlog get[n]</code>: 读取n条慢查询日志</li><li><code>slowlog reset</code>: 清空慢查询列表</li></ul><h2 id="安全性问题">安全性问题</h2><ol><li><code>Redis</code>一定要设置密码</li><li>禁止线上使用<code>keys , flushall, flushdb, config set</code>命令，可以利用<code>rename-command</code>禁用</li><li><code>bind</code>: 限制网卡，禁止外网网卡访问</li><li>开启防火墙</li><li>不要使用<code>root</code>账户启动<code>Redis</code></li><li>尽量不是默认的端口</li></ol><h2 id="内存配置">内存配置</h2><ul><li><p>内存不足会导致<code>Key</code>频繁被删除，响应时间变长，QPS不稳定，当内存使用率达到90%以上就需要警惕了，并快速定位到内存占用的原因</p><table><thead><tr><th style="text-align:center">内存占用</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">数据内存</td><td style="text-align:center">是Redis最主要的部分，存储Redis键值信息，主要是BigKey问题，内存碎片问题</td></tr><tr><td style="text-align:center">进程内存</td><td style="text-align:center">Redis本身运行肯定占用内存，比如代码，常量池，大约几兆，大多数生产环境中与Redis数据占用的内存相比可以忽略</td></tr><tr><td style="text-align:center">缓冲区内存</td><td style="text-align:center">一般包括客户端缓冲区，AOF缓冲区，复制缓冲区等，客户端缓冲区又包括输入缓冲区和输出缓冲区。这部分内存占用波动较大，不当使用BigKey，可能导致内存溢出</td></tr></tbody></table></li><li><p>复制缓冲区: 主从复制的<code>repl_backlog_buf</code>，如果太小可能导致频繁的全量复制，影响性能，通过<code>repl-backlog-size</code>设置，默认1M</p></li><li><p>AOF缓冲区: AOF刷盘之前的缓冲区，执行<code>rewrite</code>的缓冲区，无法设置容量上限</p></li><li><p>客户端缓冲区: 分为输入缓冲区和输出缓冲区，输入缓冲区最大1G不能设置，输出缓冲区可以设置</p></li></ul><h2 id="集群">集群</h2><h3 id="完整性配置">完整性配置</h3><ul><li><code>Redis</code>配置中，发现任意一个插槽不可用，则整个集群都停止对外服务。</li><li>为了保证高可用性，建议将<code>cluster-require-full-coverage</code>配置为<code>no</code>，默认是<code>yes</code></li></ul><h3 id="带宽问题">带宽问题</h3><ul><li><p>集群节点之间会不断的互相<code>ping</code>来确定集群中其他节点的状态，每次<code>ping</code>携带的信息至少包括</p><ul><li>插槽信息</li><li>集群状态信息</li></ul></li><li><p>集群中节点越多，集群状态信息数据量也就越大，10个节点的相关信息可能达到1kb，此时每次集群互通需要的带宽会非常高</p></li><li><p>解决办法:</p><ol><li>避免大集群，集群节点数不要太多，最好少于1000，如果业务庞大，则需要建立多个集群</li><li>避免在单个物理机中运行太多<code>Redis</code>实例</li><li>配置合适的<code>cluster-node-timeout</code></li></ol></li></ul><h3 id="集群问题">集群问题</h3><ol><li>完整性问题</li><li>带宽问题</li><li>数据倾斜问题</li><li>客户端性能问题</li><li>命令的集群兼容性问题</li><li>lua和事务问题(集群模式下没有办法使用lua和事务)</li></ol><div class="note info flat"><ul><li>满足需求的前提下，能不使用集群就不用集群。因为单体主从<code>Redis</code>已经能达到<strong>万级QPS</strong>，已经能满足大部分需求了</li></ul></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;传统缓存的问题&lt;/h1&gt;
&lt;p&gt;传统缓存策略是请求到达&lt;code&gt;Tomcat&lt;/code&gt;后，先查询&lt;code&gt;Redis&lt;/code&gt;，如果未命中则查询数据库:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;请求经过&lt;code&gt;Tomcat&lt;/code&gt;处理，性能成为整个系统的瓶颈&lt;/l</summary>
      
    
    
    
    <category term="Redis" scheme="https://sangs3112.github.io/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://sangs3112.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis笔记_2</title>
    <link href="https://sangs3112.github.io/posts/d8d127a4.html"/>
    <id>https://sangs3112.github.io/posts/d8d127a4.html</id>
    <published>2024-03-22T13:01:20.000Z</published>
    <updated>2024-07-23T17:18:51.910Z</updated>
    
    <content type="html"><![CDATA[<h1>数据持久化</h1><h2 id="RDB"><code>RDB</code></h2><div class="note info flat"><ul><li><code>Redis Database Backup file</code>(<code>Redis</code>数据备份文件)，也叫做<code>Redis</code>数据快照。把内存中的所有数据都记录到磁盘中，故障重启后，从磁盘读取快照文件，恢复数据。</li><li><code>RDB</code>文件称为快照文件，默认保存当前运行目录</li></ul></div><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis-cli</span><br><span class="line">save # 使用save命令来进行快照保存，由Redis主进程执行RDB，阻塞所有命令</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">所以一般不使用save，Redis在停机退出的时候会自动执行save，再次启动会读取RDB，实现默认的持久化</span></span><br><span class="line">bgsave # 开启子进程执行RDB，避免主进程受到影响</span><br></pre></td></tr></table></figure><ul><li><code>redis.conf</code>配置<code>RDB</code>机制</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">save 900 1 # 表示如果900s内至少有1个key被修改，则执行bgsave</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000 </span><br><span class="line"># 如果是save &quot;&quot; 表示禁用RDB</span><br><span class="line"></span><br><span class="line">rdbcompression yes # 是否压缩，建议不开启，因为压缩也会消耗CPU</span><br><span class="line">dbfilename dump.rdb # RDB文件名称</span><br><span class="line">dir ./ # 文件保存路径目录</span><br></pre></td></tr></table></figure><div class="note info flat"><ul><li><code>RDB</code>的<code>bgsave</code>开始时会<code>fork</code>主进程得到子进程，子进程共享主进程的内存数据。完成<code>fork</code>后读取内存数据并写入<code>RDB</code>文件</li><li>但是<code>fork</code>的过程是阻塞的，主进程此时不能处理别的请求。所以要加快<code>fork</code>过程</li></ul></div><ul><li>主进程操作虚拟内存，虚拟内存根据页表的映射关系到物理内存中真正的数据</li><li><code>fork</code>仅仅是把页表做拷贝，即对映射关系做拷贝，因此子进程可以读取相同的数据，写入行的<code>RDB</code>文件</li><li>为了避免在子进程读的时候主进程写，<code>fork</code>采用的是<code>copy-on-write</code>技术<ul><li>主要是将物理内存标记成<code>read-only</code></li><li>主进程读，则访问共享内存</li><li>主进程写，则拷贝一份数据，对副本执行写操作，写完后页表映射关系修改到副本</li><li>极端情况下就是所有数据都要拷贝一份，内存翻倍。所以一般情况下<code>Redis</code>需要预留内存<br><img src="https://gitee.com/sang3112/blog_imgs/raw/dffcbbcd0438066a55be0c2d47d6caf381416a6f/Redis/copyonwrite.png" alt="copyonwrite"></li></ul></li></ul><div class="note info flat"><ul><li><p><code>RDB</code>方式<code>bgsave</code>的基本流程</p><ul><li><code>fork</code>主进程得到一个子进程，共享内存空间</li><li>子进程读取内存数据并写入新的<code>RDB</code>文件</li><li>用新的<code>RDB</code>文件替换旧的<code>RDB</code>文件</li></ul></li><li><p><code>RDB</code>缺点</p><ul><li><code>RDB</code>执行间隔时间长，两次<code>RDB</code>之间写入数据有丢失风险</li><li><code>fork</code>子进程、压缩、写出<code>RDB</code>文件比较耗时</li></ul></li></ul></div><h2 id="AOF"><code>AOF</code></h2><div class="note info flat"><ul><li><code>Apppend Only File</code>(追加文件)，每一个写命令都会记录在<code>AOF</code>中，可以看作是命令日志文件</li><li>默认关闭</li></ul></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes # 是否开启AOF功能，默认为no</span><br><span class="line">appendfilename &quot;appendonly.aof&quot; # AOF文件名</span><br><span class="line"></span><br><span class="line">appendfsync always # 每次执行一次写命令，立即记录到AOF文件中</span><br><span class="line">appendfsync everysec # 写命令执行完写放入AOF缓存，每隔1s将缓冲区数据写到AOF文件，默认方案</span><br><span class="line">appendfsync no # 写命令执行完先放入AOF缓存，操作系统决定何时将缓冲区内容写回磁盘</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">配置项</th><th style="text-align:center">刷盘时机</th><th style="text-align:center">优点</th><th style="text-align:center">缺点</th></tr></thead><tbody><tr><td style="text-align:center">always</td><td style="text-align:center">同步刷盘</td><td style="text-align:center">可靠性高，几乎不丢数据</td><td style="text-align:center">性能影响大</td></tr><tr><td style="text-align:center">everysec</td><td style="text-align:center">每秒刷盘</td><td style="text-align:center">性能适中</td><td style="text-align:center">最多丢失1s数据</td></tr><tr><td style="text-align:center">no</td><td style="text-align:center">操作系统控制</td><td style="text-align:center">性能最好</td><td style="text-align:center">可靠性较差，可能丢失大量数据</td></tr></tbody></table><div class="note info flat"><ul><li>因为同时记录了命令和数据，所以<code>AOF</code>会比<code>RDB</code>文件大很多，并且会记录同一个<code>key</code>的多次写操作，但是只有最后一次的写才有意义，因此可以执行<code>bgrewriteaof</code>命令，让<code>AOF</code>执行重写，用最少的命令达到原来操作相同的结果</li><li>可以在<code>redis.conf</code>中配置<code>AOF</code>重写机制</li></ul></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto-aof-rewrite-percentage 100 # AOF文件比上次文件增占了多少百分比则触发重写</span><br><span class="line">auto-aof-rewrite-min-size 64mb # AOF文件体积最小多大以上才触发重写</span><br></pre></td></tr></table></figure><h2 id="RDB-VS-AOF"><code>RDB</code> VS <code>AOF</code></h2><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">RDB</th><th style="text-align:center">AOF</th></tr></thead><tbody><tr><td style="text-align:center">持久化方式</td><td style="text-align:center">定时对整个内存快照</td><td style="text-align:center">记录每次执行命令</td></tr><tr><td style="text-align:center">数据完整性</td><td style="text-align:center">不完整，两次备份之间会丢失</td><td style="text-align:center">相对完整，取决于刷盘策略</td></tr><tr><td style="text-align:center">文件大小</td><td style="text-align:center">会有压缩，文件体积小</td><td style="text-align:center">记录命令，文件体积大</td></tr><tr><td style="text-align:center">宕机恢复速度</td><td style="text-align:center">很快</td><td style="text-align:center">慢</td></tr><tr><td style="text-align:center">数据恢复优先级</td><td style="text-align:center">低，因为数据完整性不如AOF</td><td style="text-align:center">高，因为数据完整性更高</td></tr><tr><td style="text-align:center">系统资源占用</td><td style="text-align:center">高，大量CPU和内存消耗</td><td style="text-align:center">低，主要是磁盘IO资源，但是AOF重写会占用大量的CPU和内存资源</td></tr><tr><td style="text-align:center">使用场景</td><td style="text-align:center">可以容忍数分钟的数据丢失，更快启动速度</td><td style="text-align:center">对数据安全性要求较高时常见</td></tr></tbody></table><h1><code>Redis</code>主从集群</h1><ul><li>单节点<code>Redis</code>并发能力有上限，进一步提高<code>Redis</code>的并发能力，就需要搭建主从集群，实现读写分离</li><li>启动三个<code>Redis</code>服务，需要配置三台主从关系<ul><li>临时配置: <code>replicaof &lt;masterip&gt; &lt;masterport&gt;</code></li><li>永久配置: 在<code>redis.conf</code>中添加一行: <code>replicaof &lt;masterip&gt; &lt;masterport&gt;</code></li></ul></li></ul><h2 id="数据同步原理">数据同步原理</h2><ul><li>主从第一次同步是全量同步，<code>slave</code>重启后同步，则执行增量同步</li><li>如何判断是否第一次同步:<ul><li><code>replication ID</code>: 简称<code>replid</code>是数据集的标记，<code>ID</code>一致则说明是同一个数据集，每个<code>master</code>都有唯一的<code>replid</code>,<code>slave</code>则会继承<code>master</code>节点的<code>replid</code></li><li><code>offset</code>偏移量，随着记录在<code>repl_baklog</code>中的数据增多而逐渐增大，<code>slave</code>完成同步时也会记录当前同步的<code>offset</code>，如果<code>slave</code>的<code>offset</code>小于<code>master</code>的<code>offset</code>，则说明<code>slave</code>数据落后于<code>master</code>，需要更新</li><li>基于<code>replid</code>判断主从是否一致，如果不一致则表明是第一次同步</li></ul></li></ul><p><img src="https://gitee.com/sang3112/blog_imgs/raw/dffcbbcd0438066a55be0c2d47d6caf381416a6f/Redis/first.png" alt="first"></p><div class="note info flat"><p>全量同步的流程:</p><ol><li><code>slave</code>节点请求增量同步</li><li><code>master</code>节点判断<code>replid</code>，不一致，则拒绝增量同步</li><li><code>master</code>将完整内存数据生成<code>RDB</code>，发送到<code>slave</code></li><li><code>slave</code>清空本地数据，加载<code>master</code>的<code>RDB</code></li><li><code>master</code>将<code>RDB</code>期间的命令记录在<code>repl_backlog</code>，持续将<code>log</code>中的命令发送给<code>slave</code></li><li><code>slave</code>执行接收到的命令，保持与<code>master</code>之间的同步</li></ol></div><p><img src="https://gitee.com/sang3112/blog_imgs/raw/dffcbbcd0438066a55be0c2d47d6caf381416a6f/Redis/second.png" alt="second"></p><ul><li><code>repl_baklog</code>大小有上限，写满后会覆盖最早的数据，如果<code>slave</code>断开时间过久，导致尚未备份的数据被覆盖，则无法基于<code>log</code>做增量同步，只能再次进行全量同步</li></ul><div class="note info flat"><p>优化主从集群:</p><ol><li>在<code>master</code>中配置<code>repl-diskless-sync yes</code>启用无磁盘复制，避免全量同步时的磁盘IO(一般是用于磁盘比较慢，但是网络较快的场景)</li><li><code>Redis</code>单节点上的内存占用不要太大，减少<code>RDB</code>导致的过多的磁盘IO</li><li>减少全量同步的次数: 提高<code>repl_baklog</code>的大小，发现<code>slave</code>宕机则尽快实现故障恢复，避免全量同步</li><li>限制一个<code>master</code>上的<code>slave</code>数量，如果很多<code>slave</code>则使用主从从的链式结构，减少<code>master</code>压力</li></ol></div><div class="note info flat"><p>增量同步 VS 全量同步</p><ol><li>全量同步: <code>master</code>将完整内存数据生成<code>RDB</code>，发送到<code>slave</code>，后续命令记录在<code>repl_baklog</code>中，逐个发送给<code>slave</code></li><li>增量同步: <code>slave</code>提交自己的<code>offset</code>到<code>master</code>，获取<code>repl_baklog</code>中从<code>offset</code>之后的命令给<code>slave</code></li></ol></div><h2 id="哨兵Sentinel">哨兵<code>Sentinel</code></h2><h3 id="作用">作用</h3><ol><li>监控: <code>Sentinel</code>不断检查<code>master</code>和<code>slave</code>是否按照预期工作</li><li>自动故障恢复: 如果<code>master</code>故障，则<code>Sentinel</code>将<code>slave</code>提升为<code>master</code>，故障实例恢复后也会以新的<code>master</code>为主</li><li>通知: <code>Sentinel</code>充当<code>Redis</code>客户端的服务发现来源，集群发生故障转移时，将最新的信息推送给<code>Redis</code>客户端</li></ol><h3 id="判断Redis是否健康">判断<code>Redis</code>是否健康</h3><p>基于心跳机制监测服务状态，每隔1s向集群的每个实例发送<code>PING</code>命令:</p><ul><li>主观下线<code>sdown</code>: 某个<code>sentinel</code>发现节点实例没有在规定时间内响应，则认为其主观下线</li><li>客观下线<code>odown</code>: 超过指定数量<code>quorum</code>的<code>sentinel</code>都认为该实例主观下线，则其客观下线，<code>quorum</code>最好超过<code>sentinel</code>的一半</li></ul><h3 id="主从切换选择依据">主从切换选择依据</h3><ol><li>判断<code>slave</code>节点与<code>master</code>节点断开时间长短，超过指定值<code>down-after-milliseconds * 10</code>会排除该<code>slave</code>节点</li><li>判断<code>slave</code>节点的<code>slave-prority</code>越小优先级越高，如果为0则永不选举</li><li>如果<code>slave-prority</code>则判断<code>slave</code>的<code>offset</code>值，越大越新，优先级越高</li><li>最后判断<code>slave</code>节点的运行<code>ID</code>大小，越小优先级越高</li></ol><h3 id="故障转移">故障转移</h3><ol><li><code>sentinel</code>给<code>slave1</code>发送<code>slaveof no one</code> ，让节点称为<code>master</code></li><li><code>sentinel</code>给其他<code>slave</code>发送<code>slaveof ip port</code>命令，让这些<code>slave</code>称为新的<code>master</code>从节点，开始从新的<code>master</code>上同步数据</li><li><code>sentinel</code>将故障节点标记为<code>slave</code>，故障节点恢复后悔自动成为新的<code>master</code>的<code>slave</code></li></ol><h1><code>Redis</code>分片集群</h1><div class="note info flat"><p>主从集群的问题:</p><ol><li>海量数据存储</li><li>高并发写</li></ol></div><h2 id="分片集群特征">分片集群特征</h2><ol><li>集群中有多个<code>master</code>，每个<code>master</code>保存不同数据(并发写)</li><li>每个<code>master</code>可以有多个<code>slave</code>(并发读)</li><li><code>master</code>通过<code>PING</code>监测彼此健康状态</li><li>客户端请求可以访问集群的任意节点，最终都会被转发到正确的节点<br><img src="https://gitee.com/sang3112/blog_imgs/raw/dffcbbcd0438066a55be0c2d47d6caf381416a6f/Redis/Clustering.png" alt="cluster"></li></ol><div class="note info flat"><p><code>Redis</code>会把每一个<code>master</code>映射到0~16383共16384个<code>hash slot</code>上，查看集群信息就可以看到<br>数据<code>key</code>不是与节点绑定，而是与插槽绑定。<code>redis</code>会根据<code>key</code>的有效部分计算插槽值，分两种情况</p><ul><li><code>key</code>中包含&quot;{}“，且”{}“中至少包含一个字符，”{}&quot;中的部分是有效部分</li><li><code>key</code>中国不包含&quot;{}&quot;，整个<code>key</code>都是有效部分<br>利用<code>CRC16</code>算法得到一个哈希值，然后对16384取余，得到的结果就是<code>slot</code>值<br>如何将同一类数据固定的保存在同一个<code>Redis</code>实例中:</li><li>这一类数据使用相同的有效部分，比如<code>key</code>都以<code>{typeID}</code>为前缀</li></ul></div><h2 id="故障转移-2">故障转移</h2><p>集群中一个<code>master</code>宕机会发生什么?</p><ol><li>实例与其他实例失去链接</li><li>疑似宕机</li><li>确定下线，自动提升一个<code>slave</code>成为新的<code>master</code></li></ol><h2 id="数据迁移">数据迁移</h2><ul><li>利用<code>cluster failover</code>命令可以手动让集群中的某个<code>master</code>宕机，切换到执行<code>cluster failover</code>命令的这个<code>slave</code>及诶单，实现无感知的数据迁移，具体流程为:<br><img src="https://gitee.com/sang3112/blog_imgs/raw/dffcbbcd0438066a55be0c2d47d6caf381416a6f/Redis/movedate.png" alt="movedata"></li><li>手动的<code>failover</code>支持三种不同的模式:<ul><li>默认的流程，例如1~6</li><li><code>force</code>省略了对<code>offset</code>的一致性校验</li><li><code>takeover</code>直接执行第五步，忽略数据一致性，忽略<code>master</code>状态和其他<code>master</code>意见</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;数据持久化&lt;/h1&gt;
&lt;h2 id=&quot;RDB&quot;&gt;&lt;code&gt;RDB&lt;/code&gt;&lt;/h2&gt;
&lt;div class=&quot;note info flat&quot;&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Redis Database Backup file&lt;/code&gt;(&lt;code&gt;Redis&lt;/</summary>
      
    
    
    
    <category term="Redis" scheme="https://sangs3112.github.io/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://sangs3112.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis笔记_1</title>
    <link href="https://sangs3112.github.io/posts/41d8761e.html"/>
    <id>https://sangs3112.github.io/posts/41d8761e.html</id>
    <published>2024-03-21T15:29:26.000Z</published>
    <updated>2024-07-23T17:18:51.910Z</updated>
    
    <content type="html"><![CDATA[<div class="note info flat"><p>全局唯一<code>ID</code>: 经常会需要全局唯一<code>ID</code>，比如订单表的生成。因为</p><ul><li>如果<code>ID</code>自增，则规律性太明显</li><li>并且表中可能存在大量的数据，会受到表单数据量的限制</li></ul></div><div class="note info flat"><p>全局唯一<code>ID</code>生成器特性:</p><ol><li>唯一性</li><li>高可用</li><li>高性能</li><li>递增性</li><li>安全性</li></ol></div><h1>超卖问题</h1><ul><li>原本库存为1，线程1查询后发现库存满足要求。要去扣除库存，但在此之前，线程2，线程3同时查询，发现库存充足。同样满足扣除库存的要求，此时产生了超卖问题</li><li><img src="https://gitee.com/sang3112/blog_imgs/raw/4de21bf55caff74e4e42766859d0389dca4b4b93/Redis/oversell.png" alt="oversell"></li></ul><h2 id="解决方法-加锁">解决方法: 加锁</h2><ol><li><p>乐观锁: 认为线程安全问题不一定发生，因此不加锁，只是在<strong>更新数据时判断有没有其他线程对数据进行了修改</strong></p><ul><li>如果没有修改则认为自己安全，才能更新数据</li><li>如果已经被其他线程修改说明发生了安全问题，此时重试或返回异常</li></ul></li><li><p>悲观锁: 认为线程安全问题一定会发生，因此操作数据之前先获取数据，确保线程串行执行。(性能差)</p><ul><li>比如<code>Synchronized、Lock</code>都是悲观锁</li></ul></li></ol><h3 id="乐观锁">乐观锁</h3><ol><li>版本号法<ul><li>用版本标识数据更新，如果版本<code>version</code>更新了，则表示数据已经被更新了。</li></ul></li><li>CAS法<ul><li>用之前查询到的数据判断是否存在相同的数据，如果不存在，则表示数据已经更新。实际上就是简化了版本字段。</li></ul></li></ol><div class="note info flat"><p>这样存在问题，因为如果有一百个线程，初始情况下<code>stock=100</code>，第一个线程首先执行查询，满足，然后修改数据库<code>stock - 1</code>。在修改数据库之前，其他线程查询<code>stock=100</code>，也满足查询条件，但是实际上查询数据库只有<code>stock=99</code>了，发现被修改了，因此直接错误退出。<br>所以应该使用<code>stock&gt;0</code>而不是等于前一个值</p></div><h1>分布式锁</h1><div class="note info flat"><ul><li>满足分布式系统或集群模式下<strong>多进程可见</strong>并且<strong>互斥的锁</strong></li></ul></div><h2 id="要求">要求</h2><ol><li>多进程可见即所有<code>JVM</code>可见</li><li>互斥</li><li>高可用</li><li>高性能</li><li>安全性</li></ol><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">MySQL</th><th style="text-align:center">Redis</th><th style="text-align:center">Zookeeper</th></tr></thead><tbody><tr><td style="text-align:center">互斥</td><td style="text-align:center">利用MySQL本身互斥锁机制</td><td style="text-align:center">利用SETNX互斥命令</td><td style="text-align:center">利用节点的唯一性和有序性实现互斥</td></tr><tr><td style="text-align:center">高可用</td><td style="text-align:center">好</td><td style="text-align:center">好</td><td style="text-align:center">好</td></tr><tr><td style="text-align:center">高性能</td><td style="text-align:center">一般</td><td style="text-align:center">好</td><td style="text-align:center">一般</td></tr><tr><td style="text-align:center">安全性</td><td style="text-align:center">断开连接，自动释放锁</td><td style="text-align:center">利用锁超市时间，到期释放</td><td style="text-align:center">临时节点，断开连接自动释放</td></tr></tbody></table><h2 id="基于Redis的分布式锁">基于<code>Redis</code>的分布式锁</h2><div class="note info flat"><p>分布式锁需要实现两个方法：获取锁和释放锁</p></div><p><img src="https://gitee.com/sang3112/blog_imgs/raw/4de21bf55caff74e4e42766859d0389dca4b4b93/Redis/distributedlock.png" alt="distributedlock"></p><ol><li>获取锁<ul><li>互斥: 确保只有一个线程能够获取锁<code>setnx lock thread1</code>，<code>expire lock 5</code></li><li>但是上面这种两条语句的方法不是原子的，有可能执行了一条后线程中断</li><li>可以使用<code>set lock thread1 nx ex 5</code>合并成一条语句</li></ul></li><li>释放锁<ul><li>手动释放: <code>del key</code></li><li>超时释放: 获取锁的时候设置超时时间</li></ul></li></ol><h3 id="Redisson分布式锁原理"><code>Redisson</code>分布式锁原理</h3><ol><li>可重入: 利用<code>hash</code>结构记录线程<code>ID</code>和重入次数</li><li>可重试: 利用信号量和<code>pubsub</code>功能实现等待、唤醒，获取锁失败的重试机制</li><li>超时续约: 利用<code>watchDog</code>，每隔一段时间重置超时时间</li></ol><h1><code>Redis</code>消息队列</h1><h2 id="基于List的消息队列的优缺点">基于<code>List</code>的消息队列的优缺点</h2><ul><li>优点:<ol><li>利用<code>Redis</code>存储，不受限与<code>JVM</code>内存上限</li><li>基于<code>Redis</code>持久化机制，保证数据安全性</li><li>满足消息有序性</li></ol></li><li>缺点:<ol><li>无法避免消息丢失</li><li>只支持单消费者</li></ol></li></ul><h2 id="基于PubSub的消息队列">基于<code>PubSub</code>的消息队列</h2><ul><li>发布订阅，一个消费者可以订阅一个或多个<code>channel</code>，生产者向对应的<code>channel</code>发送消息后，所有订阅者可以收到相关信息</li><li><code>subscribe channel [channel]</code>: 订阅一个或多个频道</li><li><code>publish channel msg</code>: 向一个频道发送消息</li><li><code>psubscribe pattern [pattern]</code>: 订阅与pattern格式匹配的所有频道</li><li>优点:<ol><li>采用发布订阅模型，支持多生产，多消费</li></ol></li><li>缺点:<ol><li>不支持持久化</li><li>无法避免消息丢失，不安全</li><li>消息堆积有上限，超出时数据丢失</li></ol></li></ul><h2 id="基于Stream的消息队列">基于<code>Stream</code>的消息队列</h2><ul><li>发送消息: <code>xadd key [NOMKSTREAM] [MAXLEN|MINID [=|~] threadhold [LIMIT count]] *|ID field value [field value ...]</code><ul><li><code>[NOMKSTREAM]</code>: 如果队列不存在，是否自动创建队列，默认是动创建</li><li><code>[MAXLEN|MINID [=|~] threadhold [LIMIT count]]</code>: 设置消息队列的最大消息数量</li><li><code>*|ID</code>: 消息的唯一<code>ID</code>，*代表由<code>Redis</code>自动生成，格式是<code>时间戳-递增数字</code></li><li><code>field value [field value ...]</code>: 发送到队列中的消息，称为<code>Entry</code>，格式就是多个键值对</li></ul></li><li>读取消息: <code>XREAD [COUNT count] [BLOCK milliseconds] STREAMS key[key ...] ID [ID ...]</code><ul><li><code>[COUNT count]</code>: 每次读取消息的最大数量</li><li><code>[BLOCK milliseconds]</code>: 没有消息时，是否阻塞，阻塞时长</li><li><code>STREAM key [key ...]</code>: 要从哪个队列读取消息，<code>key</code>就是队列名</li><li><code>ID [ID ...]</code>: 起始<code>ID</code>，只返回大于该<code>ID</code>的消息。0表示从第一条消息开始，$表示从最新的消息开始</li></ul></li></ul><p>指定<code>$</code>表示读取最新的消息，但是如果一下到来几条消息，依然只会读取最新的消息，导致漏读</p><ul><li>优点:<ol><li>消息可回溯</li><li>一个消息可以被多个消费者读取</li><li>可以阻塞读取</li></ol></li><li>缺点:<ol><li>有消息漏镀的风险</li></ol></li></ul><h3 id="消费者组">消费者组</h3><ul><li><p>将多个消费者划分到一个组中，监听同一个队列</p></li><li><p>特点:</p><ol><li>消息分流: 队列中的消息会分流给组内不同的消费者，不是重复的消费，从而加快消息处理的速度</li><li>消息标识: 消费者组维护一个标识，记录最后一个被处理的消息，哪怕消费者宕机，还会从标识之后读取消息，确保每一个消息都会被消费</li><li>消息确认: 消费者获取消息后，消息处于<code>pending</code>状态，存入<code>pending-list</code>。当处理完成后需要通过<code>XACK</code>来确认消息，标记消息为已处理，才会从<code>pending-list</code>中移除(可以确保所有的消息都能被消费到)</li></ol></li><li><p>创建消费者组: <code>xgroup create key groupName ID [MKSTREAM]</code></p><ul><li><code>key</code>: 队列名称</li><li><code>groupName</code>: 消费者组名称</li><li><code>ID</code>: 起始<code>ID</code>标识，<code>$</code>标识队列中最后一个消息，<code>0</code>标识队列中第一个消息</li><li><code>MKSTREAM</code>: 队列不存在时自动创建队列</li></ul></li><li><p>删除消费者组: <code>xgroup destroy key groupName</code></p></li><li><p>删除消费者组中指定的消费者: <code>xgroup delconsumer key groupname consumername</code></p></li><li><p>给指定的消费者组添加消费者: <code>xgroup createconsumer key groupname consumername</code></p></li><li><p>从消费者组读取消息: <code>xreadgroup GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] ID [ID ...]</code></p><ul><li><code>group</code>: 消费者组名称</li><li><code>consumer</code>: 消费者名称，如果消费者不存在，则会自动创建一个</li><li><code>count</code>: 本次查询的最大数量</li><li><code>BLOCK milliseconds</code>: 当没有消息时最长等待时间</li><li><code>NOACK</code>: 无需手动ACK，获取到消息后自动确认</li><li><code>STREAMS key</code>: 指定队列名称</li><li><code>ID</code>: 获取消息的起始ID<ul><li>‘&gt;’: 从下一个未消费的消息开始</li><li>其他: 根据指定ID从<code>pending-list</code>中获取已经消费但是没有确认的消息，比如0，是从<code>pending-list</code>中的第一个消息开始</li></ul></li></ul></li><li><p>特点:</p><ol><li>消息可回溯</li><li>可以多消费者争抢消息，加快消费速度</li><li>可以阻塞读取</li><li>没有消息漏读风险</li><li>有消息确认机制，保证消息至少被消费一次</li></ol></li></ul><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">List</th><th style="text-align:center">PubSub</th><th style="text-align:center">Stream</th></tr></thead><tbody><tr><td style="text-align:center">消息持久化</td><td style="text-align:center">支持</td><td style="text-align:center">-</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">阻塞读取</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">消息堆积处理</td><td style="text-align:center">受限于内存空间，可以利用多消费者加快处理</td><td style="text-align:center">受限于消费者缓冲区</td><td style="text-align:center">受限于队列长度，可以利用消费者组提高消费速度，减少堆积</td></tr><tr><td style="text-align:center">消息确认机制</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">消息回溯</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">支持</td></tr></tbody></table><h1><code>GEO</code></h1><ul><li><code>GEOADD</code>: 添加一个地理空间信息，包括经度、纬度、值</li><li><code>GEODIST</code>: 计算指定两个点之间的距离并返回</li><li><code>GEOHASH</code>: 将值的坐标转为哈希字符串形式并返回</li><li><code>GEOPOS</code>: 返回指定值的坐标</li><li><code>GEORADIUS</code>: 指定圆心、半径，找到院内包含的所有值，按照圆心之间的距离排序后返回，6.2版本以后废弃</li><li><code>GEOSEARCH</code>: 指定范围内搜索值，按照与指定点之间的距离排序后返回，范围可以是圆形或矩形</li><li><code>GEOSEARCHSTORE</code>: 与<code>GEOSEARCH</code>功能一致，不过可以把结果存储到一个指定的key中</li></ul><h1><code>BitMap</code></h1><ul><li><code>Redis</code>中使用<code>String</code>类型实现<code>BitMap</code>，最大上限512M，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup><mi>b</mi><mi>i</mi><mi>t</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">2^{32} bits</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mord mathnormal">bi</span><span class="mord mathnormal">t</span><span class="mord mathnormal">s</span></span></span></span></li><li><code>SETBIT</code>: 向指定位置<code>offset</code>存入一个0 or 1</li><li><code>BITCOUNT</code>: 统计<code>BitMap</code>中值为1的<code>bit</code>位的数量</li><li><code>BITFIELD</code>: 操作<code>BitMap</code>中bit数组中的指定位置<code>offset</code>的值，实现了查询修改以及自增，一般用来查询</li><li><code>BITFIELD_RO</code>: 获取<code>BitMap</code>中bit数组，并以十进制形式返回</li><li><code>BITOP</code>: 将多个<code>BitMap</code>的结果位运算</li><li><code>BITPOS</code>: 查找bit数组中指定范围内第一个0 or 1出现的位置</li></ul><h1><code>HyperLogLog(HLL)</code></h1><ul><li><p><code>UV</code>: <code>Unique Visitor</code>独立访客量，通过互联网访问，浏览这个网页的自然人。一天内同一个用户多次访问，只记录一次</p></li><li><p><code>PV</code>: <code>Page View</code>页面访问量或点击量，用户没访问网站的一个页面，记录次<code>PV</code>，用来衡量网站的流量</p></li><li><p><code>UV</code>在服务端做会麻烦，因为要判断该用户是否统计过了，所以需要保存用户信息。但是如果每个访问的用户都保存到<code>Redis</code>中，则数据量很大</p></li><li><p><code>HLL</code>是一种概率算法，用于确定非常大的集合的基数，不需要存储其所有的值。基于<code>String</code>实现，单个<code>HLL</code>内存永远小于16K，测量结果是概率性的，误差小于81%。对于<code>UV</code>统计完全可以忽略</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;note info flat&quot;&gt;&lt;p&gt;全局唯一&lt;code&gt;ID&lt;/code&gt;: 经常会需要全局唯一&lt;code&gt;ID&lt;/code&gt;，比如订单表的生成。因为&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果&lt;code&gt;ID&lt;/code&gt;自增，则规律性太明显&lt;/li&gt;
&lt;li&gt;并</summary>
      
    
    
    
    <category term="Redis" scheme="https://sangs3112.github.io/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://sangs3112.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis笔记_0</title>
    <link href="https://sangs3112.github.io/posts/36df4688.html"/>
    <id>https://sangs3112.github.io/posts/36df4688.html</id>
    <published>2024-03-16T15:29:26.000Z</published>
    <updated>2024-07-23T17:18:51.910Z</updated>
    
    <content type="html"><![CDATA[<h1><code>SQL</code> VS <code>NoSQL</code></h1><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">SQL</th><th style="text-align:center">NoSQL</th></tr></thead><tbody><tr><td style="text-align:center">数据结构</td><td style="text-align:center">结构化</td><td style="text-align:center">非结构化</td></tr><tr><td style="text-align:center">数据关联</td><td style="text-align:center">关联的</td><td style="text-align:center">无关联</td></tr><tr><td style="text-align:center">查询方式</td><td style="text-align:center">SQL查询</td><td style="text-align:center">非SQL</td></tr><tr><td style="text-align:center">事务特性</td><td style="text-align:center">ACID</td><td style="text-align:center">BASE</td></tr><tr><td style="text-align:center">存储方式</td><td style="text-align:center">磁盘</td><td style="text-align:center">内存</td></tr><tr><td style="text-align:center">扩展性</td><td style="text-align:center">垂直</td><td style="text-align:center">水平</td></tr><tr><td style="text-align:center">使用场景</td><td style="text-align:center">数据结构固定且对安全性，一致性要求较高</td><td style="text-align:center">数据结构不固定，对一致性安全性要求不高，对性能有一定要求</td></tr></tbody></table><div class="note info flat"><p>特征:</p><ol><li>键值型，值支持多种不同的数据结构，功能丰富</li><li>单线程，每个命令具有原子性。现在多线程仅仅在网络连接请求方面，内部核心命令依然是单线程的</li><li>低延迟，速度快</li><li>支持数据持久化</li><li>支持主从集群，分片集群</li><li>支持多语言</li></ol></div><div class="note info flat"><p>为什么<code>Redis</code>单线程，但是速度快?</p><ol><li>基于内存(最重要的原因)</li><li>IO多路复用</li><li>使用C语言，良好的编码</li></ol></div><h1><code>Redis</code>安装</h1><p>使用<code>Docker</code>安装:</p><ol><li>在<code>docker-data/redis/</code>中执行命令<code>wget http://download.redis.io/redis-stable/redis.conf</code>下载config</li><li>修改权限</li><li>修改配置信息 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bind 127.0.0.1          # 注释掉这行，表示其他机器也可以链接</span><br><span class="line">protected-mode no       # 默认为yes，表示只允许本机的回环连接</span><br><span class="line">daemonize no            # 默认为no，不守护进程，不是docker部署需要改为yes</span><br><span class="line">                        # 如果是Docker部署不需要改为yes，因为docker run -d本身就是后台启动</span><br><span class="line">requirepass xxxxxx      # 密码</span><br><span class="line">appendonly yes          # 持久化</span><br><span class="line">port 6379               # 默认，监听的端口</span><br><span class="line">dir .                   # 默认，表示当前目录即为工作目录</span><br><span class="line">database 16             # 默认，表示数据库数量</span><br><span class="line">maxmemory 512mb         # 表示redis能使用的最大内存</span><br><span class="line"># logfile &quot;redis.log&quot;   # 日志文件，默认为空，表示不记录日志，存储在dir指定的目录中</span><br></pre></td></tr></table></figure></li><li>运行<code>Redis</code>: (网上的方法99%都是有问题的)以<code>redis:7.2.4-alpine3.19</code>为例</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name redis -p 6379:6379 -v /&#123;USER_DIR&#125;/docker-data/redis/redis.conf:/usr/local/etc/redis/redis.conf -v /&#123;USER_DIR&#125;/docker-data/redis:/data -d redis:7.2.4-alpine3.19 redis-server /usr/local/etc/redis/redis.conf --appendonly yes --requirepass xxxxxx</span><br></pre></td></tr></table></figure><h1>数据结构</h1><div class="note info flat"><p>通用命令:</p><ol><li><code>KEYS</code>: 查看所有符合模板的key，不建议在生产环境上使用，查询会阻塞其他线程</li><li><code>DEL</code>: 删除一个 or 多个指定的key</li><li><code>EXISTS</code>: 判断key是否存在</li><li><code>EXPIRE</code>: 给key设置有效期(秒)，到期自动删除</li><li><code>TTL</code>: 查看key的剩余有效期，-1表示永久有效， -2表示过期</li></ol></div><h2 id="基本类型">基本类型</h2><ol><li><p><code>String</code></p><ul><li>字符串底层都是字节数组的形式存储的，最大不能超过512M</li><li>格式又可以分为<code>string, int, float</code></li><li>但是对于<code>int, float</code>，都转为二进制的形式存储</li><li><code>Redis</code>的key允许多个单词形成层级结构，使用<code>:</code>分隔，即<code>项目名:业务名:类型:id</code></li></ul> <div class="note info flat"><p>常用命令:</p><ol><li><code>SET</code>: 添加或修改已经存在的一个<code>String</code>类型键值对</li><li><code>GET</code>: 根据key获取<code>String</code>类型的value</li><li><code>MSET, MGET</code>: 批量添加和批量获取多个<code>String</code>类型键值对</li><li><code>INCR</code>: 对int自增1</li><li><code>INCRBY</code>: 让整型的key自增并指定步长，比如<code>incrby num 2</code>表示让<code>num</code>自增2</li><li><code>INCRBYFLOAT</code>: 让float自增指定步长</li><li><code>SETNX</code>: 添加一个<code>String</code>类型键值对，前提是没有key，否则不执行</li><li><code>SETEX</code>: 添加一个<code>String</code>类型键值对，并指定有效期，<code>setex key 有效期 value</code></li></ol></div></li><li><p><code>Hash</code></p><ul><li>value是一个无序字段</li><li><code>String</code>将对象序列化以后存储，修改某个字段不方便。比如value为<code>&#123;name: Jack, age: 21&#125;</code></li><li><code>Hash</code>每个字段独立存储，可以单独处理</li></ul> <div class="note info flat"><p>常用命令:</p><ol><li><code>HSET key field value</code>: 添加或修改已经存在的一个<code>Hash</code>类型键值对</li><li><code>HGET key field</code>: 根据key获取<code>Hash</code>类型的value</li><li><code>HMSET, HMGET</code>: 批量添加和批量获取多个<code>Hash</code>类型键值对</li><li><code>HGETALL</code>: 获取一个<code>Hash</code>类型中所有的field</li><li><code>HKEYS</code>: 获取<code>Hash</code>类型中所有的field</li><li><code>HVALS</code>: 获取<code>Hash</code>类型中所有的value</li><li><code>HINCRBY</code>: 让<code>Hash</code>的key自增并指定步长</li><li><code>HSETNX</code>: 添加一个<code>Hash</code>类型key的field，前提是没有field，否则不执行</li></ol></div></li><li><p><code>List</code></p><ul><li>可以看作双向链表，有序、元素可以重复、插入删除速度快，但是<strong>查询速度一般</strong></li><li>朋友圈点赞，或评论列表</li></ul> <div class="note info flat"><p>常用命令:</p><ol><li><code>LPUSH key element ...</code>: 左侧插入一个 or 多个元素</li><li><code>LPOP key</code>: 左侧移除并返回第一个元素，没有就返回<code>nil</code></li><li><code>RPUSH key element ...</code>: 右侧插入一个 or 多个元素</li><li><code>RPOP key</code>: 右侧移除并返回第一个元素，没有就返回<code>nil</code></li><li><code>LRANGE key start end</code>: 返回一段角标范围内的所有元素</li><li><code>BLPOP</code>, <code>BRPOP</code>: 在没有元素时等待指定的时间，而不是直接范围<code>nil</code></li></ol></div></li><li><p><code>Set</code></p><ul><li>无序，元素不重复，查找快，支持交、并、差集</li></ul> <div class="note info flat"><p>常用命令:</p><ol><li><code>SADD key member</code>: 向<code>Set</code>中添加一个或者多个元素</li><li><code>SREM key member</code>: 移除<code>Set</code>中指定的元素</li><li><code>SCARD key</code>: 返回<code>Set</code>中元素的个数</li><li><code>SISMEMBER key memeber</code>: 判断一个元素是否存在于<code>Set</code>中</li><li><code>SMEMBERS</code>: 获取<code>Set</code>中所有的元素</li><li><code>SINTER key1 key2</code>: 求key1 和 key2的交集</li><li><code>SDIFF key1 key2</code>: 求key1 和 key2的差集</li><li><code>SUNION key1 key2</code>: 求key1 和 key2的并集</li></ol></div></li><li><p><code>SortedSet</code></p><ul><li>可排序集合，每个元素都带有<code>score</code>属性，底层是实现一个跳表和哈希表</li><li>可排序，不重复，查询速度快。用于实现排行榜</li></ul> <div class="note info flat"><p>常用命令:</p><ol><li><code>ZADD key score member</code>: 添加一个 or 多个元素，如果已经存在则更新<code>score</code></li><li><code>ZREM key member</code>: 移除指定的元素</li><li><code>ZSCORE key member</code>: 获取指定元素的<code>score</code>值</li><li><code>ZRANK key member</code>: 获取指定元素排名</li><li><code>ZSCARD key</code>: 返回元素的个数</li><li><code>ZCOUNT key min max</code>: 统计<code>score</code>在给定范围内元素的个数</li><li><code>ZINCRBY key increment member</code>: 让指定元素自增，步长为<code>incrememnt</code></li><li><code>ZRANGE key min max</code>: 按照<code>score</code>排序后，获取指定排名范围内的元素</li><li><code>ZRANGEBYSCORE key min max</code>: 按照<code>score</code>排序后，获取指定<code>score</code>范围内的元素</li><li><code>ZINTER key1 key2</code>: 求key1 和 key2的交集</li><li><code>ZDIFF key1 key2</code>: 求key1 和 key2的差集</li><li><code>ZUNION key1 key2</code>: 求key1 和 key2的并集</li><li>在<code>Z</code>后面添加<code>REV</code>即可实现降序</li></ol></div></li></ol><h2 id="特殊类型">特殊类型</h2><ol><li><code>GEO</code></li><li><code>BitMap</code></li><li><code>HyperLog</code></li></ol><h1>缓存更新策略</h1><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">内存淘汰</th><th style="text-align:center">超时剔除</th><th style="text-align:center">主动更新</th></tr></thead><tbody><tr><td style="text-align:center">说明</td><td style="text-align:center">不用自己维护，利用内存淘汰机制，内存不足时自动淘汰部分数据，下次查询时再更新</td><td style="text-align:center">给缓存数据添加TTL时间，到期后自动删除缓存，下次查询时更新缓存</td><td style="text-align:center">编写业务逻辑，修改数据库的同时更新缓存</td></tr><tr><td style="text-align:center">一致性</td><td style="text-align:center">差</td><td style="text-align:center">一般</td><td style="text-align:center">好</td></tr><tr><td style="text-align:center">维护成本</td><td style="text-align:center">无</td><td style="text-align:center">低</td><td style="text-align:center">高</td></tr></tbody></table><div class="note info flat"><ul><li>对于低一致性需求，使用内存淘汰机制。比如店铺类型这种修改频率很少的内容</li><li>对于高一致性需求，使用主动更新，并且将超时剔除作为兜底方案。比如店铺的详情、优惠券查询缓存</li></ul></div><h2 id="主动更新策略">主动更新策略</h2><ol><li><code>Cache Aside Pattern</code>: 由缓存调用者在更新数据库的同时更新缓存<ul><li>可控性更高，用的更多</li></ul></li><li><code>Read/ Write Through Pattern</code>: 缓存与数据库整合为一个服务，由服务来维护一致性。<strong>调用者调用该服务，无需关心缓存一致性问题</strong></li><li><code>Write Behind Caching Pattern</code>: <strong>调用者只操作缓存</strong>，由其他线程异步将缓存数据持久化到数据库，最终保持一致<ul><li>需要维护异步线程</li><li>一致性难以保证</li></ul></li></ol><h3 id="Cache-Aside-Pattern"><code>Cache Aside Pattern</code></h3><ol><li>删除缓存和更新缓存的选择<ul><li>更新缓存：每次更新数据库都要更新缓存，如果对应的是写多读少的环境，则会产生大量的无效写操作</li><li>删除缓存：每次更新数据库时都让缓存失效，查询时再更新缓存，延迟加载，有效更新更多，因此用的更多</li></ul></li><li>如果保证缓存与数据库的操作同时成功或失败<ul><li>单体系统，将缓存与数据库放在一个事务中</li><li>分布式系统，就需要利用<code>TCC</code>分布式事务方案</li></ul></li><li>先操作缓存还是操作数据库(线程安全问题)<ul><li><p>初始缓存和数据库内容均为10</p></li><li><p>先删除缓存再操作数据库:</p><ul><li><p>线程1删除缓存，线程1更新数据库=20</p></li><li><p>线程2查询缓存未命中，查询数据库得到20，并写入缓存。正常</p></li><li><p><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Redis/cachesqlright.png" alt="cachesqlright"></p></li><li><p>线程1删除缓存</p></li><li><p>线程2查询缓存未命中，查询数据库得到10，并写入缓存</p></li><li><p>线程1更新数据库=20。异常(<strong>概率高</strong>)</p></li><li><p><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Redis/cachesqlerror.png" alt="cachesqlerror"></p></li></ul></li><li><p><strong>先操作数据库再删缓存</strong></p><ul><li><p>线程2更新数据库=20，再删除缓存</p></li><li><p>线程1查询缓存未命中，查询数据库得到20，并写入缓存。正常</p></li><li><p><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Redis/sqlcacheright.png" alt="sqlcacheright"></p></li><li><p>假设<strong>缓存失效了</strong>，线程1查询缓存未命中，查询数据库得到10</p></li><li><p>线程2更新数据库=20，删除缓存</p></li><li><p>线程1写入缓存=10。异常(<strong>概率低</strong>)</p></li><li><p><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Redis/sqlcacheerror.png" alt="sqlcacheerror"></p></li></ul></li></ul></li></ol><div class="note info flat"><ul><li>因此，<strong>先操作数据库再删缓存</strong>用的更多一些，可以加上超时剔除策略兜底<ul><li>读操作:<ul><li>缓存命中则直接返回</li><li>缓存未命中则查询数据库，写入缓存，设定超时时间</li></ul></li><li>写操作：<ul><li>先写数据库，然后删除缓存</li><li>确保数据库与缓存操作的原子性</li></ul></li></ul></li></ul></div><h1>缓存穿透</h1><ul><li>客户端请求的数据在缓存和数据库中都不存在，则永远不会生效，请求永远会打到数据库中</li></ul><h2 id="解决办法">解决办法</h2><ol><li>缓存空对象<ul><li>优点: 实现简单，维护方便</li><li>缺点:<ul><li>额外内存消耗，可以设置短的TTL进行过期删除</li><li>可能造成短期的不一致性，也可以通过短的TTL缓解</li></ul></li></ul></li><li>布隆过滤器<ul><li>客户端请求的时候先请求布隆过滤器，如果存在则放行，不存在则直接拒绝</li><li>布隆过滤器判断不存在说明一定不存在，判断存在但是不一定真的存在，如果实际上不存在，则又发生了穿透</li><li>优点: 内存占用小，没有多余的key</li><li>缺点:<ul><li>实现复杂</li><li>存在误判</li></ul></li></ul></li><li>增加id的复杂度，避免被猜测规律</li><li>数据基础格式校验</li><li>热点参数限流</li></ol><h1>缓存雪崩</h1><ul><li>同一时段大量的缓存同时失效，或者<code>Redis</code>服务宕机，导致大量请求到达服务器，带来巨大压力</li></ul><h2 id="解决办法-2">解决办法</h2><ol><li>给不同的key添加<code>TTL</code>随机值</li><li>利用<code>Redis</code>集群提高可用性</li><li>给缓存业务添加降级限流策略</li><li>给业务添加多级缓存</li></ol><h1>缓存击穿(热点key问题)</h1><ul><li>被高并发访问并且缓存重建业务比较复杂的key失效了，无数请求访问会在瞬间给数据库带来巨大的冲击</li></ul><h2 id="解决办法-3">解决办法</h2><ol><li>互斥锁<ul><li>只有获取锁的人才能重建缓存，其他人就休眠一会再重试</li><li>会出现互相等待的问题，只有一个在获取数据，其他都在等待</li><li><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Redis/lock.png" alt="lock"></li></ul></li><li>逻辑过期<ul><li>不设置<code>TTL</code>，只设置逻辑过期时间，其他用户发现逻辑过期了，就开启独立新线程，查询<strong>数据库数据</strong>，重置逻辑时间</li><li>其他人在没有得到互斥锁的时候直接返回<strong>旧缓存数据</strong></li><li><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Redis/logicexpire.png" alt="logicexpire"></li></ul></li></ol><table><thead><tr><th style="text-align:center">方案</th><th style="text-align:center">优点</th><th style="text-align:center">缺点</th></tr></thead><tbody><tr><td style="text-align:center">互斥锁</td><td style="text-align:center">乜有额外内存消耗；保证一致性；实现简单</td><td style="text-align:center">线程需要等待，性能受影响；有死锁风险</td></tr><tr><td style="text-align:center">逻辑过期</td><td style="text-align:center">线程无需等待，性能较好</td><td style="text-align:center">不能保证一致性；有额外内存消耗；实现复杂</td></tr></tbody></table><div class="note info flat"><ul><li>因此互斥锁和逻辑过期两种方案实际上是<strong>一致性和可用性</strong>之间的取舍</li></ul></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;code&gt;SQL&lt;/code&gt; VS &lt;code&gt;NoSQL&lt;/code&gt;&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;SQL&lt;/</summary>
      
    
    
    
    <category term="Redis" scheme="https://sangs3112.github.io/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://sangs3112.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>MySQL笔记_5</title>
    <link href="https://sangs3112.github.io/posts/572df2c5.html"/>
    <id>https://sangs3112.github.io/posts/572df2c5.html</id>
    <published>2024-03-15T11:39:00.000Z</published>
    <updated>2024-07-23T17:18:51.910Z</updated>
    
    <content type="html"><![CDATA[<h1>日志</h1><div class="note info flat"><ul><li><code>MySQL</code>中日志分为四类: 错误日志、二进制日志、查询日志、慢查询日志</li></ul></div><h2 id="错误日志">错误日志</h2><ul><li>记录了当<code>mysqld</code>启动和停止时，以及服务器在运行过程中发生的任何<strong>严重错误</strong>时的相关信息。服务器出现故障无法使用就看这个日志</li><li>默认开启，存放在<code>/var/log/</code>中，日志文件名为<code>mysqld.log</code></li><li>查看错误日志位置: <code>show variables like '%log_error%';</code></li></ul><h2 id="二进制日志">二进制日志</h2><blockquote><p><code>binlog</code>是<strong>server层</strong>日志</p></blockquote><ul><li><code>binlog</code>记录了所有的<code>DDL, DML</code>语句，<strong>不包含查询语句</strong></li><li><code>binlog</code>默认开启，查看二进制日志位置: <code>show variables like '%log_bin%';</code></li><li>最开始<code>MySQL</code>只有<code>MyISAM</code>引擎，只有<code>binlog</code>用于归档，没有<code>crash-safe</code>的能力，后面<code>InnoDB</code>设计了另一套日志系统，利用<code>redo log</code>来实现<code>crash-safe</code>的能力</li></ul><h3 id="作用">作用</h3><ol><li>灾难时数据恢复</li><li><code>MySQL</code>主从复制</li></ol><h3 id="日志格式">日志格式</h3><ul><li>查看二进制的日志格式: <code>show variables like '%binlog_format%';</code></li></ul><table><thead><tr><th style="text-align:center">日志格式</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">STATEMENT</td><td style="text-align:center">基于<code>SQL</code>语句的日志记录，记录<code>SQL</code>语句，对数据进行修改的<code>SQL</code>都会记录在日志文件中</td></tr><tr><td style="text-align:center">ROW</td><td style="text-align:center">基于行的日志记录，记录的是每一行的数据变更(默认)</td></tr><tr><td style="text-align:center">MIXED</td><td style="text-align:center">混合了STATEMENT与ROW两种格式，默认采用STATEMENT，某些情况下会自动切换为ROW记录</td></tr></tbody></table><div class="note info flat"><ul><li>如果要修改二进制文件的日志格式，就去修改<code>/etc/my.cnf</code>，添加<code>binlog_format=STATMENT</code>后，使用<code>systemctl restart mysqld</code>重新启动服务即可</li></ul></div><h3 id="查看二进制日志">查看二进制日志</h3><p><code>mysqlbinlog [参数] binlog文件名</code><br>参数:<br>-d  指定数据库名称，只列出指定数据库的相关操作<br>-o  忽略日志中前n行命令<br>-v  将行事件(数据变更)重构为<code>SQL</code>语句<br>-vv 将行事件(数据变更)重构为<code>SQL</code>语句，并输出注释信息</p><h3 id="删除二进制日志">删除二进制日志</h3><p>配置二进制日志的过期时间，到了过期时间会自动删除: <code>show variables like '%binlog_expire_logs_seconds%';</code></p><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">reset master</td><td style="text-align:center">删除全部的binlog日志，删除之后日志编号从binlog.000001重新开始</td></tr><tr><td style="text-align:center">purge master logs to ‘binlog.******’</td><td style="text-align:center">删除******之前的所有日志</td></tr><tr><td style="text-align:center">purge master logs before ‘yyyy-mm-dd hh24:mm:ss’</td><td style="text-align:center">删除日志为’yyyy-mm-dd hh24:mm:ss’之前产生的所有日志</td></tr></tbody></table><h3 id="更新语句流程">更新语句流程</h3><ol><li>执行器调用引擎找到<code>ID=2</code>的一行，如果这一行的数据页本身就在内存中，那么就直接返回给执行器，否则读入内存后再返回</li><li>执行器拿到引擎返回的数据，加1，调用引擎写入新数据</li><li>引擎将数据更新到内存中，同时更新<code>redo log</code>，此时<code>redo log</code>处于<code>prepare</code>状态，告知执行器写入完成，可以提交事务。</li><li>执行器生成<code>binlog</code>，并将<code>binlog</code>写入磁盘</li><li>执行器调用引擎的提交接口，把<code>redo log</code>状态改为<code>commit</code>状态，完成更新</li></ol><blockquote><p>这里的<code>prepare</code>和<code>commit</code>就是两阶段提交，为了保证两个日志逻辑一致，所以只有在<code>binlog</code>写入完成以后，<code>redo log</code>才会从<code>prepare</code>变为<code>commit</code></p></blockquote><blockquote><p><code>binlog</code>记录的是数据操作的原始逻辑操作，也就是sql语句，所以回放的时候使用的是<code>binlog</code></p><ul><li>某时刻有一次删表操作，需要找到最近的一次全量备份，从备份的时间点开始，回放<code>binlog</code>，重放到误删表的时刻即可</li></ul></blockquote><div class="note info flat"><p>如果不是两阶段提交, 例如更新ID=2的记录中c字段原始 = 0, 更新后 + 1</p><ol><li><p>先写<code>redo log</code>，后写<code>binlog</code></p><ul><li><code>redo log</code>写完了，<code>binlog</code>没有写完就宕机了，恢复后系统依然可以得到c=1，但是<code>binlog</code>没有写完，所以<code>binlog</code>没有这个语句，备份日志就有语句丢失，如果需要使用<code>binlog</code>恢复恢复临时库，就少了一次更新，导致最终临时库中c=0, 与原始库不同</li></ul></li><li><p>先写<code>binlog</code>，后写<code>redo log</code></p><ul><li><code>binlog</code>写完了，但是<code>redo log</code>还没有写，崩溃恢复以后事务无效，所以c=0，但是<code>binlog</code>已经将c=1的更新语句记录下来了，所以使用<code>binlog</code>进行恢复的时候就会得到c=1，与原始库不同</li></ul></li></ol><ul><li>如果面临数据库的扩容问题的时候，就需要<strong>全量备份 + binlog</strong>，如果<code>binlog</code>和<code>redo log</code>记录的状态不一致，就会导致主从不一致问题</li></ul></div><h2 id="查询日志">查询日志</h2><ul><li>查询日志中记录了客户端的<strong>所有</strong>操作语句，而二进制日志不包含查询语句。</li><li><strong>默认未开启</strong>，使用<code>show variables like '%general%';</code>查看</li></ul><div class="note info flat"><p>按照如下方式修改<code>/etc/my.cnf</code>可以打开查询日志</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">general_log=1</span><br><span class="line">general_log_file=mysql_query.log # 设置日志的文件名，如果没有指定则默认为host_name.log</span><br></pre></td></tr></table></figure><p><code>systemctl restart mysqld</code> # 重启mysql服务</p></div><h2 id="慢查询日志">慢查询日志</h2><ul><li>记录所有执行时间超过参数<code>long_query_time</code>，并且扫描记录数不小于<code>min_examined_row_limit</code>的所有<code>SQL</code>语句的日志，<strong>默认未开启</strong>。</li><li><code>long_query_time</code>默认10秒，最小为0，默认文件名为<code>localhost-slow.log</code></li><li>慢查询默认不会记录管理语句，也不会记录不使用索引进行的查询语句。使用<code>log_slow_admin_statements</code>和<code>log_queries_not_using_indexes</code>更改此行为，即  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 记录执行较慢的管理语句</span><br><span class="line">log_slow_admin_statements=1</span><br><span class="line"># 记录执行较慢的未使用索引的语句</span><br><span class="line">log_queries_not_using_indexes=1</span><br></pre></td></tr></table></figure></li></ul><h2 id="redo-log"><code>redo log</code></h2><blockquote><p><code>redo log</code>是<strong>引擎层</strong>日志</p></blockquote><ul><li><code>Writing-Ahead Logging(WAL)</code>先写日志，再写磁盘，避免每次更新一条数据就要写入磁盘，导致大量的IO消耗</li><li>当一条记录需要更新，<code>InnoDB</code>就先写入到<code>redo log</code>中，并更新内存，就算更新完成。然后在适当的时候再将记录更新到磁盘中。因为写入日志是顺序写入的，比写入磁盘这种随机写入要快的多。</li><li><code>redolog</code>的大小是固定的，可以配置为一组4个文件，每个文件大小是1GB，从头开始写，写到末尾会重新从头写入<br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/MySQL/45_redolog.png" alt="45_redolog"></li></ul><div class="note info flat"><ul><li><code>write_pos</code>是当前写入的位置，边写边后移。</li><li><code>checkpoint</code>是当前擦除的位置，边擦边后移，擦除时将当前记录更新到数据文件中。</li><li><code>write_pos</code>和<code>checkpoint</code>就是可以写入的位置，如果二者相等，表明此时不能写入新的数据了，需要先擦除一些记录，才能继续写入。</li><li><code>InnoDB</code>通过<code>redolog</code>保证数据库重启以后依然可以实现数据恢复，提交的记录都不会丢失，就是<code>crash-safe</code></li></ul></div><h3 id="redo-log-VS-binlog"><code>redo log</code> VS <code>binlog</code></h3><ol><li><code>redo log</code>是<code>InnoDB</code>引擎特有的，<code>binlog</code>属于<code>server</code>层，所有引擎都可以使用</li><li><code>redo log</code>是物理日志，记录在某个数据页上修改了什么；<code>binlog</code>是逻辑日志，记录原始逻辑，比如对<code>ID = 2</code>这行的c字段+1</li><li><code>redo log</code>循环写，空间固定，会消耗完；<code>binlog</code>追加写入，一定大小后切换到下一个，不会覆盖以前的日志</li></ol><h3 id="redo-log刷脏页"><code>redo log</code>刷脏页</h3><ol><li>内存数据页与磁盘数据页不同，内存数据页就是脏页，内存写入磁盘后，就是干净页</li><li>更新写入<code>redo log</code>，没有写入磁盘，就是脏页<ul><li><code>MySQL</code>空闲，就会<code>flush</code>到磁盘上</li><li><code>MySQL</code>正常关闭，会<code>flush</code>到磁盘</li><li><code>redo log</code>写满了，没有办法接受行的请求，所有更新暂停，<code>flush</code>脏页</li><li>内存不够用了，要先<code>flush</code>一部分<ul><li>内存三种状态：还没有使用的(很少); 使用了并且干净；使用了并且脏页</li><li>读取数据的时候，需要申请行的页，那么如果没有内存空间了，就需要淘汰干净页。如果没有干净页，就需要<code>flush</code>脏页以后变成干净页再淘汰</li></ul></li></ul></li></ol><h3 id="控制刷脏页">控制刷脏页</h3><ol><li>配置<code>innodb_io_capacity</code>参数，设置为磁盘的<code>IOPS</code>，告诉<code>InnoDB</code>磁盘能力，可以利用<code>fio</code>工具测试<br><code>fio -filename=$filename -direct=1 -iodepth 1 -thread -rw=randrw -ioengine=psync -bs=16k -size=500M -numjobs=10 -runtime=10 -group_reporting -name=mytest</code><ul><li>设置这个参数，可以控制全力刷脏页。如果设置的较低，就会导致刷脏页速度变慢</li></ul></li><li>控制全力刷脏页速度的占比，有两个因素，脏页再内存中占比和<code>redo log</code>写盘的速度<ul><li><p>配置参数<code>innodb_max_dirty_pages_pct</code>，默认<code>75%</code>，<code>InnoDB</code>会计算当前脏页的占比<code>M</code></p></li><li><p>每次日志记录都有编号，跟<code>checkpoint</code>对应序号的差输入函数计算，得到<code>N</code>，<code>N</code>越大，计算结果越大。最后<code>N</code>和<code>M</code>取最大值，然后取百分号乘上全力刷脏页的速度，并以这个速度进行<code>flush</code><br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/MySQL/45_redologflush.png" alt="45_redologflush"></p></li><li><p>脏页的比例通过<code>Innodb_buffer_pool_pages_dirty/Innodb_buffer_pool_pages_total</code>计算的得到<br><code>select VARIABLE_VALUE into @a from global_status where VARIABLE_NAME = 'Innodb_buffer_pool_pages_dirty';select VARIABLE_VALUE into @b from global_status where VARIABLE_NAME = 'Innodb_buffer_pool_pages_total';select @a/@b;</code></p></li><li><p>刷新脏页的时候，如果旁边也是脏页，就会继续刷新旁边的页</p><ul><li><code>innodb_flush_neighbors = 1</code>就是连坐刷新</li><li><code>innodb_flush_neighbors = 0</code>表示只刷自己</li></ul></li><li><p>机械硬盘的话，连坐刷新有意义；但如果是SSD，建议设置为0，<strong>8.0版本后</strong>默认为0</p></li></ul></li></ol><h3 id="总结">总结</h3><ol><li><code>redo log</code>用于恢复主机故障时没有更新的数据；<code>binlog</code>用于备份</li><li>恢复数据时:<ul><li>如果<code>redo log</code>的状态为<code>commit</code>，表明<code>binlog</code>也是成功的，就可以直接恢复数据；</li><li>如果<code>redo log</code>状态是<code>prepare</code>，则需要查询<code>binlog</code>对应的事务是否成功，来决定是需要回滚还是执行</li></ul></li><li>因此，<code>redo log</code>保证了<code>crash-safe</code>的能力，<code>innodb_flush_log_at_trx_commit</code>参数表示<code>redo log</code>持久化方式<ul><li><code>innodb_flush_log_at_trx_commit = 1</code>表示每次事务的<code>redo log</code>都持久化到磁盘上，可以保证每次异常重启以后数据都不会丢失；</li><li><code>sync_binlog = 1</code>表示每次事务的<code>binlog</code>都会持久化到磁盘</li><li>所以这两个参数都建议设置为1</li><li>两个参数有<code>0 1 2</code>三个值可选，<ul><li>0表示每秒将<code>log buffer</code>同步到<code>os buffer</code>，并刷新到磁盘；</li><li>1表示每个事务都刷新到磁盘；</li><li>2表示每个事务提交都将<code>log buffer</code>同步到<code>os buffer</code>中，但是每秒刷新到磁盘</li></ul></li></ul></li></ol><h2 id="45讲对于日志的叙述">45讲对于日志的叙述</h2><ol><li><code>redo log</code>在<code>prepare</code>状态，写入<code>binlog</code>之前，崩溃了，恢复后因为<code>redo log</code>没有提交，<code>binlog</code>没有写，事务回滚，并且由于没有写<code>binlog</code>，所以从库无影响</li><li><code>redo log</code>没有<code>commit</code>, 写入<code>binlog</code>之后，<ul><li>如果<code>redo log</code>事务完整，也就是已经有了<code>commit</code>标识(但是还没有<code>commit</code>)，就直接提交</li><li>如果<code>redo log</code>只有<code>prepare</code>，判断<code>binlog</code>是否存在并完整<ul><li>如果<code>binlog</code>存在并完整，则提交事务</li><li>否则回滚事务</li><li><code>binlog</code>判断完整性：<ul><li><code>statement</code>格式<code>binlog</code>的最后会有<code>COMMIT</code></li><li><code>row</code>格式<code>binlog</code>最后会有<code>XID EVENT</code></li><li><strong>5.6版本之后</strong>引入了<code>binlog-checksum</code>验证<code>binlog</code>完整性</li></ul></li></ul></li></ul><blockquote><p>所以只要<code>binlog</code>完整，就可以通过<code>redo log</code>恢复数据，因为<code>binlog</code>完整的话，从库就会拿去用，就需要主库也有同样的数据</p></blockquote></li><li>如果没有两阶段提交，那么<code>redo log</code>写好了，就无法回滚，此时如果<code>binlog</code>写入失败，也无法回滚，导致不一致</li><li>只有<code>binlog</code>无法支持崩溃恢复，因为<code>binlog</code>是<code>WAL</code>的，如果先写了，但是事务没有<code>commit</code>，此时崩溃，就会不一致</li><li>如果只有<code>redo log</code>，可以崩溃恢复，也不需要两阶段提交。但是<code>binlog</code>可以归档，而且<code>redo log</code>循环写，历史无法保留；并且高可用，依赖监听<code>binlog</code></li><li><code>redo log</code>可以直接设置为4个文件，每个1GB。<ul><li><code>innodb_log_file_size</code>指定每个<code>redo log</code>大小，默认<code>48M</code></li><li><code>innodb_log_files_in_group</code>指定 个数，默认2</li></ul></li><li><code>redo log</code>没有记录页面的完整数据，所以不能更新磁盘，数据最终写入都依赖内存数据页的脏页</li></ol><div class="note info flat"><p>有两张表，<code>like</code>和<code>friend</code>，任何一方单方面关注的时候，只会添加在<code>like</code>表中，如果互相关注，需要在<code>friend</code>表中添加。如果两个人同时点击关注对方，就有可能出现两个单方面关注，<code>friend</code>表为空。<br>- <code>like</code>表添加一个字段<code>relationship</code><br>- 为1表示<code>userid</code>关注<code>likeid</code><br>- 为2表示<code>likeid</code>关注<code>userid</code><br>- 为3表示互相关注<br>- 设定<code>userid &lt; likeid</code></p><ul><li>插入数据比较两个用户id(A B)大小<ul><li>如果<code>A &lt; B</code>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>; <span class="comment">/*启动事务*/</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `<span class="keyword">like</span>`(user_id, liker_id, relation_ship) <span class="keyword">values</span>(A, B, <span class="number">1</span>) <span class="keyword">on</span> duplicate key <span class="keyword">update</span> relation_ship<span class="operator">=</span>relation_ship <span class="operator">|</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> relation_ship <span class="keyword">from</span> `<span class="keyword">like</span>` <span class="keyword">where</span> user_id<span class="operator">=</span>A <span class="keyword">and</span> liker_id<span class="operator">=</span>B;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">代码中判断返回的 relation_ship，</span></span><br><span class="line"><span class="comment">如果是1，事务结束，执行 commit</span></span><br><span class="line"><span class="comment">如果是3，则执行下面这两个语句：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">insert</span> ignore <span class="keyword">into</span> friend(friend_1_id, friend_2_id) <span class="keyword">values</span>(A,B);</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure></li><li>如果<code>A &gt; B</code>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>; <span class="comment">/*启动事务*/</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `<span class="keyword">like</span>`(user_id, liker_id, relation_ship) <span class="keyword">values</span>(B, A, <span class="number">2</span>) <span class="keyword">on</span> duplicate key <span class="keyword">update</span> relation_ship<span class="operator">=</span>relation_ship <span class="operator">|</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">select</span> relation_ship <span class="keyword">from</span> `<span class="keyword">like</span>` <span class="keyword">where</span> user_id<span class="operator">=</span>B <span class="keyword">and</span> liker_id<span class="operator">=</span>A;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">代码中判断返回的 relation_ship，</span></span><br><span class="line"><span class="comment">如果是2，事务结束，执行 commit</span></span><br><span class="line"><span class="comment">如果是3，则执行下面这两个语句：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">insert</span> ignore <span class="keyword">into</span> friend(friend_1_id, friend_2_id) <span class="keyword">values</span>(B,A);</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure></li><li><code>insert on duplicate</code>强制占住一行，<code>select relationship</code>在行锁保护下进行</li><li><code>|</code> 按位或 和 <code>insert ignore</code>避免重复调用</li></ul></li></ul></div><h1>主从复制</h1><ul><li>主从复制就是将主数据库的<code>DDL, DML</code>语句通过<strong>二进制日志</strong>传到从库服务器中，然后在从库上对这些日志重新执行(重做)，从而使主从库数据同步</li><li><code>MySQL</code>支持一台主库同时向多台从库进行复制，从库也可以作为其他服务器的主库，实现链状复制</li></ul><h2 id="优点">优点</h2><ol><li>主库出现问题，快速切换从库提供服务(高可用)</li><li>实现读写分离，降低主库访问压力</li><li>在从库备份，避免备份期间影响主库服务</li></ol><h2 id="原理">原理</h2><p>主数据库执行<code>DML, DDL</code>语句后，会写入<code>binlog</code>日志中。此时从数据库的<code>IOthread</code>会读取主数据库的<code>binlog</code>，写入自己的中继日志<code>Relay log</code>中，然后从数据库的<code>SQLthread</code>会读取<code>Relay log</code>，并重做其中的<code>DML, DDL</code>语句，实现主从复制</p><div class="note info flat"><p>主从复制分三步:</p><ol><li>Master 在事务提交时，把数据变更记录在二进制日志文件<code>binlog</code>中</li><li>从库读取主库的<code>binlog</code>，写入到从库的中继日志<code>Relay Log</code>中</li><li>slave重做中继日志的事件，改变自己的数据</li></ol></div><h2 id="主库配置">主库配置</h2><ol><li>修改<code>/etc/my.cnf</code> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># MySQL服务ID，保证集群环境中唯一，取值范围为(1 ~ 2^32-1)，默认为1</span><br><span class="line">server-id=1</span><br><span class="line"># 是否只读，1表示只读，0表示读写</span><br><span class="line">read-only=0</span><br><span class="line"># 忽略的数据，指不需要同步的数据库</span><br><span class="line"># binlog-ignore-db=mysql</span><br><span class="line"># 指定同步的数据库</span><br><span class="line"># binlog-do-db=db01</span><br><span class="line"># 不指定这两个设置，则表示所有数据库都需要同步</span><br></pre></td></tr></table></figure></li><li>重启mysql服务: <code>systemctl restart mysqld</code></li><li>登录mysql，创建远程连接账号，授予主从复制权限 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 创建用户，并设置密码，可以在任意主机连接mysql服务</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">with</span> mysql_native_password <span class="keyword">by</span> <span class="string">&#x27;密码&#x27;</span>;</span><br><span class="line"># 为用户分配主从复制权限</span><br><span class="line"><span class="keyword">grant</span> replication slave <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li>查看二进制日志坐标: <code>show master status;</code> <div class="note info flat"><p>字段含义:<br>file: 从哪个日志文件开始推送<br>position: 从日志文件的哪个位置开始推送日志<br>binlog_ignore_db: 指定不需要同步的数据库</p></div></li></ol><h2 id="从库配置">从库配置</h2><ol><li>修改<code>/etc/my.cnf</code> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># MySQL服务ID，保证集群环境中唯一，取值范围为(1 ~ 2^32-1)，和主库不一样即可</span><br><span class="line">server-id=2</span><br><span class="line"># 是否只读，1表示只读，0表示读写</span><br><span class="line">read-only=1</span><br></pre></td></tr></table></figure> <div class="note info flat"><ul><li>从库的<code>read-only=1</code>表示从库只需要查询即可</li><li>但是这个只读只是针对普通用户权限，对超级管理员仍然是可写</li><li>如果需要禁止超级管理员的写权限，则需要在<code>/etc/my.cnf</code>中再指定一个<code>super-read-only=1</code>参数</li></ul></div></li><li>重启mysql服务: <code>systemctl restart mysqld</code></li><li>登录从库的mysql，设置主库配置 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">change replication source <span class="keyword">to</span> source_host<span class="operator">=</span><span class="string">&#x27;主机ip&#x27;</span>, source_user<span class="operator">=</span><span class="string">&#x27;用户名&#x27;</span>, source_password<span class="operator">=</span><span class="string">&#x27;密码&#x27;</span>, source_log_file<span class="operator">=</span><span class="string">&#x27;同步的日志文件&#x27;</span>, source_log_pos<span class="operator">=</span>日志文件开始同步的位置; <span class="comment">--8.0.23</span></span><br><span class="line"></span><br><span class="line">change master <span class="keyword">to</span> master master_host<span class="operator">=</span><span class="string">&#x27;主机ip&#x27;</span>, master_user<span class="operator">=</span><span class="string">&#x27;用户名&#x27;</span>, master_password<span class="operator">=</span><span class="string">&#x27;密码&#x27;</span>, master_log_file<span class="operator">=</span><span class="string">&#x27;同步的日志文件&#x27;</span>, master_log_pos<span class="operator">=</span>日志文件开始同步的位置; <span class="comment">--8.0.23之前</span></span><br></pre></td></tr></table></figure></li><li>开启同步 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> replica; <span class="comment">--8.0.22</span></span><br><span class="line"><span class="keyword">start</span> slave; <span class="comment">--8.0.22之前</span></span><br></pre></td></tr></table></figure></li><li>查看主从同步状态 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> replica status; <span class="comment">--8.0.22</span></span><br><span class="line"><span class="keyword">show</span> slave status; <span class="comment">--8.0.22之前</span></span><br></pre></td></tr></table></figure> <div class="note info flat"><ul><li>文件显示比较乱，可以在后面加上\G，就会按行显示:<code>show replica status\G;</code></li><li>主要看两行:<ul><li><code>Replica_IO_Running: Yes</code></li><li><code>Replica_SQL_Running: Yes</code></li><li>只要这两行开启了，主从复制就没有问题</li></ul></li></ul></div></li></ol><h1>分库分表</h1><div class="note info flat"><ol><li>IO瓶颈: 热点数据太多，数据库缓存不足，产生大量磁盘I/O，请求数据太多，带宽不够</li><li>CPU瓶颈: 排序、分组、连接查询、聚合统计等<code>SQL</code>会消耗大量的CPU资源，请求数太多，CPU出现瓶颈</li></ol></div><ul><li><p>拆分维度分为垂直拆分和水平拆分，拆分粒度方面分为分库和分表</p><ol><li><strong>垂直分库</strong>: 以<strong>表</strong>为依据，将不同的业务拆分到不同数据库中<br>特点: 每个库<strong>表结构不一样</strong>、库中数据不同，所有库的并集才是全部的数据</li><li>垂直分表: 以<strong>字段</strong>为依据，根据字段属性将不同字段拆分到不同的表中<br>特点: 每个<strong>表结构不一样</strong>、每个表的数据不同，一般通过一列(主键/外键)关联、所有表的并集是全部数据</li><li>水平分库: 以<strong>字段</strong>为依据，将一个库的数据拆分到多个库中<br>特点: 每个<strong>库表结构一样</strong>、每个库数据不同、所有库的并集是全部的数据</li><li><strong>水平分表</strong>: 以<strong>字段</strong>为依据，将一个表的数据拆分到多个表中<br>特点: 每个表的<strong>表结构一样</strong>、每个表的数据不同、所有表的并集是全部的数据</li></ol>  <div class="note info flat"><ul><li><code>shardingJDBC</code>: 基于<code>AOP</code>，在应用程序对本地执行的<code>SQL</code>进行拦截，解析，改写，路由处理。只支持<code>Java</code>，性能好</li><li><code>MyCat</code>: 数据库分库分表的中间件，不用调整代码即可实现分库分表，支持多种语言</li><li>使用<code>mysql</code>一样的链接命令可以登录<code>mycat</code>，只有端口不一样，<code>mycat</code>端口是8066</li></ul></div></li></ul><h2 id="MyCat结构"><code>MyCat</code>结构</h2><ul><li><p>所有数据都存储在<strong>物理结构</strong>内<br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/MySQL/Mycat.png" alt="MyCat"></p></li><li><p>分片规则决定了某个数据应该插入到哪一个库的表中，一般水平分表的时候需要指定，默认是<code>auto-sharding-long</code>，其中规则为:根据id选择对应的数据库，但是如果超过了1500万，则直接报错</p></li></ul><h2 id="MyCat配置"><code>MyCat</code>配置</h2><ol><li><code>schema.xml</code>包含三组标签: <code>schema, datanode, datahost</code><ul><li><code>schema</code>核心属性:<ul><li><code>name</code>: 指定自定义的逻辑库库名</li><li><code>checkSQLschema</code>: 在<code>SQL</code>语句操作时指定了数据库名称，执行时是否自动去除。如果为<code>true</code>，表示第一次指定一下，后面就可以不用再指定数据库名称了。如果为<code>false</code>，则表明需要使用<code>use 数据库名;</code>进行指定</li><li><code>sqlMaxLimit</code>: 如果没有指定<code>limit</code>进行查询，列表查询模式返回查询了多少条记录</li></ul></li><li><code>schema.table</code>核心属性:<ul><li><code>name</code>: 定义逻辑表表名，在该逻辑库下唯一</li><li><code>dataNode</code>: 定义逻辑表所属的<code>dataNode</code>，需要与<code>dataNode</code>标签中的<code>name</code>对应，多个<code>dataNode</code>使用逗号分割</li><li><code>rule</code>: 分片规则名字，在<code>rule.xml</code>中定义</li><li><code>primaryKey</code>: 逻辑表对应真实表的主键</li><li><code>type</code>: 逻辑表的类型，只有全局表和普通表，默认为普通表。</li></ul></li><li><code>dataNode</code>核心属性:<ul><li><code>name</code>: 定义数据节点名称</li><li><code>dataHost</code>: 数据库实例主机名称，引用自<code>dataHost</code>标签中的<code>name</code>属性</li><li><code>database</code>: 定义分片需要的数据库</li></ul></li><li><code>dataHost</code>核心属性:<ul><li><code>name</code>: 唯一标识，供上层标签使用</li><li><code>maxCon/minCon</code>: 最大/最小连接数</li><li><code>balance</code>: 负载均衡策略，取值0,1,2,3</li><li><code>writeType</code>: 写操作分发方式，0表示写操作转发到第一个<code>writeHost</code>，第一个挂了就转发到第二个，1表示写操作随机分发到配置的<code>writeHost</code></li><li><code>dbDriver</code>: 数据库驱动，支持<code>native, jdbc</code></li></ul></li></ul></li><li><code>ruler.xml</code>包含两类标签: <code>tableRule、function</code></li><li><code>server.xml</code>主要包含两个标签: <code>system、user</code></li></ol><h2 id="MyCat分片"><code>MyCat</code>分片</h2><div class="note info flat"><ul><li>字典表类型的表可以设置成全局表</li></ul></div><h3 id="分片规则">分片规则</h3><ol><li>范围分片<code>auto-sharding-long</code></li><li>取模<code>mod-long</code></li><li>枚举<code>sharding-by-intfile-enumstatus</code></li><li>一致性哈希<code>sharding-by-murmur</code>: 计算指定的哈希值，根据哈希值计算落在哪一个逻辑表中。相同的哈希因子计算值总是划分到相同的分区表中，不会因为分区节点的增加而改变原来数据的分区位置</li><li>应用指定<code>sharding-by-substring</code>: 运行阶段由应用自主决定路由到哪个分片，并直接根据字符子串(必须是数字)计算分片号</li><li>固定分片哈希算法<code>sharding-by-long-hash</code>: 类似于十进制取模，但是为二进制操作。比如取低10位和1111111111进行位<code>&amp;</code>运算。分片长度最大默认为1024</li><li>字符串哈希解析<code>sharding-by-stringhash</code>: 截取子字符串，进行哈希算法，与<code>1023</code>进行位<code>&amp;</code>运算得出分片</li><li>按天分片<code>sharding-by-date</code></li><li>按月份分片<code>sharding-by-month</code></li></ol><h3 id="固定分片哈希算法-VS-取模">固定分片哈希算法 VS 取模</h3><ol><li>取模运算连续的值会分配到不同的分片，固定分片哈希算法中连续的值会分配到相同的分片，降低事务处理难度</li><li>固定分片哈希算法既可以均匀分配，也可以不均匀分配</li><li>分片字段必须是数字</li></ol><h2 id="MyCat管理"><code>MyCat</code>管理</h2><div class="note info flat"><ul><li>默认有两个端口，分别是8066和9066<ul><li>8066是数据访问端口，进行<code>DML</code>以及<code>DDL</code>操作</li><li>9066是数据库管理端口，即<code>MyCat</code>的服务管理控制功能，用于管理<code>MyCat</code>的整个集群状态</li></ul></li></ul></div><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">show @@help</td><td style="text-align:center">查看管理工具帮助文档</td></tr><tr><td style="text-align:center">show @@version</td><td style="text-align:center">查看mycat的版本</td></tr><tr><td style="text-align:center">reload @@config</td><td style="text-align:center">重新加载mycat的配置文件</td></tr><tr><td style="text-align:center">show @@datasource</td><td style="text-align:center">查看mycat的数据源信息</td></tr><tr><td style="text-align:center">show @@datanode</td><td style="text-align:center">查看mycat现有的分片节点信息</td></tr><tr><td style="text-align:center">show @@threadpool</td><td style="text-align:center">查看mycat线程池信息</td></tr><tr><td style="text-align:center">show @@sql</td><td style="text-align:center">查看执行的sql</td></tr><tr><td style="text-align:center">show @@sql.sum</td><td style="text-align:center">查看执行的sql统计</td></tr></tbody></table><h1>读写分离</h1><ul><li><p>主库写，从库读，配置<code>MyCat</code>的<code>writeHost</code>以及<code>readHost</code></p></li><li><p>读写分离需要修改<code>balance=1 or 3</code>，问题在于主库宕机了，就只能进行查询了(不满足高可用性)</p><table><thead><tr><th style="text-align:center">参数值</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">不开启读写分离机制，所有读操作发送到当前可用的writeHost上</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">全部的readHost与备用的writeHost都参与select语句的负载均衡(主要针对双主双从)</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">所有的读写操作都随机在writeHost，readHost上分发 (没有读写分离)</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">所有的读请求随机分发到writeHost对应的readHost上执行，writeHost不负担读压力</td></tr></tbody></table></li><li><p>为了避免主数据库挂了以后服务宕机的问题，可以使用<strong>双主双从</strong>的设置。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;日志&lt;/h1&gt;
&lt;div class=&quot;note info flat&quot;&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;MySQL&lt;/code&gt;中日志分为四类: 错误日志、二进制日志、查询日志、慢查询日志&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id=&quot;错误日志&quot;&gt;错误日志&lt;/h2&gt;
</summary>
      
    
    
    
    <category term="MySQL" scheme="https://sangs3112.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://sangs3112.github.io/tags/MySQL/"/>
    
    <category term="日志" scheme="https://sangs3112.github.io/tags/%E6%97%A5%E5%BF%97/"/>
    
    <category term="主从复制" scheme="https://sangs3112.github.io/tags/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    
    <category term="读写分离" scheme="https://sangs3112.github.io/tags/%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"/>
    
    <category term="分库分表" scheme="https://sangs3112.github.io/tags/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    
    <category term="MyCat" scheme="https://sangs3112.github.io/tags/MyCat/"/>
    
    <category term="分片规则" scheme="https://sangs3112.github.io/tags/%E5%88%86%E7%89%87%E8%A7%84%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>MySQL笔记_4</title>
    <link href="https://sangs3112.github.io/posts/202ac253.html"/>
    <id>https://sangs3112.github.io/posts/202ac253.html</id>
    <published>2024-03-15T09:22:00.000Z</published>
    <updated>2024-07-23T17:18:51.910Z</updated>
    
    <content type="html"><![CDATA[<h1>锁</h1><p><img src="https://gitee.com/sang3112/blog_imgs/raw/master/MySQL/lock.png" alt="lock"></p><h2 id="全局锁">全局锁</h2><div class="note info flat"><ul><li>锁整个数据库的，加锁后<strong>数据库只读</strong>。后续的<code>DML</code>、<code>DDL</code>包括已经更新操作的事务提交都被阻塞</li><li>应用场景:数据库逻辑备份，获得一致性视图，保证完整性</li><li><code>set global readonly=true</code>也可以实现全库只读<ul><li>但是<code>readonly</code>的值可能用来处理其他逻辑，比如主从库判断；</li><li>并且<code>FTWRL</code>可以再数据库异常退出的时候<strong>自动释放</strong>，但是<code>readonly</code>不行</li></ul></li></ul></div><ul><li><p>加全局锁: <code>flush tables with read lock;</code>(<code>FTWRL</code>)</p></li><li><p>数据库备份: <code>musqldump -u用户名 -p密码 数据库名 &gt; 路径/数据库名.sql</code></p></li><li><p>解锁: <code>unlock tables;</code></p>  <div class="note info flat"><ul><li>数据库备份的<code>mysqldump</code>命令只是一个工具，不是<code>mysql</code>内部的命令，因此不能在<code>mysql</code>界面中使用。在控制台使用即可，如果备份远程数据库，则需要使用<code>-h 设置ip</code></li></ul></div></li><li><p>缺点:</p><ol><li>主库上备份，则备份期间业务停摆，无法更新</li><li>从库上备份，则备份期间主库可以更新，但是从库无法执行主库同步的二进制日志(<code>binlog</code>)，导致主从延迟</li></ol>  <div class="note info flat"><ul><li><code>InnoDB</code>引擎中为了解决这个问题，加上<code>--single-transaction</code>参数完成不加锁的一致性备份。</li><li><code>mysqldump --single-transaction -u用户 -p密码 数据库名 &gt; 路径/数据库名.sql</code></li><li>实际上通过<strong>快照读</strong>实现，这种方式<strong>不需要</strong>添加全局锁</li><li>但是<code>MyISAM</code>中不支持这个隔离级别，所以就要<code>FTWRL</code>，因为<code>–single-transaction</code>需要数据库中所有的表的引擎都支持事务才行。</li></ul></div></li></ul><h2 id="表级锁">表级锁</h2><div class="note info flat"><ul><li>每次锁住整张表，粒度大，<strong>锁冲突的概率最高，并发度最低</strong>。</li><li>表级锁分三类:表锁、元数据锁(MDL)、意向锁</li></ul></div><h3 id="表锁">表锁</h3><div class="note info flat"><ul><li>表锁分两类: 表共享读锁(read lock)、表独占写锁(write lock)<ol><li>表共享读锁，<strong>所有人(包括自己)都只能看，不能写入</strong></li><li>表独占写锁，<strong>其他人不能看也不能写，加锁的人可读可写</strong></li></ol></li></ul></div><ul><li>加锁: <code>lock tables 表名... read / write</code></li><li>解锁: <code>unlock tables;</code>或者关闭客户端</li></ul><h3 id="元数据锁">元数据锁</h3><div class="note info flat"><ul><li>系统自动控制，无需显式使用，访问表的时候自动加上, 是<code>server</code>层的锁</li><li>维护表元数据的一致性，在表有活动事务的时候，不能对元数据进行写入</li><li>为了<strong>避免<code>DML</code>和<code>DDL</code>的冲突</strong>，保证读写的正确性</li><li>在对一张表进行增删改查(<code>DML</code>)，自动加<code>MDL</code>共享读锁</li><li>在对表结构变更的时候(<code>DDL</code>)，自动加<code>MDL</code>独占写锁</li><li>查看元数据锁: <code>select object_type, object_schema, object_name, lock_type, lock_duration from performance_schema.metadata_locks;</code><ul><li>如果<code>session A</code>申请<code>MDL</code>读锁，<code>session B</code>在之后申请<code>MDL</code>读锁，不会有问题。<code>session C</code>在之后申请<code>MDL</code>写锁，会被阻塞；如果<code>session D</code>再<code>session C</code>后面申请<code>MDL</code>读锁，也会被阻塞，因为<code>session C</code>的申请没有被处理。</li><li>为了解决这个问题，就要解决<strong>长事务</strong>；或者在<code>alert table</code>(<code>DDL</code>)中加入等待时间，如果等待时间内没有拿到<code>MDL</code>写锁就放弃</li></ul></li></ul></div><table><thead><tr><th style="text-align:center">对应SQL</th><th style="text-align:center">锁类型</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">lock tables xxx read / write</td><td style="text-align:center">SHARED READ ONLY / SHARED NO READ WRITE</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">select、select … lock in share mode</td><td style="text-align:center">SHARED READ</td><td style="text-align:center">与SHARED READ，SHARED WRITE兼容，与EXCLUSIVE互斥</td></tr><tr><td style="text-align:center">insert、update、delete、select…for update</td><td style="text-align:center">SHARED WRITE</td><td style="text-align:center">与SHARED READ，SHARED WRITE兼容，与EXCLUSIVE互斥</td></tr><tr><td style="text-align:center">alter table …</td><td style="text-align:center">EXCLUSIVE</td><td style="text-align:center">与其他MDL都互斥</td></tr></tbody></table><h3 id="意向锁">意向锁</h3><div class="note info flat"><ul><li>A更新某一行，添加了行锁，B同时想加表锁。这个时候，需要B一行一行检查是否存在行锁，性能极低。</li><li>为了减少<code>DML</code>在执行时，加的<strong>行锁和表锁的冲突</strong>，在<code>InnoDB</code>中引入了意向锁。</li><li>意向锁不用检查每行是否加锁，可以减少表锁的检查。</li><li>A更新某一行，添加了行锁，然后会对表添加意向锁。B同时想加表锁， 就先去检查是否存在意向锁。</li><li>意向锁分为两类: 意向共享锁(IS)、意向排他锁(IX)</li><li>查看<strong>意向锁以及行锁</strong>: <code>select object_schema, object_name, index_name, lock_type, lock_mode, lock_data from performance_schema.data_locks;</code></li></ul></div><ol><li><p>意向共享锁(IS)</p><ul><li>由语句<code>select ... lock in share mode</code>添加</li><li>与表锁中的共享锁(read)兼容，与表锁排他锁(write)互斥</li><li><code>select * form score where id=1 lock in share mode;</code>会加上行共享锁，同时会添加意向共享锁</li></ul></li><li><p>意向排他锁(IX)</p><ul><li>由语句<code>insert、update、delete、select ... for update</code>添加</li><li>与表锁共享锁(read)以及排他锁(write)都互斥，意向锁之间不互斥</li><li><code>update score set math=66 where id = 1</code>会加上行锁，同时会添加意向排他锁。</li></ul></li></ol><h2 id="行级锁">行级锁</h2><div class="note info flat"><ul><li>每次锁住对应的行，粒度小，<strong>锁冲突的概率最低，并发度最高</strong>。</li><li><code>InnoDB</code>数据基于索引组织，行锁通过对索引上的<strong>索引项加锁</strong>实现，<strong>不是对记录加锁</strong>。</li><li>行级分三类: 行锁、间隙锁、临键锁</li></ul></div><h3 id="行锁">行锁</h3><div class="note info flat"><ul><li>锁定单个行记录，防止其他事务进行<code>update</code>或<code>delete</code>，在<code>RC</code>,<code>RR</code>下都支持</li><li>行锁分两类: 共享锁(S)、排他锁(X)</li><li>行锁需要的时候才会加，但是在提交的时候才会释放，这就是<strong>两阶段协议</strong><ul><li>所以如果会锁住多行，要把最可能冲突的行影响并发度的行放后面</li></ul></li></ul></div><ol><li><p>共享锁(S)</p><ul><li>允许一个事务读一行，阻止其他事物获得相同数据集的排他锁</li></ul></li><li><p>排他锁(X)</p><ul><li>允许获取排他锁的事务更新数据，阻止其他事物获得相同数据集的排他锁和共享锁</li></ul></li></ol><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">共享锁</th><th style="text-align:center">排他锁</th></tr></thead><tbody><tr><td style="text-align:center">共享锁</td><td style="text-align:center">兼容</td><td style="text-align:center">冲突</td></tr><tr><td style="text-align:center">排他锁</td><td style="text-align:center">冲突</td><td style="text-align:center">冲突</td></tr></tbody></table><table><thead><tr><th style="text-align:center">SQL</th><th style="text-align:center">行锁类型</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">INSERT</td><td style="text-align:center">排他锁</td><td style="text-align:center">自动加锁</td></tr><tr><td style="text-align:center">UPDATE</td><td style="text-align:center">排他锁</td><td style="text-align:center">自动加锁</td></tr><tr><td style="text-align:center">DELETE</td><td style="text-align:center">排他锁</td><td style="text-align:center">自动加锁</td></tr><tr><td style="text-align:center">SELECT</td><td style="text-align:center">不加锁</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">SELECT … LOCK IN SHARE MODE</td><td style="text-align:center">共享锁</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">SELECT … FOR UPDATE</td><td style="text-align:center">排他锁</td><td style="text-align:center"></td></tr></tbody></table><div class="note info flat"><ul><li><code>InnoDB</code>在<code>RR</code>下会使用临键锁进行搜索和索引扫描，防止幻读。</li><li>针对唯一索引进行检索时，对已经存在的记录进行等值匹配时，会自动优化为行锁</li><li><code>InnoDB</code>行锁针对索引加锁，不通过索引条件检索数据，那么<code>InnoDB</code>将对表中所有记录加锁，此时升级为表锁。</li></ul></div><h3 id="间隙锁">间隙锁</h3><ul><li>锁定索引记录间隙(不包含该记录)，确保索引记录间隙不变，防止其他事物在这个间隙<code>insert</code>，导致幻读，在<code>RR</code>隔离级别下支持</li></ul><div class="note info flat"><ul><li><code>InnoDB</code>在<code>RR</code>下会使用临键锁进行搜索和索引扫描，防止幻读。</li><li>索引上的等值查询(唯一索引)，给不存在的记录加锁时，会优化为间隙锁</li><li>索引上的等值查询(普通索引)，向右遍历时最后一个值不满足查询要求时，临键锁退化为间隙锁</li></ul></div><h3 id="临键锁">临键锁</h3><ul><li>行锁和间隙锁的组合，同时锁住数据以及数据前的间隙，在<code>RR</code>隔离级别下支持</li></ul><div class="note info flat"><ul><li><code>InnoDB</code>在<code>RR</code>下会使用临键锁进行搜索和索引扫描，防止幻读。</li><li>索引上的范围查询(唯一索引)，会访问到不满足条件的第一个值为止，生成临键锁</li></ul></div><h2 id="死锁">死锁</h2><p><img src="https://gitee.com/sang3112/blog_imgs/raw/master/MySQL/45_deadlock.png" alt="45_deadlock"></p><ul><li>事务A等待事务B释放<code>id=2</code>的行锁，事务B等待事务A释放<code>id=1</code>的行锁，循环等待，进入死锁。</li></ul><div class="note info flat"><p>解决死锁的两种策略</p><ol><li>直接进入等待，直到超时，超时时间为<code>innodb_lock_wait_timeout</code>，默认50s，特别长，但是又不能缩短为1s，这样如果正常的请求时间长点就会被误杀。</li><li>死锁检测，发现死锁以后回滚某一个事务，让其他事务可以正常执行，将<code>innodb_deadlock_detect</code>设置为on，表示开启死锁检测逻辑</li></ol><ul><li>一般会使用死锁检测的方法，就是一个事务被锁的时候，判断依赖的线程有没有被别人锁住，最后判断是否出现循环等待，也就是死锁。</li><li>但是如果多个事务更新同一行，每个后面来的线程都会判断是不是由于自己导致死锁，时间复杂度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，每个线程都要遍历一次其他线程，所以最终时间复杂度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><ul><li>比如1000个线程同时修改一行数据，那么每个线程都要遍历其他999个线程判断是否存在循环依赖，就需要判断100万次。这样虽然不会出现死锁，但是CPU利用率很高，每秒却无法处理几个事务。<ul><li>对于上述的热点行，可以临时关闭死锁检测，就需要等待50s超时，风险较高</li><li><code>server</code>层限流，限制同一时间进入更新的线程数；可以使用中间件, 或者修改<code>MySQL</code>源码，对于同一行的修改，进入引擎之前排队。</li><li>拆行，将一行拆分为多行减少冲突概率，原理上就是分段汇总，比如<code>java</code>的原子类<code>LongAdder</code></li></ul></li></ul></li></ul></div><h1><code>InnoDB</code>引擎</h1><h2 id="逻辑存储结构-表空间-段-区-页-行">逻辑存储结构: 表空间 - 段 - 区 - 页 - 行</h2><ol><li>表空间(<code>ibd</code>文件)，一个<code>MySQL</code>实例可以对应多个表空间，用于存储记录，索引</li><li>段分为数据段(Leaf node segment)，索引段(Non-leaf node segment)，回滚段(Rollback segment)。数据段就是B+树叶子节点，索引段就是非叶子节点，段用来管理多个区</li><li>区默认大小为1M，默认存储64个页</li><li>页默认大小为16K，为了保证页的连续性，<code>InnoDB</code>每次从磁盘申请4~5个区。</li><li>行，数据按行存放。<code>Trx_id</code>就是最后一次事务操作的id;<code>Roll_pointer</code>是某条记录改动时，把旧版本写入<code>undo log</code>中，相当于一个指针，可以找到记录修改前的信息。</li></ol><h2 id="架构">架构</h2><ul><li>左侧是内存结构，右侧是磁盘结构:<br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/MySQL/architecture.png" alt="architecture"></li></ul><h3 id="内存结构">内存结构</h3><ol><li><p><code>Buffer Pool</code></p><ul><li>缓冲池是主内存中的一个区域，可以缓存磁盘上经常操作的真实数据。<strong>增删改查操作缓冲池中的数据，没有数据则从磁盘中加载到缓冲池中</strong>，再以一定的频率刷新到磁盘，减少磁盘I/O，加快处理速度。缓冲池以<strong>页</strong>为单位，底层采用<strong>链表</strong>管理页，页分三类:<br>(1) <code>free page</code>: 空闲页，没有使用<br>(2) <code>clean page</code>: 被使用的页，数据没有修改过<br>(3) <code>dirty page</code>: 脏页，被使用过被修改过，与磁盘不一致的数据(缓冲池中还没有刷新到磁盘的数据)</li></ul></li><li><p><code>Change Buffer</code></p><ul><li>更改缓冲区，(<strong>针对非唯一二级索引页</strong>，主键索引这种唯一索引是<strong>不会</strong>存储在更改缓冲区中)，执行<code>DML</code>语句时，如果这些数据页没有在缓冲池中，不会直接操作磁盘，而是将数据变更存在<code>Change Buffer</code>中，在未来数据被读取时，合并恢复到缓冲池中，再将合并后的数据刷新到磁盘</li><li>因为二级索引通常是非唯一的，以随机顺序插入二级索引。删除和更新可能会影响索引树中不相邻的二级索引页。每一次都操作磁盘则会产生大量的磁盘I/O，更改缓冲区可以在缓冲池中合并处理，减少磁盘I/O</li></ul></li><li><p><code>Adaptive Hash Index</code></p><ul><li>自适应哈希索引，<code>InnoDB</code>本身不支持哈希索引，支持B+树索引。但是B+树索引是等值索引，因此引入自适应哈希索引优化对缓冲池数据的查询。<code>InnoDB</code>会监控表上对各索引页的查询，如果观察到哈希索引可以提高速度，则会<strong>自动</strong>建立哈希索引，即为自适应哈希索引。</li><li>参数: <code>adaptive_hash_index</code>是自适应哈希索引的开关，默认是开启的</li></ul></li><li><p><code>Log Buffer</code></p><ul><li>日志缓冲区，用来保存将要写入到磁盘中的<code>Log</code>日志数据(<code>redo log</code>, <code>undo log</code>)，大小默认为16MB。日志会定期刷新到磁盘中，如果需要更新、插入或删除多行事务，增加日志缓冲区的大小可以节省磁盘I/O</li><li>参数: <code>innode_log_buffer_size</code> 缓冲区大小</li><li><code>innodb_flush_log_at_trx_commit</code> 日志刷新到磁盘的时机<ul><li>0: 日志每秒写入并刷新</li><li>1(<strong>默认</strong>): 日志在每次事务提交时写入并刷新到磁盘</li><li>2: 日志在每次事务提交后写入，并且每秒刷新到磁盘</li></ul></li></ul></li></ol><h3 id="磁盘结构">磁盘结构</h3><ol><li><p><code>System Tablespace</code></p><ul><li>系统表空间，是<strong>更改缓冲区</strong>的存储区域。如果表在系统表空间而不是每个表文件或者通用表空间中创建的，也可能包含表和索引数据</li><li>参数: <code>innodb_data_file_path</code></li></ul></li><li><p><code>File-Per-Table Tablespaces</code></p><ul><li>每个表的文件表空间包含单个表的数据和索引，存储在文件系统的单个数据文件中。</li><li>参数: <code>innodb_file_per_table</code>默认为开启的，如果不开启，则存储在系统表空间中</li></ul></li><li><p><code>General Tablespaces</code></p><ul><li>通用表空间，需要通过<code>create tablespace</code>语法创建，建表时可以指定该表空间</li><li>创建一个表空间: <code>create tablespace 表空间名 add datafile 表名.ibd engine=引擎名;</code></li><li>创建一张表并指定表空间: <code>create table xxx ... tablespae 表空间名;</code></li></ul></li><li><p><code>Undo Tablespaces</code></p><ul><li>撤销表空间，<code>MySQL</code>初始化时自动创建两个默认的<code>undo</code>表空间，初始大小16M，用于存储<code>undo log</code></li></ul></li><li><p><code>Temporary Tablespaces</code></p><ul><li>临时表空间，使用会话临时表空间和全局临时表空间，存储用户创建的临时表等数据</li></ul></li><li><p><code>Doublewrite Buffer Files</code></p><ul><li>双写缓冲区，<code>InnoDB</code>将数据页从缓冲池刷新到磁盘前，将数据页写入双写缓冲区文件中，便于系统异常时恢复数据</li><li>后缀: <code>.dblwr</code></li></ul></li><li><p><code>Redo Log</code></p><ul><li>重做日志，实现事务的<strong>持久性</strong>。日志文件由两部分组成，重做日志缓冲区<code>redo log buffer</code>和重做日志文件<code>redo log</code>。前者在内存中，后者在磁盘中。事务提交以后会把所有的修改信息都存到该日志中用于在刷新脏页到磁盘时，发生错误时进行数据恢复使用。</li><li><code>redo log</code> <strong>不会循环写</strong>，每隔一段时间清理之前没用的内容。</li><li><code>ib_logfile</code></li></ul></li></ol><h3 id="后台线程">后台线程</h3><ol><li><code>Master Thread</code> 核心后台线程，负责调度其他线程，同时将缓冲池中的数据<strong>异步</strong>刷新到磁盘中，保持数据的<strong>一致性</strong>。包括脏页的刷新，合并插入缓存，<code>undo</code>页的回收</li><li><code>IO Thread</code> 使用AIO来处理IO请求，<code>IO Thread</code>主要负责这些I/O请求的回调</li></ol><table><thead><tr><th style="text-align:center">线程类型</th><th style="text-align:center">默认个数</th><th style="text-align:center">职责</th></tr></thead><tbody><tr><td style="text-align:center">Read Thread</td><td style="text-align:center">4</td><td style="text-align:center">负责读</td></tr><tr><td style="text-align:center">Write Thread</td><td style="text-align:center">4</td><td style="text-align:center">负责写</td></tr><tr><td style="text-align:center">Log Thread</td><td style="text-align:center">1</td><td style="text-align:center">负责将日志缓冲区刷新到磁盘</td></tr><tr><td style="text-align:center">Insert Buffer Thread</td><td style="text-align:center">1</td><td style="text-align:center">负责将写缓冲区的内容刷新到磁盘</td></tr></tbody></table><ul><li><code>show engine innodb status;</code>查看<code>InnoDB</code>引擎的状态信息</li></ul><ol start="3"><li><code>Purge Thread</code>回收事务已经提交了的<code>undo log</code>，事务提交之后，<code>undo log</code>可能不用了，就用该线程来回收</li><li><code>Page Cleaner Thread</code>是协助 <code>Master Thread</code>刷新脏页到磁盘的线程，减轻<code>Master Thread</code>的工作压力，减少阻塞</li></ol><h3 id="事务原理">事务原理</h3><ul><li><p>一致性是通过<code>redo log, undo log</code>来保证的</p></li><li><p>隔离性通过锁机制，<code>MVCC</code>(多版本并发控制)实现</p></li><li><p>持久性由<code>redo log</code>保证</p></li><li><p>原子性由<code>undo log</code>保证<br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/MySQL/WAL.png" alt="WAL"></p></li><li><p><code>undo log</code>记录数据被修改前的信息，包含回滚和MVCC</p></li><li><p><code>undo log</code>记录逻辑日志，<code>redo log</code>记录物理日志</p></li><li><p>当<code>delete</code>时，<code>undo log</code>会记录一条<code>insert</code>记录；<code>update</code>时，<code>undo log</code>会有一条相反的<code>update</code>。执行<code>rollback</code>时，可以从逻辑记录中读取到相应的内容并回滚</p></li><li><p><code>undo log</code>销毁: <code>undo log</code>在事务执行时产生，事务提交时，不会立即删除，因为可能还要用于MVCC</p></li><li><p><code>undo log</code>存储: 采用<strong>段</strong>的方式进行管理和记录，存放在<code>rollback segment</code>中，内部包含1024个<code>undo log segment</code></p></li></ul><h2 id="MVCC-多版本并发控制">MVCC(多版本并发控制)</h2><div class="note info flat"><ul><li><code>MVCC</code>: 维护一个数据库的多个版本，使得<strong>读写操作没有冲突</strong>。</li><li>快照读为<code>MVCC</code>提供了一个非阻塞读的功能。</li><li>MVCC依赖:数据库记录中的三个隐式字段， <code>undo log</code>，<code>readView</code>实现</li></ul></div><div class="note info flat"><ol><li>当前读: 读取的是记录的<strong>最新版本</strong>，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。<ul><li><code>select ... lock in share mode</code>(共享锁)</li><li><code>select ... for update</code>、<code>update</code>、<code>insert</code>、<code>delete</code>(排他锁)</li><li>上述二者都是一种当前读</li></ul></li><li>快照读: 简单的<code>select</code>(不加锁)就是快照读，读取的是记录数据的可见版本，有可能是历史数据，非阻塞读<ul><li><code>Read Committed</code>: 每次<code>select</code>都生成一个快照读</li><li><code>Repeatable Read</code>: 开启事务后第一个<code>select</code>语句才是快照读的地方，后面实际上查询的都是<strong>第一个读生成的快照</strong></li><li><code>Serializable</code>: 快照读会退化为当前读</li></ul></li></ol></div><ol><li><p>记录中的隐式字段</p><table><thead><tr><th style="text-align:center">隐藏字段</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">DB_TRX_ID</td><td style="text-align:center">最近修改事务的ID，记录插入这条记录或最后一次修改该记录的事务ID</td></tr><tr><td style="text-align:center">DB_ROLL_PTR</td><td style="text-align:center">回滚指针，指向这条记录的上一个版本，用于配合undo log</td></tr><tr><td style="text-align:center">DB_ROW_ID</td><td style="text-align:center">隐藏主键，如果表没有主键才会生成</td></tr></tbody></table> <div class="note info flat"><ul><li>查看表空间<code>ibd</code>文件: <code>ibd2sdi 文件名.idb</code></li></ul></div></li><li><p><code>undo log</code></p><ul><li><code>undo log</code>日志可以被删除，但是不会立即删除<ul><li>当<code>insert</code>的时候，产生的<code>undo log</code>只在回滚时需要，事务提交以后，可以立即被删除</li><li>当<code>update, delete</code>的时候，产生的<code>undo log</code>日志不仅在回滚时需要，在快照读的时候也需要，不会立即被删除</li></ul></li></ul> <div class="note info flat"><p><code>undo log</code> 版本链</p><ul><li>不同事物或相同事务对同一条记录进行修改，导致该记录的<code>undo log</code>生成一条记录版本链表，链表头部是<strong>最新的旧记录</strong>，链表尾部是<strong>最早的旧记录</strong></li></ul></div></li><li><p><code>readView</code></p><ul><li>读视图是快照读<code>SQL</code>执行时<code>MVCC</code>提取数据的依据，记录并维护系统当前活跃的事务(<strong>未提交的</strong>)<code>id</code>，包含四个核心字段</li></ul><table><thead><tr><th style="text-align:center">字段</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">m_ids</td><td style="text-align:center">当前活跃事务ID</td></tr><tr><td style="text-align:center">min_trx_id</td><td style="text-align:center">最小活跃事务ID</td></tr><tr><td style="text-align:center">max_trx_id</td><td style="text-align:center">预分配事务，当前最大事务ID + 1(因为事务ID自增)</td></tr><tr><td style="text-align:center">creator_trx_id</td><td style="text-align:center">ReadView创建者的事务ID</td></tr></tbody></table></li></ol><h3 id="版本链数据访问规则">版本链数据访问规则:</h3><p><code>trx_id</code>表示当前事务ID</p><ol><li><code>trx_id</code> == <code>creator_trx_id</code> ? 可以访问该版本，因为等式成立表示数据是当前事务更改的(自己改的数据自己肯定可以先访问)</li><li><code>trx_id</code> &lt; <code>min_trx_id</code> ? 可以访问该版本，因为这个表明数据已经提交了，所以可以访问</li><li><code>trx_id</code> &gt; <code>max_trx_id</code> ? <strong>不可以</strong>访问该版本，因为表明当前事务是在readView生成后才开启的</li><li><code>min_trx_id</code> &lt;= <code>trx_id</code> &lt;= <code>max_trx_id</code> ? 如果<code>trx_id</code>不在<code>m_ids</code>中是可以访问该版本的。因为如果成立，表示数据已经提交了</li></ol><div class="note info flat"><ul><li><code>Read Committed</code>在事务中每一次执行快照读的时候生成<code>readView</code></li><li><code>Repeatable Read</code>在事务第一次执行快照读的时候生成<code>readView</code>，后序复用该<code>readView</code></li></ul></div><h1>MySQL四个系统数据库</h1><table><thead><tr><th style="text-align:center">数据库</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">mysql</td><td style="text-align:center">存储MySQL服务器正常运行所需要的各种信息(时区，主从，用户，权限等)</td></tr><tr><td style="text-align:center">information_schema</td><td style="text-align:center">提供了访问数据库元数据的各种表和视图，包含数据库、表、字段类型已经访问权限等</td></tr><tr><td style="text-align:center">performance_schema</td><td style="text-align:center">为MySQL服务器运行时状态提供了一个底层监控功能，用于手机数据库服务器性能参数</td></tr><tr><td style="text-align:center">sys</td><td style="text-align:center">一系列方便DBA和开发人员利用performance_schema性能数据库进行性能调优和诊断的视图</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;锁&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/sang3112/blog_imgs/raw/master/MySQL/lock.png&quot; alt=&quot;lock&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;全局锁&quot;&gt;全局锁&lt;/h2&gt;
&lt;div class=&quot;no</summary>
      
    
    
    
    <category term="MySQL" scheme="https://sangs3112.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://sangs3112.github.io/tags/MySQL/"/>
    
    <category term="锁" scheme="https://sangs3112.github.io/tags/%E9%94%81/"/>
    
    <category term="InnoDB引擎架构" scheme="https://sangs3112.github.io/tags/InnoDB%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84/"/>
    
    <category term="MVCC" scheme="https://sangs3112.github.io/tags/MVCC/"/>
    
    <category term="系统库" scheme="https://sangs3112.github.io/tags/%E7%B3%BB%E7%BB%9F%E5%BA%93/"/>
    
  </entry>
  
</feed>
