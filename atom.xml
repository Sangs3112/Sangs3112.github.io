<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sangs Blog</title>
  
  
  <link href="https://sangs3112.github.io/atom.xml" rel="self"/>
  
  <link href="https://sangs3112.github.io/"/>
  <updated>2025-01-16T15:34:13.092Z</updated>
  <id>https://sangs3112.github.io/</id>
  
  <author>
    <name>Sangs</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL笔记_6</title>
    <link href="https://sangs3112.github.io/posts/ce24a37f.html"/>
    <id>https://sangs3112.github.io/posts/ce24a37f.html</id>
    <published>2025-01-16T15:34:13.092Z</published>
    <updated>2025-01-16T15:34:13.092Z</updated>
    
    <content type="html"><![CDATA[<h1>语句耗时</h1><ol><li>如果<code>select</code>长时间不返回，使用<code>show processlist</code>查看当前语句处于什么状态<ul><li>比如<code>MDL</code>写锁阻塞了别的<code>session</code>的读</li><li>可以查询是什么<code>session</code>阻塞，但是在<code>MySQL</code>启动时需要设置<code>performance_schema = ON</code>，这样会有<code>10%</code>的性能损失</li></ul></li></ol><ul><li><p><code>sys.schema_table_lock_waits</code>，查询这张表可以找到导致阻塞的<code>processid</code>，<code>kill</code>掉即可</p></li><li><p>还有可能被<code>flush</code>阻塞了，一般<code>flush</code>的两个语句是<code>flush table t with read lock</code>锁表<code>t</code>，<code>flush tables with read lock</code>锁所有的表，本身刷脏页的速度很快，但是可能<code>flush</code>命令被别的<code>session</code>阻塞了</p></li><li><p>或者别的线程占用写锁，那么申请<code>lock in share mode</code>的读锁就会被阻塞。通过查找<code>sys.innodb_lock_waits</code>表即可</p></li><li><p>如果在<code>RR</code>场景下，或者在一个事务中，使用<code>select</code>，如果此时别的<code>session</code>有一个<code>update</code>语句，<code>update</code>了一百万次，那么自己的<code>select</code>语句就会特别慢，因为是一致性读，会存在非常大的<code>undolog</code>需要不断查找，而如果使用<code>select in lock share mode</code>，就是当前读，速度就会很快。</p></li></ul><h1>幻读</h1><ol><li><code>RR</code>下，普通查询是快照读，幻读只有在当前读的环境下才会出现，因为快照读不会看到别人提交的数据。并且，如果别人修改了一行，在当前读的两次查询中，第二次查询才读到，那不是幻读。幻读只有是读到别人新插入的行</li></ol><ul><li><p>幻读会破坏加锁的语义，因为先对d=5的行加锁，在别的<code>session</code>中<code>insert</code>了一条d=5，a=1的行，并修改a=1的行将b改成2，这样的话，也就是修改了d=5的行，破坏了最初对d=5的行加锁的语义</p></li><li><p>幻读 + statement格式的<code>binlog</code>会导致数据不一致性，因为<code>binlog</code>是在<code>commit</code>的时候才会记录，</p></li><li><p>即便给所有的行都加上锁，也无法解决幻读的问题，因为原本不存在的行，无法加锁，所以即便给所有的行都加锁，也没有办法阻止插入新的行</p></li><li><p>所以需要加上间隙锁，在值和值的中间加锁，避免插入新的值</p></li><li><p>解决幻读，需要加行锁和间隙锁(<code>gap lock</code>，开区间)</p></li><li><p>行锁 + 间隙锁 = <code>next-key lock</code> (临键锁，左开右闭)</p></li></ul><h2 id="死锁">死锁</h2><ol><li>如果对不存在的一行加锁，比如id=9，不存在<br><code>select * from t where id = 9 for update</code><ul><li>那么本来应该加行锁+间隙锁，但是因为id=9不存在，所以只会加间隙锁</li></ul></li><li>本来<code>select for update</code>是两个排他锁，但是因为不存在这一行，所以两个<code>session</code>都可以对<code>id=9</code>这一行使用<code>select for update</code>，因为都是间隙锁，所以不会冲突</li><li>此时<code>session B</code>判断不存在这一行，尝试添加<code>id=9</code>的记录，但是因为<code>session A</code>中有间隙锁，所以被阻塞</li><li><code>session A</code>也判断不存在这一行，尝试添加<code>id=9</code>的记录，但是因为<code>session B</code>中存在间隙锁，所以被阻塞，导致死锁</li></ol><ul><li>所以<code>RR</code>会导致死锁，因为只有<code>RR</code>才有间隙锁，一般会设置为<code>RC + row</code>格式的<code>binlog</code>，这样可以解决死锁，并且不会出现数据日志不一致问题</li><li>一般在金融等，或者表备份的时候，才是<code>RR</code></li></ul><h1>加锁</h1><ol><li>加锁的基本单位是<code>next-key lock</code>，前开后闭</li><li>查找中访问的对象才会加锁</li><li>索引上等值查询，唯一索引的时候<code>next-key lock</code> 退化为行锁</li><li>等值查询，最右边的值不满足等值查询的时候，退化为间隙锁</li><li>唯一索引上范围查询会找到不满足条件的第一个值</li></ol><p>现在一张表，字段是<code>id，c, d</code>，<code>c</code>上有普通索引，<code>id</code>是主键</p><ul><li>内含数据<code>(0, 0, 0)(5, 5, 5)(10, 10, 10)(15, 15, 15)(20, 20, 20)(25, 25, 25)</code></li></ul><h2 id="举例1-等值查询间隙锁">举例1 - 等值查询间隙锁</h2><table><thead><tr><th style="text-align:center">sessionA</th><th style="text-align:center">session B</th><th style="text-align:center">session C</th></tr></thead><tbody><tr><td style="text-align:center">begin;</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">update t set d = d + 1 where id = 7;</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">insert into t values(8, 8, 8);</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">update t set d = d + 1 where id = 10;</td></tr></tbody></table><ul><li>对于<code>session A</code>表中没有<code>id=7</code>的行，加锁单位是临键锁，前开后闭，所以范围是<code>(5, 10]</code></li><li>id=7是等值查询，找到最后边的值10，不满足等值条件，所以退化为间隙锁，加锁范围就是<code>(5, 10)</code></li><li><code>session B</code>插入id=8就会被阻塞，但是<code>session C</code>插入id=10不会被锁</li></ul><h2 id="举例2-非唯一索引等值查询">举例2 - 非唯一索引等值查询</h2><table><thead><tr><th style="text-align:center">sessionA</th><th style="text-align:center">session B</th><th style="text-align:center">session C</th></tr></thead><tbody><tr><td style="text-align:center">begin;</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">select id from t where c = 5 lock in share mode;</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">update t set d = d + 1 where id = 5;</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">insert into t values(7, 7, 7);</td></tr></tbody></table><ul><li>加临键锁，对<code>(0, 5]</code></li><li>c是普通索引，所以会访问到右边第一个不满足的值为止，也就是查询到10， 所以<code>(5, 10]</code>加临键锁</li><li>c=5是等值查询，最右边一个值10不满足等值条件，退化为间隙锁<code>(5, 10)</code></li><li>访问到的对象才会加锁，覆盖索引不需要访问主键，所以主键索引不需要加锁，因此<code>session B</code>可以完成，<code>session C</code>插入<code>(7, 7, 7)</code>会被阻塞</li><li><code>lock in share mode</code>只会锁覆盖索引，但是<code>for update</code>会判断你要更新，就会给主键索引上满足条件加行锁</li></ul><h2 id="举例3-主键索引范围查询">举例3 - 主键索引范围查询</h2><table><thead><tr><th style="text-align:center">sessionA</th><th style="text-align:center">session B</th><th style="text-align:center">session C</th></tr></thead><tbody><tr><td style="text-align:center">begin;</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">select * from t where id &gt;= 10 and id &lt; 11 for update;</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">insert into t values(8, 8, 8);</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">insert into t values(13, 13, 13);</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">update t set d = d + 1 where id = 15;</td></tr></tbody></table><ul><li>先找到<code>id = 10</code>，<code>next-key lock (5, 10]</code>，但是唯一索引会退化为行锁</li><li>但是范围查找，找到id=15停止，所以会有临键锁<code>(10, 15]</code></li><li>所以B插入<code>(8, 8, 8)</code>可以通过，插入<code>(13, 13, 13)</code>被阻塞；C更新15也被阻塞</li></ul><h2 id="举例4-非唯一索引范围查询">举例4 - 非唯一索引范围查询</h2><table><thead><tr><th style="text-align:center">sessionA</th><th style="text-align:center">session B</th><th style="text-align:center">session C</th></tr></thead><tbody><tr><td style="text-align:center">begin;</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">select * from t where c &gt;= 10 and c &lt; 11 for update;</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">insert into t values(8, 8, 8);</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">update t set d = d + 1 where c = 15;</td></tr></tbody></table><ul><li>查找c = 10的时候，临键锁<code>(5, 10]</code>，不是唯一索引，不会退化为行锁</li><li><code>session A</code>加上了两个临键锁<code>(5, 10]</code>和<code>(10, 15]</code></li><li>B插入<code>(8, 8, 8)</code>阻塞</li></ul><h2 id="举例5-唯一索引范围查询bug">举例5 - 唯一索引范围查询bug</h2><table><thead><tr><th style="text-align:center">sessionA</th><th style="text-align:center">session B</th><th style="text-align:center">session C</th></tr></thead><tbody><tr><td style="text-align:center">begin;</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">select * from t where id &gt; 10 and id &lt;= 15 for update;</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">update t set d = d + 1 where id = 20;</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">insert into t values(16, 16, 16);</td></tr></tbody></table><ul><li>A是范围查询，索引id加到<code>(10, 15]</code>临键锁，id是唯一索引，所以判断到id=15结束</li><li>但是会访问到第一个不满足条件的值为止，所以会找到id=20，范围查询，所以会加上<code>(15, 20]</code>的临键锁</li><li>因此B更新20会阻塞，C插入16也会阻塞</li></ul><h2 id="举例6-非唯一索引存在等值">举例6 - 非唯一索引存在等值</h2><p>比如同时有两行c=10，分别是<code>(10, 10, 10)</code>，和<code>(30, 10, 30)</code></p><ul><li>非唯一索引上包含主键值，所以不会重复</li></ul><table><thead><tr><th style="text-align:center">sessionA</th><th style="text-align:center">session B</th><th style="text-align:center">session C</th></tr></thead><tbody><tr><td style="text-align:center">begin;</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">delete from t where c = 10;</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">insert into t values(12, 12, 12);</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">update t set d = d + 1 where c = 15;</td></tr></tbody></table><ul><li>A遍历找到第一个c=10的记录，所以临键锁加在<code>(5 5, 10 10]</code>上</li><li>A向右查找，碰到第一个不满足条件的行，也就是<code>15 15</code>停止，等值查询，退化为<code>10 10</code>到<code>15 15</code>的行锁</li><li>所以最后是<code>(5 5, 10 10]</code>临键锁，<code>(10 10, 15 15)</code>行锁，因此B插入12会被阻止，C修改15会通过</li></ul><h2 id="举例7-limit加锁">举例7 - limit加锁</h2><table><thead><tr><th style="text-align:center">sessionA</th><th style="text-align:center">session B</th></tr></thead><tbody><tr><td style="text-align:center">begin;</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">delete from t where c = 10 limit 2;</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">insert into t values(12, 12, 12);</td></tr></tbody></table><ul><li>因为有<code>limit 2</code>，所以遍历到<code>10 30</code>后，就已经满足两条了，循环结束</li><li>A加锁范围就是<code>(5 5, 10 10]</code>临键锁<code>(10 10, 10 30]</code>临键锁</li><li>B插入12通过</li><li>所以删除的时候可以加<code>limit</code>，限制删除的条数，操作更安全。<ul><li>但是唯一索引上删除不需要，因为唯一索引本身就只加行锁</li><li>可能更适合普通索引，但是数据是唯一的情况</li></ul></li></ul><h2 id="举例8-死锁">举例8 - 死锁</h2><table><thead><tr><th style="text-align:center">sessionA</th><th style="text-align:center">session B</th></tr></thead><tbody><tr><td style="text-align:center">begin;</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">select id from t where c = 10 lock in share mode;</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">update t set d = d + 1 where c = 10;</td></tr><tr><td style="text-align:center">insert into t values (8, 8, 8)</td><td style="text-align:center"></td></tr></tbody></table><ul><li>A在c上加了<code>(5, 10]</code>临键锁和<code>(10, 15)</code>间隙锁</li><li>B要在c上加<code>(5, 10]</code>临键锁，所以等待A释放</li><li>A 想插入8，需要加锁，等待B释放，死锁</li><li>最后B回滚</li><li>B的临键锁没有申请成功，但是B加锁<code>(5, 10]</code>先加间隙锁，加锁成功，再加c=10的行锁，阻塞，两段执行</li></ul><h2 id="总结">总结</h2><ul><li>RR才有间隙锁，并且两阶段提交，事务<code>commit</code>了，锁释放</li><li>RC没有间隙锁，并且语句执行完就会释放不满足条件的行的行锁</li><li>RC在外键也会有间隙锁</li></ul><h1>优化</h1><ul><li><code>show variables like '%connections%;查看max_connections</code>，也就是最大连接数，超过最大连接数的就会被阻止，最大连接数不是越大越好。</li></ul><ol><li>处理掉占用连接但是没有工作的线程<ul><li><code>show variables like 'wait_timeout';</code>查看超时时间，超过时间以后就会断开连接</li><li>可以使用<code>kill connection + id</code>，但是这样客户端不会马上知道，只有在发起下一个请求以后才会报错，就变成了<code>MySQL</code>一直都没有恢复，但是再次 调用接口就可以访问了</li></ul></li><li>减少连接消耗<ul><li>用<code>–skip-grant-tables</code>跳过权限验证，但是<strong>风险极高，不建议使用</strong>，找回密码可以用</li><li><strong>8.0版本</strong>如果使用跳过权限验证，会同时<code>--skip-networking</code>打开这个，保证数据库只有本地访问</li></ul></li><li>性能问题导致短链接增加<ul><li>慢查询<ul><li>索引没设计好<ul><li><strong>5.6版本后</strong>可以使用<code>Online DDL</code>创建索引，<code>alert table</code>即可</li><li>如果一主一备，在从库处理，<code>set sql_log_bin=off</code>，不写<code>binlog</code>，加索引</li><li>主备切换</li><li>再在从库<code>set sql_log_bin=off</code>，加索引</li></ul></li><li>语句有问题<ul><li>使用存储过程<code>query_rewrite</code>重写某一个语句</li></ul></li><li>选错索引<ul><li>使用<code>query_rewrite</code>加上索引即可，或者语句加索引</li></ul></li><li>可以在上线前处理好，上线前将<code>slow log</code>打开，<code>long_query_time=0</code>记录查询语句</li><li>测试表模拟线上数据，回归测试</li><li>留意<code>row_examined</code>数据</li><li>全量回归测试可以使用开源工具<code>pt-query-digest</code></li></ul></li><li><code>QPS</code>暴增<ul><li>如果是全新业务有<code>bug</code>，下掉业务，数据库端去除白名单</li><li>新功能是单独数据库用户，删除用户，断开现有连接</li><li>如果和现有业务部署在一起，查询重写功能重写语句，压力最大的<code>SQL</code>直接<code>select 1</code>返回<ul><li>但是会有误伤，如果别的业务也用了这个SQL，或者这个语句还有别的用处，都会导致其他业务失败</li></ul></li></ul></li><li>更新语句</li></ul></li></ol><h1>数据更新</h1><ul><li><p><code>binlog</code>在事务执行时写入<code>binlog cache</code>，事务提交时写入<code>binlog</code>，清空<code>cache</code></p></li><li><p><code>binlog_cache_size</code>控制<code>cache</code>大小，超过大小的暂时写入磁盘</p></li><li><p>多个线程有自己的<code>binlog cache</code>，但是共用一个<code>binlog</code></p></li><li><p><code>write</code>是写入<code>cache</code>，速度快，<code>fsync</code>是写<code>binlog</code>文件，<code>sync_binlog</code>参数控制时机</p><ul><li><code>sync_binlog = 0</code>，每次提交只<code>write</code>，不<code>fsync</code></li><li><code>sync_binlog = 1</code>每次提交都会<code>fsync</code></li><li><code>sync_binlog = N</code>(<code>N &gt; 1</code>)，每次都<code>write</code>，累计<code>N</code>个事务再<code>fsync</code></li><li>IO非常大的话，可以适当调大这个值，<code>100 - 1000</code>，但是如果重启了，就会丢失N条<code>binlog</code>，如果容错率很低，不能设置为1</li></ul></li><li><p><code>redo log</code>三种状态，分别是<code>redo log buffer</code>，<code>write</code>到<code>page cache</code>，没有持久化和<code>fsync</code>到磁盘，<code>innodb_flush_log_at_trx_commit</code>控制</p><ul><li><code>= 0</code> 表示每次都只保存再<code>buffer</code>中</li><li><code>= 1</code> 表示每次提交都持久化到磁盘</li><li><code>= 2</code> 表示每次提交都<code>write</code>到<code>page cache</code></li><li><code>InnoDB</code>后台线程每隔1s都会将<code>redo log buffer</code>中的内容<code>write</code>到<code>pagecache</code>再<code>fsync</code>到磁盘，所有的线程共用一个<code>redo log buffer</code>，与<code>binlog</code>不同，所以没有提交的事务的<code>redo log</code>，也有可能被持久化到磁盘</li><li>同样，如果<code>redo log buffer</code>占用<code>innodb_log_buffer_size</code>即将到达一半，就会触发主动写盘，但是只<code>write</code>，没有<code>fysnc</code></li><li>如果并行事务，并且<code>innodb_flush_log_at_trx_commit=1</code>，那么别的事务提交的时候，会把自己没有提交的<code>redo log</code> 持久化到磁盘</li><li>如果=1，那么<code>prepare</code>阶段就会持久化一次，所以只需要每隔1s的刷盘，崩溃恢复的逻辑，只需要<code>binlog</code>写入磁盘，<code>redo log prepare write</code>了，就不需要<code>fsync</code>了</li><li>如果<code>sync_binlog=1， innodb_flush_log_at_trx_commit=1</code>，那么事务提交前，现需要等两次刷盘，一次是<code>redo log</code>的<code>prepare</code>，一次是<code>binlog</code></li><li>也就是如果<code>MySQL``TPS</code>两万，就会有四万次写磁盘，所以使用了组提交的方法减少写盘。</li></ul></li><li><p>日志逻辑序列号是<code>LSN</code>，单调递增，对应<code>redo log</code>的写入点，写入长度为<code>len</code>，那么<code>LSN + len</code>，可以避免多次重复提交<code>redo log</code></p><ul><li>比如三个事务同时在<code>redo log buffer</code>中，事务1写盘的时候，会带上事务23写盘，这样<code>LSN</code>之前的事务都完成了写盘，只需要看<code>LSN</code>后的事务即可</li><li><code>binlog</code>也是有组提交，但是效果不如<code>redo log</code>，因为<code>redo log</code>时间较短，所以<code>binlog</code>等不到那么多</li></ul></li></ul><ol><li>设置<code>binlog_group_commit_sync_delay</code>和<code>binlog_group_commit_sync_no_delay_count</code>，满足一个即可，减少<code>binlog</code>的写盘次数，故意等待时间，跟<code>sync_binlog</code>不同，<code>sync</code>是没有写盘就<code>commit</code>事务，但是这两个参数是直到写盘了，才<code>commit</code>事务，会增加响应时间，但是不会像<code>sync</code>一样丢数据<ul><li><code>innodb_flush_log_at_trx_commit</code>不建议为0，这样<code>redo log</code>只会在内存中，宕机了会丢数据</li><li><code>innodb_flush_log_at_trx_commit</code>设置成2，性能差不多，只有在主机关机才会丢数据，如果服务宕机，重启以后数据还在</li></ul></li></ol><ul><li><p>binlog不能中断，必须连续写，所以每个线程一个<code>binlog cache</code>，不然主从不一致；<code>redo log</code>甚至可以跟着别的线程一块写，所以都是一个<code>redo log buffer</code></p></li><li><p>所以可以<code>sync_binlog=1,innodb_flush_log_at_trx_commit=2</code>,这样<code>redo log</code>如果丢失了，就通过<code>binlog</code>恢复就可以</p></li><li><p>一般设置非双一，就是<code>innodb_flush_log_at_trx_commit=2</code>、<code>sync_binlog=1000</code></p><ul><li>业务高峰期，会有预案主库改写为非双1</li><li>从库延迟，为了让从库赶上主库，减少<code>binlog</code>生成频率，赶上了可以改回来</li><li>用备份恢复主库的副本，也就是使用<code>binlog</code>的时候</li><li>批量导入数据也可以修改，不然<code>binlog=row</code>产生内容太多</li></ul></li><li><p>主从首先保证了最终一致性，只要主库正确提交，就有<code>binlog</code>，那么从库正常就会重放<code>binlog</code></p></li><li><p>主从延迟就是从库执行完的时间点-主库执行完的时间点</p></li><li><p>从库上执行<code>show slave status</code>，可以看到<code>seconds_behind_master</code>，表示延迟了多少</p></li><li><p>主从延迟最主要是从库消费<code>relay log</code>的速度比主库生成<code>binlog</code>的速度更慢</p></li><li><p>主从延迟来源</p><ul><li>从库性能比主库机器性能差(但是现在一般不会)</li><li>从库压力大，CPU资源占用较多，导致重放<code>relay log</code>速度变慢<ul><li>一主多从，让多个从库分担压力</li><li><code>binlog</code>输出到外部，比如<code>Hadoop</code>，让外部提供查询能力</li></ul></li><li>大事务，比如一个事务再主库上执行了十分钟，就延迟了十分钟</li><li>大表上<code>DDL</code></li></ul></li></ul><h2 id="主从复制">主从复制</h2><ol><li>5.6版本之前，支持单线程，但是会导致应用日志较慢，造成延迟</li><li>多线程就是拆<code>sql thread</code>为多个线程<br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/MySQL/45_sqlthread.png" alt="45_sqlthread"><ul><li>比如<code>coordinator</code>就是原来的<code>sql thread</code>，但是不更新了，只是负责读中转日志，并分发日志，<code>work</code>线程才更新日志，<code>worker</code>线程个数根据<code>slave_parallel_workers</code>决定，一般32核设置8-16即可，</li><li><code>coordinator</code>分发规则：<ul><li>不能更新覆盖，同一行的两个事务必须在同一个<code>worker</code>中</li><li>不能拆分事务，同一个事务必须在同一个<code>worker</code>中</li></ul></li></ul></li><li>按表分发策略<ul><li>如果两个事务更新不同的表，就可以分发到不同的<code>worker</code>中</li><li>如果事务跨表，需要将两张表一起考虑</li><li>每个<code>worker</code>中对应一张<code>hash</code>表，保存当前<code>worker</code>中正在执行的事务里面涉及的表，值是多少个事务在更新这个表</li><li>如果<code>coordinator</code>收到事务T，判断其中修改的表<ul><li>没有<code>worker</code>中包含这些表，那就分给最空闲的<code>worker</code></li><li>如果跟多于一个<code>worker</code>冲突，就等待</li><li>如果只跟一个<code>worker</code>冲突，那就分给这个<code>worker</code></li></ul></li><li>所以如果热点表，就变成了单线程，如果负载均衡，就很好解决问题</li></ul></li><li>按行分发策略<ul><li>需要<code>binlog = row</code></li><li>必须有主键，不能有外键</li><li>但是对于大事务，耗费内存，耗费CPU资源更大</li></ul></li><li>5.6版本，按库分发并行</li><li>5.7版本<code>slave-parallel-type</code>控制并行策略，配置为<code>DATABASE</code>就是按库并行，配置<code>LOGICAL_CLOCK</code><ul><li>同处于<code>prepare</code>的事务，备库可以并行</li><li>处于<code>prepare</code>和<code>commit</code>的事务可以并行</li></ul></li></ol><p>一主多从基本架构<br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/MySQL/45_ms.png" alt="45_ms"></p><ol><li>主库负责写入和一部分读，从库负责读<br>切换主库的时候需要找同步位点，5.6版本使用<code>GTID</code>，全局事务ID，在事务提交时生成<br>两个部分，格式为<code>server_uuid:gno</code><ul><li><code>server_uuid</code>是实例启动产生的，全局唯一</li><li><code>gno</code>是整数，初始值为1，每次提交事务的时候分配给这个事务，就加1</li><li>启动<code>GTID</code>在启动时加上参数<code>gtid_mode=on</code> 和 <code>enforce_gtid_consistency=on</code>即可<br>使用基于<code>GTID</code>的主备切换，就不需要指定位点，因为位点是不精确的。所以建议使用基于<code>GTID</code>的主从复制</li></ul></li></ol><h3 id="主从延迟怎么解决">主从延迟怎么解决</h3><ol><li><p>强制走主库方案；</p><ul><li>比如交易平台，卖家发布商品以后，马上返回主页面，看商品是否发布成功，这个就强制走主库，因为需要拿到最新的结果</li><li>如果是买家，晚几秒看到商品也可以接受，就走从库</li></ul></li><li><p><code>sleep</code>方案</p><ul><li><code>sleep(1)</code>大部分同步1s内能搞定，但是不太稳妥</li></ul></li><li><p>判断主备无延迟方案</p><ol><li><code>show slave status中的seconds_behind_master</code>是否等于0<ul><li>单位是秒，如果精度不够，可以使用位点和<code>GTID</code></li></ul></li><li><code>Master_Log_File</code>和<code>Read_Master_Log_Pos</code>表示读到主库的最新位点<br><code>Relay_Master_Log_File</code>和<code>Exec_Master_Log_Pos</code>表示备库执行的最新位点<br>如果<code>Master_Log_File=Relay_Master_Log_File&amp;&amp;Read_Master_Log_Pos=Exec_Master_Log_Pos</code>表示日志同步完成</li><li><code>GTID</code>中<br><code>Auto_Position=1</code>表示主备使用了<code>GTID</code>协议<br><code>Retrieved_Gtid_Set</code>是备库收到的所有日志<code>GTID</code>集合<br><code>Executed_Gtid_Set</code>是备库已经执行完的<code>GTID</code>集合<br>如果两个集合相同，则日志同步完成</li><li>但是上面的方法是判断备库收到的<code>binlog</code>已经执行完了，但是实际上可能主库有<code>binlog</code>，但是备库还没有收到，这时需要使用半同步复制</li><li>业务高峰期，主库位点和<code>GTID</code>更新很快，位点判断就会一直不成立，那么从库就一直都无法响应</li></ol></li><li><p>配合<code>semi-sync</code>方案</p><ul><li>牺牲一定可用性，保持一致性</li><li>但是因为半同步只要一个从库同步就返回<code>ack</code>，实际上请求可能打到别的没有同步的从库上</li><li>所以半同步配合位点方案，会有问题<ul><li>一主多从，会有过期读的问题</li><li>如果一直有延迟，就一直无法<code>select</code>，但是实际上不需要等待到完全没有延迟，而是只要一个事务完成以后，<code>select</code>到哪个事务即可，不需要等待其他事务也同步完</li></ul></li></ul></li><li><p>等主库位点方案</p><ul><li><code>select master_pos_wait(file, pos[, timeout]);</code><ul><li><code>file pos</code>是主库上的文件名和位置</li><li>从库上执行</li><li><code>timeout</code>可选，表示超时</li><li>返回一个正整数<code>M</code>，表示命令开始执行，到应用完<code>file</code>和<code>pos</code>表示的<code>binlog</code>位置，一共执行了多少个事务</li><li>如果备库挂了，那就返回<code>NULL</code></li><li>如果超时，返回<code>-1</code></li><li>如果执行时，已经执行过这个位置了，返回0</li></ul></li><li>具体流程<ul><li>一个事务执行完，马上在主库上执行<code>show master status</code>得到主库执行到的<code>File</code>和<code>Pos</code>(不需要完全精确)</li><li>选一个从库查询</li><li>从库上执行<code>select master_pos_wait(File, Pos, 1);</code></li><li>如果返回&gt;=0，则再这个从库上执行查询语句</li><li>否则就去主库查询</li></ul></li><li>所以如果不允许过期读的情况出现，那么就超时放弃，或者转到主库查询，并做限流</li></ul></li><li><p>等 <code>GTID</code> 方案</p><ul><li><code>WAIT_FOR_EXECUTED_GTID_SET(gtid_set[, timeout])</code>，超时时间默认为0，如果为0，表示一直等待<ul><li>语句作用：等待，直到这个库执行的事务包含传入的<code>gtid_set</code>，返回0</li><li>超时返回1</li></ul></li><li>5.7版本后，不需要主动执行<code>show master status</code>，而是更新以后返回事务的<code>GTID</code>，减少一次查询<ul><li><code>session_track_gtids = OWN_GTID</code></li><li>通过API从<code>mysql_session_track_get_first</code>解析<code>GTID</code>即可</li></ul></li><li>具体流程<ul><li>事务完成，接受到事务的<code>GTID，gtid1</code></li><li>选一个从库查询，执行<code>WAIT_FOR_EXECUTED_GTID_SET(gtid1, 1)</code></li><li>返回0就在这个从库查询</li><li>否则去主库查询</li></ul></li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;语句耗时&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;如果&lt;code&gt;select&lt;/code&gt;长时间不返回，使用&lt;code&gt;show processlist&lt;/code&gt;查看当前语句处于什么状态
&lt;ul&gt;
&lt;li&gt;比如&lt;code&gt;MDL&lt;/code&gt;写锁阻塞了别的&lt;code&gt;sessi</summary>
      
    
    
    
    <category term="MySQL" scheme="https://sangs3112.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://sangs3112.github.io/tags/MySQL/"/>
    
    <category term="主从延迟解决" scheme="https://sangs3112.github.io/tags/%E4%B8%BB%E4%BB%8E%E5%BB%B6%E8%BF%9F%E8%A7%A3%E5%86%B3/"/>
    
    <category term="幻读" scheme="https://sangs3112.github.io/tags/%E5%B9%BB%E8%AF%BB/"/>
    
    <category term="死锁" scheme="https://sangs3112.github.io/tags/%E6%AD%BB%E9%94%81/"/>
    
    <category term="加锁判断" scheme="https://sangs3112.github.io/tags/%E5%8A%A0%E9%94%81%E5%88%A4%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>MySQL笔记_7</title>
    <link href="https://sangs3112.github.io/posts/b92393e9.html"/>
    <id>https://sangs3112.github.io/posts/b92393e9.html</id>
    <published>2025-01-16T15:34:13.092Z</published>
    <updated>2025-01-16T15:34:13.092Z</updated>
    
    <content type="html"><![CDATA[<h1>主备</h1><ol><li>主备切换流程<br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/MySQL/45_ms.png" alt="45_ms"><br>状态1，客户端读写都只访问节点A，B是从库，同步A的更新，保证AB数据相同<br>需要切换的时候，就变成状态2，客户端只访问节点B</li></ol><ul><li>状态1不会操作B，但是建议将B设置为<code>read only</code><ul><li>防止他人误操作B</li><li>防止切换逻辑出现双写的问题</li><li>判断访问节点的角色</li><li><code>read only</code>对超级管理员无效，所以可以同步更新的线程有超级权限</li></ul></li></ul><ol start="2"><li><p><code>binlog statement</code></p><ul><li><code>statement</code>就是记录<code>SQL</code>语言，甚至会把注释也都记录进去</li><li><code>statement</code>的格式下，<code>delete</code>带有<code>limit</code>，就是<code>unsafe</code>的，会导致主从不一致</li><li>删除条件的两个都有索引，如果主从版本不一，可能选择的索引不一致，所以顺序不同，导致<code>delete</code>的东西不同，本质上就是主从库可能<code>delete</code>的时候用到的索引不同，因为有<code>limit</code>存在，比如只删一条数据，就会导致数据不一致。</li></ul></li><li><p><code>binlog row</code></p><ul><li><code>row</code>里面多了<code>Table_map</code>和<code>Delete_rows</code></li><li><code>Table_map</code>用于说明接下来操作哪个库哪个表</li><li><code>Delete_rows</code>用于定义删除行为</li><li>实际上，<code>row</code>虽然会占用空间，但是有助于恢复数据，比如误删，可以根据<code>binlog</code>看到，直接插入即可；误增误改都可以这么处理</li></ul></li><li><p><code>binlog mixed</code></p><ul><li>如果有大量的删，那么<code>row</code>就会记录大量的内容，导致磁盘IO变多，占用空间变多</li><li><code>statement</code>就不会，只会有一条语句，但是在某些情况下，会导致不一致</li><li>所以<code>mixed</code>判断，如果不会导致不一致就用<code>statement</code>，如果可能会不一致，就切换到<code>row</code></li><li>这个格式用的不多</li></ul></li></ol><h2 id="双M">双M</h2><p><img src="https://gitee.com/sang3112/blog_imgs/raw/master/MySQL/45_2m.png" alt="45_2m"></p><ul><li>建议设置<code>log_slave_updates=ON</code>，从库执行完<code>relay log</code>以后也生成<code>binlog</code></li><li>A更新事务，<code>binlog</code>记录A的<code>server id</code></li><li>B接收到<code>binlog</code>，更新，并记录<code>server id</code>也就是A的<code>server id</code></li><li>再传回A，A判断<code>server id</code>等于自身，所以就不会处理日志</li></ul><h1>并发连接和并发查询</h1><ul><li>线程等待锁的时候，并发线程计数减一</li><li>因为等待锁的时候不吃cpu资源</li><li><code>innodb_thread_concurrency</code>设置最大并发线程数</li></ul><h1>检测MySQL</h1><ul><li><p>再<code>mysql</code>库中创建一个<code>health_check</code>表，只放一行数据，定期执行<br><code>mysql&gt; select * from mysql.health_check; </code></p></li><li><p>可以检测因为并发线程过多导致的数据库不可用的问题</p><ul><li><code>select 1</code>不行，因为不涉及<code>InnoDB</code>引擎，就算超出限制也会返回</li><li>但是这样的话，如果<code>binlog</code>磁盘占满了，也会阻塞<code>commit</code>事务，但是不会阻塞返回，所以这种方法无法判断是否存在磁盘满的情况</li></ul></li><li><p>更新判断：放一个<code>timestamp</code>字段，表示最后一次执行检测的时间：<code>mysql&gt; update mysql.health_check set t_modified=now();</code></p><ul><li>对主从库都需要执行更新检测</li><li>为了主备更新不冲突，再<code>mysql.health_check</code>上存入多行数据，用两个库的serverid作为主键</li><li>但是可能IO已经100%了，此时正好执行到<code>update</code>语句，那么就无法判断这种情况，不能及时切换</li><li>可以通过检测<code>performance_schema</code>里面<code>redolog</code>和<code>binlog</code>的写入时间判断是否存在问题，但是性能损耗10%</li></ul></li></ul><h1>误删数据</h1><ul><li><code>delete</code>误删某一行，那么就用<code>binlog</code>恢复即可，需要<code>binlog=row</code>，<code>binlog_row_image=FULL</code></li><li>可以将<code>sql_safe_updates=ON</code>预防，如果<code>delete</code>或者<code>update</code>没有写<code>where</code>条件，或者<code>where</code>条件没有索引，就会报错</li><li>如果需要删全表，则使用<code>truncate table</code> 或者 <code>drop table</code></li><li>但是如果<code>drop</code>或者<code>truncate</code>，无法使用<code>binlog</code>恢复，只能全量备份+增量恢复</li><li>如果对于核心库，可以使用延迟备份，减慢<code>binlog</code>到从库执行的时间，避免被删</li></ul><h1>kill</h1><ul><li>两个<code>kill</code>命令，<code>kill query + id</code> 和 <code>kill connection + id</code></li><li>发送<code>kill</code>命令以后，<code>session</code>运行状态改为<code>THD::KILL_QUERY</code>，并给<code>session</code>发送一个信号</li><li><code>kill</code>无效<ul><li>线程没有执行到判断线程状态的逻辑</li><li>终止逻辑耗时较长<ol><li>大事务被<code>kill</code>，需要回滚</li><li>大事务回滚包含较大的临时文件，压力过大，耗时长</li><li><code>DDL</code>最后阶段</li></ol></li><li><code>ctrl+c</code>命令是服务器开启一个新的线程发送<code>kill query</code>命令</li></ul></li></ul><h1>全表扫描</h1><ol><li>如果扫描一张大表，就获取一行数据，存储到<code>net_buffer</code>中，内存大小由<code>net_buffer_length</code>控制，默认<code>16K</code></li><li>重复获取行，直到<code>net_buffer</code>写满，发送</li><li>发送成功清空<code>net_buffer</code>，重复</li><li>发送返回<code>EAGAIN</code>或者<code>WSAEWOULDBLOCK</code>，表示本地网络栈写满，进入等待，直到网络栈重新可写，再继续等待</li></ol><ul><li>所以如果客户端接收的慢，事务执行时间就会变长<ul><li>可以使用<code>mysql_store_result</code>，将收到的内容存入客户端内存，加快接收速度</li><li>但是如果是大查询，就会占用大量内存，就需要使用<code>mysql_use_result</code></li></ul></li></ul><p><code>innodb_buffer_pool_size</code>一般设置为可用物理内存的60%-80%，线上服务的内存命中率需要达到99%，可以通过<code>show engine innodb status</code>查看<code>Buffer pool hit rate</code></p><ul><li><code>InnoDB</code>淘汰数据页用的<code>LRU</code>的改进<ul><li>因为如果对一个不常用的表使用全表扫描，这时候就会将别的业务正在使用的内存给顶掉，导致别的业务缓存失效</li><li>所以<code>InnoDB</code>按照<code>5:3</code>的比例将<code>LRU</code>分为了<code>young</code>和<code>old</code>区，<br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/MySQL/45_youngold.png" alt="45_youndold"></li><li>如图，状态1，访问P3，P3在<code>young</code>区，按照<code>LRU</code>，移到链表头部，变成状态2</li><li>此时，要插入新的数据页，淘汰<code>Pm</code>，但是新的数据页Px插入<code>LRU_old</code>处</li><li>处于<code>old</code>区的数据页，每次被访问都要做下面的判断：<ul><li>如果数据页存在超过1s，就移动到链表头</li><li>少于1s，位置不变，<code>innodb_old_blocks_time=1000</code>，表示1s</li><li>这样扫描大表也用到了<code>buffer pool</code>，但是对于<code>young</code>区没有影响</li></ul></li></ul></li></ul><h1>join</h1><ul><li><code>join</code>应该将小表作为驱动表，大表作为被驱动表，因为<code>InnoDB</code>只会用被驱动表上的索引，对于驱动表，也就是<code>join</code>前面的表，用的是全表扫描。如果驱动表是行数N，被驱动表M被驱动表上索引查询，所以如果回表，就需要在普通索引和主键索引上都查询一次，那么时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">2log_2(M)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mclose">)</span></span></span></span>,驱动表上查询<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>行，所以总共是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>+</mo><mn>2</mn><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N+2log_2(M)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mclose">)</span></span></span></span>，这就是<code>NLJ</code></li><li>这是仅限于可以使用被驱动表的索引，如果被驱动表没有索引，就会使用<code>BNL</code><ul><li>将驱动表的数据取出放到<code>join_buffer</code>中，</li><li>将被驱动表的每一行跟<code>join_buffer</code>中的数据对比，满足条件放到结果集中</li><li>总时间复杂度就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>M</mi></mrow><annotation encoding="application/x-tex">NM</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">NM</span></span></span></span></li><li>这样的话，时间复杂度就是两个表的全表扫描<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>+</mo><mi>M</mi><mo>+</mo><mi>N</mi><mi>M</mi></mrow><annotation encoding="application/x-tex">N + M + NM</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">NM</span></span></span></span></li><li>如果驱动表较大，无法放到<code>join_buffer</code>中，就会分段放，<code>join_buffer_size</code>默认<code>256k</code><ul><li>就会将驱动表放一部分行，直到<code>join_buffer</code>放满为止，然后将被驱动表取出比对，再清空<code>join_buffer</code>，放驱动表的下一部分数据，直到比对结束</li><li>假设N行驱动表分<code>K</code>段，<code>N</code>越大，<code>K</code>越大，所以<code>K</code>表示为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo>×</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">\lambda \times N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">λ</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo>∈</mo><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\lambda \in (0, 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">λ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li><li>扫描行数就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>+</mo><mi>λ</mi><mo>×</mo><mi>N</mi><mo>×</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">N + \lambda \times N \times M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">λ</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span></li><li>判断<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>∗</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">N*M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>次</li><li>所以应该让小表当驱动表</li></ul></li></ul></li><li>如果<code>join</code>很慢，就把<code>join_buffer_size</code>改大一些</li><li>尽量让<code>join</code>走<code>NLJ</code>，并且警惕<code>explain</code>检查字段是否出现<code>Block Nested Loop</code></li><li>在决定哪个表做驱动表的时候，应该是两个表按照各自的条件过滤，过滤完成之后，计算参与<code>join</code>的各个字段的总数据量，数据量小的那个表，就是“小表”，应该作为驱动表。</li><li><code>join</code>比强行拆分单表查询性能更好</li></ul><h2 id="Multi-Range-Read-MRR">Multi-Range Read(MRR)</h2><ul><li>如果一张表有主键id索引，普通索引a，通过a索引扫描，有时候需要回表查询主键</li><li>此时a虽然是在索引上顺序查询的，但是因为需要回表，所以在主键id索引上就是乱序查的。但是大都数数据都是通过主键自增顺序插入得到的，所以可以认为按照主键递增顺序查询的话对磁盘接近顺序读，性能会更好</li><li>所以MRR就是先根据索引a找到数据，放到<code>read_rnd_buffer</code>中，(随机读缓冲区)，将缓冲区中的数据按照id递增排序，然后依次在主键中查找。大小由<code>read_rnd_buffer_size</code>控制，如果<code>buffer</code>放满了就会先执行排序，然后查找id返回结果，清空<code>buffer</code>再进行下一步</li><li>如果想要使用<code>MRR</code>，<code>set optimizer_switch=&quot;mrr_cost_based=off&quot;</code>，因为优化器不会判断时使用<code>MRR</code>，所以设置为<code>off</code>，固定使用<code>MRR</code></li></ul><h2 id="Batched-Key-Access-BKA">Batched Key Access(BKA)</h2><ul><li><p>当使用<code>join</code>的时候，驱动表一行一行到被驱动表比对，用不上<code>MRR</code></p></li><li><p>现在将驱动表的内容拿出来，放到<code>join_buffer</code>中，原本<code>join_buffer</code>在<code>BNL</code>里才有暂存驱动表的数据，在<code>NLJ</code>没有用，现在<code>NLJ</code>也会用到</p></li><li><p>然后通过<code>join_buffer</code>跟被驱动表比对</p></li><li><p><code>set optimizer_switch='mrr=on,mrr_cost_based=off,batched_key_access=on';</code>通过这条语句开启<code>MRR</code>和<code>BKA</code>，因为<code>BKA</code>基于<code>MRR</code></p></li><li><p>如果<code>join</code>使用<code>BNL</code>，多次扫描一个冷表，语句执行超过1s，再次扫描冷表就会将数据页放到LRU头部</p></li><li><p>对应的情况就是冷表的数据量小于<code>buffer pool</code>的<code>3/8</code>，能够完全放到<code>old</code>区中。</p></li><li><p>如果冷表很大，业务正常访问的数据页，就没有机会进入<code>young</code>区，这是因为正常访问的数据页要进入<code>young</code>区的话，需要隔1s再被访问到，但是冷表很大，<code>old</code>区在1s内就淘汰了正常数据页，就会导致<code>buffer pool</code>没有这个数据</p></li><li><p>所以大表<code>JOIN</code>不仅会影响IO，IO在<code>join</code>结束也就恢复了，还会影响<code>buffer</code>，需要后面慢慢恢复</p></li></ul><h2 id="BNL对系统的影响">BNL对系统的影响</h2><ol><li>多次扫描被驱动表，影响IO</li><li><code>join</code>条件需要执行<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>×</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">M \times N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>次对比，大表占用非常多资源</li><li>导致<code>buffer pool</code>热数据被淘汰，影响内存利用率</li></ol><ul><li><p>可以尝试给被驱动表添加索引</p></li><li><p>如果不适合加索引，比如次数比较少，添加索引不划算。可以建临时表，给临时表加索引，再<code>join</code>即可，优化很好</p></li><li><p>或者自己在业务端实现<code>hash join</code>，会比临时表优化的还好，<code>select * from t1</code>驱动表t1所有数据存入<code>hash</code>结构，比如set之类，<code>select * from t2 where b&gt;=1 and b&lt;=2000</code>获取被驱动表的<code>2000</code>条数据，然后一条一条在业务端跟<code>hash</code>表内容比对即可。临时表需要比较<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi>k</mi><mo>×</mo><mn>2</mn><mi>k</mi></mrow><annotation encoding="application/x-tex">1k \times 2k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>次，但是<code>hash join</code>只需要比较<code>2k</code>次</p></li><li><p>临时表可以用各种引擎，但是内存表只用<code>memory</code>引擎，一般由mysql自动创建销毁</p></li><li><p>临时表建表语法时<code>create temporary table ...</code></p></li><li><p>一个临时表只能被创建它的<code>session</code>访问，其他<code>session</code>不可见</p></li><li><p>临时表可以与普通表重名</p></li><li><p>如果有同名的，那么<code>show create</code>和增删改查访问临时表</p></li><li><p><code>show tables</code>不显示临时表</p></li><li><p>所以临时表不需要担心重名问题，可以用来给<code>join</code>使用，而且不需要担心数据删除问题</p></li><li><p>分库分表跨库查询就会使用临时表</p></li><li><p>创建临时表的时候，<code>InnoDB</code>创建一个<code>frm</code>文件保存表结构定义，前缀是<code>#sql&#123;进程 id&#125;_&#123;线程 id&#125;_ 序列号</code><br>5.6版本之前，会在临时文件目录下创建一个相同前缀.ibd存放数据文件，5.7版本后有专门的临时表空间存放临时数据，因为前缀不同，所以可以创建同名临时表</p></li><li><p>但是普通表是库名+表名得到的，同一个库创建两个同名表就会报错</p></li><li><p>当<code>session</code>结束的时候，就会执行<code>drop temporary table + 表名</code></p></li><li><p>如果<code>binlog</code>不是<code>row</code>，就会记录临时表的操作，不然会报错，提示临时表不存在。但是<code>row</code>格式只会记录数据，所以不会有对临时表的操作，不会发现临时表不存在这种问题，就不会记录临时表</p></li></ul><h2 id="内存临时表">内存临时表</h2><ol><li><code>union</code>的<code>explain</code>会显示<code>using temporary</code>，表示使用临时表，将<code>union</code>前的结果存在临时表中，然后利用主键唯一性剔除第二个查询中的相同的结果</li></ol><ul><li>如果是<code>union all</code>，就没有去重了，所以也不需要临时表了</li></ul><ol start="2"><li><code>group by</code></li></ol><ul><li><p>创建内存临时表，表上两个字段m和c，主键是m</p></li><li><p>扫描t1上的索引a，取id，并%10记x</p><ul><li>临时表没有x的行，那么插入x,1</li><li>如果有x的行，那么对应的c+1</li><li><code>group by</code>处理完以后默认会对字段m按照自然顺序排序，如果不想排序提高效率，就可以直接加上<code>order by null</code><br><code>tmp_table_size</code>是内存临时表的大小设置参数，默认<code>16M</code>，超过大小会转为磁盘临时表</li></ul></li><li><p>不管是内存临时表还是磁盘临时表，<code>group by</code>都需要构建一个带唯一索引的表，执行代价高</p></li><li><p>5.7版本支持<code>generated column</code>机制，用来实现数据关联更新<code>alter table t1 add column z int generated always as(id % 100), add index(z);</code></p></li><li><p>这样索引z上的数据就是<code>group by</code>有序的数据了<code>group by id %100</code>就可以改写为<code>select z, count(*) as c from t1 group by z;</code>此时不再需要临时表，也不需要排序，直接返回即可</p></li><li><p><code>group by</code>语句使用<code>SQL_BIG_RESULT</code>提示，可以告诉<code>sql</code>数据量很大，直接使用磁盘临时表，然后优化器还会将原本的B+树直接改为数组存储 ，两次优化<br><code>select SQL_BIG_RESULT id%100 as m, count(*) as c from t1 group by m;</code></p></li><li><p>初始化<code>sort_buffer</code>，放入整型字段m</p></li><li><p>扫描t1.a，取id%100放入<code>sort_buffer</code></p></li><li><p>对<code>sort_buffer</code>中字段m排序</p></li><li><p>排完序就是有序数组</p></li><li><p>这样就不会使用临时表</p></li></ul><p><code>InnoDB</code>把数据放在主键索引上，其他索引保存主键id就是索引组织表<code>IOT</code></p><ul><li><p>总是有序</p></li><li><p>有空洞时，插入新数据只能放在固定位置，从而保证有序</p></li><li><p>数据位置改变，只需要修改主键索引</p></li><li><p>主键索引查一次，普通索引查两次</p></li><li><p>变长数据<br><code>Memory</code>数据单独存放，索引上保存数据位置，就是堆组织表<code>HOT</code></p></li><li><p>按照写入顺序</p></li><li><p>有空洞时找到空位就可以插入新数据</p></li><li><p>数据位置改变，需要修改所有索引</p></li><li><p>所有索引地位相同</p></li><li><p>不支持变长，定义<code>varchar</code>，也是 按照<code>char(N)</code></p></li><li><p>内存表锁表，并且丢失会有风险，一般不会用</p><ul><li>但是内存临时表不一样，因为不会被其他<code>session</code>访问，所以没有并发性问题</li><li>本来重启就是要删除的，所以丢失没关系</li><li>备库临时表也不会影响主库</li><li>支持<code>hash</code>索引</li></ul></li><li><p><code>MyISAM</code>主键自增值在数据文件中</p></li><li><p><code>InnoDB</code>主键自增值在内存中，8.0版本实现持久化</p><ul><li>5.7版本前没有持久化，保存在内存，重启后就找表的最大值，最大值+1作为自增值</li><li>如果id=10，则<code>AUTO_INCREMENT=11</code>，删除id=10，还是11，如果删除以后重启，AUTO=10</li><li>8.0版本变更记录在<code>redo log</code>中，重启依靠<code>redo log</code>恢复之前的值</li></ul></li><li><p>插入一行数据，指定为自增，判断id=0，null，或者没有指定，就把表的自增值赋值给他</p></li><li><p>如果id指定了值，就使用指定值；如果指定值小于自增值，则自增值不变；</p><ul><li>如果指定值大于等于自增值，就修改自增值，就是<code>auto_increment_offset</code>开始，<code>auto_increment_increment</code>为步长叠加，找到第一个大于指定值作为新的自增值。两个参数默认都是1</li></ul></li><li><p>如果插入数据，自增主键，但是插入数据失败，数据重复了，那么数据无法插入成功，并且主键自增值也没有改回去（唯一键冲突会导致主键自增不连续）</p></li><li><p>事务回滚也会导致自增主键不连续，为了性能，因为申请id很快，但是回滚id可能会导致主键冲突，没有必要</p></li><li><p>批量<code>insert ... select， replace ...select, load data</code>的场景下设置<code>innodb_autoinc_lock_mode=2</code>可以提升并发性，并且不会出现数据一致性问题</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;主备&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;主备切换流程&lt;br&gt;
&lt;img src=&quot;https://gitee.com/sang3112/blog_imgs/raw/master/MySQL/45_ms.png&quot; alt=&quot;45_ms&quot;&gt;&lt;br&gt;
状态1，客户端读写都只访问节点A</summary>
      
    
    
    
    <category term="MySQL" scheme="https://sangs3112.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://sangs3112.github.io/tags/MySQL/"/>
    
    <category term="主备切换" scheme="https://sangs3112.github.io/tags/%E4%B8%BB%E5%A4%87%E5%88%87%E6%8D%A2/"/>
    
    <category term="InnoDB和Memory" scheme="https://sangs3112.github.io/tags/InnoDB%E5%92%8CMemory/"/>
    
    <category term="join优化" scheme="https://sangs3112.github.io/tags/join%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Go笔记_0</title>
    <link href="https://sangs3112.github.io/posts/f86b96e2.html"/>
    <id>https://sangs3112.github.io/posts/f86b96e2.html</id>
    <published>2025-01-16T15:34:13.089Z</published>
    <updated>2025-01-16T15:34:13.089Z</updated>
    
    <content type="html"><![CDATA[<h1><code>GOROOT</code> VS <code>GOPATH</code> VS <code>GOBIN</code> VS <code>GOPROXY</code></h1><ul><li><code>GOROOT</code>: Go语言安装路径</li><li><code>GOPATH</code>: 若干工作区目录的路径。是我们自己定义的工作空间  <div class="note info flat"><ul><li><code>GO1.8</code>版本之后，开发包安装完成后会自动设置一个<code>GOPATH</code>目录，</li><li><code>GO1.14</code>版本之后，推荐使用<code>Go Module</code>模式，不一定非要将代码写在<code>GOPATH</code>目录下，也不需要自己配置<code>GOPATH</code></li></ul></div></li><li><code>GOBIN</code>: GO程序生成的可执行文件的路径</li><li><code>GOPROXY</code>: 默认为<code>GOPROXY=https://proxy.golang.org,direct</code>，修改为<code>GOPROXY=https://goproxy.cn,direct</code></li></ul><h1>跨平台编译</h1><h2 id="Windows-编译-LINUX或者OSX">Windows 编译 LINUX或者OSX</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SET CGO_ENABLED=0   // 禁用CGO</span><br><span class="line">SET GOOS=linux      // 目标平台, [windows, linux, darwin]</span><br><span class="line">SET GOARCH=amd64    // 目标处理器架构</span><br><span class="line">go build</span><br></pre></td></tr></table></figure><h2 id="LINUX-或者-OSX-编译其他环境">LINUX 或者 OSX 编译其他环境</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGO_ENABLED=0 GOOS=linux|darwin|windows GOARCH=amd64 go build</span><br></pre></td></tr></table></figure><div class="note info flat"><ul><li>只有Windows 需要在cmd窗口中运行<code>SET</code>命令</li></ul></div><h1>编写测试</h1><div class="note info flat"><ol><li>有一个程序名为<code>xxx.go</code>，则其测试程序应该名为<code>xxx_test.go</code></li><li>测试函数的命名以<code>Test</code>开始，例如<code>Testxxx()</code></li><li>测试函数只能有一个参数<code>t *testing.T</code>，参数<code>t</code>是测试的<code>hook</code>，测试失败时可以执行<code>t.Fail()</code>等操作</li></ol></div><h2 id="举例">举例</h2><ul><li>有一个<code>main</code>函数，打印<code>Hello world</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Hello</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Hello world&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">fmt.Println(Hello())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>则对应的测试代码应该为</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello_test.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestHello</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">got := Hello()</span><br><span class="line">want := <span class="string">&quot;Hello world&quot;</span></span><br><span class="line"><span class="keyword">if</span> got != want&#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;got &#x27;%q&#x27; want &#x27;%q&#x27;&quot;</span>, got, want)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在终端直接执行<code>go test</code>命令即可进行测试，如果文件名错误，会报错:<code>?       gogo    [no test files]</code></li></ul><h2 id="重构-t-Helper">重构 <code>t.Helper()</code></h2><p>现在有这两个文件<code>hello.go, hellotest.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> helloPrefix = <span class="string">&quot;Hello &quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Hello</span><span class="params">(name <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> helloPrefix + name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">fmt.Println(Hello(<span class="string">&quot;world&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestHello</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">assertCorrectMessage := <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T, got, want <span class="type">string</span>)</span></span>&#123;</span><br><span class="line">t.Helper()</span><br><span class="line"><span class="keyword">if</span> got != want&#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;got &#x27;%q&#x27; want &#x27;%q&#x27;&quot;</span>, got, want)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 成功</span></span><br><span class="line">t.Run(<span class="string">&quot;saying hello to people&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">got := Hello(<span class="string">&quot;chris&quot;</span>)</span><br><span class="line">want := <span class="string">&quot;Hello chris&quot;</span></span><br><span class="line">assertCorrectMessage(t, got, want)</span><br><span class="line">&#125;)</span><br><span class="line">    <span class="comment">// 失败</span></span><br><span class="line">t.Run(<span class="string">&quot;say hello world when an empty string is supplied&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">got := Hello(<span class="string">&quot;&quot;</span>)</span><br><span class="line">want := <span class="string">&quot;Hello world&quot;</span></span><br><span class="line">assertCorrectMessage(t, got, want)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>将断言单独作为一个函数，由两个子测试进行调用。</li><li>第一个子测试能通过，第二个子测试失败</li><li><code>t.Helper()</code>告诉测试套件这个函数是一个辅助函数，这样测试失败时报告的行号将在函数调用中，而不是在辅助函数内部。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不添加t.Helper()的输出</span></span><br><span class="line">--- FAIL: TestHello (0.00s)</span><br><span class="line">    --- FAIL: TestHello/say_hello_world_when_an_empty_string_is_supplied (0.00s)</span><br><span class="line">        hello_test.go:15: got &#x27;&quot;Hello &quot;&#x27; want &#x27;&quot;Hello world&quot;&#x27; # 断言函数处的行号，但是具体不知道是哪个测试用例出错</span><br><span class="line">FAIL</span><br><span class="line">exit status 1</span><br><span class="line">FAIL    gogo    0.001s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加t.Helper()的输出</span></span><br><span class="line">--- FAIL: TestHello (0.00s)</span><br><span class="line">    --- FAIL: TestHello/say_hello_world_when_an_empty_string_is_supplied (0.00s)</span><br><span class="line">        hello_test.go:28: got &#x27;&quot;Hello &quot;&#x27; want &#x27;&quot;Hello world&quot;&#x27; # 具体测试用例内部的行号</span><br><span class="line">FAIL</span><br><span class="line">exit status 1</span><br><span class="line">FAIL    gogo    0.001s</span><br></pre></td></tr></table></figure><h2 id="命名返回值">命名返回值</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Hello</span><span class="params">(name <span class="type">string</span>, language <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> name == <span class="string">&quot;&quot;</span>&#123;</span><br><span class="line">        name = <span class="string">&quot;world&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> greetingPrefix(language) + name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greetingPrefix</span><span class="params">(language <span class="type">string</span>)</span></span> (prefix <span class="type">string</span>)&#123;</span><br><span class="line">    <span class="keyword">switch</span> language &#123;</span><br><span class="line">        <span class="keyword">case</span> french:</span><br><span class="line">            prefix = frenchHelloPrefix</span><br><span class="line">        <span class="keyword">case</span> spanish:</span><br><span class="line">            prefix = spanishHelloPrefix</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            prefix = englishHelloPrefix</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在函数签名中，使用了命名返回值<code>prefix string</code><ul><li>会自动创建一个名为<code>prefix</code>的变量，并且分配零值，即如果是<code>int</code>，则<code>prefix=0</code>，如果是<code>string</code>，则<code>prefix=&quot;&quot;</code></li><li>会在<code>Go Doc</code>中显示，代码更加清晰</li><li>只需要直接写<code>return</code>即可，不需要<code>return prefix</code></li></ul></li><li>函数如果是小写字母开头，则是私有函数；如果是大写字母开头，则是公共函数</li></ul><h2 id="示例">示例</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// integer.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Add takes two integers and returns the sum of them</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info flat"><ul><li><code>Add</code>函数有两个相同类型的参数，所以可以直接写成<code>x, y int</code></li><li>添加的函数注释<code>Add takes two integers and returns the sum of them</code>会放在Go Doc中</li></ul></div><ul><li>添加示例函数，示例函数同样会更新在Go Doc中，可以反映出代码的实际功能</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// integer_test.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleAdd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sum := Add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    fmt.Println(sum)</span><br><span class="line">    <span class="comment">// Output: 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info flat"><ul><li><code>// Output: 3</code>实际上是<code>ExampleAdd()</code>这个函数的期望输出，如果写5，表明希望1 + 2 = 5，会返回测试失败</li><li>这个语法不能在别的测试中使用，只有<code>Examplexxx()</code>中可以使用</li><li>使用<code>go test -v</code>可以输出每个测试用例的通过情况，以及整体的通过情况，输出结果如下</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">=== RUN   TestAdd</span><br><span class="line">--- PASS: TestAdd (0.00s)</span><br><span class="line">=== RUN   ExampleAdd</span><br><span class="line">--- PASS: ExampleAdd (0.00s)</span><br><span class="line">PASS</span><br><span class="line">ok      integer 0.001s</span><br></pre></td></tr></table></figure></div><h2 id="基准测试">基准测试</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iter.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Repeat</span><span class="params">(a <span class="type">string</span>)</span></span> <span class="type">string</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> repeat <span class="type">string</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++&#123;</span><br><span class="line">        repeat += a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> repeat</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编写基准测试</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iter_test.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkRepeat</span><span class="params">(b *testing.B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++&#123;</span><br><span class="line">        Repeat(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info flat"><ul><li><code>testing.B</code>可以访问隐性命名<code>b.N</code>，表示这个代码的运行次数，并记录时间</li><li>测试框架会选择<code>b.N</code></li><li>使用<code>go test -bench=.</code>来运行基准测试，如果在<code>Windows</code>中则使用<code>go test -bench=&quot;.&quot;</code></li><li>如果直接使用<code>go test [-v]</code>不会运行基准测试</li><li>使用<code>go test -cover</code>查看覆盖率</li></ul></div><h1>数组 VS 切片</h1><ul><li><code>numbers := [5]int&#123;1,2,3,4,5&#125;</code></li><li><code>numbers := [...]int&#123;1,2,3,4,5&#125;</code></li><li>遍历数组的两个方式</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, number := <span class="keyword">range</span> numbers&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// range返回索引和值，使用空白标志符来忽略索引</span></span><br></pre></td></tr></table></figure><div class="note info flat"><ul><li>数组传参，比如需要传入<code>numbers</code>，参数类型应该为<code>numbers [5]int</code></li><li>此时如果传入一个<code>[4]int</code>传入函数，不能通过编译，因为会判定为不同的类型</li><li>所以导致数组没什么用，一般用切片<code>slice</code>，尺寸不固定</li><li>切片就是在声明的时候不指定长度，也就是<code>mySlice := []int{1,2,3}</code>，而不是<code>mySlice := [3]int{1,2,3}</code></li><li>参数是可变数量的切片时，应该写<code>numbers ... []int</code></li><li>不能对切片使用等于号，简单的方法是使用<code>reflect.DeepEqual</code>，用于判断两个变量是否相等</li><li>但是<code>reflect.DeepEqual</code>不是类型安全的，甚至可以比较<code>slice</code>和<code>string</code>。</li><li>使用<code>make</code>创建切片可以指定容量和长度，创建的新切片中所有元素均为<strong>0</strong></li></ul></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;code&gt;GOROOT&lt;/code&gt; VS &lt;code&gt;GOPATH&lt;/code&gt; VS &lt;code&gt;GOBIN&lt;/code&gt; VS &lt;code&gt;GOPROXY&lt;/code&gt;&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;GOROOT&lt;/code&gt;: Go语言安装路径&lt;/li</summary>
      
    
    
    
    <category term="Go" scheme="https://sangs3112.github.io/categories/Go/"/>
    
    
    <category term="Go" scheme="https://sangs3112.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go笔记_1</title>
    <link href="https://sangs3112.github.io/posts/8f6ca674.html"/>
    <id>https://sangs3112.github.io/posts/8f6ca674.html</id>
    <published>2025-01-16T15:34:13.089Z</published>
    <updated>2025-01-16T15:34:13.089Z</updated>
    
    <content type="html"><![CDATA[<h1>方法</h1><div class="note info flat"><ul><li>Go语言中只有不同的<code>package</code>中可以有相同函数名的函数，尽管参数不同，但是如果函数名相同就不能出现在相同的包中(函数重载Go语言没有)</li><li>方法需要通过一个特定的实例调用，比如<code>t.Errorf()</code>，这里的<code>Errorf</code>就是一个方法，通过实例<code>t</code>调用</li><li>函数可以随便调用，没有限制</li></ul></div><h1>接口</h1><ul><li>接口让函数接受不同类型的参数并创造类型安全并且高解耦的代码</li><li>Go语言中 interface resolution 是隐式的。如果传入的类型匹配接口需要的，则编译正确。</li><li>函数实现因此不需要关心参数是什么类型的，只需要声明一个接口，辅助函数就可以从具体类型解耦而只关心本身需要做的工作</li></ul><h1>表格驱动测试</h1><ul><li>如果需要测试一个接口的不同实现，或者传入的数据有很多不同的测试需求，则可以使用表格驱动测试</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestArea</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">areaTests := []<span class="keyword">struct</span>&#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">shape Shape</span><br><span class="line">want <span class="type">float64</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">&#123;name: <span class="string">&quot;Rec&quot;</span>, shape: Rec&#123;Width: <span class="number">12</span>, Height: <span class="number">6</span>&#125;, want: <span class="number">72.0</span>&#125;,</span><br><span class="line">&#123;name: <span class="string">&quot;Circle&quot;</span>, shape: Circle&#123;<span class="number">10</span>&#125;, want: <span class="number">314.15926</span>&#125;,</span><br><span class="line">&#123;name: <span class="string">&quot;Tri&quot;</span>, shape: Tri&#123;<span class="number">12</span>, <span class="number">6</span>&#125;, want: <span class="number">361.0</span>&#125;, </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, tt := <span class="keyword">range</span> areaTests&#123;</span><br><span class="line">got := tt.shape.Area()</span><br><span class="line">want := tt.want</span><br><span class="line"><span class="keyword">if</span> got != want&#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;%#v got &#x27;%.2f&#x27;, want &#x27;%.2f&#x27;&quot;</span>, tt.shape, got, want)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info flat"><ul><li>创建了一个匿名结构体，里面有shape和want，放在一个[]struct切片中</li><li>然后使用两个测试用例填充这个切片</li><li>Go中调用一个函数或者方法的时候，参数会被复制</li><li>使用指针解决这个问题，指向某个值，然后修改</li></ul></div><h1>map</h1><ul><li>Map是引用类型的，拥有对底层数据结构的引用</li><li>因此，Map可以是nil指，如果使用一个nil的map，那么会得到一个nil指针异常，导致程序终止</li><li>永远不要初始化一个空的map变量，比如:<code>var m map[string]string</code></li><li>可以用如下两种方式初始化空的map:</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dict = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;&#125;</span><br><span class="line">dict = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br></pre></td></tr></table></figure><ul><li>上述两种方法绝对不会出现nil指针异常</li></ul><h1>依赖注入</h1><ul><li><code>fmt.Fprintf</code>接受一个<code>Writer</code>参数，将字符串传递过去。</li><li><code>fmt.Printf</code>是标准的默认输出</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// di.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Greet</span><span class="params">(writer io.Writer, name <span class="type">string</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// fmt.Printf(&quot;Hello, %s&quot;, name)</span></span><br><span class="line">fmt.Fprintf(writer, <span class="string">&quot;Hello, %s&quot;</span>, name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Greet(os.Stdout, <span class="string">&quot;Elodie&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// di_test.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bytes&quot;</span></span><br><span class="line"><span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGreet</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">buffer := bytes.Buffer&#123;&#125; <span class="comment">// 注入依赖</span></span><br><span class="line">Greet(&amp;buffer, <span class="string">&quot;Chris&quot;</span>)</span><br><span class="line">got := buffer.String()</span><br><span class="line">want := <span class="string">&quot;Hello, Chris&quot;</span></span><br><span class="line"><span class="keyword">if</span> got != want &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;got %s want %s&quot;</span>, got, want)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info flat"><ul><li>Go中可以使用反引号创建字符串，允许将字符串中的东西放在新的一行，比如<br>`<br>3<br>1<br>2<br>`</li></ul></div><ul><li><p>Go中不会阻塞的操作在成为goroutine的单独进程中运行。使用go关键字声明</p></li><li><p><code>go test -race</code>可以发现<code>goroutine</code>中的竞争条件，比如可能多个进程同时写一个<code>map</code>，但是一次执行并不会触发这种现象。</p></li><li><p>可以通过<code>channels</code>协调<code>goroutine</code>解决数据竞争问题。</p></li><li><p>比如原本需要将多个进程的数据写入<code>map</code>中，现在可以使用<code>channel &lt;- data</code>，将数据发送到<code>channel</code>中，然后再使用<code>for</code>循环，将数据保存保存在新的map中，这样不会产生数据竞争的问题。<code>result := &lt;- channel</code></p></li><li><p>在函数调用之前加上<code>defer</code>前缀会在包含他的函数结束时调用它。</p><ul><li>有时候需要清理资源，比如在函数结束时关闭一个文件，或者关闭一个服务器，但是要把它放在创建服务器语句附近，以便函数内后面的代码仍然可以使用这个服务器，就可以使用<code>defer</code>，等到函数执行完再调用</li></ul></li></ul><h1>进程同步</h1><ul><li><code>select</code>可以轻易实现进程同步</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Racer</span> <span class="params">(a, b <span class="type">string</span>)</span></span> (winner <span class="type">string</span>, err <span class="type">error</span>)&#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;- ping(a):</span><br><span class="line"><span class="keyword">return</span> a, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> &lt;- ping(b):</span><br><span class="line"><span class="keyword">return</span> b, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> M- time.After(<span class="number">10</span> *time.Second):</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span>, fmt.Errorf(<span class="string">&quot;timed out waiting for %s and %s&quot;</span>, a, b)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ping</span><span class="params">(url <span class="type">string</span>)</span></span> <span class="keyword">chan</span> <span class="type">bool</span>&#123;</span><br><span class="line">ch := <span class="built_in">make</span> (<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">http.Get(url)</span><br><span class="line">ch &lt;- <span class="literal">true</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果是<code>v := &lt;- ch</code>等待值发送给<code>channel</code>，则这是一个阻塞调用，因为需要等待值返回</li><li><code>select</code>允许多个<code>channel</code>等待，第一个发送值的<code>channel</code>胜出。</li><li>使用<code>select</code>时，<code>time.After</code>是一个很好用的函数，因为<code>channel</code>可能永远不会返回一个值，那就有可能不会返回，因此使用<code>time.After</code>设置超时时间</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">t.Run(<span class="string">&quot;returns an error if a server doesn&#x27;t respond within 10s&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    serverA := makeDelayedServer(<span class="number">11</span> * time.Second)</span><br><span class="line">    serverB := makeDelayedServer(<span class="number">12</span> * time.Second)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> serverA.Close()</span><br><span class="line">    <span class="keyword">defer</span> serverB.Close()</span><br><span class="line"></span><br><span class="line">    _, err := Racer(serverA.URL, serverB.URL)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        t.Error(<span class="string">&quot;expected an error but didn&#x27;t get one&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1>反射</h1><blockquote><p>编写函数 <code>walk(x interface&#123;&#125;, fn func(string))</code>，参数为结构体x，并对 x 中的所有字符串字段调用 fn 函数</p></blockquote><ul><li>反射提供了程序检查自身结构体的能力。</li><li>允许使用类型<code>interface&#123;&#125;</code>，代表任意类型。但是这样市区了对类型安全的检查，编译器不会再检查类型</li><li>除非真的需要，否则不要使用反射</li><li>如果想要实现多态，可以考虑围绕接口实现。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;方法&lt;/h1&gt;
&lt;div class=&quot;note info flat&quot;&gt;&lt;ul&gt;
&lt;li&gt;Go语言中只有不同的&lt;code&gt;package&lt;/code&gt;中可以有相同函数名的函数，尽管参数不同，但是如果函数名相同就不能出现在相同的包中(函数重载Go语言没有)&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    <category term="Go" scheme="https://sangs3112.github.io/categories/Go/"/>
    
    
    <category term="Go" scheme="https://sangs3112.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>安卓逆向笔记_0</title>
    <link href="https://sangs3112.github.io/posts/4dd06a82.html"/>
    <id>https://sangs3112.github.io/posts/4dd06a82.html</id>
    <published>2025-01-15T08:08:00.000Z</published>
    <updated>2025-01-16T15:34:13.093Z</updated>
    
    <content type="html"><![CDATA[<h1>环境配置</h1><ol><li><p>雷电模拟器9(<code>debug</code>版)</p><ul><li>开启<code>Root</code>权限</li></ul></li><li><p>安装面具(<code>app-debug.apk</code>)</p><ul><li>进入主页后安装<code>Magisk</code>, 会发现只勾选了<code>安装到Recovery</code>, 不要点击其他内容</li><li>直接控制台杀死进程</li><li>重新打开面具, 再次点击安装, 发现勾选了两个选项, 点击下一步</li><li>方式选择<code>安装至系统分区</code>, 点击开始</li><li>如果出现了<code>Installation failed</code>, 需要在雷电模拟器的<code>设置</code>中选择<code>磁盘</code> -&gt; <code>系统磁盘</code>, 勾选<code>可写入</code></li><li>出现<code>All done</code>表示安装完成</li><li>重启模拟器</li><li>再次启动面具, 如果有弹窗<code>异常状态: 检测到不属于Magisk的su文件</code>直接<code>确定</code>不需要管</li><li>在面具的设置中打开<code>Zygisk</code></li></ul></li></ol><div class="note info flat"><ul><li>关于<code>异常状态</code>的提示, 可以进入模拟器的文件管理器</li><li><code>System</code> -&gt; <code>xbin</code>删除其中的<code>su</code>文件, 第一次删除失败就再删一次, 就可以消除这个提示</li></ul></div><ol start="2"><li><p><code>LSPosed</code>模块</p><ul><li>模拟器右侧<code>更多</code> -&gt; <code>共享文件夹</code> -&gt; <code>打开电脑文件夹</code> -&gt; 将<code>LSPosed.zip</code>拖到文件夹中</li><li>面具下面的<code>模块</code> -&gt; <code>从本地安装</code> -&gt; 右边选择<code>文件管理器</code> -&gt; 找到刚刚的共享文件夹 -&gt; 直接点击压缩包即可开始安装</li><li>出现<code>Done</code>表示安装完成, 重启模拟器</li><li>再次进入面具, 点击<code>模块</code>, 如果出现了<code>Zygisk-LSPosed</code>表示安装完成</li></ul></li><li><p>核心破解</p><ul><li>直接安装<code>核心破解.apk</code></li><li>提示<code>已安装, 但尚未激活</code>, 点击提示</li><li><code>启用模块</code> -&gt; 勾选<code>系统框架</code>, 重启模拟器</li></ul></li><li><p>算法助手</p><ul><li>安装<code>算法助手.apk</code></li><li>点击提示, 勾选需要<code>Hook</code>的软件即可, 然后重启<code>算法助手</code>即可</li><li>如果出现模块未启动, 重启模拟器即可</li><li>开启需要<code>Hook</code>对象的应用开关, 勾选<code>弹窗定位</code>, 点击右上角的启动</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;环境配置&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;雷电模拟器9(&lt;code&gt;debug&lt;/code&gt;版)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开启&lt;code&gt;Root&lt;/code&gt;权限&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装面具(&lt;code&gt;app-debug.apk&lt;</summary>
      
    
    
    
    <category term="Reverse" scheme="https://sangs3112.github.io/categories/Reverse/"/>
    
    
    <category term="Android" scheme="https://sangs3112.github.io/tags/Android/"/>
    
    <category term="Reverse" scheme="https://sangs3112.github.io/tags/Reverse/"/>
    
    <category term="Environment" scheme="https://sangs3112.github.io/tags/Environment/"/>
    
  </entry>
  
  <entry>
    <title>Java笔记_13</title>
    <link href="https://sangs3112.github.io/posts/9dced3f3.html"/>
    <id>https://sangs3112.github.io/posts/9dced3f3.html</id>
    <published>2024-12-16T01:18:00.000Z</published>
    <updated>2025-01-16T15:34:13.090Z</updated>
    
    <content type="html"><![CDATA[<h1>并发</h1><h2 id="创建线程">创建线程</h2><ol><li>将线程任务放在一个类的<code>run()</code>中, 这个类需要实现<code>Runnable</code>接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Runnable</code>是个函数式接口, 所以可以使用<code>lambda</code>表达式创建实例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">    task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>从这个<code>Runnable</code>构造一个<code>Thread</code>对象 <code>Thread t = new Thread(r);</code></li><li>启动线程 <code>t.start();</code></li></ol><div class="note info flat"><ul><li>还可以通过建立<code>Thread</code>类的子类定义线程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span> <span class="params">()</span> &#123;</span><br><span class="line">        task;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>然后构造这个子类的对象并调用<code>start()</code>, 但是现在一般不用这个方法, 如果有多个任务, 每个任务都要创建一个线程的开销的太大, 一般使用线程池</li><li>不要调用<code>Thread</code>类或者<code>Runnable</code>对象的<code>run()</code>, 直接调用<code>run()</code>会在同一个线程中执行这个任务, 而不会启动新的线程</li><li>应该调用<code>Thread.start()</code>创建一个新的线程执行<code>run()</code></li></ul></div><h2 id="线程的状态">线程的状态</h2><blockquote><p>使用<code>getState()</code>可以确定当前的状态</p></blockquote><ol><li><code>New</code> 新建</li><li><code>Runnable</code> 可运行</li><li><code>Blocked</code> 阻塞</li><li><code>Waiting</code> 等待</li><li><code>Time waiting</code> 计时等待</li><li><code>Terminated</code> 终止</li></ol><h3 id="New"><code>New</code></h3><ul><li>使用<code>new</code>新建一个线程, 比如<code>new Thread(r)</code>, 线程还没有开始运行</li></ul><h3 id="Runnable"><code>Runnable</code></h3><ul><li>调用<code>start()</code>后, 线程就是<code>Runnable</code>状态, 可以是正在运行, 也可以没有在运行</li></ul><h3 id="Blocked-Waiting-Time-waiting"><code>Blocked</code> &amp; <code>Waiting</code> &amp; <code>Time waiting</code></h3><ul><li>处于阻塞或等待状态时, 线程不活动, 不执行任何代码, 消耗最少的资源<ul><li>当一个线程试图获取一个内部的对象锁, 不是<code>java.util.concurrent.Lock</code>, 而这个锁目前被其他线程占有, 该线程就会阻塞; 当其他线程都释放了这个锁, 并且调度器允许该线程持有锁时, 该线程转换为非阻塞状态</li><li>当线程等待另一个线程通知调度器出现某个条件时, 线程进入等待状态, 阻塞状态和等待状态没有太大的区别. 调用<code>Object.wait(), Thread.join()</code>, 或者等待<code>java.util.concurrent</code>中的<code>Lock, Condition</code>时会进入等待状态</li><li>有几个方法有超时参数, 调用这些方法会让线程进入计时等待状态, 这个状态将会一直保持到计时器满, 或者接收到适当通知. 带有超时参数的方法有<code>Thread.sleep()</code>和计时版的<code>Object.wait(), Thread.join(), Lock.tryLock(), Condition.await()</code></li></ul></li></ul><h3 id="Terminated"><code>Terminated</code></h3><ul><li>由于<code>run()</code>正常退出, 线程自然终止</li><li>因为一个没有捕获的异常终止<code>run()</code>, 线程意外终止</li><li><code>stop()</code>会抛出一个<code>ThreadDeath</code>错误对象, 终止线程, 但是现在已经废弃不用</li></ul><h2 id="线程的属性">线程的属性</h2><h3 id="中断线程">中断线程</h3><ul><li>当线程执行了最后一条语句, 或者抛出了一个没有捕获的异常, 线程就会终止</li><li><code>stop()</code>可以强制停止, 但是已经废弃, 现在没有方法可以强制停止一个线程</li><li>可以使用<code>interrupt()</code>请求终止一个线程, 对一个线程调用<code>interrupt()</code>, 设置线程为中断状态, 每个线程都会不时检测这个<code>boolean</code>标志, 判断线程是否被中断了<ul><li>使用<code>Thread.currentThread().isInterrupted()</code>判断当前线程是否处于中断状态</li><li>如果线程被阻塞, 就无法查看中断状态, 需要引入<code>InterruptedException</code></li><li>在一个被<code>sleep(), wait()</code>阻塞的线程上调用<code>interrupt()</code>, 那个阻塞调用将被<code>InterruptedException</code>中断</li><li>如果在线程循环中调用了<code>sleep()</code>, 就没有必要使用<code>isInterrupted()</code>检测了, 因为如果设置了中断状态, <code>sleep()</code>也只会清除中断装填并直接抛出<code>InterruptedException</code>, 所以还要循环调用了<code>sleep()</code>, 可以直接<code>try-catch``InterruptedException</code></li></ul></li></ul><div class="note info flat"><ul><li><code>interrupted()</code>是一个静态方法, 检查当前线程是否被中断, 调用该方法会清除该线程中断状态</li><li><code>isInterrupted()</code>是一个实例方法, 检查是否有线程被中断, 不会清除线程中断状态</li></ul></div><ul><li>如果<code>catch(InterruptedException e)</code>没有什么需要做的, 可以<code>Thread.currentThread().interrupt()</code>设置中断状态, 或者直接不<code>try-catch</code>, 而是<code>throws InterruptedException</code></li></ul><h3 id="守护线程">守护线程</h3><ul><li><code>t.setDaemon(true)</code>将一个线程转换为守护线程, 唯一的作用是为其他线程提供服务</li><li>比如计时器线程, 或者清空过时缓存项的线程, 如果只剩下守护线程, <code>JVM</code>就会退出, 因为只有守护线程就没有必要运行程序了</li></ul><h3 id="线程名">线程名</h3><ul><li><code>t.setName(&quot;Name&quot;);</code>可以为任何线程设置一个名字</li></ul><h3 id="未捕获异常的处理器">未捕获异常的处理器</h3><ul><li>线程的<code>run()</code>不能抛出任何检查型异常, 如果有非检查型异常则会导致线程终止, 最终线程死亡</li><li>对于可以传播的异常, 也没有<code>catch</code>子句, 因为在线程死亡之前, 异常会传递到一个用于处理未捕获异常的处理器</li><li>这个处理器必须属于实现了<code>Thread.UncaughtExceptionHelper</code>接口的类, 接口只有一个方法<code>void uncaughtException(Thread t, Throwable e);</code></li><li>可以调用<code>setUncaughtExceptionHandler()</code>为任何线程设置处理器, 也可以使用静态方法<code>Thread.setDefaultUncaughtExceptionHandler()</code>为所有线程安装一个默认处理器</li><li>如果没有安装默认处理器, 则为<code>null</code>, 如果没有为单个线程安装处理器, 则处理器就是该线程的<code>ThreadGroup</code>对象</li><li>建议不要在自己的程序中使用线程组</li><li><code>ThreadGroup</code>类实现了<code>Thread.UncaughtExceptionhandler</code>接口, <code>uncaughtException()</code>执行以下操作<ul><li>如果该线程组有父线程组, 调用父线程组的<code>uncaughtExcpeiton()</code></li><li>否则, 如果<code>Thread.getDefaultUncaughtExceptionHandler()</code>返回一个非<code>null</code>的处理器, 则调用该处理器</li><li>否则, 如果<code>Throwable</code>是<code>ThreadDeath</code>的一个实例, 则什么都不做</li><li>否则, 将线程的名字以及<code>Throwable</code>的栈轨迹输出到<code>System.err</code></li></ul></li></ul><h3 id="线程优先级">线程优先级</h3><ul><li>每个线程都有一个优先级, 默认一个线程会继承构造他的线程的优先级</li><li>可以使用<code>setPriority()</code>设置优先级, <code>MIN_PRIORITY = 1</code>, <code>MAX_PRIORITY = 10</code>, <code>NORM_PRIORITY = 5</code></li><li>调度器选择新的线程时优先选择优先级高的线程, 优先级高度依赖于系统</li><li>早期优先级可能很有用, 现在不要使用线程优先级</li></ul><h2 id="同步">同步</h2><ul><li><code>javap -c -p xxx</code>可以反编译<code>xxx.class</code>, 查看虚拟机字节码</li><li>两种机制可以防止并发访问一个代码块, <code>synchronized</code>关键字和<code>Java 5</code>引入的<code>ReentrantLock</code>类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">myLock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    myLock.unLock();</span><br><span class="line">    <span class="comment">// 一定需要将unLock()放在finally中, 不然抛出异常退出将永远阻塞</span></span><br><span class="line">    <span class="comment">// 使用锁时不能使用try-with-resources</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>如果两个线程尝试访问同一个对象, 可以保证串行化访问; 如果两个线程访问不同的对象, 每个线程都会得到不同的锁对象, 两个线程都不会阻塞</p><ul><li>这个锁称为重入锁, 因为线程可以反复获得已经拥有的锁, 锁持有一个计数器跟踪对<code>lock</code>方法的嵌套调用</li><li><code>ReentrantLock(boolean fail)</code>可以构造一个采用公平策略的锁, 但是公平锁比常规锁慢的多, 而且就算使用公平锁, 也不能保证就可以公平处理</li></ul></li><li><p>线程进入临界区以后发现需要满足某个条件才能继续执行, 可以使用条件对象(条件变量)管理那些已经获得锁但是不能有效工作的线程</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">    bankLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (accounts[from] &lt; amout) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        bankLock.unLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果from账户中没有钱, 则while会一直循环, 一直持有锁, 别的线程无法充钱</span></span><br><span class="line"><span class="comment">// 可以使用newCondition()获得一个条件对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Condition sufficientFunds;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bank</span><span class="params">()</span> &#123;</span><br><span class="line">        sufficientFunds = bankLock.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果transfer()发现没有钱, 会调用sufficientFunds.await(), 当前线程暂停, 放弃锁, 其他线程可以执行</span></span><br><span class="line"><span class="comment">// 一旦一个线程调用了await(), 就进入了这个条件的等待集</span></span><br><span class="line"><span class="comment">// 锁可用时, 这个线程也不会变成可运行状态, 而是仍然保持非活动状态, 直到另一个线程在同一个条件上调用signalAll()</span></span><br></pre></td></tr></table></figure><ul><li><code>signalAll()</code>会重新激活所有满足条件的线程, 从等待集中移出, 再次变为可运行状态</li><li><code>await()</code>一般放在一个循环中<code>while(!(OK is proceed)) condition.await()</code></li><li>最终都需要有一个其他线程调用<code>signalAll()</code>, 因为当一个线程调用<code>await()</code>时, 没有办法自行激活<ul><li>如果没有别的线程调用<code>signalAll()</code>, 将永远阻塞, 导致死锁</li><li>只要一个对象状态有变化, 并且可能有利于正在等待的线程, 就可以调用<code>signalAll()</code></li><li><code>signal()</code>可以随机选择等待集的一个线程, 解除其阻塞状态, 比解除所有线程阻塞状态更加高效</li><li>但是如果随机解除阻塞状态的线程发现自己仍然无法运行, 就会再次阻塞, 此时没有其他线程调用<code>signal()</code>以后就会导致死锁</li></ul></li></ul><h3 id="synchronized"><code>synchronized</code></h3><ul><li><p>锁用来保护代码段, 一次只允许一个线程执行被保护的代码段</p></li><li><p>锁可以用来管理试图进入被保护的代码段的线程</p></li><li><p>一个锁可以有一个或者多个关联的条件对象</p></li><li><p>每个条件对象管理那些已经进入被保护代码段, 但是还不能执行的线程</p></li><li><p>如果一个方法声明时有<code>synchronized</code>关键字, 则对象的锁将会保护整个方法, 所以如果需要调用这个方法, 则线程必须获得内部对象锁</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    method body</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.intrinsicLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        method body</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.intrinsicLock.unLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>内部对象锁只有一个关联条件, <code>wait()</code>将一个线程添加到等待集, <code>notifyAll(), notify()</code>可以解除等待集线程阻塞</p></li><li><p>内部锁和条件存在一些限制</p><ul><li>不能中断一个正在尝试获得锁的线程</li><li>不能指定尝试获得锁的线程超时时间</li><li>没有锁只有一个条件对象, 比较低效</li></ul></li></ul><h3 id="同步块">同步块</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(obj) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 就获得了obj的锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bank</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span>[] accounts;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">            accounts[from] -= amount;</span><br><span class="line">            accounts[to] += amount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 但是如果是</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="string">&quot;lock&quot;</span>;</span><br><span class="line"><span class="keyword">synchronized</span> (lock) &#123;...&#125;</span><br><span class="line"><span class="comment">// 这里如果两个线程使用将会锁同一个对象, 因为字符串字面量会共享, 最终导致死锁</span></span><br><span class="line"><span class="comment">// 同时需要避免基本包装类型作为锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">lock</span> <span class="operator">=</span> Integer.valueOf(<span class="number">42</span>);</span><br><span class="line"><span class="comment">// 如果同一个数使用两次, 将会导致共享锁</span></span><br><span class="line"><span class="comment">// 如果需要修改一个静态字段, 会从特定的类上获得锁, 而不是从getClass()返回值上获得</span></span><br><span class="line"><span class="keyword">synchronized</span>(MyClass.class) &#123;...&#125; <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">synchronized</span>(getClass()) &#123;...&#125; <span class="comment">// Error</span></span><br><span class="line"><span class="comment">// 如果从一个子类调用这个方法, getClass()会返回一个不同的class对象, 不能保证互斥了</span></span><br></pre></td></tr></table></figure><h3 id="监视器">监视器</h3><ul><li>监视器是指包含私有字段的类</li><li>监视器类的每个对象都有一个关联的锁</li><li>所有方法由这个锁锁定, 如果客户端调用<code>obj.method()</code>, 调用开始时就会自动获得<code>obj</code>对象的锁, 并且在返回时自动释放这个锁<ul><li>因为所有的字段都是私有的, 这样就可以保证一个线程处理字段时, 其他线程都无法访问</li></ul></li><li>锁可以有任意多个关联的条件</li></ul><h3 id="volatile"><code>volatile</code></h3><ul><li>如果写一个对象, 这个对象接下来可能被另一个线程读取; 或者读一个对象, 这个对象可能已经被另一个线程写入, 就必须使用同步</li><li><code>volatile</code>关键字为实例字段的同步访问提供了一种免锁机制</li><li>如果声明一个字段时<code>volatile</code>, 那编译器或虚拟机就会考虑这个字段可能被另一个线程并发更新</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> done;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span> &#123;<span class="keyword">return</span> done;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setDone</span><span class="params">()</span> &#123;done = <span class="literal">true</span>;&#125;</span><br><span class="line"><span class="comment">// 如果另一个线程已经对该对象加锁, isDone()和setDone()就会被阻塞</span></span><br><span class="line"><span class="comment">// 可以声明为volatile</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> done;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span> &#123;<span class="keyword">return</span> done;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDone</span><span class="params">()</span> &#123;done = <span class="literal">true</span>;&#125;</span><br><span class="line"><span class="comment">// 但是volatile不能保证原子性</span></span><br></pre></td></tr></table></figure><h3 id="final变量"><code>final</code>变量</h3><ul><li><code>final var accounts = new HashMap&lt;String, Double&gt;()</code>声明为<code>final</code>以后, 其他线程会在构造器完成构造以后才能看到这个<code>accounts</code></li><li>如果不使用<code>final</code>, 不能保证其他线程看到的是<code>accounts</code>更新以后的值, 可能都只是<code>null</code>, 而不是信构造的<code>HashMap</code></li></ul><h3 id="原子性">原子性</h3><ul><li>假设对共享变量除了赋值以外不做其他操作, 可以使用<code>volatile</code></li><li><code>java.util.concurrent.atomic</code>包中包含很多原子操作, 使用了机器指令, 没使用锁<ul><li><code>AtomicInteger</code>类中包含<code>incrementAndGet, decrementAndGet</code>以原子方式对一个整数完成自增自减</li></ul></li><li>如果有大量的线程要访问相同的原子值, 性能会大幅度下降, 因为乐观更新需要叫多次重试<ul><li><code>LongAdder</code>和<code>LongAccumulator</code>类解决了这个问题</li></ul></li></ul><h3 id="stop-和-suspend"><code>stop()</code> 和 <code>suspend()</code></h3><ul><li><code>stop()</code>方法就不安全, 会终止所有未完成的方法, 包括<code>run()</code><ul><li>一个线程终止时, 会立即释放被它锁定的对象的锁, 导致对象处于不一致状态</li></ul></li><li><code>suspend()</code>不会破坏对象, 但是如果用来挂起一个持有锁的线程, 在这个线程恢复运行之前这个锁不可用<ul><li>如果调用<code>suspend()</code>的线程试图获得同一个锁, 那么就会导致死锁问题</li></ul></li></ul><h3 id="按需初始化">按需初始化</h3><ul><li><code>JVM</code>会在第一次使用类时初始化一个静态初始化器, 并且只会执行一次</li><li><code>JVM</code>利用一个锁来确保这一点, 但是需要确保构造器不会抛出任何异常</li></ul><h3 id="线程局部变量">线程局部变量</h3><ul><li><p>如果一个类中设置静态变量</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">final</span> <span class="type">SimpleDateFormat</span> <span class="variable">dataFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-mm-dd&quot;</span>);</span><br><span class="line"><span class="comment">// 如果此时两个线程都执行如下操作</span></span><br><span class="line"><span class="type">String</span> <span class="variable">dataStamp</span> <span class="operator">=</span> dataFormat.format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"><span class="comment">// 则dataFormat的内部结构可能会被破坏</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; dataFormat = ThreadLocal.withInitial() -&gt; <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-mm-dd&quot;</span>);</span><br><span class="line"><span class="comment">// 如果需要格式化方法, 可以调用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">dataStamp</span> <span class="operator">=</span> dataFormat.get().format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br></pre></td></tr></table></figure></li><li><p><code>java.util.Random</code>是线程安全的, 但是如果多个线程需要等待一个共享随机数生成器, 就很低效</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">random</span> <span class="operator">=</span> ThreadLocalRandom.current().nextInt(upperBound);</span><br><span class="line"><span class="comment">// ThreadLocalRandom.current()会返回当前线程的一个随机数实例</span></span><br></pre></td></tr></table></figure></li><li><p>如果需要共享一个数据库连接</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Connection&gt; connection = ThreadLocal.withInitial(() -&gt; <span class="literal">null</span>);</span><br><span class="line"><span class="comment">// 任务开始时可以初始化这个连接</span></span><br><span class="line">connection.set(connect(url, username, password));</span><br><span class="line"><span class="comment">// 任务调用某些方法, 所有方法都在一个线程, 其中一个方法需要这个连接</span></span><br><span class="line"><span class="type">var</span> <span class="variable">result</span> <span class="operator">=</span> connection.get().executeQuery(query);</span><br></pre></td></tr></table></figure></li><li><p>上述都要求只有一个任务使用线程, 如果是一个线程池执行任务, 可能不想共享相同线程的其他任务提供数据库连接, 就不能使用上述方法</p></li></ul><h2 id="线程安全的集合">线程安全的集合</h2><ul><li>有的并发散列表映射较大, 使用<code>size()</code>返回<code>int</code>类型, 如果超过了20亿则无法正常返回, 可以使用<code>mappingCount()</code>方法返回<code>long</code>类型数据</li><li>集合返回弱一致性迭代器, 表示迭代器不一定能够反映出构造之后所做的全部更改, 但是他们不会将同一个值返回两次, 也不会抛出<code>ConcurrentModificationException</code></li><li><code>java.util</code>包中的集合, 如果集合在迭代器构造之后发生改变, 将会抛出一个``ConcurrentModificationException`</li><li><code>ConcurrentHashMap</code>不允许有<code>null</code>, 如果传入<code>compute, merge</code>的函数返回<code>null</code>, 就会从映射中删除现有的条目</li></ul><h3 id="并发散列映射的批操作">并发散列映射的批操作</h3><ul><li><p>批操作会遍历映射映射, 处理遍历过程中找到的元素, 不会冻结映射的当前快照</p><ul><li>搜索<code>search</code>: 为每个键或值应用一个函数, 直到函数生成一个非<code>null</code>的结果, 然后函数终止, 返回这个结果</li><li>规约<code>reduce</code>: 组合所有的键值, 这里要使用所提供的一个累加函数</li><li><code>forEach</code>为所有键值应用一个函数</li></ul></li><li><p>所有操作都需要指定一个参数化阈值, 如果希望批操作在一个线程中运行, 可以使用<code>Long.MAX_VALUE</code>, 如果希望用尽可能多的线程运行批操作, 可以使用阈值1</p></li><li><p>希望找到出现次数超过1000次的单词:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> map.search(threshold, (k, v) -&gt; v &gt; <span class="number">1000</span> ? k : <span class="literal">null</span>);</span><br><span class="line"><span class="comment">// res最终是第一个匹配的单词, 如果所有单词都不匹配, 则res是null</span></span><br></pre></td></tr></table></figure></li><li><p><code>forEach</code>有两种形式, 第一种是为每个条目应用一个消费者函数</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.forEach(threshold, (k, v) -&gt; System.out.println(k + <span class="string">&quot;-&gt;&quot;</span> + v));</span><br></pre></td></tr></table></figure></li><li><p>第二种形式接受一个额外的转换器, 先应用转换器, 再传递到消费者函数</p></li><li><p>比如只打印很大的条目:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map.forEach(threshold, </span><br><span class="line">    (k, v) -&gt; v &gt; <span class="number">1000</span> ? k + <span class="string">&quot;-&gt;&quot;</span> + v : <span class="literal">null</span>,</span><br><span class="line">    System.out::prinln);</span><br></pre></td></tr></table></figure></li><li><p><code>reduce</code>操作用一个累加函数组合输入, 比如计算所有值的总和</p><ul><li><code>Long sum = map.reduceValues(threshold, Long::sum);</code></li></ul></li><li><p>同样可以使用一个转换器函数, 比如计算最长的键的长度</p><ul><li><code>Integer mLen = map.reduceKeys(threshold, String::length, Integer::max);</code></li></ul></li><li><p><code>CopyOnWriteArrayList</code>和<code>CopyOnWriteArraySet</code>是线程安全的集合, 所有更改器会建立底层数组的副本</p><ul><li>如果迭代访问集合的线程数超过更改集合的线程数, 这个更改就很有用</li><li>构造一个迭代器, 包含对当前数组的引用, 如果这个数组后来被更改了, 迭代器仍然会引用原来的数组, 尽管集合的数组已经被替换了, 所以迭代器可以访问一致, 但是过时的视图, 并不存在同步开销</li></ul></li></ul><h3 id="并行数组算法">并行数组算法</h3><ul><li><p><code>Arrays</code>提供了大量的并行化操作, 比如<code>Arrays.parallelSort()</code>可以对一个基本类型或对象数组排序</p><ul><li>对对象数组排序, 可以提供一个<code>Comparator</code>数组 <code>Arrays.parallelSort(words, Comparator.comparing(String::length));</code></li></ul></li><li><p>任何集合类都可以使用同步包装器变成线程安全的</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;E&gt; synchArrayList = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;E&gt;());</span><br><span class="line">Map&lt;K, V&gt; synchHashMap = Collections.synchronizedMap(New HashMap&lt;K, V&gt;());</span><br></pre></td></tr></table></figure><ul><li>得到的集合方法会使用一个锁加以保护</li><li>如果希望迭代访问一个集合, 同时另一个线程仍然可能修改这个集合, 就要使用客户端锁定</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(synchHashMap) &#123;</span><br><span class="line">    Iterator&lt;K&gt; iter = synchHashMap.keySet().iterator();</span><br><span class="line">    <span class="keyword">while</span>(iter.hasNext()) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="任务和线程池">任务和线程池</h2><ul><li>如果程序中使用了大量生命周期很短的线程, 不能将每个任务映射到一个单独的线程, 而是应该使用一个线程池</li></ul><h3 id="Callable-Future"><code>Callable</code>, <code>Future</code></h3><ul><li><code>Runnable</code>封装了一个异步运行任务, 可以想象成一个没有参数和返回值的异步方法</li><li><code>Callable</code>与<code>Runnable</code>相似, 只是有返回值, <code>Callable</code>是一个参数化接口, 只有一个方法<code>call</code>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line">    V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>Future</code>可以保存异步计算的结果, 可以启动一个计算, 将<code>Future</code>对象交给某个方法, 然后忘掉他</li><li>计算得到结果的时候, <code>Future</code>对象的所有者就会得到这个结果</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Future接口具有下面的方法</span></span><br><span class="line">V <span class="title function_">get</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// get()调用会阻塞, 直到计算完成</span></span><br><span class="line">V <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span>;</span><br><span class="line"><span class="comment">// 同样会阻塞, 不过如果超时了就会抛出一个TimeoutException</span></span><br><span class="line"><span class="comment">// 如果运行该计算的线程被中断, 两个方法都会抛出InterruptedException, 如果计算完成, 则get()立即返回</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 如果计算还在进行, 则isDone()返回false</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterrupt)</span>;</span><br><span class="line"><span class="comment">// cancel()取消计算, 如果计算还没有开始, 则永远不会开始了</span></span><br></pre></td></tr></table></figure><ul><li><p>取消一个任务涉及两个步骤, 找到并中断底层线程, <code>call()</code>方法中必须感知到中断, 并放弃工作</p></li><li><p>可以使用<code>FutureTask</code>执行<code>Callable</code>, 实现了<code>Future</code>和<code>Runnable</code>接口</p></li><li><p>也可以将一个<code>Callable</code>传递到执行器来执行</p></li><li><p><code>newCachedThreadPool()</code>构造一个线程池, 立即执行各种任务, 如果有空线程可以使用, 就使用空线程, 如果没有就创建</p></li><li><p><code>newFixedThreadPool()</code> 构造一个大小固定的线程池, 如果提交任务数大于空线程数, 没有得到服务的任务就放到队列中</p></li><li><p><code>newSingleThreadPool()</code> 退化的大小为1的线程池, 顺序执行所提交的任务</p></li><li><p>上述三个方法返回一个实现了<code>ExecutorService</code>接口的<code>ThreadPoolExecutor</code>类的对象</p></li><li><p>如果线程生存期很短, 或者大量时间都在阻塞, 可以使用一个缓存线程池</p></li><li><p>为了得到最优的运行速度, 并发线程数等于处理器内核个数, 这种情况应该使用固定线程池, 这样并发线程总数会有一个上限</p></li><li><p>单线程执行器对性能测试有帮助, 可以临时使用一个单线程池替换固定线程池, 测试不并发的情况下性能降低的量</p></li><li><p>使用线程池时所做的工作:</p><ul><li>调用<code>Executors</code>类的静态方法<code>newCachedTreadPool</code>或<code>newFixedThreadPool</code></li><li>调用<code>submit</code>提交<code>Runnable</code>或<code>Callable</code>对象</li><li>保留返回的<code>Future</code>对象, 以便得到结果或者取消任务</li><li>不想再提交任务时可以调用<code>shutdown</code></li></ul></li><li><p><code>invokeAny</code>提交一个<code>Callable</code>对象集合中的所有对象, 并返回某一个已经完成任务的结果, 不知道会返回哪个, 一般都是速度最快的</p></li><li><p>对于搜索问题, 可以使用这个方法</p></li><li><p><code>invokeAll</code>提交一个<code>Callable</code>对象集合中的所有对象, 方法阻塞, 直到所有任务都完成了, 并返回一个<code>Future</code>对象列表, 包含所有答案</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Callable&lt;T&gt;&gt; tasks = ...;</span><br><span class="line">List&lt;Future&lt;T&gt;&gt; res = executor.invokeAll(tasks);</span><br><span class="line"><span class="keyword">for</span> (Future&lt;T&gt; r: res) &#123;</span><br><span class="line">processFuture(r.get());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// get()方法会阻塞, 直到获得了一个结果</span></span><br></pre></td></tr></table></figure></li><li><p>可以使用<code>ExecutorCompletionService</code>管理, 将任务提交到这个完成服务中, 服务会管理一个<code>Future</code>对象的阻塞队列\</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExecutorCompletionService</span>&lt;T&gt;(executor);</span><br><span class="line"><span class="keyword">for</span> (Callable&lt;T&gt; task: tasks) service.submit(task);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tasks.size(); i ++) &#123;</span><br><span class="line">processFuture(service.task().get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>有的应用使用大量线程, 但是大部分是空闲的</p><ul><li>比如服务器为每个连接使用一个线程;</li><li>或者处理器内核使用一个线程执行计算密集型任务, 比如图像或者视频处理</li><li><code>Java 7</code>引入了<code>fork-join</code>框架支持后一类应用</li><li>比如一个任务可以分解为两个子任务分别计算, 需要扩展<code>Recursive&lt;T&gt;</code>的类, 或者扩展<code>RecursiveAction</code>的类</li><li>前者生成一个<code>T</code>结果, 后者不生成结果, 再覆盖<code>compute()</code>生成并调用子任务, 合并结果</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> <span class="keyword">extends</span> <span class="title class_">Recuresive</span>&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (to - from &lt; THRESHOLD) &#123;</span><br><span class="line">...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>后台中, <code>fork-join</code>框架使用了工作密取的启发式方法平衡可用线程的工作负载, 每个工作线程都有任务的一个双端队列<ul><li>一个工作线程将子任务压入双端队列的队头, 只有一个线程可以访问队头, 所以不需要加锁</li><li>一个工作线程空闲时, 会从另一个双端队列的队尾密取一个任务, 由于大的子任务都在队尾, 这种密取很少见</li><li><code>fork-join</code>是对非阻塞任务进行负载优化的, 对于阻塞任务就失效了, 需要使用<code>ForkJoinPool.ManagedBlocker</code>接口解决这个问题</li></ul></li></ul><h2 id="异步计算">异步计算</h2><h3 id="可完成Future">可完成<code>Future</code></h3><ul><li>如果有一个<code>Future</code>对象, 需要调用<code>get()</code>获得值, 方法会阻塞, 直到值可以使用</li><li><code>CompletableFuture</code>类实现了<code>Future</code>接口, 可以注册一个回调, 一旦结果可用, 就会在某个线程中利用该结果调用这个回调</li><li>采用这种方法, 一旦结果可用就可以对结果进行处理, 而不需要阻塞</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title function_">readPage</span><span class="params">(Url url)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UncheckedIOException</span>(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;, executor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果省略executor, 任务会在ForkJoinPool.commonPool()返回的执行器上运行</span></span><br><span class="line"><span class="comment">// supplyAsync()第一个参数是Supplier&lt;T&gt;, 而不是Callable&lt;T&gt;, 这两个接口都描述了无参并且返回类型为T的函数</span></span><br><span class="line"><span class="comment">// Supplier&lt;T&gt;允许抛出检查型异常, 但是Callable&lt;T&gt;不允许</span></span><br></pre></td></tr></table></figure><h2 id="进程">进程</h2><ul><li>有时候需要执行另一个程序, 可以使用<code>ProcessBuilder, Process</code>类<ul><li><code>Process</code>类在单一操作系统进程中执行一个命令</li><li><code>ProcessBuilder</code>类允许配置<code>Process</code>对象, 可以取代<code>Runtime.exec</code>调用</li></ul></li></ul><h3 id="创建进程">创建进程</h3><ul><li>指定需要执行的命令, 或者传入一个<code>List&lt;String&gt;</code><br><code>var builder = new ProcessBuilder(&quot;gcc&quot;, &quot;myapp.c&quot;);</code></li><li>可以使用<code>directory</code>改变工作目录<br><code>builder = builder.directory(path.toFile());</code></li><li>然后需要指定处理进程的标准输入, 输出, 错误流, 默认情况分别是一个管道  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OutputStream</span> <span class="variable">processIn</span> <span class="operator">=</span> p.getOutputStream();</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">processOut</span> <span class="operator">=</span> p.getInputStream();</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">processErr</span> <span class="operator">=</span> p.getErrorStream();</span><br></pre></td></tr></table></figure></li><li>如果希望使用管道将一个进程的输出作为另一个进程的输入, 可以使用<code>Java 9</code>提供的<code>startpipeline()</code></li></ul><h3 id="进程句柄">进程句柄</h3><ul><li>可以用四种方法得到一个<code>ProcessHandler</code></li></ul><ol><li>给定一个<code>Process</code>对象<code>p</code>, <code>p.toHandler()</code>会生成他的<code>ProcessHandler</code></li><li>给定一个<code>Long</code>类型的进程<code>ID</code>, <code>ProcessHandler.of(ID)</code>可以生成这个进程的句柄</li><li><code>Process.current()</code>是运行这个<code>JVM</code>的进程句柄</li><li><code>ProcessHandler.allProcesses()</code>可以生成对当前进程可见的所有操作系统进程的<code>Stream&lt;ProcessHandler&gt;</code></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;并发&lt;/h1&gt;
&lt;h2 id=&quot;创建线程&quot;&gt;创建线程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;将线程任务放在一个类的&lt;code&gt;run()&lt;/code&gt;中, 这个类需要实现&lt;code&gt;Runnable&lt;/code&gt;接口&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highli</summary>
      
    
    
    
    <category term="Java" scheme="https://sangs3112.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://sangs3112.github.io/tags/Java/"/>
    
    <category term="Java核心技术(卷一)" scheme="https://sangs3112.github.io/tags/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%8D%B7%E4%B8%80/"/>
    
  </entry>
  
  <entry>
    <title>Java笔记_12</title>
    <link href="https://sangs3112.github.io/posts/eac9e365.html"/>
    <id>https://sangs3112.github.io/posts/eac9e365.html</id>
    <published>2024-12-15T01:18:00.000Z</published>
    <updated>2025-01-16T15:34:13.090Z</updated>
    
    <content type="html"><![CDATA[<h1>集合</h1><h2 id="Collection接口"><code>Collection</code>接口</h2><ul><li>集合类的基本接口是<code>Collection</code>接口, 有两个基本方法  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Collection</span>&lt;E&gt; &#123;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E element)</span>;</span><br><span class="line">Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">E <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> E&gt; action)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果到达末尾依然调用next(), 会抛出NoSuchElementException</span></span><br><span class="line"><span class="comment">// remove()会删除上一次调用next()返回的元素</span></span><br><span class="line"><span class="comment">// remove()和next()有依赖性, 如果不先调用next(), 会抛出IllegalStateException</span></span><br><span class="line"><span class="comment">// 如果需要删除两个元素</span></span><br><span class="line">it.next();</span><br><span class="line">it.remove();</span><br><span class="line">it.next();</span><br><span class="line">it.remove();</span><br></pre></td></tr></table></figure></li></ul><h3 id="LinkedList"><code>LinkedList</code></h3><ul><li>对于<code>LinkedList</code>, 还存在一个<code>previous()</code>, 支持从后往前遍历</li><li>如果调用了<code>previous()</code>, 则<code>remove</code>或<code>set</code>将修改右边的元素</li><li>如果有两个迭代器, 一个修改元素, 另一个在遍历元素, 就会产生错误, 抛出<code>ConcurrentModificationException</code><ul><li>这里的修改只有增加或删除<code>add(), remove()</code>, <code>set()</code>不会引发错误</li></ul></li><li><code>LinkedList</code>的<code>get()</code>方法不是随机访问, 因为是链表格式, 只是做了一点优化, 如果索引大于<code>n / 2</code>, 则从后往前调用<code>previous()</code>访问</li></ul><h3 id="ArrayList"><code>ArrayList</code></h3><ul><li>支持动态数组, 并且不是同步的</li><li><code>Vector</code>也是动态数组, 但是是同步的, 如果只有一个线程访问<code>Vector</code>, 会在同步操作上花费大量时间, 此时用<code>ArrayList</code>会比较好</li></ul><h3 id="散列表">散列表</h3><ul><li><code>Java</code>中散列表使用<code>LinkedList</code>实现, 每个列表称为一个桶</li><li>先计算一个对象的散列码, 然后与桶的个数取余, 得到的就是存储桶的索引</li><li><code>Java 8</code>中, 桶满了会从链表转换为平衡二叉树</li><li>散列表的键要尽可能属于实现了<code>Comparable</code>接口的类, 这样可以避免散列码分布不均的问题</li><li>桶的个数一般设计为预计元素个数的<code>75%~150%</code>, 默认桶个数是16个</li><li>默认装填因子是0.75, 也就是当哈希表中已经转满了75%就会触发再散列</li></ul><h3 id="TreeSet"><code>TreeSet</code></h3><ul><li><code>TreeSet</code>是一个有序集合, 使用红黑树实现</li><li>插入元素比普通散列表慢, 但是查找一个元素只需要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">log_2(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>因为是有序的, 所以其中的元素必须实现了<code>Comparable</code>接口</li></ul><h2 id="Map"><code>Map</code></h2><ul><li>同样分为<code>HashMap</code>, <code>TreeMap</code></li></ul><h3 id="更新">更新</h3><ul><li><code>counts.put(word, counts.get(word) + 1)</code>, 可能<code>word</code>本身不存在, 会抛出<code>NullPointerException</code></li><li><code>counts.put(word, counts.getOrDefault(word, 0) + 1);</code></li><li><code>counts.putIfAbsent(word, 0)</code>, 表示如果<code>word</code>不存在, 则赋值为0, 然后调用<code>put</code>即可正常更新, 避免<code>null</code></li><li>也可以使用<code>merge</code>简化操作, <code>counts.merge(word, 1, Integer::sum)</code><ul><li>如果<code>word</code>不存在, 就设置为1</li><li>如果存在, 就使用<code>Integer::sum</code>设置为<code>word</code>与1的求和</li></ul></li></ul><h2 id="视图">视图</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; keys = map.keySet();</span><br><span class="line"><span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, E&gt; entry : map.entrySet()) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">k</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line"><span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> entry: map.entrySet) &#123;</span><br><span class="line">..</span><br><span class="line">&#125;</span><br><span class="line">map.forEach((k, v) -&gt; &#123;</span><br><span class="line">...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>可以在视图上调用<code>remove()</code>删除散列表的元素, 但是不能添加元素</li><li><code>keySet</code>方法返回了一个<code>Set</code>接口的类对象</li></ul><h2 id="WeakHashMap"><code>WeakHashMap</code></h2><ul><li>如果一个<code>HashMap</code>中删除了元素, 但是因为<code>HashMap</code>还在使用, 所以<code>GC</code>不会释放这个元素的空间</li><li>因此使用<code>WeakHashMap</code>可以释放删除元素的空间, 使用弱引用保存键</li></ul><h2 id="LinkedHashSet-与-LinkedHashMap"><code>LinkedHashSet</code> 与 <code>LinkedHashMap</code></h2><ul><li>会记住插入元素的顺序, 在元素加入哈希表后, 会添加到<code>LinkedList</code>双向链表中</li></ul><h2 id="EnumSet"><code>EnumSet</code></h2><ul><li>使用位序列实现, 如果对应的值出现了, 则在相应的位置设为1</li><li>没有公共构造器, 要使用静态工厂方法构造  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Weekday</span> &#123;MONDAY, TUESDAY, ...&#125;;</span><br><span class="line">EnumSet&lt;Weekday&gt; always = EnumSet.allOf(Weekday.class);</span><br><span class="line">EnumSet&lt;Weekday&gt; never = EnumSet.noneOf(Weekday.class);</span><br></pre></td></tr></table></figure></li></ul><h2 id="标识散列映射">标识散列映射</h2><ul><li><code>IdentityHashMap</code>, 键的散列值不是通过<code>hashCode()</code>计算得到, 而是使用<code>System.indentityHashCode()</code>计算</li><li><code>Object.hashCode()</code>计算散列码就使用这个方法, 比较两个对象, <code>IdentityHashMap</code>使用<code>==</code>, 而不是<code>equals</code></li></ul><h2 id="小集合">小集合</h2><ul><li><p><code>Java 9</code>引入了一些静态方法, 可以生成给定元素的集合或列表, 以及给定的键值对</p><ul><li><code>List&lt;String&gt; names = List.of(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;);</code></li><li><code>Set&lt;Integer&gt; nums = Set.of(1, 2, 3);</code></li><li><code>Map&lt;String, Integer&gt; m = Map.of(&quot;1&quot;, 1, &quot;2&quot;, 2, &quot;3&quot;, 3);</code></li></ul></li><li><p><code>List, Set</code>有11个<code>of</code>方法, 还有一个参数可变的<code>of</code>方法, 这样是为了提高效率</p></li><li><p><code>Map</code>没有这个参数可变的版本, 因为参数类型会交替为键类型和值类型</p><ul><li>不过有一个<code>ofEntries</code>, 可以接受任意多个<code>Map.Entry&lt;K, V&gt;</code>对象<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Stirng, Integer&gt; socres = ofEntries(</span><br><span class="line">entry(<span class="string">&quot;1&quot;</span>, <span class="number">1</span>),</span><br><span class="line">entry(<span class="string">&quot;2&quot;</span>, <span class="number">2</span>),</span><br><span class="line">entry(<span class="string">&quot;3&quot;</span>, <span class="number">3</span>));</span><br></pre></td></tr></table></figure></li></ul></li><li><p>集合对象是不可修改的, 会导致<code>UnsupportedOperationException</code></p></li><li><p>如果需要一个可修改的集合, 可以把这个不可修改的集合传递到构造器中 <code>var names = new ArrayList&lt;&gt;(List.of(&quot;1&quot;, &quot;2&quot;));</code></p></li><li><p><code>Collections.nCopies(n, anObject)</code>会返回一个实现了<code>List</code>接口的不可变对象</p><ul><li><code>List&lt;String&gt; settings = Collections.nCopies(100, &quot;DEFAULT&quot;);</code></li><li>这样构造包含了100个<code>&quot;DEFAULT&quot;</code>的<code>List</code>, 存储开销很小, 对象只会存储一次</li></ul></li><li><p><code>Array.asList</code>会返回一个可以更改, 但是大小不可改变的列表, 即可以调用<code>set()</code>, 但是不能使用<code>add(), remove()</code></p></li></ul><h3 id="不可修改的副本和视图">不可修改的副本和视图</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; names = ...</span><br><span class="line">Set&lt;String&gt; nameSet = Set.copyOf(names);</span><br><span class="line">List&lt;String&gt; nameList = List.copyOf(names);</span><br><span class="line"><span class="comment">// 每个copyOf()方法会建立集合的一个副本, 修改了原集合这个副本不会受到影响</span></span><br><span class="line"><span class="comment">// 如果原集合正好不可修改, 则copyOf会直接返回原集合</span></span><br></pre></td></tr></table></figure><h2 id="同步视图">同步视图</h2><ul><li><p>如果多个线程访问集合, 一个在修改, 另一个在查看, 结果会发生错误</p></li><li><p><code>synchronizedMap()</code>可以将任何一个映射转换成有同步访问方法的<code>Map</code></p><ul><li><code>var map = Collections.synchronizedMap(new HashMap&lt;String, Integer&gt;());</code></li><li>这样, <code>get(), put()</code>方法就是同步的, 只有一个执行完了才会调用另一个</li></ul></li><li><p>对链表排序可以使用归并排序, 但是<code>Java</code>中是先将链表中的数据复制到数组中, 然后在数组中排序完以后再复制回链表</p></li><li><p><code>Collections.sort()</code>可以对<code>List</code>数据进行排序</p></li><li><p><code>Collections.binarySearch</code>可以对实现了<code>List</code>的接口的列表去进行二分搜索</p><ul><li>如果集合没有采用<code>Comparable</code>接口的<code>compareTo</code>方法进行排序, 则还需要提供一个比较器对象</li><li>如果为<code>binarySearch()</code>提供一个链表, 则会退化为线性查找</li><li><code>binarySearch()</code>返回值<code>ret</code>如果小于零, 则<code>-ret - 1</code>的位置就是这个元素应该插入的位置</li></ul></li></ul><h2 id="批操作">批操作</h2><ul><li><p><code>coll1.removeAll(coll2)</code>, 在<code>coll1</code>中删除所有<code>coll2</code>包含的元素 (补)</p></li><li><p><code>coll1.retainAll(coll2)</code>, 在<code>coll1</code>中删除所有<code>coll2</code>中没有包含的元素 (交)</p></li><li><p>数组转集合</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] names = ...;</span><br><span class="line">List&lt;String&gt; staff = List.of(names);</span><br></pre></td></tr></table></figure></li><li><p>集合转数组</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object[] names = staff.toArray();</span><br><span class="line"><span class="comment">// 得到一个Object[]数组, 无法进行类型转换</span></span><br><span class="line">String[] names = (String[]) staff.toArray(); <span class="comment">// Error</span></span><br><span class="line"><span class="comment">// 需要向toArray传入一个数组构造器表达式</span></span><br><span class="line">String[] names = staff.toArray(String[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="遗留">遗留</h2><ul><li><p><code>Hashtable</code>类和<code>HashMap</code>类作用相同, 但是<code>HashTable</code>是同步的, 不需要兼容性应该使用<code>HashMap</code>, 需要并发应该使用<code>ConcurrentHashMap</code></p></li><li><p><code>Enumeration</code>有两个方法<code>hasMoreElements(), nextElements()</code>, 可以使用<code>Collections.list</code>将元素收集到一个<code>ArrayList</code></p></li><li><p>属性映射的特性</p><ul><li>键值都是字符串</li><li>映射可以保存到文件并从文件加载</li><li>有一个二级表存放默认值</li></ul></li><li><p>实现属性映射的<code>Java</code>平台类名为<code>Properties</code>, 对于配置项很有用</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">settings</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">settings.setProperty(<span class="string">&quot;1&quot;</span>, <span class="number">1</span>);</span><br><span class="line">settings.setProperty(<span class="string">&quot;filename&quot;</span>, <span class="string">&quot;/home);</span></span><br></pre></td></tr></table></figure></li><li><p>使用<code>store()</code>将属性映射表保存到一个文件中, 比如<code>program.properties</code></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;program.properties&quot;</span>, StandardCharsets.UTF_8);</span><br><span class="line">settings.store(out, <span class="string">&quot;Program Properties&quot;</span>);</span><br><span class="line"><span class="type">var</span> <span class="variable">in</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;program.properties&quot;</span>, StandardCharsets.UTF_8);</span><br><span class="line">settings.load(in);</span><br><span class="line"><span class="type">String</span> <span class="variable">userDir</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.home&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p><code>Properties</code>因为历史原因实现了<code>Map&lt;&gt;</code>, 因此可以使用<code>get(), put()</code>, 但是<code>get()</code>返回类型是<code>Object</code>, <code>put()</code>允许插入任意对象</p><ul><li>所以最好使用处理字符串的<code>getProperty(), setProperty()</code></li></ul></li><li><p>栈, <code>Stack</code>, 扩展的<code>Vector</code>, 但是可以使用<code>insert(), remove()</code>添加删除任意的位置</p></li><li><p>位集, <code>BitSet</code>, 如果需要存储一个位序列, 比如标志, 可以使用位集</p><ul><li>因为位集将位包装在字节里, 所以使用位集比使用<code>Boolean, ArrayList</code>高效</li><li><code>bitSet.get(i)</code>会返回第<code>i</code>位的结果, <code>true, false</code></li><li><code>bitSet.set(i)</code>将第<code>i</code>位的结果设置为<code>true</code></li><li><code>bitSet.clear(i)</code>将第<code>i</code>位的结果设置为<code>false</code></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;集合&lt;/h1&gt;
&lt;h2 id=&quot;Collection接口&quot;&gt;&lt;code&gt;Collection&lt;/code&gt;接口&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;集合类的基本接口是&lt;code&gt;Collection&lt;/code&gt;接口, 有两个基本方法  &lt;figure class=&quot;highli</summary>
      
    
    
    
    <category term="Java" scheme="https://sangs3112.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://sangs3112.github.io/tags/Java/"/>
    
    <category term="Java核心技术(卷一)" scheme="https://sangs3112.github.io/tags/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%8D%B7%E4%B8%80/"/>
    
  </entry>
  
  <entry>
    <title>Java笔记_10</title>
    <link href="https://sangs3112.github.io/posts/4c78249.html"/>
    <id>https://sangs3112.github.io/posts/4c78249.html</id>
    <published>2024-12-12T01:18:00.000Z</published>
    <updated>2025-01-16T15:34:13.089Z</updated>
    
    <content type="html"><![CDATA[<h1>异常</h1><ul><li>所有的异常都是由<code>Throwable</code>继承而来, 下一层有两个分支, <code>Error</code>和<code>Exception</code><ul><li><code>Error</code>类描述了<code>Java</code>运行时系统的内部错误和资源耗尽问题, 一般不要抛出这个类型</li><li><code>Exception</code>层次分为两个分支, <code>RuntimeException</code>和其他异常<ul><li>编程错误导致的是<code>RuntimeException</code></li><li>由于<code>IO</code>错误导致的是其他异常</li><li>继承自<code>RuntimeException</code>异常包括: 错误的强制类型转换; 数组越界; 访问<code>null</code>指针</li><li>不继承自<code>RuntimeException</code>异常包括: 打开不存在的文件; 越过文件末尾读取数据; 根据给定字符串查找<code>Class</code>, 但是这个类并不存在</li></ul></li><li>所有派生于<code>Error</code>和<code>RuntimeException</code>的异常是非检查型异常, 其他异常都是检查型异常</li></ul></li></ul><h2 id="抛出异常的情况">抛出异常的情况</h2><ol><li>调用了某个会抛出异常的方法, 比如<code>FileInputStream</code>构造器</li><li>检测到一个错误, 使用<code>throw</code>语句抛出异常</li><li>程序出现错误, 比如<code>a[-1]</code>抛出一个非检查型异常</li><li><code>JVM</code>内部错误</li></ol><ul><li>一个方法必须声明所有可能抛出的检查型异常, 也可以捕获一个异常, 这样也不需要抛出了</li><li>如果子类覆盖了超类的一个方法, 子类抛出的异常不能比超类的更通用, 如果超类没有抛出异常, 则子类也不能抛出异常</li></ul><h2 id="创建异常">创建异常</h2><ul><li>定义一个派生于<code>Exception</code>或者他子类的一个类, 包含两个构造器, 一个是无参构造器, 另一个是包含详细信息的构造器  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileFormatException</span> <span class="keyword">extends</span> <span class="title class_">IOException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileFormatException</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileFormatException</span><span class="params">(String gripe)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(gripe);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="捕获异常">捕获异常</h2><ul><li>如果<code>try</code>语句块中任何代码抛出了<code>catch</code>指定的一个异常类<ol><li>跳过<code>try</code>语句块剩余执行内容</li><li>执行<code>catch</code>语句块代码</li></ol></li><li>如果没有抛出异常, 则直接跳过<code>catch</code>部分</li><li>如果抛出了异常, 但是不在<code>catch</code>中, 则方法会直接退出</li><li>一般是捕获知道如何处理的异常, 抛出不知道如何处理的异常</li><li>一个<code>try</code>语句块可能抛出多种不同的异常, 每个异常需要一个<code>catch</code>语句块<ul><li>如果两个异常的捕获动作一样的话, 可以使用<code>catch(Exception e1 | Exception e2)</code>合并</li><li>捕获多个变量时, 异常变量银行了<code>final</code></li></ul></li></ul><h2 id="再次抛出">再次抛出</h2><ul><li>有时候只想记录一个异常, 再次抛出  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    logger.log(level, message, e);</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果这段代码存在于 public void update() throws SQLException中</span></span><br><span class="line"><span class="comment">// 在Java 7之前会报错, 因为 throw e可能抛出其他类型的异常, 而不是SQLException</span></span><br><span class="line"><span class="comment">// 现在改变了, 编译器会跟踪到e来自try代码块, try代码块中仅有的检查型异常是SQLException实例, 并且</span></span><br><span class="line"><span class="comment">// e在catch块中没有改变, 那么外围方法声明为throws SQLException就是合法的</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="finally子句"><code>finally</code>子句</h2><ul><li><p>代码抛出异常, 剩下的代码就不会运行, 如果这时候已经获取到了一些资源, 在退出之前需要释放.</p><ul><li>可以先捕获所有异常, 然后释放资源, 再重新抛出异常</li><li>也可以使用<code>finally</code>子句, 无论是否抛出异常, <code>finally</code>子句部分一定都会执行</li><li><code>Java 7</code>之后可以使用<code>try-with-resources</code>, 这个更常用</li></ul></li><li><p><code>try</code>语句可以只有<code>finally</code>, 没有<code>catch</code></p></li><li><p><code>finally</code>语句中不要放<code>throw, continue, break, return</code>这种改变程序执行顺序的语句</p></li></ul><h2 id="try-with-resources"><code>try-with-resources</code></h2><ul><li><code>AutoCloseable</code>接口有一个方法 <code>void close() throwa Exception</code></li><li><code>Closeable</code>接口是<code>AutoCloseable</code>接口的子接口, 同样只包含<code>close()</code>, 但是抛出的是<code>IOException</code></li><li><code>try-with-resources</code>语句的最简单形式是:  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Resources</span> <span class="variable">res</span> <span class="operator">=</span> ...) &#123;</span><br><span class="line">    work with res</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里try块退出时, 会自动调用res.close()</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">var</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(Path.of(<span class="string">&quot;1.txt&quot;</span>), StandardCharsets.UTF_8);</span><br><span class="line">    <span class="type">var</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="string">&quot;2.txt&quot;</span>, StandardCharsets.UTF_8)) &#123;</span><br><span class="line">    <span class="keyword">while</span> (in.hasNext()) &#123;</span><br><span class="line">        out.println(in.next().toUpperCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上述代码不论是如何退出的, 都一定会自动关闭in和out</span></span><br></pre></td></tr></table></figure></li><li>如果是<code>try-catch-finally</code>语句, 在<code>try</code>中抛出了异常, 然后<code>finally</code>调用<code>in.close()</code>又抛出了异常就会产生问题<ul><li>此时使用<code>try-with-resources</code>就可以解决这个问题</li><li>原来的异常会重新抛出, <code>close()</code>产生的异常会被抑制, 自动捕获, 由<code>addSuppressed()</code> 添加到原来的异常方法中</li><li>可以调用<code>getSuppressed()</code>, 会生成一个数组, 包含其中从<code>close()</code>方法中抛出的被抑制的异常</li></ul></li><li><code>try-with-resources</code>语句本身可以有<code>catch, finally</code>语句, 这些子句会在关闭资源以后才执行</li></ul><h2 id="栈轨迹">栈轨迹</h2><ul><li>栈轨迹是程序执行中某个特定点所有挂起的方法调用的一个列表</li><li><code>Throwable</code>类的<code>printStackTrace()</code>可以打印  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Throwable</span>();</span><br><span class="line"><span class="type">var</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringWriter</span>();</span><br><span class="line">t.printStackTrace(<span class="keyword">new</span> <span class="title class_">PrintWriter</span>(out));</span><br><span class="line"><span class="type">String</span> <span class="variable">des</span> <span class="operator">=</span> out.toString();</span><br><span class="line"><span class="comment">// Java 9之前, Throwable.printStackTrace()会生成一个StackTraceElement[]</span></span><br><span class="line"><span class="comment">// 数组中包含了和StackWalker.StackFrame类似的信息, 效率较低</span></span><br><span class="line"><span class="comment">// 因为会得到整个栈, 但是调用者只需要几个栈帧, 并且只允许访问挂起方法的类名, 不能访问类对象</span></span><br></pre></td></tr></table></figure></li><li>还可以使用<code>StackWalker</code>类, 生成一个<code>StackWalker.StackFrame</code>实例流, 其中每个实例表示一个栈帧  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StackWalker</span> <span class="variable">walker</span> <span class="operator">=</span> StackWalker.getInstance();</span><br><span class="line">walker.forEach(frame -&gt; ananlyze frame)</span><br></pre></td></tr></table></figure></li></ul><div class="note info flat"><ul><li>栈轨迹一般显示在<code>System.err</code>上, 如果想要记录栈轨迹, 可以捕获到字符串中</li><li>也可以记录到文件中, 不过如果是错误的话, 就会发送到<code>System.err</code>中, 所以就不能使用下面的代码<ul><li><code>java MyApp &gt; errors.txt</code>, 而是应该使用 <code>java MyApp 2&gt; errors.txt</code></li><li>如果需要在同一个文件中同时保存<code>System.out, System.err</code>可以使用如下代码</li><li><code>java MyApp 1&gt; errors.txt 2&gt;&amp;1</code></li></ul></li><li>可以使用静态方法<code>Thread.setDefaultUncaughtExceptionHandler</code>改变没有捕获异常的处理器</li><li>启动<code>JVM</code>可以使用<code>-verbose</code>看到类加载器加载过程</li><li><code>Xlint</code>选项可以告诉编译器找出常见的代码问题, 比如<code>javac -Xlint sourceFiles</code></li><li><code>JDK</code>提供了<code>jconsole</code>可以显示<code>JVM</code>性能统计结果</li></ul></div><h2 id="使用异常技巧">使用异常技巧</h2><ol><li>异常不能代替简单测试, 使用捕获异常会导致程序耗时大大增加, 因此只在异常情况下使用异常</li><li>不要过分细化异常, 否则一个异常一个<code>catch</code>会导致代码量激增</li><li>合理使用异常层次<ul><li>不要只抛出<code>RuntimeException</code>, 应该需要寻找一个合适的子类, 或者创建自己的异常类</li><li>不要只捕获<code>Throwable</code>异常, 否则代码会很难读懂</li><li>考虑检查型异常和非检查型异常, 检查型异常本质上开销较大</li></ul></li><li>不要压制异常, 可以使用</li><li>使用标准方法报告<code>null</code>指针和越界异常</li><li>不要向用户展示最终的栈轨迹</li></ol><h1>断言</h1><ul><li>断言允许在测试期间在代码中插入一些检查, 在生产代码中自动删除这些  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> condition;</span><br><span class="line"><span class="keyword">assert</span> condition : expression;</span><br><span class="line"><span class="comment">// 两个写法都会计算condition, 如果为false, 会抛出AssertionError异常</span></span><br><span class="line"><span class="comment">// 第二个语句会将expression传入到AssertionError构造器中, 转换为一个消息字符串</span></span><br></pre></td></tr></table></figure></li><li>默认情况下禁用断言, 运行是使用<code>java -enableassertions MyApp</code> 或者<code>java -ea MyApp</code>启用</li><li>不需要重新编译启用断言, 因为断言是类加载器的功能, 禁用断言的时候类加载器会自动删去断言的代码, 不会降低速度</li><li>可以在特定的类或整个包中打开断言<code>java -ea:MyClass -ea:com.mycompany.mylib MyApp</code><ul><li>这样会在<code>MyClass</code>类, <code>com.mycompany.mylib</code>包及其子包中的所有类打开断言</li><li>同样可以使用<code>-da</code> 或者<code>-disableassertions</code>禁用断言</li><li><code>-ea</code>和<code>-da</code>不能应用于没有类加载器的系统类, 需要使用<code>-esa</code>或者<code>enablesystemassertions</code>开启系统类断言</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;异常&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;所有的异常都是由&lt;code&gt;Throwable&lt;/code&gt;继承而来, 下一层有两个分支, &lt;code&gt;Error&lt;/code&gt;和&lt;code&gt;Exception&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Error&lt;/code&gt;类描述了</summary>
      
    
    
    
    <category term="Java" scheme="https://sangs3112.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://sangs3112.github.io/tags/Java/"/>
    
    <category term="Java核心技术(卷一)" scheme="https://sangs3112.github.io/tags/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%8D%B7%E4%B8%80/"/>
    
  </entry>
  
  <entry>
    <title>Java笔记_11</title>
    <link href="https://sangs3112.github.io/posts/73c0b2df.html"/>
    <id>https://sangs3112.github.io/posts/73c0b2df.html</id>
    <published>2024-12-12T01:18:00.000Z</published>
    <updated>2025-01-16T15:34:13.089Z</updated>
    
    <content type="html"><![CDATA[<h1>泛型</h1><ul><li>没有泛型类的时候, 泛型程序用继承实现, <code>ArrayList</code>类只维护一个<code>Object</code>引用数组, 这样就会每次都需要进行强制类型转换</li><li>现在是使用尖括号<code>&lt;String&gt;</code></li><li><code>Java</code>类库使用<code>E</code>表示集合类型, <code>K,V</code>表示键值对, <code>T,U</code>等表示任意类型</li></ul><h2 id="泛型类">泛型类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    T first;</span><br><span class="line">    T second;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">()</span> &#123; </span><br><span class="line">        first = <span class="literal">null</span>;</span><br><span class="line">        second = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(T first, T second)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">        <span class="built_in">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getSecond</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFirst</span><span class="params">(T newV)</span> &#123;</span><br><span class="line">        first = newV;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSecond</span><span class="params">(T newV)</span> &#123;</span><br><span class="line">        second = newV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型方法">泛型方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">getMiddle</span><span class="params">(T...a)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a[a.length / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型代码和虚拟机">泛型代码和虚拟机</h2><ul><li><p>无论何时定义一个泛型类, 都会自动提供一个相应的原始类型, 就是去掉类型参数以后的泛型类型名</p></li><li><p>类型变量会被擦除, 替换为其限定类型, 如果没有限定类型就是<code>Object</code></p></li><li><p>泛型方法的类型擦除会存在一些问题:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> <span class="keyword">extends</span> <span class="title class_">Pair</span>&lt;LocalDate&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSecond</span><span class="params">(LocalDate second)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (second.compareTo(getFirst()) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">super</span>.setSecond(second);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 日期区间是一对LocalDate对象, 覆盖这个方法保证第二个值永远不小于第一个值, 类擦除以后就是</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> <span class="keyword">extends</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSecond</span><span class="params">(LocalDate second)</span> &#123;...&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 但是还有另一个从Pair继承的setSecond方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSecond</span><span class="params">(Object second)</span> &#123;&#125;</span><br><span class="line"><span class="comment">// 这两个方法参数不同, 所以是不同的方法, 但是他们不应该不同</span></span><br><span class="line"><span class="comment">// 此时类型擦除和多态就产生了冲突, 编译器就会在D类中生成一个桥方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSecond</span><span class="params">(Object second)</span> &#123;setSecond((LocalDate) second);&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同样, 在编译器中, 如果是getSecond(), 会同时存在两个</span></span><br><span class="line"><span class="keyword">public</span> LocalDate <span class="title function_">getSecond</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getSecond</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 这两个方法只有返回类型不同, 不能这么编写代码</span></span><br><span class="line"><span class="comment">// 但是虚拟机会根据参数类型和返回类型共同指定一个方法, 所以虚拟机可以正确处理这两个方法</span></span><br><span class="line"><span class="comment">// 所以编译器可以为只有返回类型不同的两个方法生成字节码文件</span></span><br><span class="line"><span class="comment">// 只是自己编写这样的代码不合法</span></span><br></pre></td></tr></table></figure></li></ul><div class="note info flat"><ul><li>虚拟机中没有泛型, 只有普通的类和方法</li><li>所有的类型参数都会替换为他们的限定类型</li><li>会合成桥方法来保持多态</li><li>会插入强制类型转换来保持类型安全性</li></ul></div><h2 id="限制">限制</h2><ol><li>不能使用基本类型实例化类型参数<ul><li>不能使用<code>Pair&lt;double&gt;</code>, 因为在类型擦除后的<code>Object</code>类中不能存储基本类型, 只能存储<code>Double</code></li></ul></li><li>运行时类型查询只适用于原始类型 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a <span class="keyword">instanceof</span> Pair&lt;String&gt;) <span class="comment">// Error 实际上只会检测a是否是Pair的任意一个类型实例</span></span><br><span class="line"><span class="keyword">if</span> (a <span class="keyword">instanceof</span> Pair&lt;T&gt;) <span class="comment">// Error</span></span><br><span class="line">Pair&lt;String&gt; p = (Pair&lt;String&gt;) a; <span class="comment">// Warn</span></span><br><span class="line"></span><br><span class="line">Pair&lt;String&gt; stringp = ...;</span><br><span class="line">Pair&lt;E&gt; ep = ...;</span><br><span class="line"><span class="keyword">if</span> (stringp.getClass() == ep.getClass()) &#123;&#125;</span><br><span class="line"><span class="comment">// 这里一定相等, 因为两个getClass()返回值都是Pair.Class</span></span><br></pre></td></tr></table></figure></li><li>不能创建参数化类型的数组 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">table</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;String&gt;[<span class="number">10</span>]; <span class="comment">// Error</span></span><br><span class="line"><span class="comment">// 因为类型擦除以后, table的类型是Object[], 存储不正确的元素会抛出ArrayStoreException</span></span><br><span class="line"><span class="comment">// 只是不允许创建, 但是声明依旧合法 即Pair&lt;String&gt;[]变量是合法的</span></span><br><span class="line"><span class="comment">// 但是new Pair&lt;String&gt;[10]初始化会抛出异常</span></span><br><span class="line"><span class="comment">// 可以声明通配符类型数组, 然后进行强制类型转换</span></span><br><span class="line"><span class="type">var</span> <span class="variable">table</span> <span class="operator">=</span> (Pair&lt;String&gt;[]) <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;?&gt;[<span class="number">10</span>];</span><br><span class="line"><span class="comment">// 结果不安全, 比如table[0]存储一个Pair&lt;E&gt;, 然后table[0].getFirst()调用一个String方法, 就会抛出ClassCastException</span></span><br><span class="line"><span class="comment">// 可以直接使用ArrayList: ArrayList&lt;Pair&lt;String&gt;&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="Varargs警告"><code>Varargs</code>警告</h2><ul><li>如果向可变参数的方法传递一个泛型类型实例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;T&gt; coll, T... ts)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (T t : ts) &#123;</span><br><span class="line">        coll.add(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ts是一个数组, 包含所有提供的实参</span></span><br><span class="line">Collection&lt;Pair&lt;String&gt;&gt; table = ...</span><br><span class="line">Pair&lt;String&gt; p1 = ...</span><br><span class="line">Pair&lt;String&gt; p2 = ...</span><br><span class="line">addAll(table, p1, p2);</span><br><span class="line"><span class="comment">// 此时JVM必须创建一个Pair&lt;String&gt;类型数组, 违反规则</span></span><br><span class="line"><span class="comment">// 但是有所放松, 只会给出警告</span></span><br><span class="line"><span class="comment">// 使用@SuppressWarnings(&quot;unchecked&quot;) 去掉警告</span></span><br><span class="line"><span class="comment">// 或者Java 7还可以使用@SafeVarargs注解addAll方法</span></span><br></pre></td></tr></table></figure><div class="note info flat"><ul><li><code>@SafeVarargs</code>注解只能用于<code>static, final</code>或<code>private</code>的构造器或方法中, 其他方法都可能被覆盖, 会使这注解失去作用</li></ul></div><h2 id="不能实例化类型变量">不能实例化类型变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T second;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">()</span> &#123;</span><br><span class="line">        first = <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">        second = <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这个无参构造函数是不合法的, 因为类型擦除以后会变成new Object()</span></span><br><span class="line"><span class="comment">// Java 8之后, 可以使用构造器表达式解决这个问题</span></span><br><span class="line">Pair&lt;String&gt; p = Pair.makePair(String::<span class="keyword">new</span>);</span><br><span class="line"><span class="comment">// makePair()接收一个Supplier&lt;T&gt;, 一个函数式接口, 表示一个无参并且返回类型为T的函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Pair&lt;T&gt; <span class="title function_">makePair</span><span class="params">(Supplier&lt;T&gt; constr)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(constr.get, constr.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传统解决方法是调用反射Constructor.newInstance()构造泛型对象</span></span><br><span class="line">first = T.class.getConstructor().newInstance(); <span class="comment">// Error</span></span><br><span class="line"><span class="comment">// 因为T.class不合法, 会类型擦除为Object.class, 所以应该用如下方法:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Pair&lt;T&gt; <span class="title function_">makePair</span><span class="params">(Class&lt;T&gt; cl)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(cl.getConstructor.newInstance(), cl.getConstructor().newInstance());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Pair&lt;String&gt; p = Pair.makePair(String.class);</span><br><span class="line"><span class="comment">// Class 类本身是泛型的, String.class 是Class&lt;String&gt;的唯一实例, 所以makePair()可以推断pair的类型</span></span><br></pre></td></tr></table></figure><h2 id="不能构造泛型数组">不能构造泛型数组</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&gt; T[] minmax(T... a) &#123;</span><br><span class="line">    T[] mm = <span class="keyword">new</span> <span class="title class_">T</span>[<span class="number">2</span>]; <span class="comment">// Error</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类型擦除, 所以总会构造一个Comparable[2]数组</span></span><br><span class="line"><span class="comment">// 如果数组只会作为类的私有实例字段, 可以将这个数组元素类型声明为擦除以后的类型, 再强制类型转换, 比如ArrayList</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] elements;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> </span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (E) elements[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> n, E e)</span> &#123;</span><br><span class="line">        elements[n] = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是minmax返回一个T[], 就无法使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&gt; minmax(T... a) &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Comparable</span>[<span class="number">2</span>];</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> (T[]) result; <span class="comment">// Warnings</span></span><br><span class="line">&#125; </span><br><span class="line">String[] names = A.minmax(<span class="string">&quot;T&quot;</span>, <span class="string">&quot;A&quot;</span>, <span class="string">&quot;N&quot;</span>);</span><br><span class="line"><span class="comment">// 编译器不会有警告, 但是Comparable[]转换为String[]会出现ClassCastException</span></span><br><span class="line"><span class="comment">// 所以最好提供一个构造器表达式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&gt; T[] minmax(IntFunction&lt;T[]&gt; constr, T... a) &#123;</span><br><span class="line">    T[] result = constr.apply(<span class="number">2</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">String[] names = A.minmax(String::<span class="keyword">new</span>, <span class="string">&quot;T&quot;</span>, <span class="string">&quot;A&quot;</span>, <span class="string">&quot;N&quot;</span>);</span><br><span class="line"><span class="comment">// 或者利用反射</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&gt; T[] minmax(T... a) &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">result</span> <span class="operator">=</span> (T[]) Array.newInstance(a.getClass().getComponentType(), <span class="number">2</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型类的静态上下文中类型变量无效">泛型类的静态上下文中类型变量无效</h2><ul><li>不能在静态方法或字段中引用类型变量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">S</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T si; <span class="comment">// Error</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T <span class="title function_">getSi</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (si == <span class="literal">null</span>) construct <span class="keyword">new</span> <span class="title class_">instanceof</span> T;</span><br><span class="line">        <span class="keyword">return</span> si;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类型擦除以后, 只剩下S类, 只包含一个si字段, 所以非法</span></span><br></pre></td></tr></table></figure><h2 id="不能抛出或捕获泛型类的实例">不能抛出或捕获泛型类的实例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不能扩展Exception</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Problem</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;...&#125; <span class="comment">// Error </span></span><br><span class="line"><span class="comment">// catch 子句不能使用类型变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt; <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">(Class&lt;T&gt; t)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">catch</span> (T e) &#123; <span class="comment">// Error</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 但是在异常规范中允许使用类型变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt; <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">(T t)</span> <span class="keyword">throws</span> T &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable realCause) &#123;</span><br><span class="line">        t.initCause(realCause);</span><br><span class="line">        <span class="keyword">throw</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可以取消对检查型异常的检查">可以取消对检查型异常的检查</h2><ul><li>正常必须对所有检查型异常提供一个处理器, 但是可以利用泛型取消这个检查</li><li>只需要使用泛型类, 类型擦除和<code>@SuppressWarnings(&quot;unchecked&quot;)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt; <span class="keyword">void</span> <span class="title function_">throwAs</span><span class="params">(Throwable t)</span> <span class="keyword">throws</span> T &#123;</span><br><span class="line">    <span class="keyword">throw</span> (T) t;</span><br><span class="line">&#125;</span><br><span class="line">Task.&lt;RuntimeException&gt;throwAs(e);</span><br><span class="line"><span class="comment">// 编译器就会认为e是一个非检查型异常</span></span><br><span class="line"><span class="comment">// 下面的代码会将所有的异常都转换为非检查型异常</span></span><br><span class="line"><span class="keyword">try</span> &#123;...&#125; </span><br><span class="line"><span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    Task.&lt;RuntimeException&gt;throwAs(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="擦除以后可能会存在冲突">擦除以后可能会存在冲突</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> first.equals(value) &amp;&amp; second.equals(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实际上Pair有两个equals方法, boolean equals(String); boolean equals(Object);</span></span><br><span class="line"><span class="comment">// 只能重新命名这个方法</span></span><br></pre></td></tr></table></figure><ul><li>假如两个接口类型是同一个接口的不同参数化, 一个类或者类型变量就不能同时作为这两个接口类型的子类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">E</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;E&gt; &#123;...&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">M</span> <span class="keyword">extends</span> <span class="title class_">E</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;M&gt; &#123;...&#125; <span class="comment">// Error</span></span><br><span class="line"><span class="comment">// 如果上述代码可行, 则M就会同时实现Comparable&lt;E&gt; 和Comparable&lt;M&gt;</span></span><br></pre></td></tr></table></figure><h2 id="泛型继承规则">泛型继承规则</h2><ul><li>如果<code>M</code>是<code>E</code>的子类, <code>Pair&lt;M&gt;</code>不会是<code>Pair&lt;E&gt;</code>的子类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;E&gt; b = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;M&gt;(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 非法</span></span><br></pre></td></tr></table></figure><ul><li>可以将参数化类型转换为一个原始类型</li></ul><h2 id="通配符类型">通配符类型</h2><ul><li><p><code>Pair&lt;? extends E&gt;</code>允许类型参数变化, 表示任何<code>Pair</code>类型, 只要是<code>E</code>的子类</p></li><li><p><code>Pair&lt;M&gt;</code>是<code>Pair&lt;? extends E&gt;</code>的子类型</p></li><li><p>可以使用<code>? super M</code>指定一个超类型限定, 限制为<code>M</code>的所有超类型</p></li><li><p>带超类限定的通配符允许写入一个泛型对象, 带子类限定的通配符允许读取一个泛型对象</p></li><li><p><code>Comparable</code>接口本身就是一个泛型类型</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(T other)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类型变量指示了other参数的类型, String类实现了Comparable&lt;String&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(String other)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;? <span class="built_in">super</span> T&gt;&gt; pair&lt;T&gt; <span class="title function_">minmax</span><span class="params">(T[] a)</span></span><br></pre></td></tr></table></figure></li><li><p>无限定通配符<code>Pair&lt;?&gt;</code></p></li><li><p><code>Pair&lt;?&gt;</code>和<code>Pair</code>本质区别在于可以使用任意的<code>Object</code>对象调用原始<code>Pair</code>类的<code>setFirst()</code></p></li><li><p>测试一个<code>Pair</code>是否包含<code>Null</code>引用, 不需要具体的类型</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">hasNulls</span><span class="params">(Pair&lt;?&gt; p)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> p.getFirst() == <span class="literal">null</span> || p.getSecond() == <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将hasNulls转换为泛型方法, 可以避免使用通配符类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">boolean</span> <span class="title function_">hasNulls</span><span class="params">(Pair&lt;T&gt; p)</span>;</span><br><span class="line"><span class="comment">// 带有通配符版本的可读性更强</span></span><br></pre></td></tr></table></figure></li><li><p>交换<code>Pair</code>元素</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(Pair&lt;?&gt; p)</span>;</span><br><span class="line"><span class="comment">// 通配符不是一个类型变量, 所以不能作为类型编码</span></span><br><span class="line">? t = p.getFirst(); <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">swapHelper</span><span class="params">(Pair&lt;T&gt; p)</span> &#123;</span><br><span class="line">    <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> p.getFirst();</span><br><span class="line">    p.setFirst(p.getSecond());</span><br><span class="line">    p.setSecond(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// swapHelper是一个泛型方法, 但是swap不是, 它有一个固定的Pair&lt;?&gt;类型参数</span></span><br><span class="line"><span class="comment">// 可以由swap调用swapHelper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(Pair&lt;?&gt; p)</span> &#123;swapHelper(p);&#125;</span><br><span class="line"><span class="comment">// 此时swapHelper()参数T捕获通配符, 并不知道通配符指示什么类型, 但是是一个明确的类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">minmaxB</span><span class="params">(M[] a, Pair&lt;? <span class="built_in">super</span> M&gt; res)</span> &#123;</span><br><span class="line">    minmaxB(a, res);</span><br><span class="line">    PairAlg.swapHelper(res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 只有在编译器能够保证通配符表示单个确定的类型时才不会报错</span></span><br><span class="line"><span class="comment">// ArrayList&lt;Pair&lt;T&gt;&gt;绝对不能捕获ArrayList&lt;Pair&lt;?&gt;&gt;中的通配符, 因为ArrayList可能包含两个Pair&lt;?&gt;, 而且指向了不同的类型</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="反射和泛型">反射和泛型</h2><h3 id="泛型Class类">泛型<code>Class</code>类</h3><ul><li><code>Class</code>类是泛型类, <code>String.class</code>实际上是<code>Class&lt;String&gt;</code>类的对象</li><li>类型参数非常有用, 允许<code>Class&lt;T&gt;</code>的方法有更加特定的返回类型  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">T <span class="title function_">newInstance</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 返回这个类的实例, 由无参构造器获得, 返回类型声明为T, 避免强制类型转换</span></span><br><span class="line">T <span class="title function_">cast</span><span class="params">(Object obj)</span>;</span><br><span class="line"><span class="comment">// 返回特定的对象, 给定对象的额实际类型是T的一个子类型, 会声明为T, 否则会抛出一个BadCastException</span></span><br><span class="line">T[] getEnumConstants();</span><br><span class="line"><span class="comment">// 如果这个类不是一个Enum或者T类型枚举值的一个数组, 就会返回null</span></span><br><span class="line">Class&lt;? <span class="built_in">super</span> T&gt; getSuperclass();</span><br><span class="line"><span class="comment">// 返回这个类的超类, 如果T不是一个类, 或者T是Object, 则返回null</span></span><br><span class="line">Constructor&lt;T&gt; <span class="title function_">getConstructor</span><span class="params">(Class... parameterTypes)</span>;</span><br><span class="line">Constructor&lt;T&gt; <span class="title function_">getDeclaredConstructor</span><span class="params">(Class... parameterTypes)</span>;</span><br><span class="line"><span class="comment">// 获得公共构造器, 或者有给定参数类型的构造器</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="使用Class-T-参数进行类型匹配">使用<code>Class&lt;T&gt;</code>参数进行类型匹配</h3><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Pair&lt;T&gt; <span class="title function_">makePair</span><span class="params">(Class&lt;T&gt; c)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(c.newInstance(), c.newInstance());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用makePair(E.class), E.class是一个Class&lt;E&gt;类型的对象</span></span><br><span class="line"><span class="comment">// makePair()的类型参数T 与E匹配, 编译器可以推断出这个方法返回一个Pair&lt;E&gt;</span></span><br></pre></td></tr></table></figure></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;泛型&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;没有泛型类的时候, 泛型程序用继承实现, &lt;code&gt;ArrayList&lt;/code&gt;类只维护一个&lt;code&gt;Object&lt;/code&gt;引用数组, 这样就会每次都需要进行强制类型转换&lt;/li&gt;
&lt;li&gt;现在是使用尖括号&lt;code&gt;&amp;lt;</summary>
      
    
    
    
    <category term="Java" scheme="https://sangs3112.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://sangs3112.github.io/tags/Java/"/>
    
    <category term="Java核心技术(卷一)" scheme="https://sangs3112.github.io/tags/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%8D%B7%E4%B8%80/"/>
    
  </entry>
  
  <entry>
    <title>Java笔记_9</title>
    <link href="https://sangs3112.github.io/posts/1d15a4a2.html"/>
    <id>https://sangs3112.github.io/posts/1d15a4a2.html</id>
    <published>2024-12-07T01:37:00.000Z</published>
    <updated>2025-01-16T15:34:13.090Z</updated>
    
    <content type="html"><![CDATA[<h1>内部类</h1><h2 id="使用内部类的原因">使用内部类的原因</h2><ol><li>对同一个包中的其他类隐藏</li><li>访问定义这些方法的作用域的数据, 包括原本的私有数据</li></ol><div class="note info flat"><ul><li>内部类对象会有一个隐式引用, 指向实例化这个对象的外部类对象, 可以访问外部对象的全部状态</li><li>但是<code>Java</code>中静态内部类没有这个指针, 所以<code>Java</code>静态内部类等于<code>CPP</code>中的嵌套类</li><li>可以使用<code>OuterClass.this</code>表示外部类的引用, 比如 <code>T.this.b</code></li><li>可以使用<code>outerObject.new InnerClass()</code>编写内部类的构造器, 比如<code>A listen = this.new B();</code></li><li>在外部类的作用域之外, 可以使用<code>OutClass.InnerClass</code>引用</li></ul></div><ul><li>内部类声明的所有静态字段都必须是<code>final</code>, 初始化为一个编译时常量</li><li>内部类不能有<code>static</code>方法</li><li>使用<code>$</code>和<code>javap -private ClassName</code>可以将内部类文件转换为常规类文件</li></ul><h2 id="局部类">局部类</h2><ul><li>可以在一个方法中声明局部类, 这个类不能用<code>public</code>或者<code>private</code>访问修饰符, 对外部完全隐藏, 除了这个方法外都不知道这个局部类的存在</li><li>局部类不仅可以访问外部类的字段, 还可以访问局部变量, 不过这些局部变量都需要是只能赋值一次就不会改变的事实最终变量</li></ul><h2 id="匿名内部类">匿名内部类</h2><ul><li>如果只想要创建类的一个对象, 不需要为类指定名字  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(<span class="type">int</span> interval, <span class="type">boolean</span> flag)</span> &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">listener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActionListener</span>() &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent event)</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (flag) Toolkit.getDefaultToolkit().flag();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建了一个新的对象listener, 这个类实现了ActionListener接口</span></span><br><span class="line"><span class="comment">// 接口实现了actionPerformed方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以是接口, 也可以是一个类</span></span><br><span class="line"><span class="comment">// 因为匿名内部类没有名字, 所以没有构造器</span></span><br></pre></td></tr></table></figure></li><li>对比构造类对象和构造匿名内部类  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"><span class="type">var</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;2&quot;</span>) &#123;...&#125;;</span><br><span class="line"><span class="comment">// a 是类Person的一个对象</span></span><br><span class="line"><span class="comment">// b 是匿名内部类的一个对象, 这个匿名内部类是Person的子类</span></span><br><span class="line"><span class="comment">// 如果构造类的时候小括号后面跟上了大括号, 那么就是一个匿名内部类</span></span><br><span class="line"><span class="type">var</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>() &#123;<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;c&quot;</span>;&#125;</span><br><span class="line">System.out.println(c.name);</span><br><span class="line"><span class="comment">// 如果声明c的类型为Object, c.name就无法编译了, 因为Object是不可指示的</span></span><br></pre></td></tr></table></figure></li></ul><div class="note info flat"><ul><li>如果在一个方法中, 想要打印类名<br><code>System.out.println(getClass())</code></li><li>普通方法可以调用<code>this</code>, 但是静态方法没有<code>this</code></li><li>如果想要打印静态方法的类名, 可以使用匿名内部类<br><code>System.out.println(new Object(){}.getClass().getEnclosingClass())</code></li><li>这里的<code>getEnclosingClass()</code>是得到这个静态方法的外围类</li></ul></div><h2 id="静态内部类">静态内部类</h2><ul><li>如果生成内部类只是为了隐藏这个类, 并不想生成这个内部类的引用, 可以使用<code>static</code>修饰</li><li>比如要计算一个数组的最大值和最小值<ul><li>可以遍历数组两遍</li><li>也可以定义一个类, 其中包含两个私有字段, 分别记录最大值和最小值</li><li>但是这个类的类名可能会重复, 所以可以定义内部类隐藏类名</li><li>可以将内部类声明为<code>static</code>的, 避免包含其他类的引用</li><li>如果内部类是在一个静态方法中构造的, 则这个内部类必须要声明为静态内部类</li></ul></li></ul><h1>代理</h1><ul><li>代理可以在运行时创建一组给定接口的新类</li><li>只有在编译时无法确定需要实现哪个接口的时候才需要使用代理</li><li>代理类可以在运行时创建一个全新的类, 能够实现指定的接口</li><li>一个代理类包含指定接口需要实现的方法, 以及<code>Object</code>类中的所有方法, 比如<code>toString(), equals()</code></li><li>必须提供一个调用处理器, 调用处理器是实现了<code>InvocaitonHandler</code>接口的类对象, 这个接口只有一个方法, <code>Object invoke()</code></li><li>只要调用代理方法, 就会调用这个<code>invoke</code>方法</li></ul><h2 id="创建代理对象">创建代理对象</h2><ul><li><p>需要使用<code>Proxy</code>类的<code>newProxyInstance()</code>, 包含三个参数</p><ol><li>类加载器</li><li><code>Class</code>对象数组</li><li>一个调用处理器</li></ol></li><li><p>使用目的:</p><ol><li>方法调用 路由到远程服务器</li><li>用户界面事件关联运行中的程序动作</li><li>调试跟踪方法调用</li></ol></li><li><p>定义一个<code>TraceHandler</code>包装器类存储一个包装的对象, <code>invoke()</code>打印所调用方法的名字和参数, 然后调用这个方法, 提供包装的对象作为隐式参数</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TraceHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">new</span> <span class="title class_">TraceHandler</span>(Object t) &#123;</span><br><span class="line">        target = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method m, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// print</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> m.invoke(target, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Object</span> <span class="variable">val</span> <span class="operator">=</span> ...;</span><br><span class="line"><span class="type">var</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TraceHandler</span>(val);</span><br><span class="line"><span class="type">var</span> <span class="variable">interfaces</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;Comparable.class&#125;;</span><br><span class="line"><span class="type">Object</span> <span class="variable">proxy</span> <span class="operator">=</span> Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;Comparable.class&#125;, handler);</span><br></pre></td></tr></table></figure></li></ul><h2 id="特性">特性</h2><ol><li>代理类是程序运行过程中动态创建的, 一旦创建就是常规的类</li><li>所有的代理类都扩展<code>Proxy</code>类, 一个代理类只有一个实例字段, 也就是调用处理器, 在<code>Proxy</code>超类中定义<ul><li>完成代理对象任务所需要的任何额外的数据都需要存储在调用处理器中</li></ul></li><li>所有的代理类都需要覆盖<code>Object</code>类的<code>toString(), equals(), hashCode()</code>, 这些方法只是在调用处理器上调用<code>invoke()</code><ul><li><code>Object</code>类中的其他方法, <code>clone(), getClass()</code>没有重新定义</li></ul></li><li>没有定义代理类的名字, 虚拟机中的<code>Proxy</code>类会生成<code>$Proxy</code>开头的类名</li><li>一个特定的类加载器和一组接口, 只能有一个代理类, 同样可以使用<code>Class proxyClass = Proxy.getProxyClass(null, interface)</code>得到这个类</li><li>代理类一定是<code>public, final</code>的, 如果代理类实现的所有接口都是<code>public</code>的, 那么这个代理类就不属于任何包, 否则一定属于某一个包</li><li>可以通过调用<code>Proxy.isProxyClass()</code>检测一个特定的<code>Class</code>对象是否表示一个代理类</li></ol><ul><li>调用一个目标代理的默认方法会触发调用处理器, 使用<code>InvocationHandler</code>接口的静态方法<code>invokeDefault</code>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> (proxy, method, args) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (method.isDefault()) &#123;</span><br><span class="line">        <span class="keyword">return</span> InvocationHandler.invokeDefault(proxy, method, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;内部类&lt;/h1&gt;
&lt;h2 id=&quot;使用内部类的原因&quot;&gt;使用内部类的原因&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;对同一个包中的其他类隐藏&lt;/li&gt;
&lt;li&gt;访问定义这些方法的作用域的数据, 包括原本的私有数据&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;note info flat</summary>
      
    
    
    
    <category term="Java" scheme="https://sangs3112.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://sangs3112.github.io/tags/Java/"/>
    
    <category term="Java核心技术(卷一)" scheme="https://sangs3112.github.io/tags/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%8D%B7%E4%B8%80/"/>
    
  </entry>
  
  <entry>
    <title>Java笔记_7</title>
    <link href="https://sangs3112.github.io/posts/faad89a5.html"/>
    <id>https://sangs3112.github.io/posts/faad89a5.html</id>
    <published>2024-12-01T10:21:00.000Z</published>
    <updated>2025-01-16T15:34:13.090Z</updated>
    
    <content type="html"><![CDATA[<h1>继承</h1><blockquote><p>基本思想: 基于已有的类创建新的类, 复用已有类的方法, 同时可以增加一些新的方法和字段</p></blockquote><ul><li>反射是程序在运行期间更多地了解类以及属性的能力</li></ul><div class="note info flat"><ul><li><code>CPP</code>中使用<code>:</code>表示继承, 除了公共继承以外, 还存在私有继承和保护继承</li><li><code>Java</code>中<code>extends</code>关键字表示继承, 所有继承都是<strong>公共继承</strong></li></ul></div><ul><li><code>extends</code>表示正在构造的类(子类, 派生类)派生于一个已经存在的类(超类, 基类, 父类)<ul><li>子类比超类拥有更多的功能</li></ul></li></ul><div class="note info flat"><ul><li>“声明为私有的类成员不会被这个类的子类继承”<ul><li>这里其实是子类不能<strong>直接</strong>访问这些私有成员</li><li>但是子类的每个实例对象中依然会包含超类中的私有字段</li></ul></li></ul></div><ul><li>记录不能被扩展, 记录也不能继承别的类</li><li>如果希望使用超类中的方法, 就使用<code>super</code>关键字, <code>super</code>只是用于指示编译器调用超类方法的特殊关键字<ul><li>同时可以使用<code>super()</code>来调用超类中对应的构造器</li><li>不管是<code>this</code>还是<code>super</code>, <strong>在调用其他构造器的时候</strong>, 都必须放在第一行, 否则会报错</li></ul></li></ul><div class="note info flat"><ul><li>一个对象可以指示多种实际类型<ul><li>比如一个类的超类以及他的子类都在一个数组中, 使用<code>foreach</code>循环的时候, 循环变量可以同时指示多个不同的类, 那么这就是多态</li></ul></li><li>运行的时候可以自动的选择适合的方法, 就是动态绑定</li><li><code>CPP</code>中, 如果希望实现动态绑定, 可以将成员函数设置为<code>virtual</code></li><li><code>Java</code>中默认会执行动态绑定, 如果不希望方法是虚拟的, 可以使用<code>final</code>关键字</li><li><code>CPP</code>中, 一个类可以有多个超类</li><li><code>Java</code>中不支持多重继承, 但是可以使用接口实现多重继承的功能</li></ul></div><h2 id="对象方法调用过程">对象方法调用过程</h2><blockquote><p>假设需要<code>x.f(args)</code>, <code>x</code>是类<code>C</code>的一个对象, 具体调用过程如下:</p></blockquote><ol><li>编译器查看对象的声明类型和方法名, 可能存在多个名为<code>f</code>的方法, 他们具有不同的参数类型, 编译器会一一列举出<code>C</code>中的所有名为<code>f</code>的方法, 以及<code>C</code>的超类中所有名为<code>f</code>的<strong>非私有方法</strong></li><li>重载解析: 编译器确定方法调用中提供的参数类型, 如果所有名为<code>f</code>的方法中存在一个与所提供的参数类型完全匹配的方法, 就直接使用这个方法<ul><li>如果找不到匹配的方法, 或者找到了多个匹配的方法, 编译器就会抛出异常</li><li>方法的名字与参数类型会组成签名, 如果子类的签名和超类的重复了, 子类的方法会覆盖超类的方法</li><li>尽管返回类型不是签名的一部分, 但是在覆盖的时候, 需要保证子类的返回类型是超类返回类型的子类型</li></ul></li><li>如果是<code>private</code>, <code>static</code>, <code>final</code>方法 或者 构造器方法, 编译器就可以准确知道调用哪个方法, 这称为静态绑定. 如果调用方法依赖于隐式参数的实际类型, 就是动态绑定. 所以只要不是上述四种方法, 就是动态绑定</li><li>程序使用动态绑定时, 虚拟机必须调用与<code>x</code>引用对象实际类型对应的方法, 比如<code>x</code>的实际类型是<code>D</code>, <code>D</code>是<code>C</code>的子类, 如果<code>D</code>定义了方法<code>f(String)</code>, 那么就会调用这个方法, 否则就会在<code>D</code>的超类中寻找这个方法<ul><li>如果每一次调用方法都需要执行一次搜索的话, 时间消耗非常大, 所以虚拟机预先为每个类计算了一个方法表, 列出了所有方法的签名和需要调用的方法</li><li>虚拟机加载一个类以后就可以构建这个方法表</li></ul></li></ol><div class="note info flat"><ul><li>覆盖一个方法的时候, 子类方法的可见性不能低于超类方法的可见性</li><li>如果超类方法是<code>public</code>, 子类也必须要是<code>public</code>方法, 如果漏了, 就会报错</li></ul></div><h2 id="final方法"><code>final</code>方法</h2><ul><li>使用<code>final</code>修饰一个类, 就可以阻止定义这个类的子类  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">E</span> <span class="keyword">extends</span> <span class="title class_">M</span> &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li><code>final</code>类的方法自动变为<code>final</code>方法</li><li><code>final</code>类的字段<strong>不会自动</strong>变为<code>final</code>字段</li></ul></li><li>如果将类中的某个方法设定为<code>final</code>, 则该类的所有子类都不能覆盖这个方法  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>final</code>字段表示以后都不会改变的字段</li><li>枚举和记录总是<code>final</code>的, 因为他们不允许被扩展</li></ul><h2 id="对象引用的强制类型转换">对象引用的强制类型转换</h2><ul><li>现在有<code>M</code>类是<code>E</code>的子类  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">E</span>[<span class="number">3</span>];</span><br><span class="line">s[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">M</span>();</span><br><span class="line">s[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">E</span>();</span><br><span class="line">s[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">E</span>();</span><br><span class="line"><span class="type">M</span> <span class="variable">b</span> <span class="operator">=</span> (M) s[<span class="number">0</span>]; <span class="comment">// 强制类型转换</span></span><br><span class="line"><span class="type">M</span> <span class="variable">c</span> <span class="operator">=</span> (M) s[<span class="number">1</span>]; <span class="comment">// 抛出异常 ClassCastException</span></span><br></pre></td></tr></table></figure></li><li>为了避免抛出异常, 可以使用<code>instanceof</code>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s[i] <span class="keyword">instanceof</span> M) &#123;</span><br><span class="line">    b = (M) s[i];</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><ul><li><code>JDK 16</code>中有更加简单的写法, 可以直接在<code>instanceof</code>语句中声明子类变量<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s[i] <span class="keyword">instanceof</span> M b) &#123;</span><br><span class="line">    b.setB();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><div class="note info flat"><ul><li>只能在继承层次内使用强制类型转换</li><li>将超类转换为子类之前, 需要使用<code>instanceof</code>检查类型</li><li>如果<code>x</code>是<code>null</code>, <code>x instanceof C</code>不会抛出异常, 返回<code>false</code></li><li>一般情况下最好少用强制类型转换和<code>instanceof</code></li></ul></div><h2 id="protected"><code>protected</code></h2><ul><li>将超类中的某个字段声明为<code>protected</code>, 子类就可以进行访问</li><li>受保护的字段只能由同一个包中的类进行访问, 如果子类在不同的包中, 就不能访问了</li><li>相比之下, <code>protected</code>方法更有意义, 表示可以相信子类能够正确的使用这个方法</li><li>所以<code>Java</code>中的<code>protected</code>允许所有子类, 以及同一个包中的所有其他类访问, 不如<code>CPP</code>中的安全</li></ul><h1><code>Object</code></h1><blockquote><p><code>Object</code>类是<code>Java</code>中所有类的超类</p></blockquote><h2 id="写equals方法">写<code>equals</code>方法</h2><ol><li>显式参数命名为<code>otherObject</code></li><li>检测<code>this</code>与<code>otherObject</code>是否相同</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span> == otherObject) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>检测<code>otherObject</code>是否为<code>null</code>, 如果为<code>null</code>, 则返回<code>false</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (otherObject == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>比较<code>this</code>与<code>otherObject</code>的类<br>如果<code>equals</code>的语义可以在子类中改变, 就使用<code>getClass</code>检测</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (getClass() != otherObject.getClass()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">ClassName</span> <span class="variable">other</span> <span class="operator">=</span> (ClassName) otherObject;</span><br><span class="line"><span class="comment">// 这个判断对于匿名子类会失败</span></span><br></pre></td></tr></table></figure><p>如果所有的子类都有相同的相等性语义, 就可以使用<code>instanceof</code>检测</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(otherObject <span class="keyword">instanceof</span> ClassName other)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>使用相等性概念来比较字段, 使用<code>==</code>比较基本类型字段, 使用<code>Objects.equals</code>比较对象字段, 如果所有的字段都匹配, 返回<code>true</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> field1 == other.field1 &amp;&amp; Objects.equals(field2, other.field2) &amp;&amp; ... ;</span><br></pre></td></tr></table></figure><ul><li>对于数组类型, 使用<code>Arrays.equals()</code>方法检查相应的数组元素, 如果是多维数组, 可以使用<code>Arrays.deepEquals()</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(E other)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> other != <span class="literal">null</span> </span><br><span class="line">            &amp;&amp; getClass() == other.getClass() </span><br><span class="line">            &amp;&amp; Objects.equals(name, other.name) </span><br><span class="line">            &amp;&amp; salary == other.salary </span><br><span class="line">            &amp;&amp; Objects.equals(hireDay, other.hireDay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里有错误, 因为参数类型是E, 没有覆盖Object类的equals方法, 而是定义了一个新的方法</span></span><br><span class="line"><span class="comment">// 为了避免这个错误, 可以使用@Override public boolean equals(Object other)</span></span><br><span class="line"><span class="comment">// 此时编译器就会给出报错信息, 因为当前方法没有覆盖Object中的任何方法</span></span><br></pre></td></tr></table></figure><h2 id="hashCode"><code>hashCode</code></h2><blockquote><p><code>hashCode</code>方法定义在<code>Object</code>类中, 所以每个对象都有一个默认的散列码, 由对象的存储地址得出</p></blockquote><ul><li>自定义<code>hashCode</code>方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">7</span> * name.hashCode() </span><br><span class="line">            + <span class="number">11</span> * Double.valueOf(s).hashCode() </span><br><span class="line">            + <span class="number">13</span> * hireDay.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以使用Objects.hashCode(), 这是null安全的, 如果参数为null, 会直接返回0</span></span><br><span class="line"><span class="comment">// 可以使用静态方法Double.hashCode()避免创建一个Double对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">7</span> * Objects.hashCode(name) </span><br><span class="line">            + <span class="number">11</span> * Double.hashCode(s) </span><br><span class="line">            + <span class="number">13</span> * Objects.hashCode(hireDay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果有多个内容需要hash, 可以直接调用Objects.hash()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, s, hireDay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果有数组类型, 可以使用静态<code>Arrays.hashCode()</code>计算一个散列码, 这个散列码由数组元素的散列码组成</li><li>记录类型会自动提供一个<code>hashCode()</code>, 由字段值的散列码得到一个散列码</li></ul><h2 id="toString"><code>toString()</code></h2><ul><li>使用<code>getClass().getName()</code>获得类名的字符串</li><li>每一个子类都应该实现自己的<code>toString()</code>, 如果超类中实现了, 可以直接使用<code>super.toString()</code></li><li>只要一个对象与一个字符串通过<code>+</code>连接, 编译器就会自动调用<code>toString()</code>方法获得这个字符串的描述</li><li>如果<code>x</code>是任意一个对象, 使用<code>System.out.println(x)</code>也会自动调用<code>x.toString()</code></li><li><code>Objects</code>定义了<code>toString()</code>, 会打印对象的类名和散列码</li></ul><h1><code>ArrayList</code></h1><blockquote><p><code>ArrayList</code>是一个有类型参数的泛型类</p></blockquote><ul><li>使用<code>var</code>可以避免重复写类型 <code>var staff = new ArrayList&lt;E&gt;();</code><ul><li>如果使用了<code>var</code>, 就需要声明类型; 如果不使用<code>var</code>, 可以使用菱形语法 <code>ArrayList&lt;E&gt; staff = new Arraylist&lt;&gt;();</code></li></ul></li><li>使用<code>add</code>添加元素, 如果满了会自动扩容</li><li>如果可以估计大小, 可以在添加元素之前使用<code>staff.ensureCapacity(nums)</code>来设置分配的空间<ul><li>也可以使用<code>var staff = new ArrayList&lt;E&gt;(nums)</code>将初始容量传递给构造器</li></ul></li><li>如果数组的大小保持恒定不会发生变化了, 可以使用<code>staff.trimToSize()</code>将内存块的大小调整为当前所需空间, <code>GC</code>回收多余的空间</li></ul><h1>对象包装器</h1><ul><li>有时候需要将<code>int</code>转换为对象, 所有基本类型都有一个与之对应的类</li><li><code>Integer, Long, Float, Double, Short, Byte, Character, Boolean</code> 前六个派生于公共超类<code>Number</code><ul><li>包装类不可变, 一旦构造了包装器, 就不能更改其中的值</li><li>包装器类还是<code>final</code>, 所以不能派生子类</li><li>尖括号中的类型参数不能是基本数据类型, 必须要是包装器类型</li><li>因为每一个值都包装在对象中, 所以<code>ArrayList&lt;integer&gt;</code> 效率低于<code>int[]</code></li></ul></li><li>当使用<code>list.add(3)</code>的时候, 会自动转换为<code>list.add(Integer.valueOf(3))</code>, 这就是自动装箱</li><li>同样的, 当我们使用<code>int n = list.get(i)</code>的时候, 实际上是将<code>Integer</code>对象赋值给<code>int</code>类型, 这是自动拆箱, 等价于<code>list.get(i).intValue()</code></li><li><code>Integer n = 3; n ++;</code>这里面实际上先自动拆箱, 然后<code>+1</code>, 再自动装箱</li><li>不要使用包装器类构造器, 可以使用<code>Integer.valueOf(i)</code>, 也可以依赖自动装箱:<code>Integer a = i</code>, 不要使用<code>new Integer(i)</code>, 这个将会被删除</li><li>包装器类引用可以为<code>null</code>, 所以会触发<code>NPE</code></li><li>如果表达式中混用了<code>Integer, Double</code>, 则<code>Integer</code>会自动拆箱, 提升为<code>double</code>, 再自动装箱为<code>Double</code></li><li>自动装箱和拆箱是编译器做的工作, 不是虚拟机</li></ul><h1>可变参数个数方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> PrintStream <span class="title function_">printf</span><span class="params">(String fmt, Object... args)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> format(fmt, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这里的<code>...</code>表示接受任意数量的对象, 是一个<code>Object</code>数组, 保存着除了<code>fmt</code>之外的其他参数</li><li>如果调用者给了其他类型或者基本类型的值, 就会自动装箱为对象, 现在就只需要<code>fmt</code>中扫描到第<code>i</code>个格式说明, 与<code>args[i]</code>值匹配</li></ul><h1>抽象类</h1><ul><li>如果一个类中存在抽象方法, 类本身必须声明为抽象的; 抽象类<strong>可以没有</strong>抽象方法; 抽象类可以有具体字段和方法  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">P</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">getD</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>抽象类的子类可以保留抽象类中的部分或所有抽象方法, 那么子类依然是抽象的; 也可以全部实现, 则子类不是抽象的</li><li>抽象类不能被实例化, 但是可以存在抽象类的变量, 只是只能引用其非抽象子类  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">P</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">S</span>();</span><br></pre></td></tr></table></figure></li><li>接口是抽象类的泛化</li></ul><h1>密封类</h1><ul><li>比如有一个抽象类<code>JSONValue</code>, 还有两个<code>final</code>子类, 分别是<code>JSONNumber, JSONArray</code></li><li>两个子类是<code>final</code>的, 所以无法被派生了, 但是不能阻止别人派生<code>JSONValue</code></li><li>可以将<code>JSONValue</code>声明为密封类  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">JSONValue</span></span><br><span class="line">    <span class="keyword">permits</span> JSONArray, JSONNumber, JSONString, JSONBoolean, JSONObject, JSONNull &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 这样使用sealed声明为密封类, 可以保证JSONValue只有六个定义好的子类, 无法派生别的子类了</span></span><br></pre></td></tr></table></figure></li><li>一个密封类的子类必须是可以访问的, 不能是嵌套在别的类中的私有类, 也不能位于另一个包中</li><li>密封类允许的公共子类, 必须要在同一个包中, 如果使用了模块, 还必须要在同一个模块中</li><li>声明密封类可以不加<code>permits</code>, 但是这样的话所有子类都必须要在同一个文件中声明, 这样的话, 子类就不是公共的了</li><li>密封类的子类必须声明为<code>sealed, final, non-sealed</code>中的一种，最后一种允许继续派生</li></ul><h1>反射</h1><h2 id="Class类"><code>Class</code>类</h2><ul><li><code>Java</code>始终为所有对象维护一个运行时类型标识, 跟踪每个对象所属的类</li><li>可以用<code>Class</code>类访问这些信息, <code>Object.getClass()</code>返回一个<code>Class</code>对象的实例<ul><li>最常用的方法就是<code>getName()</code>, 返回一个对象类型的名称, 包名也作为类名的一部分</li></ul></li><li>也可以直接使用<code>类名.class</code>的方法访问这个类</li><li>虚拟机为每个类型管理一个唯一的<code>Class</code>对象, 所以可以使用<code>==</code>比较  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (e.getClass() == E.class) &#123;&#125;</span><br><span class="line"><span class="comment">// 如果e是一个E的实例, 则为true, 如果e是M的实例, 其中M是E的子类, 则为false</span></span><br><span class="line"><span class="comment">// 如果是 e instanceof E的话, 那么当e是M的实例时, 依然会返回true</span></span><br></pre></td></tr></table></figure></li><li>如果有一个<code>Class</code>类型的对象, 可以用他构造实例  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">className</span> <span class="operator">=</span> <span class="string">&quot;java.uril.Random&quot;</span>;</span><br><span class="line"><span class="type">Class</span> <span class="variable">cl</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> cl.getConstructor().newInstance();</span><br><span class="line"><span class="comment">// 如果这个类没有无参构造器, 则会抛出异常InvocationTargetException</span></span><br></pre></td></tr></table></figure></li><li><code>Class.forName()</code>会抛出一个检查型异常, 没有办法保证指定名字的类一定存在, 所以需要在函数后面加上<code>throws ReflectOperationException</code></li></ul><h2 id="异常">异常</h2><ul><li>分两种: 非检查型异常和检查型异常<ul><li>检查型异常: 编译器会检查你是否知道这个异常, 并做好准备处理</li><li>非检查型异常: 比如数组越界, <code>null</code>引用访问, 编译器不期望你为这些异常提供处理方法</li></ul></li></ul><h2 id="应用">应用</h2><ol><li><p>资源文件加载</p><ul><li>获得拥有资源的类的<code>Class</code>对象, 比如<code>ResourcesTest.class</code></li><li>调用部分可以接受描述资源位置<code>URL</code>的方法, 比如<code>URL url = cl.getResource(&quot;about.txt&quot;);</code></li><li>否则, 使用<code>getResourceStream()</code>得到输入流读取文件</li></ul></li><li><p>国际化</p><ul><li>与语言相关的字符串都放在资源文件中, 每个语言对应一个文件</li></ul></li></ol><h2 id="利用反射分析类">利用反射分析类</h2><ul><li><code>java.util.reflect</code>包中有三个类: <code>Field, Method, Constructor</code>, 分别用于描述类的字段, 方法和构造器<ul><li>三个类都有一个方法, 名为<code>getName()</code></li><li><code>Field.getType()</code>可以返回字段类型的一个对象, 对象的类型同样是<code>Class</code></li><li><code>Method, Constructor</code>有报告类型参数的方法, <code>Method</code>有报告返回类型的方法, 三者都有<code>getModifiers()</code> 返回一个整数, 用不同的<code>0/1</code>位描述修饰符, 比如<code>public, static</code></li><li>可以使用<code>Modifier</code>类的静态方法分析<code>getModifiers()</code>返回的整数, 需要做的就是在返回的整数基础上, 调用<code>Modifier</code>类中适当的方法</li><li>可以用<code>Modifier.toString()</code>打印修饰符</li></ul></li><li><code>Class</code>中的<code>getFields(), getMethods(), getConstructors()</code>分别返回这个类支持的公共字段, 方法和构造器</li><li><code>Class</code>中的<code>getDeclaredFields(), getDeclaredMethods(), getDeclaredConstructors()</code>返回这个类声明的全部字段, 方法和构造器, 包括私有成员， 包成员, <code>protected</code>成员, 有包访问权限的成员, 但是不会包括超类的成员</li></ul><h2 id="利用反射分析对象">利用反射分析对象</h2><ul><li>利用反射可以查看在编译时还不知道的对象字段</li><li>利用<code>Field</code>中的<code>get</code>, 比如<code>f</code>是一个<code>Field</code>类型的对象, <code>obj</code>是包含<code>f</code>字段的类的对象, 则<code>f.get(obj)</code>将会返回一个对象, 值为<code>obj</code>的当前字段值  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">E</span>();</span><br><span class="line"><span class="type">Class</span> <span class="variable">cl</span> <span class="operator">=</span> h.getClass();</span><br><span class="line"><span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> cl.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">v</span> <span class="operator">=</span> f.get(h);</span><br></pre></td></tr></table></figure></li><li>同样可使用<code>f.set(obj, val)</code>设置值, 但是如果<code>name</code>是一个私有字段, 则不能使用<code>get, set</code>, 会抛出<code>IllageAccessException</code></li><li>只能对可以访问的字段使用<code>get, set</code>, <code>Java</code>允许查看一个对象中的字段, 但是无法访问</li><li>不过可以调用<code>f.setAccessible(true)</code>覆盖<code>Java</code>的访问控制</li><li><code>setAccessible()</code>是<code>Field, Method, Constructor</code>的公共超类<code>AccessibleObject</code>中的方法</li></ul><h2 id="通用toString">通用<code>toString()</code></h2><ul><li>使用<code>getDeclaredFields</code>获得实例字段, 使用<code>setAccessible()</code>将字段设置为可以访问的, 再对每个字段调用<code>toString()</code></li><li>不过如果引用循环会导致无限递归, <code>ObjectAnalyzer</code>会跟踪已经访问过的对象</li></ul><h2 id="使用反射编写泛型数组">使用反射编写泛型数组</h2><ul><li><code>java.util.reflect</code>中的<code>Array</code>类, <code>Arrays.copyOf()</code>就使用了这个类, 这个方法可以用来扩展一个数组  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">goodCopyOf</span><span class="params">(Object a, <span class="type">int</span> newLength)</span> &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">cl</span> <span class="operator">=</span> a.getClass();</span><br><span class="line">    <span class="keyword">if</span> (!cl.isArray()) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">componentType</span> <span class="operator">=</span> cl.getComponentType();</span><br><span class="line">    <span class="comment">// 如果对象是一个数组类型, 返回对应元素的Class, 否则返回null</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> Array.getLength(a);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">newArray</span> <span class="operator">=</span> Array.newInstance(componentType, newLength);</span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, newArray, <span class="number">0</span>, Math.min(length, newLength));</span><br><span class="line">    <span class="keyword">return</span> newArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>这个<code>goodCopyOf</code>可以扩展任意数组, 参数声明为<code>Object</code>类型, 而不是<code>Object[]</code>, 因为<code>int[]</code>可以转换为一个<code>Object</code>, 而不是转换成对象数组</li><li>如果是<code>Object[]</code>的话, 在强制类型转换回去的时候会抛出异常<code>ClassCastException</code></li></ul><h2 id="使用反射调用任意的方法">使用反射调用任意的方法</h2><ul><li>可以使用<code>Field.get()</code>查看一个方法的字段, 使用<code>Method.invoke()</code>调用包装在当前<code>Method</code>中的方法  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Object <span class="title function_">invoke</span><span class="params">(Object obj, Object... args)</span>;</span><br><span class="line"><span class="comment">// 第一个参数是隐式参数, 其他参数是显式参数</span></span><br><span class="line"><span class="comment">// 如果是静态方法, 则第一个参数会被忽略为null</span></span><br><span class="line"><span class="comment">// 比如m1表示E类中的getName()</span></span><br><span class="line"><span class="type">String</span> <span class="variable">n</span> <span class="operator">=</span> (String) m1.invoke(h);</span><br><span class="line"><span class="comment">// 如果返回的是基本数据类型, invoke会返回其包装类型, 需要强制类型转换后使用自动拆箱</span></span><br><span class="line"><span class="comment">// 比如m2表示E类中的getSalary()</span></span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> (Double) m2.invoke(h);</span><br><span class="line"><span class="comment">// 使用getMethod()可以得到一个类中的方法</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">m1</span> <span class="operator">=</span> E.class.getMethod(<span class="string">&quot;getName&quot;</span>);</span><br><span class="line"><span class="type">Method</span> <span class="variable">m2</span> <span class="operator">=</span> E.class.getMethod(<span class="string">&quot;getSalary&quot;</span>, <span class="type">double</span>.class);</span><br><span class="line"><span class="comment">// 可以获得构造器方法</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">cl</span> <span class="operator">=</span> Random.class;</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">cons</span> <span class="operator">=</span> cl.getConstructor(<span class="type">long</span>.class);</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> cons.newInstance(<span class="number">42L</span>);</span><br></pre></td></tr></table></figure></li><li><code>Method, Construtor</code>类扩展了<code>Executable</code>类, 并且<code>Executable</code>是<code>sealed</code>的, 只允许<code>Method, Constructor</code>作为子类</li><li>比如调用<code>Math.sqrt()</code>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">dx</span> <span class="operator">=</span> (to - from) / (n - <span class="number">1</span>);</span><br><span class="line">Math.class.getMethod(<span class="string">&quot;sqrt&quot;</span>, <span class="type">double</span>.class);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> from; x &lt;= to; x += dx) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> <span class="variable">y</span> <span class="operator">=</span> (Double) f.invoke(<span class="literal">null</span>, x);</span><br><span class="line">    <span class="comment">// 因为Math.sqrt是一个静态方法, 所以invoke的第一个参数为null</span></span><br><span class="line">    System.out.printf(<span class="string">&quot;%10.4f | %10.4f%n&quot;</span>, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>反射能完成所有操作, 但是很不方便, <code>invoke</code>参数错误还会抛出异常. 同时<code>invoke</code>返回类型一定是<code>Object</code>的, 所以必须来回强制类型转换</li><li>编译器就丧失了检查代码的机会, 反射获得方法指针的代码比直接调用慢的多</li><li>所以一般只有绝对必要的时候才会引入<code>Method</code>对象, 更好的方法是使用<code>lambda</code>表达式</li><li>不要使用回调函数的<code>Method</code>对象, 要是用回调的接口, 这样执行速度更快, 也更好维护</li></ul><h1>继承设计技巧</h1><ol><li>公共字段和方法放在超类中</li><li>不要使用<code>protected</code></li><li>使用继承实现<code>is-a</code>关系</li><li>除非所有继承的方法都有意义, 否则不要使用继承</li><li>覆盖方法不要改变预期的行为</li><li>不要滥用反射</li><li>使用多态, 不要使用类型信息 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x is of type <span class="number">1</span>) </span><br><span class="line">    action1(x)</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    action2(x)</span><br><span class="line"><span class="comment">// 这种形式的代码都可以用多态实现</span></span><br><span class="line"><span class="comment">// 如果action1() action2()表示通用的概念, 可以定义为这两个类型的公共超类或接口中的方法, 然后可以调用</span></span><br><span class="line"><span class="comment">// x.action(), 利用多态的动态分配机制执行正确的动作</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;继承&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;基本思想: 基于已有的类创建新的类, 复用已有类的方法, 同时可以增加一些新的方法和字段&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;反射是程序在运行期间更多地了解类以及属性的能力&lt;/li&gt;
&lt;/ul&gt;
&lt;div </summary>
      
    
    
    
    <category term="Java" scheme="https://sangs3112.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://sangs3112.github.io/tags/Java/"/>
    
    <category term="Java核心技术(卷一)" scheme="https://sangs3112.github.io/tags/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%8D%B7%E4%B8%80/"/>
    
  </entry>
  
  <entry>
    <title>Java笔记_8</title>
    <link href="https://sangs3112.github.io/posts/6a129434.html"/>
    <id>https://sangs3112.github.io/posts/6a129434.html</id>
    <published>2024-12-01T10:21:00.000Z</published>
    <updated>2025-01-16T15:34:13.090Z</updated>
    
    <content type="html"><![CDATA[<h1>接口</h1><blockquote><p>接口用来描述类应该做什么, 不指定具体如何做, 一个类可以实现多个接口</p></blockquote><ul><li>接口可以定义常量, 但是绝不能有实例字段</li><li><code>Java 8</code>之前, 接口中的方法都是抽象方法</li></ul><div class="note info flat"><ul><li>定义接口的方法不必指定为<code>public</code>, 因为接口方法自动为<code>public</code></li><li>接口中的字段都是<code>public static final</code>的, 也不需要手动指定</li><li>但是实现接口时, 必须明确写<code>public</code>, 否则编译器会默认认为这个方法的访问属性是包可访问, 就会报错</li></ul></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">E</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;E&gt; &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(E oth)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Double.compare(salary, oth.salary);</span><br><span class="line">    <span class="comment">// 如果x &lt; y 返回 负数</span></span><br><span class="line">    <span class="comment">// 如果x = y 返回 0</span></span><br><span class="line">    <span class="comment">// 如果x &gt; y 返回正数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info flat"><ul><li><code>Comparable</code>接口文档建议<code>compareTo</code>方法与<code>equals</code>方法兼容, 即<code>x.equals(y)</code>时, <code>x.compareTo(y) == 0</code></li><li>大部分都是兼容的, 除了<code>BigDecimal</code><ul><li><code>x = new BigDecimal(&quot;1.0&quot;)</code>和<code>y = new BigDecimal(&quot;1.00&quot;);</code>因为精度不同, 所以<code>x.compareTo(y) == 0</code>但是<code>x.equals(y) == false;</code></li><li>理论上应该不返回<code>0</code>, 但是不知道谁大谁小</li></ul></li></ul></div><ul><li>语言标准规定 <code>x.compareTo(y) == -y.compareTo(x)</code>, 同样如果前者抛出异常, 后者也必须抛出异常</li><li>如果<code>M</code>继承自<code>E</code>, <code>E</code>实现了<code>Comparable&lt;E&gt;</code>, 而没有实现<code>Comparable&lt;M&gt;</code></li><li>如果要在<code>M</code>中重写, 就要做好准备比较<code>M</code>和<code>E</code>, 不能简单的将<code>E</code>转换为<code>M</code></li><li>比如<code>x</code>是<code>M</code>, <code>y</code>是<code>E</code>, 调用<code>y.compareTo(x)</code>不会抛出异常, 调用<code>x.compareTo(y)</code>就会抛出一个<code>ClassCastException</code></li><li>可以在每个<code>compareTo</code>之前都进行检测: <code>if (getClass != oth.getClass()) throw new ClassCastException</code></li></ul><h2 id="接口属性">接口属性</h2><ul><li>接口不是类, 不能使用<code>new Comparable()</code></li><li>但是可以使用接口变量, 必须引用一个实现了这个接口的对象<code>Comparable x = new E()</code></li><li>可以使用<code>instanceof</code>检查某个对象是否实现了一个接口</li><li>可以使用<code>extends</code>扩展接口, 一个类只能有一个超类, 但是可以实现多个接口</li></ul><div class="note info flat"><ul><li>记录和枚举类不能扩展其他类, 因为他们隐式扩展了<code>Record</code>和<code>Enum</code>类, 但是他们可以实现接口</li><li>接口也可以是密封的<code>sealed</code>, 直接子类型, 必须声明在<code>permits</code>中, 或者在一个文件中</li></ul></div><h2 id="默认方法">默认方法</h2><ul><li><p>可以为接口提供一个<code>default</code>方法, 表示方法的默认实现</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(T oth)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>大部分情况没什么用, 因为每个实现的接口都会覆盖这个方法</p></li><li><p>不过有时候也能有用, 比如<code>Iterator</code>接口, 声明了一个<code>remove()</code></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportOperationException</span>(<span class="string">&quot;remove&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>默认方法也可以调用其他方法</p></li><li><p>默认方法可以实现接口演化, 实现代码兼容. 比如以前有一个类<code>class B implements Collection</code>, 后来<code>Java</code>版本更新, <code>Collection</code>接口中添加了新的方法, 如果不用<code>default</code>修饰新的方法就会导致原来的类<code>B</code>无法编译</p></li><li><p>如果在一个接口中定义了一个方法, 在超类或者另一个接口中定义了同样的方法, <code>Java</code>有自己的规则:</p><ol><li>超类优先: 如果超类定义了一个具体方法, 同名且有相同参数类型的默认方法会被忽略</li><li>接口冲突: 如果一个接口提供了一个默认方法, 另一个接口提供了一个同名并且参数类型相同的方法, 不论是否为默认方法, 就需要覆盖这个方法来解决冲突 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Name</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;<span class="keyword">return</span> getClass().getName() + <span class="string">&quot;_&quot;</span> + hashCode();&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果有一个类同时实现了这两个接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Person</span>, Name &#123;&#125;</span><br><span class="line"><span class="comment">// 编译器会报错, 需要在Student类中提供一个getName(), 可以选择两个冲突方法中的一个</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Person</span>, Name &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Person.<span class="built_in">super</span>.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 就算如果Name类中没有定义默认的getName()方法, 编译器还是会报错, 要求程序员解决二义性问题</span></span><br><span class="line"><span class="comment">// 如果两个类都没有提供默认的getName()方法, 就不会有冲突</span></span><br></pre></td></tr></table></figure><ul><li>另一种情况是类扩展了超类, 同时实现了一个接口, 超类和接口继承了相同的方法</li></ul> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Name</span> &#123;&#125;</span><br><span class="line"><span class="comment">// 这种情况下只会考虑超类的方法, 接口所有的默认方法都会被忽略</span></span><br><span class="line"><span class="comment">// 类优先的规则可以确保和Java 7的兼容性</span></span><br><span class="line"><span class="comment">// 如果为一个接口添加默认方法, 对于有默认方法之前的版本代码不会有影响</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><div class="note info flat"><ul><li>绝对不能为<code>Object</code>某个方法定义默认方法, 比如<code>toString(), equals()</code></li><li>因为类优先的规则, 这样的方法绝对无法超越<code>Object.toString()</code>或<code>Objects.equals()</code></li></ul></div><h2 id="Comparator接口"><code>Comparator</code>接口</h2><ul><li><p>如果调用<code>Arrays.sort()</code>对字符串进行排序的话, 会按照字典序</p></li><li><p>现在如果想要按照字符串的长度进行排序, 就不能修改<code>String.compareTo()</code></p></li><li><p>可以使用<code>Arrays.sort()</code>方法的第二个版本, 接受一个数组和一个比较器作为参数, 比较器是实现了<code>Comparator</code>接口的类的实例</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">compare</span><span class="params">(T first, T second)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 比如需要按照长度比较字符串, 可以以如下方法实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LengthComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String first, String second)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> first.length() - second.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 完成比较需要建立一个实例</span></span><br><span class="line"><span class="type">var</span> <span class="variable">comp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LengthComparator</span>();</span><br><span class="line"><span class="keyword">if</span> (comp.compare(words[i], words[j]) &gt; <span class="number">0</span>) &#123;&#125;</span><br><span class="line"><span class="comment">// 如果需要对一个数组进行排序, 可以调用 Arrays.sort()</span></span><br><span class="line">String[] f = &#123;&#125;;</span><br><span class="line">Arrays.sort(f, <span class="keyword">new</span> <span class="title class_">LengthComparator</span>);</span><br></pre></td></tr></table></figure></li><li><p>静态<code>comparing</code>方法接受一个键提取器函数, 将类型<code>T</code>映射为一个可比较的类型, 比如<code>String</code></p><ul><li>要比较的对象引用这个函数, 然后对返回的键完成比较, 比如假设有一个<code>Person</code>数组, 可以按照名字进行排序</li><li><code>Arrays.sort(people, Comparator.comparing(Person::getName));</code></li><li>可以把比较器和<code>thenComparing()</code>串起来, 处理比较相同的结果</li><li><code>Arrays.sort(people, Comparator.comparing(Person::getLastName).thenComparing(Person::getFirstName));</code></li><li>可以给<code>comparing</code>和<code>thenComparing</code>提取的键指定一个比较器, 完成对人名长度的排序</li><li><code>Arrays.sort(people, Comparator.comparing(Person::getName, (s, t) -&gt; Integer.compare(s.length(), t.length())));</code></li><li><code>Arrays.sort(people, Comparator.comparingInt(p -&gt; p.getName().length()));</code></li></ul></li><li><p>如果键函数可能返回<code>null</code>, 就需要用到<code>nullsFirst</code>和<code>nullsLast</code>适配器, 可以修改比较器, 遇到<code>null</code>的时候不会抛出异常, 而是标记当前值小于或大于正常值</p><ul><li><code>Comparator.comparing(Person::getMiddleName(), Comparator.nullsFirst(...));</code></li><li><code>nullsFirst</code>方法需要一个比较器, 就是两个字符串的比较器</li><li><code>naturalOrder</code>方法可以为任何实现了<code>Comparable</code>的类建立一个比较器</li><li><code>Arrays.sort(people, comparing(Person::getMiddleName, nullsFirst(naturalOrder()));</code></li><li>静态<code>reverseOrder</code>方法可以提供逆序, 等同于<code>naturalOrder().reversed()</code></li></ul></li></ul><h2 id="Cloneable接口"><code>Cloneable</code>接口</h2><ul><li><code>clone</code>是<code>Object</code>的<code>protected</code>方法, 不能直接调用这个方法, 子类只能调用受保护的<code>clone()</code>来克隆他自己的对象, 如果其中包含了一些其他对象, 就没有办法<code>clone</code>了</li><li>默认的克隆操作是一个浅拷贝, 没有克隆对象中引用的其他对象</li><li>如果原对象和浅克隆对象共享的子对象是不可变的, 那么这种共享就是安全的, 比如<code>String</code><ul><li>或者在对象生命周期中, 子对象一直保持不变，没有更改器方法改变它, 也没有方法生成他的引用, 这种情况下就是安全的</li></ul></li><li>但是大多数情况下, 子对象都是可变的, 必须重新定义<code>clone</code>方法, 需要确定<ol><li>默认的<code>clone</code>方法能满足要求</li><li>可以在可变子对象上调用<code>clone</code>弥补默认的<code>clone</code></li><li>不能使用<code>clone</code></li></ol><ul><li>如果指定第一项或者第二项, 需要实现<code>Cloneable</code>接口, 重新定义<code>clone</code>方法, 同时指定<code>public</code></li></ul></li></ul><div class="note info flat"><ul><li><code>Cloneable</code>接口是<code>Java</code>中少数的标记接口, 记号接口</li><li>用途是确保一个类实现一个特定的方法或一组方法, 标记接口不包含任何方法, 唯一的作用就是允许在类型查询中使用<code>instabceof</code></li><li>自己写代码<strong>不要</strong>使用标记接口</li></ul></div><ul><li>即使默认的<code>clone()</code>可以满足要求, 还是需要实现<code>Clonebale</code>接口, 将<code>clone</code>重新定义为<code>public</code>, 调用<code>super.clone()</code>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">E</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportException &#123;</span><br><span class="line">        <span class="type">E</span> <span class="variable">cloned</span> <span class="operator">=</span> (E) <span class="built_in">super</span>.clone();</span><br><span class="line">        cloned.Day = (Date) Day.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><div class="note info flat"><ul><li>需要注意子类的克隆, 一旦为<code>E</code>定义了<code>clone()</code>, 别人就可以使用他克隆子类<code>M</code></li><li>所以最好避免使用<code>clone()</code>, 使用另一个方法达到同样的目的</li></ul></div><h1><code>lambda</code>表达式</h1><blockquote><p><code>lambda</code>表达式是一个可传递的代码块, 可以在以后执行一次或多次</p></blockquote><ul><li>以上面的排序为例, <code>first.length() - secode.length()</code> 其中<code>first, second</code>都是字符串  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lambda表达式写法</span></span><br><span class="line">(String first, String second) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (first.length() &lt; second.length()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (first.length() &gt; second.length()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 即使lambda表达式没有参数, 仍然需要提供空括号</span></span><br><span class="line">() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果可以推导出lambda表达式的类型, 就可以忽略类型</span></span><br><span class="line">Comparator&lt;String&gt; comp = (first, second) -&gt; &#123;</span><br><span class="line">    first.length() - second.length();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果只有一个参数, 并且参数类型还可以推导出来, 那么还可以省略小括号</span></span><br><span class="line"><span class="type">ActionListener</span> <span class="variable">listener</span> <span class="operator">=</span> event -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;1111&quot;</span> + Instant.ofEpochMilli(event.getWhen()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不需要指定lambda表达式的返回类型, 因为返回类型一定会根据上下文推导得到</span></span><br><span class="line"><span class="comment">// 可以使用var指示一个推导的类型, 不常用, 一般为了关联注解</span></span><br><span class="line">(<span class="meta">@NonNull</span> <span class="keyword">var</span> first, <span class="meta">@NonNull</span> <span class="keyword">var</span> second) -&gt; first.length() - second.length();</span><br></pre></td></tr></table></figure></li></ul><div class="note info flat"><ul><li>如果一个<code>lambda</code>表达式只有部分分支有返回值, 是不合法的</li></ul></div><h2 id="函数式接口">函数式接口</h2><ul><li>对于只有一个抽象方法的接口, 需要这种接口的对象时, 就可以提供一个<code>lambda</code>表达式, 称为函数式接口  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比如Arrays.sort()第二个参数需要一个Comparator实例</span></span><br><span class="line"><span class="comment">// 只有一个抽象方法的接口, 就可以改成lambda表达式</span></span><br><span class="line">Arrays.sort(words, (first, second) -&gt; first.length() - second.length());</span><br><span class="line"><span class="comment">// 可以把lambda表达式看作一个函数, 而不是一个对象, 同时lambda表达式可以传递到函数式接口</span></span><br><span class="line"><span class="comment">// 不能把lambda表达式赋值给类型为Object的变量, Object不是一个函数式接口</span></span><br><span class="line"><span class="comment">// ArrayList通过lambda表达式删除一个数组列表中所有的null</span></span><br><span class="line">list.removeIf(e -&gt; e == <span class="literal">null</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="方法引用">方法引用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>(<span class="number">1000</span>, event -&gt; System.out.println(event));</span><br><span class="line"><span class="comment">// 方法引用可以直接将println传入timer中</span></span><br><span class="line"><span class="type">var</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>(<span class="number">1000</span>, System.out::println);</span><br><span class="line"><span class="comment">// 这里System.out::println是一个方法引用</span></span><br><span class="line"><span class="comment">// 指示编译器生成一个函数式接口实例, 覆盖这个接口的抽象方法来调用给定的方法</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> System.out::println;</span><br><span class="line"><span class="comment">// 这里的Runnable函数式接口有一个无参数的抽象方法 void run()</span></span><br><span class="line"><span class="comment">// 这里调用task.run() 就会自动选择无参数的println() 打印一个空行</span></span><br><span class="line"><span class="comment">// 如果想要对字符串进行排序, 忽略大小写</span></span><br><span class="line">Arrays.sort(words, String::compareToIgnoreCase);</span><br></pre></td></tr></table></figure><ul><li>使用<code>::</code>操作符分割方法名和对象或者类名, 有三种情况:<ol><li><code>object::instanceMethod</code><ul><li>方法引用等价于一个<code>lambda</code>表达式, 参数传递到方法, 对于<code>System.out::println</code>, 对象是<code>System.out</code>, 方法等价于<code>x -&gt; System.out.println(x)</code></li></ul></li><li><code>Class::instanceMethod</code><ul><li>第一个参数会成为隐式参数, 比如<code>String::compareToIgnoreCase</code>等同于<code>(x, y) -&gt; x.compareToIgnoreCase(y)</code></li></ul></li><li><code>Class::staticMethod</code><ul><li>所有参数都传递到静态方法, <code>Math::pow</code>等价于<code>(x, y) -&gt; Math.pow(x, y)</code></li></ul></li></ol></li></ul><div class="note info flat"><ul><li>只有当<code>lambda</code>表达式的体只调用一个方法而不做其他操作的时候, 才能将其转换为方法引用</li><li><code>s -&gt; s.length() == 0</code>里面只有一个方法调用, 但是还有一个比较, 所以不能使用方法引用</li><li>方法引用不会独立存在, 总是会转换为函数式接口的实例</li><li>如果要删除数组中所有为空的值, 可以使用 <code>list.removeIf(Objects::isNull)</code></li><li>包含对象的方法引用与等价的<code>lambda</code>表达式的区别, 比如<code>separator::equals</code>, 如果<code>separator</code>为<code>null</code>, 构造<code>separator::equals</code>时就会立即抛出<code>NullPointerException</code>异常, <code>lambda</code>表达式<code>x -&gt; separator.equals(x)</code>只会在调用时才会抛出<code>NPE</code></li></ul></div><ul><li>可以在方法引用中使用<code>this</code>参数, 比如<code>this::equals</code> 等同于<code>x -&gt; this.equals(x)</code></li><li>同样使用<code>super</code>也是可以的</li></ul><h2 id="构造器引用">构造器引用</h2><blockquote><p>和方法引用类似, 只不过方法名为<code>new</code>, 比如<code>Person::new</code>是<code>Person</code>的构造器引用, 使用哪一个构造器取决于上下文</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; names = ...;</span><br><span class="line">Stream&lt;Person&gt; stream = names.stream().map(Person::<span class="keyword">new</span>);</span><br><span class="line">List&lt;Person&gt; people = stream.toList();</span><br><span class="line"><span class="comment">// 这里将字符串列表转换为一个Person数组</span></span><br><span class="line"><span class="comment">// map为各个列表元素调用Person(String)构造器</span></span><br></pre></td></tr></table></figure><ul><li><code>int[]::new</code>有一个数组的长度作为参数, 是一个构造器引用</li><li><code>Java</code>中无法构造泛型类型<code>T</code>的数组, 数组构造器可以克服这个限制</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object[] people = stream.toArray();</span><br><span class="line"><span class="comment">// toArray()可以返回一个Object类型数组, 但是如果希望得到一个Person数组, 就需要构造器引用</span></span><br><span class="line">Person[] people = stream.toArray(Person[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure><h2 id="变量作用域">变量作用域</h2><ul><li>一个<code>lambda</code>表达式有三个部分<ol><li>一个代码块</li><li>参数</li><li>自由变量: 指非参数, 并且不在代码中定义的变量</li></ol></li><li><code>lambda</code>会将自由变量的值复制到<code>lambda</code>表达式的数据结构实例对象中</li></ul><div class="note info flat"><ul><li><code>lambda</code>表达式中只能引用不会改变的值, 比如引用<code>int</code>就是不合法的</li><li>如果在<code>lambda</code>表达式中更改变量, 并发执行多个动作的时候就不安全</li><li>就算<code>lambda</code>表达式内部没有修改变量, 但是这个变量也有可能在外部改变, 这也是不合法的</li><li><code>lambda</code>表达式捕获的变量必须是<strong>事实最终变量</strong>, 指的是这个变量初始化以后不会赋新值, 比如<code>String</code></li><li><code>lambda</code>表达式中不能声明和局部变量同名的参数或变量</li></ul></div><ul><li>在<code>lambda</code>表达式中使用<code>this</code>参数的时候, 是指创建这个<code>lambda</code>表达式的方法的<code>this</code>参数  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> event -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="built_in">this</span>.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里的this.toString()调用的是A对象的toString(), 而不是B实例方法</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="处理lambda表达式">处理<code>lambda</code>表达式</h2><blockquote><p><code>lambda</code>表达式的重点是延迟执行</p></blockquote><ul><li>延迟执行的原因<ol><li>单线程</li><li>多次运行代码</li><li>在算法的适当位置运行, 比如排序的比较操作</li><li>发生某种情况的时候运行, 比如点击按钮, 数据到达</li><li>只有必要时才运行代码</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repeat(<span class="number">10</span>, () -&gt; System.out.println(<span class="string">&quot;1&quot;</span>));</span><br></pre></td></tr></table></figure><ul><li>如果设计自己的函数式接口, 里面只有一个抽象方法, 可以使用<code>@FunctionalInterface</code>注解来标记接口<ul><li>这样如果添加了一个新的抽象方法, 可以检查出来并报错</li><li>同时<code>javadoc</code>会标记这个接口是一个函数式接口</li><li>不是必须使用这个注解</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;接口&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;接口用来描述类应该做什么, 不指定具体如何做, 一个类可以实现多个接口&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;接口可以定义常量, 但是绝不能有实例字段&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Java 8&lt;/code&gt;</summary>
      
    
    
    
    <category term="Java" scheme="https://sangs3112.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://sangs3112.github.io/tags/Java/"/>
    
    <category term="Java核心技术(卷一)" scheme="https://sangs3112.github.io/tags/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%8D%B7%E4%B8%80/"/>
    
  </entry>
  
  <entry>
    <title>Docker笔记_0</title>
    <link href="https://sangs3112.github.io/posts/81d2299d.html"/>
    <id>https://sangs3112.github.io/posts/81d2299d.html</id>
    <published>2024-11-30T01:53:35.000Z</published>
    <updated>2025-01-16T15:34:13.089Z</updated>
    
    <content type="html"><![CDATA[<h1><code>Docker</code> 下载安装</h1><blockquote><p>众所周知, 来自中国的程序员往往具有更好的网络相关基础 :(</p><p>因为多次尝试在<code>Ubuntu</code>上安装<code>Docker</code>以及<code>Docker Compose</code>, 中间踩了无数坑, 为此在这里做一个记录总结</p><p>如果有条件, 直接<code>clash</code>, 按照官网的流程, 大抵是可行的 (虽然我尝试了一下还是存在不少问题…)</p><p>哪怕直接<code>sudo apt install docker</code> 也是完全不行的, 软件源中的<code>docker</code>是究极老版本, 几乎用不了</p></blockquote><ol><li>卸载 <code>Docker</code> (有可能叫<code>docker-engine</code> <code>docker.io</code>)</li></ol><blockquote><p><code>Ubuntu</code>大概率会自带老版本的<code>Docker</code>, 很多语法还有命令都不一样了, 所以需要先卸载了</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt remove docker docker-engine docker.io containerd runc</span><br></pre></td></tr></table></figure><ol start="2"><li>更新软件包</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade</span><br></pre></td></tr></table></figure><ol start="3"><li>安装一些依赖</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ca-certificates curl gnupg lsb-release</span><br></pre></td></tr></table></figure><ol start="4"><li>添加<code>Docker</code>官方<code>GPG</code>密钥</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure><ol start="5"><li>添加<code>Docker</code>软件源</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository &quot;deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot;</span><br></pre></td></tr></table></figure><ol start="6"><li>安装<code>Docker</code></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure><ol start="7"><li>配置用户组</li></ol><blockquote><p>如果不配置的话, 运行<code>Docker</code>的时候会一直提示没有<code>root</code>权限</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure><ul><li>配置完以后需要重新登录才能刷新</li></ul><h1><code>Docker Compose</code> 下载安装</h1><ol><li><p>使用<code>docker version</code>查看<code>Docker</code>版本</p></li><li><p>接着按照<a href="https://docs.docker.com/compose/install/">这个链接</a>里面步骤操作即可.</p><ul><li>因为现在我三台<code>Linux</code>服务器已经安装过了, 不想再卸载重新搞了, 以后下一台机器搞的时候再加上截图以及具体步骤</li></ul></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">github: https://github.com/docker/compose/releases/tag/v2.20.2</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">国内下载地址：https://gitee.com/smilezgy/compose/releases/tag/v2.20.2</span></span><br><span class="line">sudo curl -SL \</span><br><span class="line">https://github.com/docker/compose/releases/download/v2.20.2/docker-compose-linux-x86_64 \</span><br><span class="line">-o /usr/local/bin/docker-compose</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者手动下载, 上传到服务器后执行如下指令(use)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在 docker-compose-linux-x86_64 文件同一目录下执行</span></span><br><span class="line">sudo cp docker-compose-linux-x86_64 /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><ol start="3"><li>添加执行权限</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><h1>使用<code>Docker</code>以及<code>Docker Compose</code></h1><blockquote><p>安装好只是第一步. 2024-06 之后<code>Docker</code>国内的绝大部分镜像站都停了</p><p>比如<code>Docker</code>中国, 网易云, 七牛云, 腾讯云, 百度云, 各个大学</p></blockquote><ul><li>可以在<a href="https://gist.github.com/y0ngb1n/7e8f16af3242c7815e7ca2f0833d3ea6">这个链接</a>中找到停止服务的镜像以及还能用的镜像</li></ul><h2 id="2024-10为止还能使用的镜像站">2024-10为止还能使用的镜像站</h2><blockquote><p>不知道还会撑多久 :(</p></blockquote><table><thead><tr><th>镜像站</th><th>链接</th></tr></thead><tbody><tr><td>1Panel</td><td><a href="https://docker.1panel.live">https://docker.1panel.live</a></td></tr><tr><td>耗子面板</td><td><a href="https://hub.rat.dev">https://hub.rat.dev</a></td></tr><tr><td>不知名</td><td><a href="https://docker.zlzlme.cloudns.ph/">https://docker.zlzlme.cloudns.ph/</a></td></tr></tbody></table><h2 id="Docker换源"><code>Docker</code>换源</h2><blockquote><p>如果不换源, 那么<code>docker pull</code>就会失败</p></blockquote><ol><li>编辑<code>/etc/docker/daemon.json</code></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/docker/daemon.json</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">daemon.json</span></span><br><span class="line">&#123;</span><br><span class="line">    &quot;registry-mirrors&quot;: [</span><br><span class="line">        &quot;https://docker.1panel.live&quot;,</span><br><span class="line">        &quot;https://hub.rat.dev&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>重启<code>Docker</code>服务</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><ol start="3"><li>检查是否配置成功</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker info</span><br></pre></td></tr></table></figure><ul><li>如果配置成功了, 镜像信息会显示在最后</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;code&gt;Docker&lt;/code&gt; 下载安装&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;众所周知, 来自中国的程序员往往具有更好的网络相关基础 :(&lt;/p&gt;
&lt;p&gt;因为多次尝试在&lt;code&gt;Ubuntu&lt;/code&gt;上安装&lt;code&gt;Docker&lt;/code&gt;以及&lt;c</summary>
      
    
    
    
    <category term="Docker" scheme="https://sangs3112.github.io/categories/Docker/"/>
    
    
    <category term="Docker" scheme="https://sangs3112.github.io/tags/Docker/"/>
    
    <category term="Docker Compose" scheme="https://sangs3112.github.io/tags/Docker-Compose/"/>
    
    <category term="Docker安装" scheme="https://sangs3112.github.io/tags/Docker%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>Java笔记_6</title>
    <link href="https://sangs3112.github.io/posts/8daab933.html"/>
    <id>https://sangs3112.github.io/posts/8daab933.html</id>
    <published>2024-11-29T01:53:35.000Z</published>
    <updated>2025-01-16T15:34:13.090Z</updated>
    
    <content type="html"><![CDATA[<h1>面向对象编程(<code>OOP</code>)</h1><ul><li><code>Java</code>中对象变量只是包含了一个引用, 没有实际包含一个变量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">startTime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="comment">// 这里的startTime只是一个指向Date实例的引用</span></span><br><span class="line"><span class="comment">// 不能看作是CPP中的引用, 应该看作CPP中的对象指针, 也就是Date* startTime</span></span><br></pre></td></tr></table></figure><div class="note info flat"><ul><li>所有的<code>Java</code>对象都存储在堆中, 当一个对象包含了另一个对象的时候, 实际上只是包含了另一个对象在堆中的指针</li><li>所以如果需要得到一个对象的副本, 不能简单的用<code>=</code>, 而是应该用<code>clone()</code>方法</li></ul></div><h2 id="更改器方法和访问器方法">更改器方法和访问器方法</h2><blockquote><p>更改器方法: 调用方法以后, 对应实例的状态会改变</p><p>访问器方法: 调用方法以后, 只访问对象, 不会修改它. 比如<code>get()</code></p></blockquote><ul><li>访问器方法<strong>不要返回可变对象的引用</strong>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">E</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Date hireDay;</span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getHireDay</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> hireDay;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里的hireDay就是一个Date类的对象引用, 而Date类本身存在更改器方法setTime</span></span><br><span class="line"><span class="comment">// 所以此时hireDay是可变的, 破坏了封装性</span></span><br><span class="line"><span class="comment">// 如果需要返回一个可变对象引用, 需要先clone</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">R</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getHireDay</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (Date) hireDay.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><div class="note info flat"><ul><li><code>CPP</code>中带有<code>const</code>后缀的方法是访问器方法, 没有<code>const</code>后缀的方法是更改器方法</li><li><code>Java</code>中没有这种明显的标识</li></ul></div><ul><li>构造器没有返回值, 总是和<code>new</code>一起使用</li><li>所有的方法中都不要使用和实例字段同名的方法, 可以同名, 但是最好不要出现, 除了后面讲到的<code>record</code></li><li>实例字段不要设置成<code>public</code>, 这样会破坏封装, 要保证数据私有</li><li>在构造类的实例时, 推荐使用<code>var</code>来声明这个对象的类型, 这样就不用重复写类了</li><li>不要对数值类型写<code>var</code>, <code>var</code>只能用于局部字段, 对于参数和实例字段不能使用<code>var</code></li></ul><h2 id="null"><code>null</code></h2><ul><li>对象变量包含一个引用, 或者是<code>null</code></li><li>如果对<code>null</code>值变量调用方法会产生<code>NullPointException</code></li><li>基本数据类型不会是<code>null</code>, 需要注意<code>String</code>类型的<code>null</code>, 可以检测到以后将其转换为另一个值  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (n == <span class="literal">null</span>) &#123;</span><br><span class="line">    name = <span class="string">&quot;unknown&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    name = n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 也有更简单的方法</span></span><br><span class="line">name = Objects.requireNonNullElse(n, <span class="string">&quot;unknown&quot;</span>);</span><br><span class="line"><span class="comment">// 或者可以直接拒绝null</span></span><br><span class="line">name = Objects.requireNonNull(n, <span class="string">&quot;The name can not be null&quot;</span>);</span><br><span class="line"><span class="comment">// 这样可以直接定位到哪里有空值, 如果等程序自动触发NPE的话, 可能不是空值存在的地方</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="静态字段">静态字段</h2><h3 id="静态变量">静态变量</h3><ul><li>一个对象定义为<code>static</code>, 那么这个字段并不会出现在每个类的对象中. 每个静态字段<strong>只有一个副本</strong></li><li>所以静态字段属于类, 但是不属于单个类的实例</li></ul><div class="note info flat"><p>比如对员工分配唯一的标识码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">E</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">nextId</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">E</span><span class="params">()</span> &#123;</span><br><span class="line">        id = nextId;</span><br><span class="line">        nextId ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这样所有员工共享一个nextId, 但是每个员工有自己的id</span></span><br><span class="line"><span class="comment">// 就算没有员工对象, 这个nextId也是存在的</span></span><br></pre></td></tr></table></figure></div><h3 id="静态常量">静态常量</h3><ul><li>静态常量相比于静态变量更加常用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Math</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.14</span>...;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">System</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">PrintStream</span> <span class="variable">out</span> <span class="operator">=</span> ...;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 分别使用Math.PI和System.out可以访问</span></span><br><span class="line"><span class="comment">// 如果省略了static, 那么PI就需要通过一个MATH的实例来访问</span></span><br></pre></td></tr></table></figure><div class="note info flat"><ul><li>类中最好不要有公共字段, 因为公共字段谁都可以访问, 但是如果是final的公共常量就不要紧</li><li>因为<code>out</code>是由<code>final</code>修饰的, 所以<code>out</code>本身是不允许重新赋值的</li><li>但是<code>System</code>中有一个<code>setOut</code>方法, 这是因为<code>setOut</code>方法不是<code>Java</code>实现的, 是一个原生方法, 可以跳过访问控制机制</li></ul></div><h2 id="静态方法">静态方法</h2><ul><li>静态方法是不操作对象的方法, 比如<code>Math.pow(x, a)</code>, 不需要使用<code>Math</code>对象, 没有隐式参数<code>this</code></li><li>所以上面的<code>E</code>类, 静态方法不能访问<code>id</code>字段, 因为不操作对象, 但是静态方法可以访问静态字段</li><li>同样可以使用对象实例调用静态方法, 但是没有意义, 因为静态方法与对象无关, 所以最好直接用类名调用静态方法</li></ul><div class="note info flat"><p>以下两种情况可以使用静态方法:</p><ol><li>方法不需要访问对象状态, 所有的参数可以直接通过显示参数提供, 比如<code>Math.pow(x, a)</code></li><li>方法只需要访问静态字段</li></ol></div><ul><li><code>main</code>方法就是一个静态方法, 可以在每个类都创建一个静态方法, 用于演示</li><li>不演示的时候直接调用<code>Application.main</code>则不会执行内部其他类的<code>main</code>函数</li></ul><h3 id="静态工厂方法">静态工厂方法</h3><div class="note info flat"><p>为什么不用构造器要用静态工厂方法:</p><ol><li>无法为构造器命名, 因为构造器的命名总是要与类名相同, 但是如果需要得到两个不同的名字, 就无法实现了</li><li>构造器无法改变构造对象的类型, 静态工厂方法可以返回指定的类型, 比如某个类的子类</li></ol></div><h2 id="构造器">构造器</h2><ul><li>可以在一个构造器中调用另一个构造器  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">E</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 调用了E(String, double)的构造方法, 这样只需要写一次公共的构造函数</span></span><br><span class="line">        <span class="built_in">this</span>(<span class="string">&quot;123&quot;</span> + nextId, s);</span><br><span class="line">        nextId ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><div class="note info flat"><ul><li>自动定义的, 设置所有实例字段的构造器是标准构造器</li><li>自定义构造器的第一个语句<strong>必须</strong>调用另一个构造器, 最终调用标准构造器</li></ul></div><h1>记录</h1><blockquote><p><code>JDK 14</code>引入, <strong>状态不可变</strong>, <strong>公共可读</strong>, 一个记录的实例字段称为<strong>组件</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">record</span> <span class="title class_">Point</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> &#123;&#125;;</span><br><span class="line"><span class="comment">// 这个Point就是一个记录, 不再需要写class中的很多内容</span></span><br><span class="line"><span class="comment">// 具有一个构造器 Point(double x, double y)</span></span><br><span class="line"><span class="comment">// 具有两个访问器 public double x(); public double y();</span></span><br><span class="line"><span class="comment">// 方法和实例字段可以同名</span></span><br><span class="line"><span class="type">var</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">System.out.Println(p.x() + <span class="string">&quot; &quot;</span> + p.y());</span><br></pre></td></tr></table></figure><ul><li>每个记录都有自动定义的三个方法: <code>toString(), equals(), hashCode()</code></li><li>记录可以自己定义静态字段和方法, 但是不能新增<strong>实例字段</strong>, 实例字段应该全部都作为参数</li></ul><h1>包</h1><blockquote><p>包名为了确保类名的唯一性, 一般是<code>域名的逆序.项目名.类名</code></p></blockquote><ul><li>一个类可以使用所属包中的所有类, 以及其他包中的公共类</li><li>如果包名写错了, 但是他不依赖其他包, 那么可以顺利编译通过, 但是执行的时候会失败, 因为虚拟机无法根据包名找到类</li></ul><h2 id="jar"><code>jar</code></h2><ul><li>使用<code>jar cvf jarFileName file1 file2 ... </code>创建新的<code>jar</code>文件, <code>u</code>选项可以更新<code>jar</code>包</li><li>每个<code>jar</code>都包含一个清单文件<code>manifest</code>用于描述归档文件的特殊性</li></ul><div class="note info flat"><ul><li>清单文件<code>MANIFEST.MF</code>位于<code>jar</code>文件的<code>META-INF</code>子目录中</li><li>清单文件中包含多个条目, 分组成多个节, 第一节称为主节, 作用于整个<code>JAR</code>文件</li><li>节与节之间使用<strong>空行</strong>分割, 除主节外，随后的每一节中的条目可以指定命名实体的属性, 比如单个文件, 包或者<code>url</code>, 都需要以<code>Name</code>条目开始</li><li>如果需要<strong>编辑</strong>清单文件, 可以将需要添加到清单文件的行放到文本文件中, 使用<code>jar cfm jarFileName manifestFileName</code></li><li>如果需要<strong>更新</strong>清单文件, 可以将增加的部分放到文本文件中, 使用<code>jar ufm xxx.jar manifest-additions.mf</code></li><li>清单文件的最后一行需要以换行符作为结束, 否则无法正确读取</li></ul></div><ul><li>可以使用<code>jar cvfe xxx.jar xxxxxClass</code>来指定程序的入口点<ul><li>或者可以在清单文件中添加主类<code>Main-Class: xxxxxClass</code></li><li>这样就可以使用<code>java -jar xxx.jar</code>来启动程序<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hello.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.Println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><div class="note info flat"><ul><li>比如上述<code>Hello.java</code>, 使用<code>javac Hello.java</code>可以编译为<code>Hello.class</code>, 运行<code>java Hello</code>可以直接输出<code>&quot;Hello&quot;</code></li><li>此时如果使用<code>jar cvf Hello.jar Hello.java Hello.class</code>, 将会生成<code>Hello.jar</code></li><li>运行<code>java -jar Hello.jar</code>, 会报错, 提示没有主清单属性<ul><li>第一种解决办法: 重新生成一个<code>jar</code>包, 生成的时候指定入口程序<ul><li><code>jar -cvfe Hello.jar Hello Hello.java Hello.class</code></li><li>第一个<code>Hello.jar</code>是生成的<code>jar</code>包, 第二个<code>Hello</code>是主入口程序为<code>Hello</code>这个类, 第三个和第四个是<code>jar</code>包中需要包含的文件</li></ul></li><li>第二种解决办法: 修改<code>MANIFEST.mf</code><ul><li>创建一个<code>MANIFEST-ADD.mf</code>文件, 添加<code>Main-Class: Hello</code></li><li>这里<strong>一定需要换行</strong>, 保存文件后, 运行<code>jar -ufm Hello.jar MANIFEST-ADD.mf</code>即可</li></ul></li></ul></li></ul></div><h3 id="多版本jar">多版本<code>jar</code></h3><blockquote><p><code>JDK 9</code>引入了多版本<code>jar</code>, 将特定于版本的类文件放在了<code>META-INF/versions</code>中</p></blockquote><ul><li>如果要增加不同版本(比如<code>JDK 9</code>)的类文件, 可以使用<code>jar -uf xxx.jar --release 9 xxx.class</code></li><li>如果要从头构建一个多版本<code>jar</code>, 可以使用<code>-C</code>, 每个对应的版本切换到一个不同的类文件目录<ul><li><code>jar cf xxx.jar -C bin/8 . --release 9 -C bin/9 xxx.class</code></li></ul></li><li>不同版本的编译, 需要使用<code>--release</code>和<code>-d</code>指定输出目录</li><li>多版本<code>jar</code>唯一的作用是让你的程序可以使用不同版本的<code>jdk</code></li></ul><h1>注释</h1><h2 id="类注释">类注释</h2><ul><li>放在 <code>import</code> 之后, <code>class</code> 之前</li><li>使用<code>\**  *\</code></li></ul><h2 id="方法注释">方法注释</h2><ul><li>可以对方法的作用, 方法的参数, 返回值, 异常添加注释, 使用<code>@param, @return, @throws</code></li></ul><h2 id="字段注释">字段注释</h2><ul><li>只需要对公共字段, 静态常量进行注释</li></ul><h2 id="包注释">包注释</h2><ul><li>需要单独写一个文件, 比如<code>package-info.java</code>, 里面是文档注释</li><li>或者可以写一个<code>package.html</code>, 里面抽取标记<code>&lt;body&gt;...&lt;/body&gt;</code>的所有文本</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;面向对象编程(&lt;code&gt;OOP&lt;/code&gt;)&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Java&lt;/code&gt;中对象变量只是包含了一个引用, 没有实际包含一个变量&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;</summary>
      
    
    
    
    <category term="Java" scheme="https://sangs3112.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://sangs3112.github.io/tags/Java/"/>
    
    <category term="Java核心技术(卷一)" scheme="https://sangs3112.github.io/tags/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%8D%B7%E4%B8%80/"/>
    
  </entry>
  
  <entry>
    <title>Java笔记_5</title>
    <link href="https://sangs3112.github.io/posts/14a3e889.html"/>
    <id>https://sangs3112.github.io/posts/14a3e889.html</id>
    <published>2024-11-26T01:53:35.000Z</published>
    <updated>2025-01-16T15:34:13.090Z</updated>
    
    <content type="html"><![CDATA[<h1>概述和环境</h1><h2 id="源码文件">源码文件</h2><ol><li>确保安装了<code>JDK</code>, 并且配置了环境变量</li><li><code>jdk/lib</code>目录中可以找到<code>src.zip</code>, 这个压缩包包含了<strong>所有的公共类库</strong>的源码</li><li>使用<code>jar xvf jdk/lib/src.zip</code>可以将<code>src.zip</code>解压缩到<strong>当前目录</strong>下</li><li>如果是别的源码, 比如编译器, 原生方法, 虚拟机, 私有辅助类, 需要从<code>openjdk</code>那边拿到</li></ol><h2 id="控制台运行Java">控制台运行<code>Java</code></h2><ol><li>一个包含<code>Main</code>函数的<code>Java</code>类, 使用<code>javac xxx.java</code>可以将<code>xxx.java</code>文件编译为<code>.class</code>文件</li><li>然后再使用<code>java xxx</code>, 不需要加<code>.class</code>后缀即可直接运行这个编译后的文件</li></ol><h2 id="JShell"><code>JShell</code></h2><ul><li><code>JDK 9</code>引入了另一种使用<code>Java</code>的方法，就是&quot;读取-评估-打印循环&quot; (<code>Read-Evaluate-Print Loop</code>, <code>REPL</code>)</li><li>输入一个<strong>表达式</strong>, <code>JShell</code>会评估输入, 打印结果, 并等待下一个输入. 直接在控制台输入<code>jshell</code>即可开始使用<ul><li>输入<code>&quot;java&quot;.length()</code>就会返回字符个数<code>$1 ==&gt; 4</code></li><li>然后再输入<code>4 * $1 + 1</code>, 会返回<code>$2 ==&gt; 17</code></li><li>并不需要手动输入<code>System.out.println()</code>也可以直接返回结果, 并自动存储变量</li><li>也可以手动指定变量名, 例如<code>int ans = 42</code>, 会返回结果<code>ans ==&gt; 42</code></li></ul></li></ul><h1><code>Java</code>规范</h1><ol><li>类名需要驼峰: 首字母大写, 后面每个单词的首字母均大写</li><li>文件名必须和文件内的公共类相同</li><li><code>main</code>函数一定需要在<code>public</code>类中, 虚拟机从<code>main</code>函数开始执行. <code>main</code>方法总是静态的</li><li><code>main</code>函数返回值为<code>0</code>, 如果需要以其他的返回值返回, 需要使用<code>System.exit(nums)</code></li><li>变量的声明尽可能靠近使用变量的地方</li><li><code>JDK 10</code>开始, 对于局部变量, 可以使用<code>var</code>关键字声明, 这样可以从变量的初始值推断出他的类型<ul><li><code>var d = 12; // d is an int</code></li><li><code>var s = &quot;12&quot;; // s is a String</code></li></ul></li><li><code>Java</code>中不区分变量的声明和定义</li></ol><h1>类型</h1><ul><li><code>Java</code>具有8种基本类型, 其中4种整型, 2种浮点类型, 1种字符类型<code>char</code>(用于表示<code>Unicode</code>编码), 1种<code>boolean</code>类型</li><li>同时<code>Java</code>具有一个表示任意精度的算数包, 大数<code>big number</code>是一个<code>Java</code>对象, 而不是基本<code>Java</code>类型</li></ul><h2 id="整型">整型</h2><ul><li><code>Java</code>的<code>int</code>无论在什么环境下都是<code>4 Bytes</code>, 可以表示<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">2 \times 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span></li><li>可以给数字加上下划线, 在编译时会自动去除, 方便源码阅读: <code>12_000_000_000</code></li><li><code>Java</code>中没有无符号类型, 如果确实需要无符号数, 比如<code>short</code>表示范围需要在<code>0~255</code>之间的话, 进行计算的时候可以使用<code>Byte.toUnsignedInt(b)</code>来得到一个无符号整数</li></ul><h2 id="浮点型">浮点型</h2><ul><li>一般都使用<code>8 Bytes</code>的<code>double</code>类型, <strong>而不是</strong><code>4 Bytes</code>的<code>float</code>类型</li><li>可以使用十六进制表示浮点数字面量, 例如<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.125</mn><mo>=</mo><msup><mn>2</mn><mrow><mo>−</mo><mn>3</mn></mrow></msup></mrow><annotation encoding="application/x-tex">0.125 = 2^{-3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.125</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span></span>可以写成<code>0x1.0p-3</code><ul><li>这里<code>0x</code>表示十六进制, <code>p</code>表示指数. 不是<code>e</code>是因为<code>e</code>在十六进制中了, <code>-3</code>表示十进制的<code>-3</code>次方, 基数为<code>2</code></li></ul></li><li>浮点数溢出的三种情况：正溢出，负溢出和<code>NaN</code>，如果正数/0就是正溢出，反之负溢出；如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mi mathvariant="normal">/</mi><mn>0</mn></mrow><annotation encoding="application/x-tex">0/0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0/0</span></span></span></span>就是<code>NaN</code></li><li><code>Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NaN</code>表示三个特殊的值, 基本不用</li><li><code>if (x == Double.NaN)</code>永远为假, 因为<code>NaN</code>是永远不会和其他值相同, (<code>Double.NaN</code>也不会和<code>Double.NaN</code>相同)<ul><li>如果需要判断<code>x</code>是否为<code>NaN</code>, 可以使用<code>if (Double.isNaN(x))</code></li></ul></li><li>如果需要精确表示浮点数的话, 需要使用<code>BigDecimal</code>类</li><li>整数除<code>0</code>产生异常, 浮点数除<code>0</code>得到结果<code>NaN</code></li></ul><h2 id="字符类型">字符类型</h2><ul><li><code>char</code>类型可以表示十六进制值, 范围从<code>\u0000~\uFFFF</code></li><li>需要注意注释中尽量不要出现<code>Unicode</code>字符, 例如 <code>// \u000A is a newline.</code>这句话会产生一个语法错误, 因为读程序时会将<code>\u000A</code>转换为一个换行符<ul><li><code>// look inside c:\user</code>这里也是会报错的, 因为<code>\u</code>后面没有跟着<code>4</code>位十六进制数</li></ul></li><li>原本<code>Unicode</code>字符不超过<code>65536</code>个, 所以<code>Java</code>设置了<code>char</code>类型只有<code>16</code>位</li><li>后来字符放不下了, <code>Java</code>设置码点来解决问题, 指一个编码表中某个字符对应的代码值</li><li>码点采用十六进制编写, 加上前缀<code>U+</code>, 比如<code>U+0041</code>就是<code>A</code>的码点</li><li><code>Unicode</code>的码点可以分为<code>17</code>个代码平面, 第一个代码平面被称为<strong>基本多语言平面</strong>, 包括了码点范围是<code>U+0000~U+FFFF</code></li><li>其余<code>16</code>个平面的码点范围是<code>U+10000~U+10FFFF</code></li><li><strong>不要</strong>在<code>Java</code>代码中使用<code>char</code>类型, 一般将字符串作为抽象数据类型处理</li></ul><h2 id="布尔类型">布尔类型</h2><ul><li><code>Java</code>的整型和布尔值<strong>不能</strong>相互转换</li></ul><h2 id="常量">常量</h2><ul><li>使用<code>final</code>关键字定义的, 只能被赋值一次, 不能再更改, 一般用全大写命名</li><li>可能需要创建一个常量在类中的多个方法中使用, 称为<strong>类常量</strong>, 可以使用<code>static final</code>设置一个类常量</li><li><code>const</code>是<code>Java</code>保留的一个关键字, 但是目前并没有使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">100</span>; </span><br><span class="line">    <span class="comment">// b可以被类A中的所有方法访问, 因为使用static final修饰</span></span><br><span class="line">    <span class="comment">// 同时因为 b 是 public 的, 所以也可以被其他类使用A.b访问</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// a只能被main函数访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="枚举类型">枚举类型</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Size</span> &#123;SMALL, MEDIUM, LARGE, EXTRA_LARGE&#125;;</span><br><span class="line"><span class="type">Size</span> <span class="variable">s</span> <span class="operator">=</span> Size.SMALL; <span class="comment">// s只能存储枚举中的值, 或者是null</span></span><br></pre></td></tr></table></figure><h2 id="循环移位">循环移位</h2><ul><li><code>&gt;&gt;</code>表示左移, 使用符号位填充; <code>&gt;&gt;&gt;</code>表示左移, 永远使用<code>0</code>填充</li><li><code>&lt;&lt;</code>表示右移; 不存在<code>&lt;&lt;&lt;</code></li><li>所有移位的右操作数都需要对<strong>32</strong>取模, 如果左操作数是<code>Long</code>类型, 则右操作数需要对<strong>64</strong>取模  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="number">1</span> &lt;&lt; <span class="number">35</span>; <span class="comment">// 与 1 &lt;&lt; 3等价, 结果为8</span></span><br><span class="line">i &lt;&lt; <span class="number">35</span>; <span class="comment">// 与 1 &lt;&lt; 3等价, 结果为8</span></span><br><span class="line">j &lt;&lt; <span class="number">35</span>; <span class="comment">// 与 1 &lt;&lt; 35等价, 结果为34359738368</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="字符串">字符串</h2><ul><li><code>Java</code>中字符串就是<code>Unicode</code>序列, 比如<code>&quot;Java\u2122&quot;</code>由五个<code>Unicode</code>字符组成</li><li><code>Java</code>没有内置的字符串类型, 标准<code>Java</code>类库中提供了一个预定义类</li><li>任何<code>Java</code>对象都可以转换为字符串, 所以<code>&quot;PG&quot; + 12 = &quot;PG12&quot;</code></li><li>如果多个字符串使用界定符分割的话, 可以使用静态<code>join</code>方法  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">all</span> <span class="operator">=</span> String.join(<span class="string">&quot;/&quot;</span>, <span class="string">&quot;S&quot;</span>, <span class="string">&quot;M&quot;</span>, <span class="string">&quot;I&quot;</span>); <span class="comment">// all = &quot;S/M/I&quot;</span></span><br></pre></td></tr></table></figure></li><li><code>JDK 11</code>中提供了<code>repeat</code>方法  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">rep</span> <span class="operator">=</span> <span class="string">&quot;J&quot;</span>.repeat(<span class="number">3</span>); <span class="comment">// rep = &quot;JJJ&quot;</span></span><br></pre></td></tr></table></figure></li><li><code>Java</code>中字符串不可变, 如果需要修改一个字符串的一部分, 需要先使用<code>substring</code>提取字符串不需要修改的部分, 然后加上其他修改后的结果字符串</li></ul><div class="note info flat"><ul><li>字符串不可变每次都需要生成新的字符串, 会降低效率, 但是编译器底层可以实现字符串共享</li><li>开发者认为字符串共享带来的收益比修改字符串带来的收益明显, 因为往往需要比对字符串是否相同, 修改频率较少</li><li>只会共享字符串字面量, 由<code>+</code>或者<code>substring</code>得到的字符串无法共享</li><li>因此比较两个字符串相等的时候务必使用<code>&quot;A&quot;.equals(&quot;A&quot;)</code>, 如果使用<code>==</code>, 则会比较两个字符串引用是否相等</li><li>如果要检查字符串不是空串也不是<code>null</code>的话, 需要先检查<code>null</code>:<ul><li><code>if (s != null &amp;&amp; s.length() != 0)</code>, 否则如果字符串为<code>null</code>的话, 调用这个字符串的<code>length()</code>函数会报错</li></ul></li></ul></div><ul><li><p><code>Java</code>中最常用的<code>Unicode</code>由一个代码单元表示, 但是辅助字符需要两个代码单元, 所以如果使用<code>charAt()</code>, 会返回指定索引的代码单元</p><ul><li>如果正好某个索引需要两个代码单元, 但是使用<code>charAt()</code>指定了前一个索引, 就会出现问题. 因此，<code>charAt()</code>一般不要用</li><li>为了测试, 需要提前设置<code>cmd</code>窗口内编码格式为<code>Unicode</code>, 在<code>cmd</code>内输入<code>chcp 65001</code>将当前窗口的编码格式切换为<code>Unicode</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;123\uD835\uDD46&quot;</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;当前字符串是: &quot;</span> + s);</span><br><span class="line">    System.out.println(<span class="string">&quot;s.length() = &quot;</span> + s.length());</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;使用s.charAt()打印每一个元素: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i ++) &#123;</span><br><span class="line">        System.out.print(s.charAt(i) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line"></span><br><span class="line">    System.out.print(<span class="string">&quot;s的实际长度(码点个数)为: &quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">trueLen</span> <span class="operator">=</span> s.codePointCount(<span class="number">0</span>, s.length());</span><br><span class="line">    System.out.println(trueLen);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;使用s.codePointAt()打印每一个元素: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; trueLen; i ++) &#123;</span><br><span class="line">        System.out.print(s.codePointAt(s.offsetByCodePoints(<span class="number">0</span>, i)) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上面代码的输出结果为:<br><img src="https://gitee.com/sang3112/blog_imgs/raw/4c5ed5605556dc05064ff326aca418d72b731cfe/Java/codepoint.png" alt="codepoint"></li></ul></li></ul></li><li><p>如果需要拼接多个较短的字符串, 可以使用<code>StringBuilder</code></p><ul><li><code>StringBuffer</code>效率不如<code>StringBuilder</code>, 不过<code>StringBuffer</code>可以支持多线程添加删除字符</li><li>如果所有操作都在单线程, 则使用<code>StringBuilder</code></li></ul></li><li><p><code>JDK 15</code>中存在文本块, 以三个引号开头结尾, 可以更加方便的写换行, 例如</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Hello</span></span><br><span class="line"><span class="string">World</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;Hello\nWorld\n&quot;</span>;</span><br><span class="line"><span class="comment">// a == b</span></span><br><span class="line"><span class="comment">// 文本块最适合放SQL语句或者HTML语句, 但是如果所有的反斜线都需要转义</span></span><br><span class="line"><span class="comment">// 如果不转义就会变成不换行</span></span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Hello\</span></span><br><span class="line"><span class="string">World</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> <span class="string">&quot;HelloWorld\n&quot;</span>;</span><br><span class="line"><span class="comment">// c == d</span></span><br></pre></td></tr></table></figure></li></ul><h1>输入输出</h1><ul><li>如果是密码相关的内容, 建议不要使用<code>println()</code>, 可以使用<code>Console.readPassword()</code></li><li><code>printf(&quot;%+f&quot;, d)</code> 可以打印<code>d</code>的正负号</li><li><code>printf(%,f, d)</code> 可以对<code>d</code>增加三个数一组的分割符</li><li><code>printf(&quot;%1$d,%1$x&quot;, d)</code> 分别以十进制和十六进制打印第一个参数<code>d</code></li><li><code>printf(&quot;%d%&lt;x&quot;, d)</code> 分别以十进制和十六进制打印<strong>同一个数</strong></li><li>使用<code>String.format</code>方法可以格式化字符串, 不打印输出  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> String.format(<span class="string">&quot;Hello, %s. Next year, you&#x27;ll be %d&quot;</span>, name, age + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// JDK 15版本以后可以使用下面这种更加简单的方法</span></span><br><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello, %s. Next year, you&#x27;ll be %d&quot;</span>.formatted(name, age + <span class="number">1</span>);</span><br></pre></td></tr></table></figure></li><li>写入文件使用  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="string">&quot;tmp.txt&quot;</span>, StandardCharsets.UTF_8);</span><br><span class="line">out.write(<span class="string">&quot;werwr&quot;</span>);</span><br><span class="line">out.flush();</span><br><span class="line"><span class="comment">// 如果tmp.txt不存在, 则会自动创建一个</span></span><br><span class="line"><span class="comment">// 写入以后需要使用flush才能保存</span></span><br></pre></td></tr></table></figure></li></ul><h1>控制流程</h1><ul><li><code>Java</code>中两个嵌套的块不能重复定义相同的变量</li><li>在 <code>for</code>循环中不能检测了两个浮点数是否相等, 因为误差的存在, 可能会导致死循环</li></ul><h2 id="switch-case"><code>switch-case</code></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种</span></span><br><span class="line"><span class="keyword">switch</span> (s) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;yes&quot;</span>, <span class="string">&quot;y&quot;</span> -&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;no&quot;</span>, <span class="string">&quot;n&quot;</span> -&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span> -&gt; &#123;</span><br><span class="line">        ... </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种</span></span><br><span class="line"><span class="keyword">switch</span> (s) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;y&quot;</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;n&quot;</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第二种方法如果不使用break会导致执行多个分支</span></span><br><span class="line"><span class="comment">// 使用javac -Xlint:fallthrough xxx.java编译可以得到这个方面的警告</span></span><br><span class="line"><span class="comment">// 但是如果本身就想执行多个分支, 可以在整个函数外加上</span></span><br><span class="line"><span class="comment">// @SuppressWarnings(&quot;fallthrough&quot;), 这样就不会产生警告了</span></span><br></pre></td></tr></table></figure><ul><li>不能混用<code>:</code>和<code>-&gt;</code>, 同时<code>-&gt;</code>也<strong>不</strong>存在直通的行为</li><li><code>yield</code>也会终止<code>switch</code>语句, 但是还会生成一个值<ul><li><code>switch</code>表达式的关键是生成一个值, 或者抛出异常, <strong>不允许</strong>使用<code>return</code>跳出</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">switch</span>(s) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;y&quot;</span> -&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;n&quot;</span> -&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span> -&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">nums</span> <span class="operator">=</span> <span class="keyword">switch</span>(s) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Spring&quot;</span>, <span class="string">&quot;Summer&quot;</span>, <span class="string">&quot;Winter&quot;</span> -&gt; <span class="number">6</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Fall&quot;</span> -&gt; <span class="number">4</span></span><br><span class="line">    <span class="keyword">default</span> -&gt; -<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面表达式优于下面的表达式</span></span><br><span class="line"><span class="keyword">switch</span>(s) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Spring&quot;</span>, <span class="string">&quot;Summer&quot;</span>, <span class="string">&quot;Winter&quot;</span> -&gt; &#123;</span><br><span class="line">        nums = <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Fall&quot;</span> -&gt; &#123;</span><br><span class="line">        nums = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span> -&gt; &#123;</span><br><span class="line">        nums = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 除非是需要直通式, 才会使用`break`和`yield`</span></span><br></pre></td></tr></table></figure><h1>大数</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用valueOf()静态方法可以将一个普通的数转换为大数</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">a</span> <span class="operator">=</span> BigInteger.valueOf(<span class="number">123</span>);</span><br><span class="line"><span class="comment">// 对于一个很长的数, 使用带有字符串参数的构造器生成</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;1231231231231231231231231&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>对于 <code>BigDecimal</code>类, 总应该使用带有字符串参数的构造器生成. 尽管有<code>BigDecimal(double)</code>, 但是传入的时候会产生浮点数精度误差</li><li><code>Java</code>不能通过编程实现运算符的重载, 所以只能使用<code>add(), multiply()</code>等方法实现加减乘除</li><li><code>Java</code>设计者只重载了<code>+</code>来实现字符串拼接</li></ul><h1>数组</h1><ul><li><code>Java</code>中<strong>允许</strong>长度为<code>0</code>的数组存在</li><li>数组创建时, 数字数组初始化为<code>0</code>, 对象数组初始化为<code>null</code>, <code>boolean</code>数组初始化为<code>false</code></li><li>如果想要打印数组a, 可以直接写<code>Arrays.toString(a)</code>, 这个返回值包含了数组中所有元素的字符串</li><li>如果想要快速打印一个二维数组, 可以使用<code>Arrays.deepToString(a)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">System.out.println(Arrays.toString(a));</span><br></pre></td></tr></table></figure><h2 id="数组拷贝">数组拷贝</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] b = a;</span><br><span class="line"><span class="comment">// b和a引用同一个数组</span></span><br><span class="line"><span class="comment">// 如果需要拷贝一个副本到新的数组, 可以使用copyOf</span></span><br><span class="line"><span class="type">int</span>[] c = Arrays.copyOf(a, a.length);</span><br><span class="line"><span class="comment">// 第二个参数是新数组的长度, 一般用于扩充新数组</span></span><br><span class="line"><span class="comment">// 如果需要扩充, 则数组数组自动填充0, boolean数组自动填充false</span></span><br><span class="line"><span class="comment">// 如果新数组长度更小, 则只拷贝前面的部分</span></span><br></pre></td></tr></table></figure><ul><li><code>main</code>函数的参数, 是<code>String[] args</code>, 接受一个字符串数组, 也就是命令行指定的参数</li><li><code>java Message -h hello</code> 这里面<code>args[0]=-h</code> <code>args[1] = hello</code></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;概述和环境&lt;/h1&gt;
&lt;h2 id=&quot;源码文件&quot;&gt;源码文件&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;确保安装了&lt;code&gt;JDK&lt;/code&gt;, 并且配置了环境变量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;jdk/lib&lt;/code&gt;目录中可以找到&lt;code&gt;src.zip&lt;/code&gt;, 这</summary>
      
    
    
    
    <category term="Java" scheme="https://sangs3112.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://sangs3112.github.io/tags/Java/"/>
    
    <category term="Java核心技术(卷一)" scheme="https://sangs3112.github.io/tags/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%8D%B7%E4%B8%80/"/>
    
  </entry>
  
  <entry>
    <title>设计模式笔记_1</title>
    <link href="https://sangs3112.github.io/posts/b406aa8c.html"/>
    <id>https://sangs3112.github.io/posts/b406aa8c.html</id>
    <published>2024-05-04T06:37:35.000Z</published>
    <updated>2025-01-16T15:34:13.089Z</updated>
    
    <content type="html"><![CDATA[<h1>简单工厂模式</h1><blockquote><p>需要实例化谁,以后可能会添加实例化的对象,就要用一个单独的类来做这个创造实例的过程,就是<strong>工厂</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Operation.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Operation</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">getResult</span><span class="params">(<span class="type">double</span> numberA, <span class="type">double</span> numberB, String operation)</span>&#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span> (operation) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                ans = numberA + numberB;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                ans = numberA - numberB;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                ans = numberA * numberB;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                ans = numberA / numberB;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;not support operation&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info flat"><p>问题:</p><ol><li>如果需要增加函数,就需要添加新的<code>case</code>,有可能会改变原有的函数;</li><li>如果代码只需要调用除法,却需要编译其他的加,减,乘函数<br>解决办法:<br>实现一个运算抽象类,都有一个方法<code>getResult()</code>,用来得到结果.然后加减乘除都写成运算类的子类</li></ol></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Operation.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Operation</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getResult</span><span class="params">(<span class="type">double</span> numberA, <span class="type">double</span> numberB)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0d</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Add</span> <span class="keyword">extends</span> <span class="title class_">Operation</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getResult</span><span class="params">(<span class="type">double</span> numberA, <span class="type">double</span> numberB)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numberA + numberB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sub.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Operation</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getResult</span><span class="params">(<span class="type">double</span> numberA, <span class="type">double</span> numberB)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numberA - numberB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mul.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mul</span> <span class="keyword">extends</span> <span class="title class_">Operation</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getResult</span><span class="params">(<span class="type">double</span> numberA, <span class="type">double</span> numberB)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numberA * numberB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Div.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Div</span> <span class="keyword">extends</span> <span class="title class_">Operation</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getResult</span><span class="params">(<span class="type">double</span> numberA, <span class="type">double</span> numberB)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numberB == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;除数不能为0&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArithmeticException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numberA / numberB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OperationFactory.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperationFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Operation <span class="title function_">createOperation</span><span class="params">(String opertaion)</span>&#123;</span><br><span class="line">        <span class="type">Operation</span> <span class="variable">oper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (opertaion) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                oper = <span class="keyword">new</span> <span class="title class_">Add</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                oper = <span class="keyword">new</span> <span class="title class_">Sub</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                oper = <span class="keyword">new</span> <span class="title class_">Mul</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                oper = <span class="keyword">new</span> <span class="title class_">Div</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;we didnt implement this operation&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> oper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="type">Operation</span> <span class="variable">oper</span> <span class="operator">=</span> OperationFactory.createOperation(flag);</span><br><span class="line"><span class="type">double</span> <span class="variable">ans</span> <span class="operator">=</span> oper.getResult(a, b);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/sang3112/blog_imgs/raw/master/DesignPattern/SFP.png" alt="SFP"></p><div class="note info flat"><p>三个角色:</p><ol><li>抽象类: 定义所有支持算法的公共接口,比如运算抽象类</li><li>具体算法类: 具体的算法,比如加减乘除运算类</li><li>简单工厂类: 用来维护对运算类的应用</li></ol><ul><li>可以将类类比为产品,使用者在不清楚类生产的具体过程的情况下,可以使用不同的产品.</li></ul></div><h1>策略模式</h1><blockquote><p>定义算法家族,分别封装,让他们之间可以相互替换.这样可以保证算法的变化不会影响到客户<br>一系列算法都完成相同的工作,只是实现不同,可以以相同的方式调用所有的算法,减少耦合.<br>只需要在不同的时间应用不同的业务规则,就可以考虑使用策略模式进行处理</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CashSuper.java</span></span><br><span class="line"><span class="comment">// 收费抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CashSuper</span> &#123;</span><br><span class="line">    <span class="comment">// 收费的抽象方法,参数为单价和数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">acceptCash</span><span class="params">(<span class="type">double</span> price, <span class="type">int</span> num)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CashNormal.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CashNormal</span> <span class="keyword">extends</span> <span class="title class_">CashSuper</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">acceptCash</span><span class="params">(<span class="type">double</span> price, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> price * num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CashRebate.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CashRebate</span> <span class="keyword">extends</span> <span class="title class_">CashSuper</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> <span class="variable">moneyRebate</span> <span class="operator">=</span> <span class="number">1d</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CashRebate</span><span class="params">(<span class="type">double</span> moneyRebate)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.moneyRebate = moneyRebate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">acceptCash</span><span class="params">(<span class="type">double</span> price, <span class="type">int</span> num)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price * num * moneyRebate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CashReturn.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CashReturn</span> <span class="keyword">extends</span> <span class="title class_">CashSuper</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> <span class="variable">moneyCondition</span> <span class="operator">=</span> <span class="number">0d</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> <span class="variable">moneyReturn</span> <span class="operator">=</span> <span class="number">0d</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CashReturn</span><span class="params">(<span class="type">double</span> moneyCondition, <span class="type">double</span> moneyReturn)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.moneyCondition = moneyCondition;</span><br><span class="line">        <span class="built_in">this</span>.moneyReturn = moneyReturn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">acceptCash</span><span class="params">(<span class="type">double</span> price, <span class="type">int</span> num)</span>&#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">ans</span> <span class="operator">=</span> price * num;</span><br><span class="line">        <span class="keyword">if</span> (moneyCondition &gt; <span class="number">0</span> &amp;&amp; ans &gt;= moneyCondition)&#123;</span><br><span class="line">            ans -= Math.floor(ans / moneyCondition) * moneyReturn;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CashContext.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CashContext</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> CashSuper cs;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CashContext</span><span class="params">(CashSuper cs)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.cs = cs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getResult</span><span class="params">(<span class="type">double</span> price, <span class="type">int</span> num)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cs.acceptCash(price, num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;输入策略: 1 - 正常收费; 2 - 打八折; 3 - 打七折; 4 - 满300减100&quot;</span>);</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">discount</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;输入产品的单价:&quot;</span>);</span><br><span class="line">        <span class="type">double</span> <span class="variable">price</span> <span class="operator">=</span> in.nextDouble();</span><br><span class="line">        System.out.println(<span class="string">&quot;输入产品的数量:&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">        in.close();</span><br><span class="line">        <span class="type">CashContext</span> <span class="variable">cs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (discount) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                cs = <span class="keyword">new</span> <span class="title class_">CashContext</span>(<span class="keyword">new</span> <span class="title class_">CashNormal</span>());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                cs = <span class="keyword">new</span> <span class="title class_">CashContext</span>(<span class="keyword">new</span> <span class="title class_">CashRebate</span>(<span class="number">0.8d</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                cs = <span class="keyword">new</span> <span class="title class_">CashContext</span>(<span class="keyword">new</span> <span class="title class_">CashRebate</span>(<span class="number">0.7d</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                cs = <span class="keyword">new</span> <span class="title class_">CashContext</span>(<span class="keyword">new</span> <span class="title class_">CashReturn</span>(<span class="number">300d</span>, <span class="number">100d</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;we dont support this strategy&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> <span class="variable">totalPrice</span> <span class="operator">=</span> cs.getResult(price, num);</span><br><span class="line">        System.out.println(totalPrice);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>策略模式,使用<code>CashContext</code>计算不同策略下的收费及结果,但是会发现在<code>Main</code>中进行了判断需要使用哪一个策略</li><li>可以使用工厂模式+策略模式的方法进行调整</li></ul><h2 id="策略-工厂模式">策略 + 工厂模式</h2><blockquote><p>只需要将<code>Main</code>中的<code>switch</code>部分移动到<code>CashContext</code>中即可</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CashContext.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CashContext</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> CashSuper cs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CashContext</span><span class="params">(<span class="type">int</span> discount)</span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (discount) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                cs = <span class="keyword">new</span> <span class="title class_">CashNormal</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                cs = <span class="keyword">new</span> <span class="title class_">CashRebate</span>(<span class="number">0.8d</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                cs = <span class="keyword">new</span> <span class="title class_">CashRebate</span>(<span class="number">0.7d</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                cs = <span class="keyword">new</span> <span class="title class_">CashReturn</span>(<span class="number">300d</span>, <span class="number">100d</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;we dont support this strategy&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getResult</span><span class="params">(<span class="type">double</span> price, <span class="type">int</span> num)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cs.acceptCash(price, num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在导航中,不同的路径规划算法,比如步行,骑行,搭乘公共交通的,开车的.主要导航类的主要工作是渲染路径,不会在意算法生成的路径,因此可以将路径规划算法使用策略模式进行封装,方便交互</p></blockquote><p><img src="https://gitee.com/sang3112/blog_imgs/raw/master/DesignPattern/SP.png" alt="SP"></p><ul><li>策略模式不适合算法极少变化的场景,这样会使得程序整体变得复杂</li><li>同时要求客户知晓策略的不同</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;简单工厂模式&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;需要实例化谁,以后可能会添加实例化的对象,就要用一个单独的类来做这个创造实例的过程,就是&lt;strong&gt;工厂&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight j</summary>
      
    
    
    
    <category term="DesignPattern" scheme="https://sangs3112.github.io/categories/DesignPattern/"/>
    
    
    <category term="DesignPattern" scheme="https://sangs3112.github.io/tags/DesignPattern/"/>
    
    <category term="简单工厂模式" scheme="https://sangs3112.github.io/tags/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="策略模式" scheme="https://sangs3112.github.io/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式笔记_0</title>
    <link href="https://sangs3112.github.io/posts/c3019a1a.html"/>
    <id>https://sangs3112.github.io/posts/c3019a1a.html</id>
    <published>2024-05-03T06:37:35.000Z</published>
    <updated>2025-01-16T15:34:13.089Z</updated>
    
    <content type="html"><![CDATA[<h1>单一职责原则 <code>SRP</code></h1><blockquote><p>一个类应该只有一个更改它的原因,也就是这个类只有一个职责</p></blockquote><ul><li>每个类的职责都有清晰明确的定义</li><li>一个类的修改只对自身有影响,对其他类没有影响</li></ul><h1>开闭原则 <code>OCP</code></h1><blockquote><p>软件实体(类 模块 函数)应该可以扩展,但是不能修改.对于扩展是开放的,对于修改是封闭的.<br>对于要怎讲爱新功能或者需要调整的改动,应该扩展新的代码而不是修改原有的代码.</p></blockquote><ul><li>对程序中频繁变化的部分抽象</li><li>不要刻意的对每一个部分都进行抽象,拒绝不成熟的抽象,这和抽象本身一样重要.</li></ul><h1>依赖倒置原则 <code>DIP</code></h1><blockquote><p>程序不应该依赖细节,细节应该依赖于抽象. 针对接口编程 而不是针对实现编程</p></blockquote><ul><li>使用接口或者抽象类的目的是制定好规范,不涉及任何具体的操作,把细节任务交给实现类去完成</li><li>让程序中所有的依赖关系都终止于抽象类或者接口</li><li>高层模块不应该依赖底层模块,二者都应该依赖抽象</li><li>抽象不应该依赖细节,细节应该依赖抽象</li></ul><h1>里氏替换原则 <code>LSP</code></h1><blockquote><p>一个软件实体如果适用于父类,必定适用于子类,并且察觉不出子类和父类的区别,也就是子类必须能够替换父类</p></blockquote><ul><li>父类一般使用抽象类或者接口</li><li>抽象类定义公共对象和状态;接口定义公共行为</li><li>子类通过继承父类和接口进行扩展</li><li>子类的方法参数类型 返回值类型 异常 都应该跟父类相匹配;子类不应该强加参数条件限制;子类不能修改父类的私有成员</li></ul><h1>迪米特原则 <code>LoD</code></h1><blockquote><p>最小知识原则.如果两个类不必彼此互相通信,那么这两个类就不应该发生直接的相互作用;如果其中一个类需要调用另一个类的某一个方法,则可以通过第三者转发这个调用</p></blockquote><ul><li>类设计上,每一个类都应该尽量降低成员的访问权限,不要让别的类知道字段或行为就不要公开</li><li>类之间不建立联系,而是通过中间类来中转</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;单一职责原则 &lt;code&gt;SRP&lt;/code&gt;&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;一个类应该只有一个更改它的原因,也就是这个类只有一个职责&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;每个类的职责都有清晰明确的定义&lt;/li&gt;
&lt;li&gt;一个类的修改只对自身</summary>
      
    
    
    
    <category term="DesignPattern" scheme="https://sangs3112.github.io/categories/DesignPattern/"/>
    
    
    <category term="DesignPattern" scheme="https://sangs3112.github.io/tags/DesignPattern/"/>
    
    <category term="设计原则" scheme="https://sangs3112.github.io/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>Java笔记_4</title>
    <link href="https://sangs3112.github.io/posts/63a4d81f.html"/>
    <id>https://sangs3112.github.io/posts/63a4d81f.html</id>
    <published>2024-04-22T06:37:35.000Z</published>
    <updated>2025-01-16T15:34:13.090Z</updated>
    
    <content type="html"><![CDATA[<h1>垃圾回收算法(四种)</h1><div class="note info flat"><ul><li>垃圾回收需要找到内存中存活的对象</li><li>还需要释放不再存活的对象, 使程序可以再次利用这部分空间</li></ul></div><ol><li>标记-清除算法</li><li>复制算法</li><li>标记-整理算法</li><li>分代GC</li></ol><div class="note info flat"><ul><li>垃圾回收会有单独的<code>GC</code>线程来完成, 但是不管哪一种<code>GC</code>算法, 都会有部分阶段需要停止所有用户线程, 称之为<code>Stop The World</code>, 简称<code>STW</code>, 如果<code>STW</code>的时间过长, 则会影响用户使用</li><li>为什么一定需要<code>STW</code>?<ul><li>分析工作必须在能够确保一致性的快照中进行</li><li>一致性指整个分析期间系统被冻结在某个时间点上</li><li>如果分析过程中对象的引用关系还在不断地变化, 那么分析的准确性就没有办法保证</li><li>如果不暂停业务线程的话, 在垃圾回收期间新创建的对象会被错误的回收, 这是因为业务线程和垃圾回收线程都是并行执行的</li></ul></li><li>评价标准:<ol><li><strong>吞吐量</strong>: <code>CPU</code>用于执行用户代码的时间与<code>CPU</code>总执行时间的比值, 吞吐量=执行用户代码的时间/(执行用户代码的时间+<code>GC</code>时间), 吞吐量越高表示垃圾回收效率越高</li><li><strong>最大暂停时间</strong>: 垃圾回收过程中<code>STW</code>时间的最大值, 越小越好</li><li><strong>堆使用效率</strong>: 不同垃圾回收算法, 堆内存使用效率不同. 比如标记清除算法, 可以完整的使用堆内存, 复制算法会将堆内存一分为二, 每次只能使用一半内存. 从堆使用效率上来说, 标记清除算法要优于复制算法</li></ol></li><li>三者不可兼得, 堆内存越大, 最大暂停时间就越大, 减少最大暂停时间, 就会降低吞吐量</li></ul></div><h2 id="标记-清除算法">标记-清除算法</h2><blockquote><p>两个阶段</p><ol><li>标记阶段: 将所有存活对象标记, 使用可达性算法, 从<code>GC Root</code>开始通过引用链遍历出所有的存活对象</li><li>清除阶段: 从内存中<strong>删除</strong>没有被标记, 也就是非存活对象</li></ol></blockquote><div class="note info flat"><ul><li>优点: 实现简单, 只需要在第一阶段维护每个对象的标志位, 第二阶段删除即可</li><li>缺点:<ol><li><strong>碎片化问题</strong>: 内存是连续的, 所以对象被删除之后, 内存中可能会出现很多细小的可用内存单元. 如果我们需要一个比较大的空间, 这些内存单元会无法进行分配</li><li><strong>分配速度比较慢</strong>：因为内存碎片存在, 需要维护一个空闲链表, 有可能发生每次遍历链表的最后才能获得合适的内存空间</li></ol></li></ul></div><h2 id="复制算法">复制算法</h2><blockquote><p>核心思想</p><ol><li>准备两块空间<code>From</code>和<code>To</code>空间, 每次在对象分配阶段, 只能使用其中一块空间(<code>From</code>空间)</li><li><code>GC</code>阶段将<code>From</code>中存活的对象复制到<code>To</code>空间中</li><li>将两块空间的名字互换, 也就是<code>From</code>和<code>To</code>互换名字, 因为只有<code>From</code>空间存储对象</li></ol></blockquote><div class="note info flat"><ul><li>完整复制算法<ol><li>将堆内存分隔成两块<code>From</code>空间和<code>To</code>空间, 对象分配阶段, 创建对象</li><li><code>GC</code>阶段开始, 将<code>GC Root</code>搬运到<code>To</code>空间</li><li>将<code>GC Root</code>关联的对象, 搬运到<code>To</code>空间, <code>From</code>空间剩下的是没有被<code>GC Root</code>关联的对象了</li><li>清理<code>From</code>空间, 并把名称互换</li></ol></li><li>优点:<ol><li>吞吐量高, 只需要遍历一次存活对象并复制到<code>To</code>空间即可, 比标记-整理算法少了一次遍历过程. 但是性能比标记-清除算法低, 因为标记-清除算法不需要进行对象的移动</li><li>不会出现碎片化的问题, 复制算法复制后会有序地排列对象, 所以不会出现内存碎片</li></ol></li><li>缺点: 每次只能用一半的堆内存, 另一半的空间来创建对象使用</li></ul></div><h2 id="标记-整理算法-标记-压缩算法">标记-整理算法(标记-压缩算法)</h2><blockquote><p>对标记-清理算法中容易产生内存碎片的问题的一种解决方案<br>两个阶段</p><ol><li>标记阶段: 将所有的存活对象标记, 使用可达性分析算法, 从<code>GC Root</code>开始通过引用链遍历出所有存活对象</li><li>整理阶段: 将存活对象<strong>移动</strong>到堆的一端, 清理掉非存活对象的内存空间</li></ol></blockquote><div class="note info flat"><ul><li>优点:<ol><li>内存使用率高, 整个堆内存都可以使用, 复制算法只能用半个堆内存</li><li>不会出现碎片化的问题, 整理阶段可以将对象往内存的一侧进行移动, 剩下的空间都是可以分配对象的有效空间</li></ol></li><li>缺点: 整理阶段的效率不高, 整理算法有很多, 比如<code>Lisp2</code>整理算法需要对整个堆中的对象搜索三次, 整体性能不佳. 可以通过<code>Two-Finger</code>, 表格算法, <code>ImmixGC</code>等高效的整理算法优化这个阶段的性能</li></ul></div><h2 id="分代GC-Generational-GC">分代<code>GC</code>(<code>Generational GC</code>)</h2><blockquote><p>分代垃圾回收将整个内存区域划分为年轻代(<code>Young</code>区, 新生代)和老年代(<code>Old</code>区)</p><p>年轻代存放存活时间比较短的对象, 老年代存放存活时间比较长的对象</p><p>年轻代中有<code>Eden</code>区, <code>Survivor</code>区(<code>S0, S1</code>)</p><p><code>JDK 8</code>中, 添加<code>-XX:+UserSerialGC</code>参数使用分代回收的垃圾回收器, 运行程序, 使用<code>Arthas</code>中的<code>memory</code>命令可以查看三个区域的内存情况, 分别是<code>eden_space, survivio_space, tenured_gen</code>, 就是伊甸园区, 幸存者区, 老年代</p></blockquote><div class="note info flat"><ul><li><code>-Xmn</code>: 设置新生代的大小, 也就是伊甸园区和幸存者区的大小</li><li><code>-XX:SurvivorRatio</code>: 伊甸园区和幸存区的比例, 默认为8. 如果新生代<code>1G</code>内存, 伊甸园区就是<code>800MB</code>, <code>S0</code>和<code>S1</code>各<code>100MB</code></li><li><code>-XX:+PrintGCDetails</code> or <code>verbose:gc</code>打印<code>GC</code>日志, 前者打印信息详细一些，后者简单一些。</li><li>老年代大小就是堆大小与新生代大小的差</li></ul></div><ul><li>使用分代回收时, 创建出来的对象首先放入<code>Eden</code>伊甸园区, 如果对象在<code>Eden</code>区越来越多, 直到<code>Eden</code>区满, 新创建的对象无法放入, 就会触发年轻代<code>GC</code>, 称为<code>Minor GC</code>或者<code>Young GC</code>. <code>Minor GC</code>会把需要<code>Eden</code>中和<code>From</code>需要回收的对象回收, 把没有回收的对象放在<code>To</code>区域中<ul><li>所以<code>Minor GC</code>就是一个复制算法, 初始<code>S0</code>是<code>From</code>, <code>S1</code>是<code>To</code>, 接下来<code>S0</code>变成了<code>To</code>, <code>S1</code>变成了<code>From</code></li><li>当<code>Eden</code>再次满时, 此时会回收<code>Eden</code>区和<code>S1 From</code>中的对象, 并把<code>Eden, From</code>中的剩余的对象放在<code>S0</code>中</li></ul></li><li>每次<code>Minor GC</code>后都会为对象记录他的年龄, 初始值为0, 每次<code>GC</code>完都要加1</li><li>年龄到达15以后(15是最大值), 默认值和垃圾回收器有关, 对象就会<strong>晋升</strong>到老年代</li><li>老年代空间不足, 无法放入新的对象时, 先会尝试<code>Minor GC</code>(为了尽量避免对象放入老年代, 比如新生代中年龄都是2或者3, 只是被占用满了, 需要将对象放在老年代中, 如果新生代空间没有满, 也可以不用放入老年代, 所以先进行<code>Minor GC</code>, 尽量避免对象放入老年代). 如果还是不足, 就会触发<code>Full GC</code>, 对整个堆进行垃圾回收<ul><li>如果<code>Full GC</code>没有释放足够的老年代的空间, 就会产生<code>OutOfMemory</code>错误</li></ul></li></ul><div class="note info flat"><ul><li>为什么分代<code>GC</code>要把堆分成年轻代和老年代?</li></ul><blockquote><p>系统中的大部分对象, 都是创建出来以后不再使用可以被回收, 比如用户获取订单数据, 订单数据返回给用户之后就可以释放了</p><p>老年代中会存放长期存活的对象, 比如<code>Spring</code>中的大部分<code>bean</code>对象, 在程序启动之后就不会被回收了</p><p>在虚拟机的默认设置中, 新生代的大小要远小于老年代的大小</p></blockquote><ol><li>可以通过调整新生代和老年代的比例来适应不同类型的应用程序, 提高内存的利用率和性能.<ul><li>比如一个用户很多的网站, 有很多人需要访问订单数据, 那如果新生代较小, 则会有很多年龄较小的对象进入老年代, 导致<code>GC</code>时间延长, 此时可以将新生代的内存区调大一些, 直接可以通过<code>Minor GC</code>回收</li></ul></li><li>新生代和老年代可以使用不同的垃圾回收算法, 新生代一般使用复制算法, 减少内存碎片; 老年代可以使用标记-清除或者标记-整理算法, 由程序员自己调整(因为老年代空间比较大, 使用了复制算法就只能使用一半空间了, 就不合理了), 标记-清除算法效率较高, 但是会有内存碎片, 而标记-整理算法没有内存碎片, 但是<code>STW</code>较长</li><li>分代设计中允许只回收新生代<code>Minor GC</code>, 如果能满足对象分配的要求就不需要堆整个堆进行回收了, <code>STW</code>时间减少(最核心), 尽可能做<code>Minor GC</code>, 减少<code>Full GC</code></li></ol></div><h1>垃圾回收器</h1><ul><li>垃圾回收器是垃圾回收算法的具体实现, 由于垃圾回收器分为年轻代和老年代, 所以除了<code>G1</code>之外的其他垃圾回收器必须成对使用<br><img src="https://gitee.com/sang3112/blog_imgs/raw/6d55251373589f7b63584fece6808ec3cbcdad27/Java/GC.png" alt="GC"></li></ul><blockquote><p>年轻代的<code>Serial</code>以及老年代的<code>Serial Old</code></p><p>年轻代的<code>ParNew</code>以及老年代的<code>CMS</code></p><p>年轻代的<code>Parallel Scavenge</code>以及老年代的<code>Parallel Old</code></p><p><code>G1</code>可以同时控制年轻代和老年代(<code>JDK 9</code>之后主流推荐)</p><p><code>JDK 9</code>废弃了年轻代的<code>Serial</code>以及老年代的<code>CMS</code>; 年轻代的<code>ParNew</code>以及老年代的<code>Serial Old</code></p><p><code>JDK 14</code>中废弃了<code>Parallel Scavenge</code>以及老年代的<code>Serial Old</code></p></blockquote><h2 id="Serial垃圾回收器-年轻代"><code>Serial</code>垃圾回收器-年轻代</h2><blockquote><p><strong>单线程串行</strong>回收年轻代的垃圾回收器</p></blockquote><p><img src="https://gitee.com/sang3112/blog_imgs/raw/6d55251373589f7b63584fece6808ec3cbcdad27/Java/Serial.png" alt="Serial"></p><ul><li>回收年轻代, 使用复制算法</li><li>优点: 单<code>CPU</code>下吞吐量出色</li><li>缺点: 多<code>CPU</code>下吞吐量不如其他垃圾回收器, 堆偏大会让用户线程处于长时间等待(因为回收的时候只有单线程进行<code>GC</code>)</li><li>适合<code>Java</code>编写的客户端程序, 或者硬件配置有限的场景</li></ul><h2 id="Serial-Old垃圾回收器-老年代"><code>Serial Old</code>垃圾回收器-老年代</h2><blockquote><p><strong>单线程串行回收</strong>, 是<code>Serial</code>的老年代版本</p></blockquote><ul><li><code>-XX:+UseSerialGC</code>新生代、老年代都使用串行回收器</li><li>回收老年代, 使用标记-整理算法</li><li>优缺点跟<code>Serial</code>算法相同</li><li>一般配合<code>Serial</code>使用, 或者在特殊情况下同<code>CMS</code>使用, 实际使用不多, 一般在<code>CPU</code>资源比较匮乏的时候使用</li></ul><h2 id="ParNew垃圾回收器-年轻代"><code>ParNew</code>垃圾回收器-年轻代</h2><blockquote><p>本质上就是对<code>Serial</code>在多<code>CPU</code>下的优化, 使用多线程进行垃圾回收</p></blockquote><p><img src="https://gitee.com/sang3112/blog_imgs/raw/6d55251373589f7b63584fece6808ec3cbcdad27/Java/ParNew.png" alt="ParNew"></p><blockquote><p><code>-XX:+UseParNewGC</code>新生代使用<code>ParNew</code>回收器，老年代使用串行回收器</p></blockquote><ul><li>回收年轻代, 使用复制算法</li><li>优点: 多<code>CPU</code>下停顿时间较短</li><li>缺点: 吞吐量和停顿时间不如<code>G1</code>, 所以在<code>JDK 9</code>之后不建议使用</li><li>适合<code>JDK 8</code>以及之前的版本中, 与<code>CMS</code>老年代垃圾回收器配合使用</li></ul><h2 id="CMS-Concurrent-Mark-Sweep-垃圾回收器-老年代"><code>CMS(Concurrent Mark Sweep)</code>垃圾回收器-老年代</h2><blockquote><p>关注的是系统的<strong>暂停时间</strong>, 允许用户线程和垃圾回收线程在某些步骤中同时执行, 减少用户线程的等待</p><p><code>-XX:+UseConcMarkSweepGC</code></p></blockquote><p><img src="https://gitee.com/sang3112/blog_imgs/raw/6d55251373589f7b63584fece6808ec3cbcdad27/Java/CMS.png" alt="CMS"></p><ul><li>使用标记-清除算法回收老年代</li><li>优点: 系统由于垃圾回收停顿时间较短, 所以用户体验好</li><li>缺点: 内存碎片问题, 退化问题(会退化为<code>Serial Old</code>单线程), 浮动垃圾问题</li><li>适合大型互联网系统中, 用户请求数据量大, 频率高的场景, 比如订单接口, 商品接口等</li></ul><div class="note info flat"><p><code>CMS</code>执行步骤</p><ol><li>初始标记: 用<strong>极短</strong>的时间标记出<code>GC Root</code>能够直接关联到的对象</li><li>并发标记: 标记所有的对象, 用户线程此时不需要暂停</li><li>重新标记: 由于并发标记阶段没有<code>STW</code>, 因此有些对象会发生变化, 存在错标和漏标的情况, 需要重新标记(这也是<code>STW</code>的原因)</li><li>并发清理: 清理死亡对象, 用户线程<strong>不需要</strong>暂停(因此会有浮动垃圾, 不能完全垃圾回收)</li></ol><blockquote><p>只有初始标记和重新标记两个阶段用户线程需要暂停, 但是这两个线程执行时间较短, 是并发执行的, 所以<code>STW</code>较短</p></blockquote><ul><li><code>CMS</code>缺点:<ol><li>使用标记-清除算法, 会有大量内存碎片, 在<code>Full GC</code>时进行碎片整理, 导致用户线程暂停, 可以使用<code>-XX:CMSFullGCsBeforeCompation=N</code>(默认为0)调整<code>N</code>次<code>Full GC</code>之后再整理</li><li>无法处理在并发清理过程中产生的<strong>浮动垃圾</strong>, 不能做到完全的垃圾回收, 也就是在并发清理阶段, 如果用户产生了对象, 并且很快就失效了, 则不能在并发清理阶段被回收</li><li>如果老年代内存不足无法分配对象, <code>CMS</code>就会退化为<code>Serial Old</code>单线程回收老年代</li></ol></li></ul></div><h2 id="Parallel-Scavenge垃圾回收器-年轻代"><code>Parallel Scavenge</code>垃圾回收器-年轻代</h2><ul><li>是<code>JDK 8</code>默认的垃圾回收器, 多线程并行回收, 关注系统的<strong>吞吐量</strong>, 具备自动调整堆内存大小的特点</li><li>年轻代的复制算法</li><li>优点: 吞吐量高, 手动可控, 为了提高吞吐量, 虚拟机会动态调整堆的参数(不需要关注最大堆内存, 年轻代的大小了)</li><li>缺点: 不能保证单次的停顿时间(可以设置最大单次暂停时间)</li><li>适合后台任务, 不需要与用户进行交互, 并且容易产生大量的对象的任务, 比如大数据的处理, 大文件的导出</li></ul><blockquote><p>允许手动设置最大暂停时间和吞吐量, 官方建议<strong>不要设置堆内存的最大值</strong>, 垃圾回收器会根据最大暂停时间和吞吐量自动调整内存大小</p><p>最大暂停时间<code>-XX:MaxGCPauseMillis=n</code>设置每次垃圾回收时的最大停顿毫秒数</p><p>吞吐量<code>-XX:GCTimeRatio=n</code>设置吞吐量为<code>n</code>, 也就是用户线程执行时间=n/(n+1)</p><p>自动调整内存大小<code>-XX:+UseAdaptiveSizePolicy</code>设置可以让垃圾回收器根据吞吐量和最大停顿毫秒数自动调整内存大小</p><p>实际上, 当我们把最大暂停时间减小的时候, 垃圾回收器会主动减少堆内存, 从而减少最大暂停时间</p></blockquote><p><img src="https://gitee.com/sang3112/blog_imgs/raw/6d55251373589f7b63584fece6808ec3cbcdad27/Java/PS.png" alt="PS"></p><h2 id="Parallel-Old垃圾回收器-老年代"><code>Parallel Old</code>垃圾回收器-老年代</h2><ul><li>是<code>PS</code>收集器的老年代版本, 利用多线程并发收集</li><li><code>-XX:+UseParallelGC</code>或者<code>-XX:+UseParallelOldGC</code>可以使用<code>PS + PO</code>这种组合</li><li>回收老年代的标记-整理算法, (<code>Arthas</code>上面显示<code>MarkSweep</code>也就是标记清除, 这是因为老年代垃圾回收器不会单独使用标记清除算法, 官方没有将整理放上来, 所以显示<code>MarkSweep</code>, 包括<code>CMS</code>用的也不是单纯的标记清除算法)</li><li>优点: 并发收集, 在多<code>CPU</code>下效率较高</li><li>缺点: 暂停时间较长</li><li>适合与<code>PS</code>一起使用</li></ul><h2 id="G1垃圾回收器"><code>G1</code>垃圾回收器</h2><blockquote><p><code>JDK 9</code>之后默认使用<code>G1</code>垃圾回收器, <code>PS</code>关注吞吐量, 允许用户设置最大暂停时间, 但是会减少年轻代的可用空间大小</p><p><code>CMS</code>关注暂停时间, 但是吞吐量方面会有下降</p><p><code>G1</code>设计目标就是将上述两种垃圾回收器的优点融合:</p><ol><li>支持巨大的堆空间回收, 具有较高的吞吐量</li><li>支持多<code>CPU</code>并行垃圾回收</li><li>允许用户设置最大暂停时间<br>所以强烈建议使用<code>G1</code>垃圾回收器</li></ol></blockquote><h3 id="内存结构">内存结构</h3><ul><li><code>G1</code>之前的垃圾回收器, 一般内存结构是连续的<br><img src="https://gitee.com/sang3112/blog_imgs/raw/6d55251373589f7b63584fece6808ec3cbcdad27/Java/beforeg1.png" alt="beforeg1"></li><li><code>G1</code>将整个堆划分为多个大小相等的区域, 称为区<code>Region</code>, 区域不要求连续, 分为<code>eden, Survivor, Old</code>区.<ul><li><code>Region</code>的大小通过堆空间大小/2048计算得到, 也可以通过<code>-XX:G1HeapRegionSize=32m</code>指定(<code>region</code>大小为<code>32M</code>), <code>Region size</code>必须是2的指数幂，取值范围从<code>1M</code>到<code>32M</code></li></ul></li></ul><h3 id="垃圾回收方式">垃圾回收方式</h3><ol><li>年轻代回收(<code>Young GC</code>)</li><li>混合回收(<code>Mixed GC</code>)(回收年轻代加上老年代)</li></ol><h3 id="年轻代回收-Young-GC">年轻代回收(<code>Young GC</code>)</h3><blockquote><p>回收<code>Eden</code>区和<code>Survivor</code>区中不再使用的对象, 会导致<code>STW</code>, <code>G1</code>会尽可能的保证暂停时间, 可以通过<code>-XX:MaxGCPauseMillis=n</code>(默认为200)设置最大暂停时间的毫秒数</p></blockquote><ol><li>新创建的对象放在<code>Eden</code>区, 如果<code>Eden + Survivor</code>超过年轻代区的<code>60%</code>, 就会判断年轻代空间不足, 无法分配对象的时候会执行<code>Young GC</code></li><li>标记<code>Eden</code>和<code>Survivor</code>区域中的存活对象</li><li>根据最大暂停时间选择某些区域将存活对象复制到一个新的<code>Survivor</code>区域, 并且年龄+1, 并清空这些区域(因为使用了复制方法, 不会产生内存碎片)</li></ol><blockquote><p>进行<code>Young GC</code>的时候会记录每次垃圾回收的<code>Eden</code>区域和<code>Survivor</code>区域的<strong>平均耗时</strong>, 从而作为下次回收时的参考依据, 这样就可以根据配置的最大暂停时间计算出本次回收最多能回收多少个<code>Region</code>区域了</p><p>比如<code>-XX:MaxGCPauseMillis=n</code>(默认为200)，每个<code>Region</code>回收耗时<code>40ms</code>, 所以这次最多只能回收4个<code>Region</code></p></blockquote><ol start="4"><li>后面如果再发生<code>Young GC</code>, 步骤相同, 只是<code>Survivor</code>会搬运到另一个<code>Survivor</code>区</li></ol><blockquote><p>如果一个对象年龄达到阈值(默认是15), 就会被放入老年代</p></blockquote><ol start="5"><li>如果部分对象大小超过<code>Region</code>的一半, 那么就会直接放到老年代中, 称为<code>Humongous</code>区(巨大的)</li></ol><blockquote><p>比如堆内存<code>4G</code>, 每个<code>Region``2M</code>, 只要一个对象超过<code>1M</code>, 就会被放入<code>Humongous</code>区中, 如果对象过大, 就会横跨多个<code>Region</code></p></blockquote><ol start="6"><li>多次回收之后, 会有很多老年代区, 如果达到阈值(<code>-XX:InitiatingHeapOccupancyPercent</code>)占用总堆空间的默认的<code>45%</code>, 就会触发<code>Mixed GC</code>, 回收所有年轻代和部分老年代对象以及大对象区, 采用复制算法完成</li></ol><h3 id="混合回收-Mixed-GC">混合回收(<code>Mixed GC</code>)</h3><blockquote><p>分为初始标记<code>Initial Mark</code>, 并发标记<code>Concurrent Mark</code>, 最终标记<code>Remark</code>或者<code>Finalize Marking</code>, 并发清理(<code>Cleanup</code>)</p><p><code>G1</code>对老年代的清理会选择存活度最低的区域来进行回收, 可以保证回收效率最高, 也就是<code>G1</code>的由来(判断哪个区域存活对象最少, 就优先清除哪个区域)</p></blockquote><p><img src="https://gitee.com/sang3112/blog_imgs/raw/6d55251373589f7b63584fece6808ec3cbcdad27/Java/G1old.png" alt="G1old"></p><ul><li>初始标记: 标记<code>GC Root</code>引用的对象为存活, 并行执行, 暂停用户线程, 速度较快</li><li>并发标记: 将第一步中标记对象的引用对象标记为存活, 和用户线程一起执行(可能会出现错标漏标)</li><li>最终标记: 标记一些引用改变漏标的对象, 不管新创建、不再关联的对象(但是上一步结束后可能有些对象不再使用了, <code>G1</code>不再处理)</li><li>并发复制清理: 使用复制算法, 将存活对象复制到别的<code>Region</code>中, 此操作不会产生内存碎片</li></ul><div class="note info flat"><ul><li>如果清理过程中没有足够的空<code>Region</code>存放转移的对象, 就会出现<code>Full GC</code>, 单线程执行标记-整理算法, 此时会导致用户线程暂停. 所以尽量保证堆中有一定的空间</li></ul></div><blockquote><p><code>-XX:+UseG1GC</code>, 打开<code>G1</code>的开关, <code>JDK 9</code>之后默认打开</p><p><code>-XX:MaxGCPauseMillis=n</code>设置最大暂停时间</p></blockquote><ul><li>使用<strong>复制算法</strong>回收年轻代+老年代</li><li>优点:<ol><li>对较大的堆如果超过<code>6G</code>对回收时, 延迟也可控</li><li>不会产生内存碎片</li><li>并发标记的<code>SATB</code>算法效率高</li></ol></li><li>缺点: <code>JDK 8</code>之前还不够成熟</li></ul><h2 id="总结">总结</h2><ol><li><code>JDK 8</code>以及之前: <code>ParNew + CMS</code>(关注暂停时间); <code>PS + PO</code>(关注吞吐量); <code>G1</code>(<code>JDK 8</code>之前不建议使用, 较大堆并且关注暂停时间)</li><li><code>JDK 9</code>之后, 使用<code>G1</code></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;垃圾回收算法(四种)&lt;/h1&gt;
&lt;div class=&quot;note info flat&quot;&gt;&lt;ul&gt;
&lt;li&gt;垃圾回收需要找到内存中存活的对象&lt;/li&gt;
&lt;li&gt;还需要释放不再存活的对象, 使程序可以再次利用这部分空间&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;标</summary>
      
    
    
    
    <category term="Java" scheme="https://sangs3112.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://sangs3112.github.io/tags/Java/"/>
    
    <category term="垃圾回收算法" scheme="https://sangs3112.github.io/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"/>
    
    <category term="垃圾回收器" scheme="https://sangs3112.github.io/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Java笔记_3</title>
    <link href="https://sangs3112.github.io/posts/fdc04dbc.html"/>
    <id>https://sangs3112.github.io/posts/fdc04dbc.html</id>
    <published>2024-04-21T06:37:35.000Z</published>
    <updated>2025-01-16T15:34:13.091Z</updated>
    
    <content type="html"><![CDATA[<h1>垃圾回收器</h1><blockquote><p>主要负责在<strong>堆</strong>上进行内存回收</p></blockquote><ul><li>自动垃圾回收可以降低实现难度, 降低回收bug的可能性</li><li>但是程序员无法控制内存回收的及时性, 也无法完全避免内存溢出</li></ul><h2 id="应用场景">应用场景</h2><ol><li>解决系统僵死(因为频繁的垃圾回收)</li><li>性能优化</li><li>常见垃圾回收, 四种引用等</li></ol><h2 id="方法区回收">方法区回收</h2><blockquote><p>线程不共享的程序计数器和<code>Java</code>虚拟机栈以及本地方法栈, 都只需要等待线程销毁自己就销毁了, 不需要垃圾回收</p></blockquote><h3 id="方法区回收的条件-三个">方法区回收的条件(三个)</h3><blockquote><p>方法区中的类不再使用, 即可被回收</p></blockquote><ol><li>类的<strong>所有实例</strong>都已经被回收了, 在堆中不存在任何该类的实例对象以及子类对象 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = loader.loadClass(<span class="string">&quot;类的全限定名&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">o = <span class="literal">null</span>; <span class="comment">// 此时对象o不再使用, 就可以让gc自动回收clazz类</span></span><br></pre></td></tr></table></figure></li><li>加载该类的类加载器已经被回收了 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">URLClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URLClassLoader</span>(<span class="keyword">new</span> <span class="title class_">URL</span>[]&#123;<span class="keyword">new</span> <span class="title class_">URL</span>(spec:<span class="string">&quot;路径&quot;</span>)&#125;);</span><br><span class="line">loader = <span class="literal">null</span>; </span><br></pre></td></tr></table></figure></li><li>该类对应的<code>java.lang.Class</code>对象没有任何地方被引用 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = loader.loadClass(<span class="string">&quot;类的全限定名&quot;</span>);</span><br><span class="line">clazz = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>使用<code>System.gc()</code>可以手动触发垃圾回收</p></blockquote><div class="note info flat"><ul><li>开发过程中此类场景出现较少, 主要在<code>OSGI, JSP</code>的热部署等场景中</li><li>每个<code>jsp</code>文件对应一个类加载器, 一个<code>jsp</code>文件被修改了, 直接写在这个<code>jsp</code>类加载器, 创建新的类加载器, 重新加载<code>jsp</code>文件</li></ul></div><h2 id="堆回收">堆回收</h2><blockquote><p>堆上的对象主要看是否还被<strong>引用</strong>, 如果被引用, 说明不能回收</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Demo</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">        d = <span class="literal">null</span>; <span class="comment">// 此时没有引用, 可以被回收</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceCounting</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        <span class="type">B</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        a1.b = b1;</span><br><span class="line">        b1.a = a1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// A实例要回收, 需要消除两个引用关系, 分别是栈中a1对对象的引用, 以及B对象中b1.a对对象的引用</span></span><br><span class="line">    <span class="comment">// a1 = null;</span></span><br><span class="line">    <span class="comment">// b1.a = null;</span></span><br><span class="line"><span class="comment">// 如果单纯的执行a1 = null; b1 = null; A和B对象也可以被回收, 因为方法里面没有办法访问到AB对象了</span></span><br></pre></td></tr></table></figure><div class="note info flat"><ul><li>如果想要查看垃圾回收的信息, 可以使用<code>-verbose:gc</code></li></ul></div><h2 id="判断堆上的对象是否被引用-两种方法">判断堆上的对象是否被引用(两种方法)</h2><ol><li><strong>引用计数法</strong>: 每个对象维护一个计数器, 初始值为0, 对象被引用就加1, 取消引用就减1<ul><li>缺点:</li></ul><blockquote><p>引用和取消引用需要维护计数器, 对性能有一定影响</p><p>循环引用, 比如<code>A</code>引用<code>B</code>, <code>B</code>引用<code>A</code>, 就会导致对象无法回收(上面的例子如果用引用计数法, 就无法回收了)</p></blockquote></li><li>可达性分析法(<code>Java</code>使用, 性能更高, 解决了循环引用的问题)<ul><li>可达性分析算法将对象分为两类: 垃圾回收的根对象(<code>GC Root</code>); 普通对象, 对象与对象之间存在引用关系</li><li><code>GC Root</code>对象一般不可以被回收, <code>JVM</code>也会维护一个<code>GC Root</code>对象列表</li><li>每次从某个<code>GC Root</code>遍历引用链, 如果某个普通对象可以从<code>GC Root</code>到达, 说明不可被回收<br><img src="https://gitee.com/sang3112/blog_imgs/raw/6d55251373589f7b63584fece6808ec3cbcdad27/Java/achieve.png" alt="achieve"></li></ul></li></ol><div class="note info flat"><p>什么样的对象可以作为<code>GC Root</code>对象?</p><ol><li>线程<code>Thread</code>对象, 引用线程栈帧中的方法参数、局部变量等</li><li>系统类加载器加载的<code>java.lang.Class</code>对象, 引用类中的静态变量 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceCounting</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">A</span> <span class="variable">a2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// sun.misc.Launcher是一个GC Root对象, 可以找到应用程序类加载器, 以及扩展类加载器</span></span><br><span class="line"><span class="comment">// 自定义的ReferenceCounting是由应用程序类加载器加载的, 所以可以由GC Root找到</span></span><br><span class="line"><span class="comment">// a2 引用了A, 所以GC Root可以找到a2, 所以不会回收</span></span><br></pre></td></tr></table></figure></li><li>监视器对象, 用来保存同步锁<code>synchronized</code>关键字持有的对象<br><code>synchronized(Reference.class)</code> 只要这个关系建立起来, 监视器对象就可以找到<code>ReferenceCounting</code>, 就无法回收</li><li>本地方法调用时使用的全局对象(不需要程序员过多关注)</li></ol></div><ul><li>通过<code>Arthas</code>以及<code>eclise MAT(Memory Analyzer)</code>工具可以查看<code>GC Root</code></li><li><code>Arthas</code>使用<code>heapdump &lt;dir/文件名.hprof&gt;</code>命令将堆内存快照保存到本地磁盘中</li><li>使用<code>MAT</code>工具打开堆内存的快照文件</li><li>使用<code>GC Roots</code>功能查看所有的<code>GC Root</code></li></ul><h3 id="对象引用-五种">对象引用(五种)</h3><blockquote><p>强引用, 软引用, 弱引用, 虚引用, 终结器引用</p></blockquote><ol><li><p>强引用</p><blockquote><p>可达性算法中的对象引用一般指强引用, 就是<code>GC Root</code>对象对普通对象有引用关系, 那么普通对象就不会被回收</p></blockquote></li><li><p>软引用</p><blockquote><p>如果一个对象只有软引用关联到它, 如果程序内存不足, 则会将软引用进行回收</p><p><code>JDK 1.2</code>提供<code>SoftReference</code>实现软引用, 经常用于缓存中</p><p>因此使用软引用应该创建两个对象, 一个是<code>SoftReference</code>对象, 用于引用真正使用的对象, 而<code>SoftReference</code>本身应该被<code>Gc Root</code>引用, 保证可以找到</p></blockquote> <div class="note info flat"><p>软引用的执行过程</p><ol><li>对象使用软引用包装起来, <code>new SoftReference&lt;对象类型&gt;(对象);</code></li><li>内存不足时, <code>JVM</code>进行垃圾回收</li><li>垃圾回收仍然不能解决内存不足的问题, 回收软引用中的对象</li><li>如果依然内存不足, 会抛出<code>OutOfMemory</code>异常</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">100</span>];</span><br><span class="line">SoftReference&lt;<span class="type">byte</span>[]&gt; softReference = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;<span class="type">byte</span>[]&gt;(bytes);</span><br><span class="line"><span class="comment">// 这段代码将100M的数据放在软引用中</span></span><br></pre></td></tr></table></figure><ul><li><code>Java</code>中的<code>Caffeine</code>可以在创建缓存的过程中将缓存对象设置成<code>softValues()</code>也就是软引用</li></ul></div> <div class="note info flat"><ul><li>软引用中的对象如果内存不足会被回收, <code>SoftReference</code>对象本身也需要被回收, 但是<code>SoftReference</code>一旦被回收了, 就无法知道其引用的对象是否真的被回收了, 所以<code>SoftReference</code>提供了一套<strong>队列机制</strong>来进行判断:<ol><li>软引用创建时, 通过构造器传入引用队列(程序员自定义)</li><li>软引用中包含对象被回收时, 该软引用对象会被放入引用队列</li><li>通过代码遍历引用队列, 将<code>SoftReference</code>的强引用删除</li></ol></li></ul></div><ul><li>软引用可以继承<code>SoftReference</code>类的方式来实现, <code>SoftReference</code>类就是一个软引用对象, 通过构造器传入软引用包含的对象, 以及引用队列</li><li>使用软引用实现学生数据的缓存, 软引用如果被回收了, 则要清理<code>HashMap</code>中的<code>key</code><br><img src="https://gitee.com/sang3112/blog_imgs/raw/6d55251373589f7b63584fece6808ec3cbcdad27/Java/stucac.png" alt="stucache"></li></ul> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">StudentCache</span> <span class="variable">cache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StudentCache</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; ; ++ i) &#123;</span><br><span class="line">            StudentCache.getInstance().cacheStudent(<span class="keyword">new</span> <span class="title class_">Student</span>(i, String.valueOf(i)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, StudentRef&gt; StudentRefs; <span class="comment">// 用于Cache内容的存储</span></span><br><span class="line">    <span class="keyword">private</span> ReferenceQueue&lt;Student&gt; q; <span class="comment">// 垃圾Reference队列</span></span><br><span class="line">    <span class="comment">// 继承SoftReference, 每个实例都具有一个可识别的标识</span></span><br><span class="line">    <span class="comment">// 并且标识与在HashMap中的key相同</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">StudentRef</span> <span class="keyword">extends</span> <span class="title class_">SoftReference</span>&lt;Student&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">_key</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">StudentRef</span><span class="params">(Student em, ReferenceQueue&lt;Student&gt; q)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(em, q); <span class="comment">// 调用父类的构造方法</span></span><br><span class="line">            _key = em.getId();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造一个缓存器实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">StudentCache</span><span class="params">()</span> &#123;</span><br><span class="line">        StudentRefs = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, StudentRef&gt;();</span><br><span class="line">        q = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;Student&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取得缓存器实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StudentCache <span class="title function_">getInstance</span><span class="params">()</span> &#123;<span class="keyword">return</span> cache;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以软引用的方式对一个Student对象的实例进行引用并保存该引用(放入缓存)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">cacheStudent</span><span class="params">(Student em)</span> &#123;</span><br><span class="line">        cleanCache(); <span class="comment">// 清除垃圾引用</span></span><br><span class="line">        <span class="type">StudentRef</span> <span class="variable">ref</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StudentRef</span>(em, q);</span><br><span class="line">        StudentRefs.put(em.getId(), ref);</span><br><span class="line">        System.out.println(StudentRefs.size());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 依据指定的ID, 重新获取相应的Student对象的实例</span></span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">getStudent</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">em</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 缓存中是否有该Student实例的软引用, 如果有就从软引用中获得</span></span><br><span class="line">        <span class="keyword">if</span> (StudentRefs.containsKey(id)) &#123;</span><br><span class="line">            <span class="type">StudentRef</span> <span class="variable">ref</span> <span class="operator">=</span> StudentRefs.get(id);</span><br><span class="line">            em = ref.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有这个软引用, 或者这个软引用得到的实例为空, 则重新构建一个实例, 保存对这个实例的软引用</span></span><br><span class="line">        <span class="keyword">if</span> (em == <span class="literal">null</span>) &#123;</span><br><span class="line">            em = <span class="keyword">new</span> <span class="title class_">Student</span>(id, String.valueOf(id));</span><br><span class="line">            System.out.println(<span class="string">&quot;Retrieve From StudentInfoCenter. ID = &quot;</span> + id);</span><br><span class="line">            <span class="built_in">this</span>.cacheStudent(em);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> em;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除那些软引用的所有Student对象已经被回收的StudentRef对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">cleanCache</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">StudenRef</span> <span class="variable">ref</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>((ref = (StudentRef)q.poll() != <span class="literal">null</span>)) &#123;</span><br><span class="line">            StudentRefs.remove(ref._key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;<span class="keyword">return</span> id;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;<span class="built_in">this</span>.id = id;&#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;<span class="keyword">return</span> name;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;<span class="built_in">this</span>.name = name;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>弱引用</p><blockquote><p>关联的对象在垃圾回收时, 不管内存够不够, 都会被直接回收</p><p><code>JDK 1.2</code>版本之后提供了<code>WeakReference</code>类来实现弱引用, 主要用在<code>ThreadLocal</code>中, 弱引用本身也可以使用引用队列回收</p><p>除了<code>ThreadLocal</code>以外, 基本上不会使用这个, <code>Caffeine</code>中也有弱引用的实现, 但是一般不用</p></blockquote></li><li><p>虚引用(幽灵引用, 幻影引用)</p><blockquote><p>在常规开发中<strong>不会</strong>使用</p><p>不能通过虚引用对象获取包含的对象, 唯一的用途是当对象被垃圾回收器回收时可以接收到对应的通知</p><p>使用<code>PhantomReference</code>实现了虚引用</p><p>直接内存为了及时知道直接内存中的对象不再使用, 从而回收内存, 就会用虚引用实现<code>Cleaner</code>类(解决了直接内存中内存的释放问题)</p></blockquote></li><li><p>终结器引用</p><blockquote><p>在常规开发中不会使用</p><p>对象需要被回收的时候, 终结器引用会关联对象并且放在<code>Finalizer</code>类中的引用队列, 由一条<code>FinalizerThread</code>线程从队列中获取对象. 然后执行对象的<code>finalize()</code>方法(这个方法实际上重写了<code>Object</code>中的方法, 作用是回收对象时做一些收尾的工作), 在对象第二次被回收时, 该对象才会被真正的回收. 这个过程中<code>finalize()</code>方法再将自身对象使用强引用关联上, 但是不建议这么做, 因为这个<code>finalize()</code>方法什么时候调用, 甚至可能不调用, 都是<code>GC</code>决定的, 不是程序员决定的. (不管是实现自救, 也就是用强引用关联; 还是实现清理工作都是不合适的, 所以基本不会用)</p></blockquote></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;垃圾回收器&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;主要负责在&lt;strong&gt;堆&lt;/strong&gt;上进行内存回收&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;自动垃圾回收可以降低实现难度, 降低回收bug的可能性&lt;/li&gt;
&lt;li&gt;但是程序员无法控制内存回收的</summary>
      
    
    
    
    <category term="Java" scheme="https://sangs3112.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://sangs3112.github.io/tags/Java/"/>
    
    <category term="方法区 堆的垃圾回收" scheme="https://sangs3112.github.io/tags/%E6%96%B9%E6%B3%95%E5%8C%BA-%E5%A0%86%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
    <category term="五种引用关系" scheme="https://sangs3112.github.io/tags/%E4%BA%94%E7%A7%8D%E5%BC%95%E7%94%A8%E5%85%B3%E7%B3%BB/"/>
    
  </entry>
  
  <entry>
    <title>Java笔记_2</title>
    <link href="https://sangs3112.github.io/posts/8ac77d2a.html"/>
    <id>https://sangs3112.github.io/posts/8ac77d2a.html</id>
    <published>2024-04-20T06:37:35.000Z</published>
    <updated>2025-01-16T15:34:13.091Z</updated>
    
    <content type="html"><![CDATA[<h1>运行时数据区</h1><h2 id="分类">分类</h2><ol><li>线程不共享: 程序计数器、<code>Java</code>虚拟机栈、本地方法栈</li><li>线程共享: 方法区、堆区</li></ol><h2 id="程序计数器">程序计数器</h2><blockquote><p><code>Program Counter Register</code>, 也叫做<code>PC</code>寄存器, 每个线程会通过程序计数器记录当前<strong>要执行</strong>的字节码指令的地址</p></blockquote><h3 id="作用">作用</h3><ol><li>控制程序指令的执行, 比如跳转, 分支, 异常</li><li>多线程情况下<code>JVM</code>通过程序计数器记录CPU切换前执行到哪一句, 切换回来后执行并继续解释运行</li></ol><div class="note info flat"><p>程序计数器会产生内存溢出的问题吗</p><ul><li>内存溢出指在使用某一块内存区域时, 存放的数据需要占用的内存大小超过了虚拟机能够提供的内存上限</li><li>每个线程只存储一个固定长度的内存地址, 因此程序计数器不会产生内存溢出</li><li><code>PC</code>不用程序员修改</li></ul></div><h2 id="Java虚拟机栈"><code>Java</code>虚拟机栈</h2><blockquote><p>先进后出(<code>FILO</code>), 每个方法调用一个栈帧来保存</p></blockquote><ul><li><code>Java</code>虚拟机栈随着线程的创建而创建, 线程销毁则栈回收</li><li>由于方法可能会在不同的线程中执行, 所以每个线程都有自己的虚拟机栈</li></ul><h3 id="栈帧组成">栈帧组成</h3><blockquote><p>局部变量表, 操作数栈, 帧数据</p></blockquote><ol><li>局部变量表: 方法执行过程中存放所有的局部变量, 与字节码局部变量表不太一样<ul><li>栈帧中的局部变量表是一个数组, 每一个位置成为槽<code>slot</code>, <code>long, double</code>占用两个槽, 其他类型占用一个槽</li><li>实例方法中的序号为<code>0</code>的位置存放的是<code>this</code>, 指的是当前调用方法的对象, 运行时会在内存中存放实例对象的地址</li><li>方法参数也会保存在局部变量表中, 顺序与参数定义顺序一致</li><li>所以局部变量表保存了实例方法的<code>this</code>对象, 方法的参数, 方法体中声明的局部变量</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 占用了6个槽, 为了节省空间, 槽是可以复用的, 一旦某个局部变量不再生效, 则当前的槽可以再次使用</span></span><br><span class="line"><span class="comment">// ab在代码块中, 代码块结束以后, ab就释放了</span></span><br></pre></td></tr></table></figure><ol start="2"><li>操作数栈: 存放中间数据的一块区域, 如果一条指令将一个值压入操作数栈, 则后面的指令可以弹出并使用该值</li></ol><blockquote><p><strong>编译期</strong>就可以确定操作数栈的最大深度, 从而在执行时正确分配内存大小</p></blockquote><ol start="3"><li>帧数据: 包含动态链接, 方法出口, 异常表的引用<ul><li>动态链接保存的是符号引用到运行时常量池中内存地址的映射关系(比如引用其他类)</li><li>方法出口: 方法在正确或异常结束时, 栈帧会被弹出, <code>PC</code>应该指向<strong>上一个栈帧中的下一条指令的地址</strong>, 所以在当前栈帧中, 需要存储此方法的出口的地址</li><li>异常表引用: 存放代码中的异常处理信息, 包含异常捕获的生效范围以及异常发生以后跳转到的字节码指令位置</li></ul></li></ol><div class="note info flat"><ol><li><p>栈内存溢出</p><ul><li>如果栈帧过多, 占用内存超过栈内存可以分配的最大空间以后就会出现内存溢出, 报<code>StackOverflowError</code>错误</li><li>比如递归的时候没有设置递归出口, 则会栈内存溢出</li></ul></li><li><p>设置栈内存</p><ul><li>通过参数<code>-Xss&lt;值&gt;</code>设置虚拟机栈大小, 单位是[字节, 且必须是1024的倍数, 默认] [k或者K] [m或者M] [g或者G]</li><li>也可以用<code>-XX:ThreadStackSize=&lt;大小&gt;</code>, 但是比较复杂</li><li><code>HotSpot JVM</code>对栈的大小的最大值和最小值有要求, 超过范围会自动调整</li><li>局部变量过多, 操作数栈深度过大也会影响栈内存大小</li><li>可以手动指定<code>-Xss256k</code>节省内存</li></ul></li></ol></div><h2 id="本地方法栈">本地方法栈</h2><blockquote><p><code>Java</code>虚拟机栈存储了<code>Java</code>方法调用时的栈帧, 本地方法栈存储的是本地方法的栈帧, 用<code>cpp</code>编写的</p></blockquote><ul><li>在<code>Hotspot</code>虚拟机中, <code>Java</code>虚拟机栈和本地方法栈实现上用了同一个栈空间, 本地方法栈会在栈内存上生成一个栈帧, 临时保存方法参数的同时, 方便出现异常时也把本地方法的栈信息打印出来</li></ul><h2 id="堆">堆</h2><blockquote><p>堆内存是最大的内存区域, <strong>创建出来的对象都在堆上</strong></p><p>栈上的局部变量表中可以存放堆上对象的<strong>引用</strong>, 静态变量也可以存放堆对象的引用, <strong>通过静态变量可以实现对象在线程之间共享</strong></p></blockquote><div class="note info flat"><ol><li>堆内存溢出<ul><li>堆内存大小有上限, 如果一直向堆中放入对象达到上限后, 就会抛出<code>OutOfMemory</code>错误</li><li>有三个需要关注的值: <code>used, total, max</code>, 在<code>Arthas</code>中可以使用<code>dashbord -i </code> or <code>memory</code>命令查看<ul><li><code>used</code>: 当前已经使用的堆内存</li><li><code>total</code>: <code>JVM</code>已经分配的可用堆内存</li><li><code>max</code>: 是可以分配的最大堆内存<ul><li><code>total</code>内存不足的时候, <code>JVM</code>会扩大<code>total</code>, 直到达到<code>max</code>为止</li><li>但<strong>不是</strong>在<code>total = used = max</code>的时候产生堆内存溢出, 这是因为有垃圾回收器存在的原因</li><li>默认情况下, <code>max</code>默认是系统内存的<code>1/4</code>, <code>total</code>默认是系统内存的<code>1/64</code>, 实际应用中需要单独设置</li><li><code>-Xmx值 -Xms值</code>, 分别表示<code>max</code>和<code>total</code>的大小, <code>max</code>必须大于<code>2MB</code>, <code>total</code>必须大于<code>1MB</code></li><li>但是实际上<code>Arthas</code>堆内存显示的比实际上分配的要小一点, 这是因为使用了<code>JMX</code>技术, 与垃圾回收器有关, 计算的是可以<strong>分配对象的内存, 而不是整个内存</strong></li></ul></li></ul></li><li>一般设置的时候, 可以将<code>total</code>设置成<code>max</code>相同的大小, 减少申请内存和压缩内存的开销</li></ul></li></ol></div><h2 id="方法区">方法区</h2><blockquote><p>存放基础信息的位置(类的元信息, 运行时常量池, 字符串常量池), 线程间共享, 是一个虚拟概念</p></blockquote><ul><li>用来存放每个类的基本信息(元信息), 一般称为<code>InstanceKlass</code>对象, 在类的加载阶段完成</li><li>还用来存放了字节码中的运行时常量池, 通过<strong>编号查表</strong>的方式找到常量, 称为<strong>静态常量池</strong></li><li>常量池<strong>加载</strong>到内存中之后, 可以通过<strong>内地址快读</strong>定位到常量池中的内容, 就是<strong>运行时常量池</strong></li></ul><h3 id="JDK-7以及之前"><code>JDK 7</code>以及之前</h3><ul><li>方法区存放在<strong>堆的永久代空间</strong>, 堆的大小由<code>JVM</code>参数控制</li><li>在<code>Arthas</code>中可以看见<code>ps_perm_gen</code>就是永久代, 因为在堆上, 所以设置了<code>max</code>, 存储空间大小有限制</li></ul><h3 id="JDK-8以及之后"><code>JDK 8</code>以及之后</h3><ul><li>方法区存放在<strong>元空间</strong>中, 位于<strong>操作系统内存</strong>中, 独立于<code>JVM</code>内存之外, 默认情况下只要不超过操作系统上限, 可以一直分配</li><li>在<code>Arthas</code>中可以看见<code>metaspace</code>, 就是元空间, <code>max=-1</code>, 表示没有上限, 因此只要不超过操作系统的上限即可</li></ul><div class="note info flat"><ol><li>方法区溢出<ul><li><code>JDK 7</code>在堆上, 十几万个类会出现错误</li><li><code>JDK 8</code>运行上百万次, 不会出现错误</li><li><code>JDK 7</code>方法区存储在堆区中的永久代空间, 可以设置<code>-XX:MaxPermSize=值</code>来控制</li><li><code>JDK 8</code>方法区位于元空间中, 默认不超过操作系统内存上限即可, 同样可以使用<code>-XX:MaxMetaspaceSize=值</code>设置元空间大小</li><li>启动程序的时候最好设置元空间的最大大小, 没有特殊情况设置成<code>256M</code>, 以免占用其他程序的内存, 能够容纳三十多万个类的加载</li></ul></li></ol></div><h3 id="字符串常量池">字符串常量池</h3><blockquote><p>存储代码中定义的常量字符串内容, 比如<code>&quot;123&quot;</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译成字节码以后, &quot;abc&quot;会加入到静态常量池中</span></span><br><span class="line"><span class="comment">// s1通过new创建, 所以&quot;abc&quot;放在堆内存中, 由s1保存</span></span><br><span class="line"><span class="comment">// s2没有使用new, 所以s2存放的是字符串常量池中的&quot;abc&quot;</span></span><br><span class="line"><span class="comment">// 所以最后打印s1 == s2两个地址不同, 返回false</span></span><br></pre></td></tr></table></figure><div class="note info flat"><ul><li>早期的设计中, 字符串常量池是运行时常量池的一部分, 存储位置相同, 但后续将字符串常量池和运行时常量池进行拆分</li><li><code>JDK 7</code>之前, 运行时常量池包含字符串常量池, 都在方法区的永久代中</li><li><code>JDK 7</code>时, 字符串常量池从方法区拿到了堆中, 运行时常量池剩下的东西还在方法区的永久代中</li><li><code>JDK 8</code>之后, 没有永久代了, 所以运行时常量池在元空间中, 而字符串常量池仍然在堆中</li></ul></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;2&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;12&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> a + b;</span><br><span class="line">    System.out.println(c == d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译成字节码以后, 字符串常量池中会有&quot;1&quot;, &quot;2&quot;, &quot;12&quot;</span></span><br><span class="line"><span class="comment">// c 指向的是字符串常量池中的&quot;12&quot;</span></span><br><span class="line"><span class="comment">// d 中的 + 变成了使用StringBuilder方法进行连接</span></span><br><span class="line"><span class="comment">// d指向的是堆内存中的&quot;12&quot;</span></span><br><span class="line"><span class="comment">// 所以是false</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;2&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;12&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span> + <span class="string">&quot;2&quot;</span>;</span><br><span class="line">    System.out.println(c == d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此时cd都是在字符串常量池中</span></span><br><span class="line"><span class="comment">// 所以返回true</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>().append(<span class="string">&quot;think&quot;</span>).append(<span class="string">&quot;123&quot;</span>).toString();</span><br><span class="line">    System.out.println(s1.intern() == s1);</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>().append(<span class="string">&quot;ja&quot;</span>).append(<span class="string">&quot;va&quot;</span>).toString();</span><br><span class="line">    System.out.println(s2.intern() == s2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// String.intern()是手动将字符串放在字符串常量池中</span></span><br><span class="line"><span class="comment">// 比如多次输入, 每次Scanner.next().intern(), 如果有两次输入相同的字符串, 就可以减少存储的消耗, 只需要往字符串常量池中存储一份字符串即可</span></span><br><span class="line"><span class="comment">// JDK 6这个版本中, intern()会把第一次遇到的字符串实例复制到永久代字符串常量池中, 返回的也是永久代字符串实例的引用, JVM启动时会把&quot;java&quot;加入到常量池中</span></span><br><span class="line">    <span class="comment">// 所以JDK 6中, s1.intern()方法在字符串常量池中, s1在堆上，返回false</span></span><br><span class="line">    <span class="comment">// s2.intern()在字符串常量池中, s2在堆上, 所以返回false</span></span><br><span class="line"><span class="comment">// JDK 7之后的版本, 由于字符串常量池在堆上, 所以intern()会把第一次遇到的字符串引用放在字符串常量池中</span></span><br><span class="line">    <span class="comment">// s1.intern()返回的就是s1在堆上的引用, 也就是地址, 所以返回true</span></span><br><span class="line">    <span class="comment">// s2.intern()由于java已经在字符串常量池中有了,. 所以s2.intern()是字符串常量池中的地址, s2是堆中的地址, 因此返回false</span></span><br></pre></td></tr></table></figure><div class="note info flat"><ol><li>静态变量存储在哪里?<ul><li><code>JDK 6</code>以及之前, 静态变量存储在方法区中, 也就是永久代中</li><li><code>JDK 7</code>以及之后的版本中, 静态变量存储在<code>Class</code>对象中, 脱离了永久代</li></ul></li></ol></div><h2 id="直接内存">直接内存</h2><blockquote><p>不属于<code>Java</code>运行时的内存区域, 在<code>JDK 1.4</code>中引入了<code>NIO</code>机制, 使用了直接内存, 比如<code>Netty</code>网络框架</p></blockquote><ul><li><p>直接内存解决两个问题</p><ol><li><code>Java</code>堆中的对象如果不再使用要回收, 回收时会影响对象的创建和使用</li><li><code>IO</code>操作比如读文件, 需要先把文件读入直接内存(缓冲区), 然后再把数据复制到<code>Java</code>堆中</li></ol></li><li><p>现在直接放入直接内存即可, 同时<code>Java</code>堆上维护直接内存的引用, 减少了数据复制的开销, 写文件也是同样的思路</p></li><li><p>所以现在不需要从直接内存上复制到堆中了, 减少回收对象的影响, 提升读写文件的效率</p></li><li><p>可以使用<code>ByteBuffer</code>在直接内存上创建数据, 在<code>Arthas</code>中的<code>memory</code>可以查看<code>direct</code>部分的相关信息</p><ul><li><code>ByteBuffer directBuffer = ByteBuffer.allocateDirect(size);</code></li></ul></li></ul><div class="note info flat"><ol><li>直接内存存在溢出现象<ul><li><code>-XX:MaxDirectMemorySize=值</code>修改直接内存的大小, 如果不设置这个参数, 则会自动选择最大分配的大小</li><li>如果底层使用了<code>NIO</code>, 则需要设置这个参数; 如果没有用到直接内存, 也可以不设置这个参数</li><li>具体设置的大小需要进行压力测试以后, 确定最大内存</li></ul></li></ol></div><h2 id="总结">总结</h2><ol><li>运行时数据区分为了哪几个部分? 每个部分的作用是什么?<ul><li>程序计数器, <code>Java</code>虚拟机栈, 本地方法栈. 是线程不共享, 每个线程有一块独立的区域<ul><li>程序计数器: 记录当前要执行的字节码指令的地址, 不会出现内存溢出的问题</li><li>Java虚拟机栈和本地方法栈: 每个方法的调用会使用一个栈帧来保存数据, 会内存溢出, 一般因为递归没有出口</li></ul></li><li>方法区, 堆, 是线程共享的<ul><li>堆中存放创建的对象, 最容易内存溢出, 与垃圾回收有关</li><li>方法区存放类的元信息, 以及常量池, 会出现内存溢出</li></ul></li></ul></li><li>不同<code>JDK</code>版本之间运行时区域的区别是什么?<ul><li><code>JDK 6</code>方法区放在堆里面, 称为永久代, 字符串常量池放在方法区中</li><li><code>JDK 7</code>字符串常量池从方法区中独立, 放在了堆上</li><li><code>JDK 8</code>字符串常量池依然在堆里面, 但是方法区称为元空间, 从堆中独立</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;运行时数据区&lt;/h1&gt;
&lt;h2 id=&quot;分类&quot;&gt;分类&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;线程不共享: 程序计数器、&lt;code&gt;Java&lt;/code&gt;虚拟机栈、本地方法栈&lt;/li&gt;
&lt;li&gt;线程共享: 方法区、堆区&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;程序计数器&quot;&gt;程序计数器&lt;</summary>
      
    
    
    
    <category term="Java" scheme="https://sangs3112.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://sangs3112.github.io/tags/Java/"/>
    
    <category term="运行时数据区" scheme="https://sangs3112.github.io/tags/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/"/>
    
  </entry>
  
</feed>
