<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sangs Blog</title>
  
  
  <link href="https://sangs3112.github.io/atom.xml" rel="self"/>
  
  <link href="https://sangs3112.github.io/"/>
  <updated>2024-12-11T04:42:14.727Z</updated>
  <id>https://sangs3112.github.io/</id>
  
  <author>
    <name>Sangs</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL笔记_6</title>
    <link href="https://sangs3112.github.io/posts/ce24a37f.html"/>
    <id>https://sangs3112.github.io/posts/ce24a37f.html</id>
    <published>2024-12-11T04:42:14.727Z</published>
    <updated>2024-12-11T04:42:14.727Z</updated>
    
    <content type="html"><![CDATA[<h1>语句耗时</h1><ol><li>如果<code>select</code>长时间不返回，使用<code>show processlist</code>查看当前语句处于什么状态<ul><li>比如<code>MDL</code>写锁阻塞了别的<code>session</code>的读</li><li>可以查询是什么<code>session</code>阻塞，但是在<code>MySQL</code>启动时需要设置<code>performance_schema = ON</code>，这样会有<code>10%</code>的性能损失</li></ul></li></ol><ul><li><p><code>sys.schema_table_lock_waits</code>，查询这张表可以找到导致阻塞的<code>processid</code>，<code>kill</code>掉即可</p></li><li><p>还有可能被<code>flush</code>阻塞了，一般<code>flush</code>的两个语句是<code>flush table t with read lock</code>锁表<code>t</code>，<code>flush tables with read lock</code>锁所有的表，本身刷脏页的速度很快，但是可能<code>flush</code>命令被别的<code>session</code>阻塞了</p></li><li><p>或者别的线程占用写锁，那么申请<code>lock in share mode</code>的读锁就会被阻塞。通过查找<code>sys.innodb_lock_waits</code>表即可</p></li><li><p>如果在<code>RR</code>场景下，或者在一个事务中，使用<code>select</code>，如果此时别的<code>session</code>有一个<code>update</code>语句，<code>update</code>了一百万次，那么自己的<code>select</code>语句就会特别慢，因为是一致性读，会存在非常大的<code>undolog</code>需要不断查找，而如果使用<code>select in lock share mode</code>，就是当前读，速度就会很快。</p></li></ul><h1>幻读</h1><ol><li><code>RR</code>下，普通查询是快照读，幻读只有在当前读的环境下才会出现，因为快照读不会看到别人提交的数据。并且，如果别人修改了一行，在当前读的两次查询中，第二次查询才读到，那不是幻读。幻读只有是读到别人新插入的行</li></ol><ul><li><p>幻读会破坏加锁的语义，因为先对d=5的行加锁，在别的<code>session</code>中<code>insert</code>了一条d=5，a=1的行，并修改a=1的行将b改成2，这样的话，也就是修改了d=5的行，破坏了最初对d=5的行加锁的语义</p></li><li><p>幻读 + statement格式的<code>binlog</code>会导致数据不一致性，因为<code>binlog</code>是在<code>commit</code>的时候才会记录，</p></li><li><p>即便给所有的行都加上锁，也无法解决幻读的问题，因为原本不存在的行，无法加锁，所以即便给所有的行都加锁，也没有办法阻止插入新的行</p></li><li><p>所以需要加上间隙锁，在值和值的中间加锁，避免插入新的值</p></li><li><p>解决幻读，需要加行锁和间隙锁(<code>gap lock</code>，开区间)</p></li><li><p>行锁 + 间隙锁 = <code>next-key lock</code> (临键锁，左开右闭)</p></li></ul><h2 id="死锁">死锁</h2><ol><li>如果对不存在的一行加锁，比如id=9，不存在<br><code>select * from t where id = 9 for update</code><ul><li>那么本来应该加行锁+间隙锁，但是因为id=9不存在，所以只会加间隙锁</li></ul></li><li>本来<code>select for update</code>是两个排他锁，但是因为不存在这一行，所以两个<code>session</code>都可以对<code>id=9</code>这一行使用<code>select for update</code>，因为都是间隙锁，所以不会冲突</li><li>此时<code>session B</code>判断不存在这一行，尝试添加<code>id=9</code>的记录，但是因为<code>session A</code>中有间隙锁，所以被阻塞</li><li><code>session A</code>也判断不存在这一行，尝试添加<code>id=9</code>的记录，但是因为<code>session B</code>中存在间隙锁，所以被阻塞，导致死锁</li></ol><ul><li>所以<code>RR</code>会导致死锁，因为只有<code>RR</code>才有间隙锁，一般会设置为<code>RC + row</code>格式的<code>binlog</code>，这样可以解决死锁，并且不会出现数据日志不一致问题</li><li>一般在金融等，或者表备份的时候，才是<code>RR</code></li></ul><h1>加锁</h1><ol><li>加锁的基本单位是<code>next-key lock</code>，前开后闭</li><li>查找中访问的对象才会加锁</li><li>索引上等值查询，唯一索引的时候<code>next-key lock</code> 退化为行锁</li><li>等值查询，最右边的值不满足等值查询的时候，退化为间隙锁</li><li>唯一索引上范围查询会找到不满足条件的第一个值</li></ol><p>现在一张表，字段是<code>id，c, d</code>，<code>c</code>上有普通索引，<code>id</code>是主键</p><ul><li>内含数据<code>(0, 0, 0)(5, 5, 5)(10, 10, 10)(15, 15, 15)(20, 20, 20)(25, 25, 25)</code></li></ul><h2 id="举例1-等值查询间隙锁">举例1 - 等值查询间隙锁</h2><table><thead><tr><th style="text-align:center">sessionA</th><th style="text-align:center">session B</th><th style="text-align:center">session C</th></tr></thead><tbody><tr><td style="text-align:center">begin;</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">update t set d = d + 1 where id = 7;</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">insert into t values(8, 8, 8);</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">update t set d = d + 1 where id = 10;</td></tr></tbody></table><ul><li>对于<code>session A</code>表中没有<code>id=7</code>的行，加锁单位是临键锁，前开后闭，所以范围是<code>(5, 10]</code></li><li>id=7是等值查询，找到最后边的值10，不满足等值条件，所以退化为间隙锁，加锁范围就是<code>(5, 10)</code></li><li><code>session B</code>插入id=8就会被阻塞，但是<code>session C</code>插入id=10不会被锁</li></ul><h2 id="举例2-非唯一索引等值查询">举例2 - 非唯一索引等值查询</h2><table><thead><tr><th style="text-align:center">sessionA</th><th style="text-align:center">session B</th><th style="text-align:center">session C</th></tr></thead><tbody><tr><td style="text-align:center">begin;</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">select id from t where c = 5 lock in share mode;</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">update t set d = d + 1 where id = 5;</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">insert into t values(7, 7, 7);</td></tr></tbody></table><ul><li>加临键锁，对<code>(0, 5]</code></li><li>c是普通索引，所以会访问到右边第一个不满足的值为止，也就是查询到10， 所以<code>(5, 10]</code>加临键锁</li><li>c=5是等值查询，最右边一个值10不满足等值条件，退化为间隙锁<code>(5, 10)</code></li><li>访问到的对象才会加锁，覆盖索引不需要访问主键，所以主键索引不需要加锁，因此<code>session B</code>可以完成，<code>session C</code>插入<code>(7, 7, 7)</code>会被阻塞</li><li><code>lock in share mode</code>只会锁覆盖索引，但是<code>for update</code>会判断你要更新，就会给主键索引上满足条件加行锁</li></ul><h2 id="举例3-主键索引范围查询">举例3 - 主键索引范围查询</h2><table><thead><tr><th style="text-align:center">sessionA</th><th style="text-align:center">session B</th><th style="text-align:center">session C</th></tr></thead><tbody><tr><td style="text-align:center">begin;</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">select * from t where id &gt;= 10 and id &lt; 11 for update;</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">insert into t values(8, 8, 8);</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">insert into t values(13, 13, 13);</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">update t set d = d + 1 where id = 15;</td></tr></tbody></table><ul><li>先找到<code>id = 10</code>，<code>next-key lock (5, 10]</code>，但是唯一索引会退化为行锁</li><li>但是范围查找，找到id=15停止，所以会有临键锁<code>(10, 15]</code></li><li>所以B插入<code>(8, 8, 8)</code>可以通过，插入<code>(13, 13, 13)</code>被阻塞；C更新15也被阻塞</li></ul><h2 id="举例4-非唯一索引范围查询">举例4 - 非唯一索引范围查询</h2><table><thead><tr><th style="text-align:center">sessionA</th><th style="text-align:center">session B</th><th style="text-align:center">session C</th></tr></thead><tbody><tr><td style="text-align:center">begin;</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">select * from t where c &gt;= 10 and c &lt; 11 for update;</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">insert into t values(8, 8, 8);</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">update t set d = d + 1 where c = 15;</td></tr></tbody></table><ul><li>查找c = 10的时候，临键锁<code>(5, 10]</code>，不是唯一索引，不会退化为行锁</li><li><code>session A</code>加上了两个临键锁<code>(5, 10]</code>和<code>(10, 15]</code></li><li>B插入<code>(8, 8, 8)</code>阻塞</li></ul><h2 id="举例5-唯一索引范围查询bug">举例5 - 唯一索引范围查询bug</h2><table><thead><tr><th style="text-align:center">sessionA</th><th style="text-align:center">session B</th><th style="text-align:center">session C</th></tr></thead><tbody><tr><td style="text-align:center">begin;</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">select * from t where id &gt; 10 and id &lt;= 15 for update;</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">update t set d = d + 1 where id = 20;</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">insert into t values(16, 16, 16);</td></tr></tbody></table><ul><li>A是范围查询，索引id加到<code>(10, 15]</code>临键锁，id是唯一索引，所以判断到id=15结束</li><li>但是会访问到第一个不满足条件的值为止，所以会找到id=20，范围查询，所以会加上<code>(15, 20]</code>的临键锁</li><li>因此B更新20会阻塞，C插入16也会阻塞</li></ul><h2 id="举例6-非唯一索引存在等值">举例6 - 非唯一索引存在等值</h2><p>比如同时有两行c=10，分别是<code>(10, 10, 10)</code>，和<code>(30, 10, 30)</code></p><ul><li>非唯一索引上包含主键值，所以不会重复</li></ul><table><thead><tr><th style="text-align:center">sessionA</th><th style="text-align:center">session B</th><th style="text-align:center">session C</th></tr></thead><tbody><tr><td style="text-align:center">begin;</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">delete from t where c = 10;</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">insert into t values(12, 12, 12);</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">update t set d = d + 1 where c = 15;</td></tr></tbody></table><ul><li>A遍历找到第一个c=10的记录，所以临键锁加在<code>(5 5, 10 10]</code>上</li><li>A向右查找，碰到第一个不满足条件的行，也就是<code>15 15</code>停止，等值查询，退化为<code>10 10</code>到<code>15 15</code>的行锁</li><li>所以最后是<code>(5 5, 10 10]</code>临键锁，<code>(10 10, 15 15)</code>行锁，因此B插入12会被阻止，C修改15会通过</li></ul><h2 id="举例7-limit加锁">举例7 - limit加锁</h2><table><thead><tr><th style="text-align:center">sessionA</th><th style="text-align:center">session B</th></tr></thead><tbody><tr><td style="text-align:center">begin;</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">delete from t where c = 10 limit 2;</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">insert into t values(12, 12, 12);</td></tr></tbody></table><ul><li>因为有<code>limit 2</code>，所以遍历到<code>10 30</code>后，就已经满足两条了，循环结束</li><li>A加锁范围就是<code>(5 5, 10 10]</code>临键锁<code>(10 10, 10 30]</code>临键锁</li><li>B插入12通过</li><li>所以删除的时候可以加<code>limit</code>，限制删除的条数，操作更安全。<ul><li>但是唯一索引上删除不需要，因为唯一索引本身就只加行锁</li><li>可能更适合普通索引，但是数据是唯一的情况</li></ul></li></ul><h2 id="举例8-死锁">举例8 - 死锁</h2><table><thead><tr><th style="text-align:center">sessionA</th><th style="text-align:center">session B</th></tr></thead><tbody><tr><td style="text-align:center">begin;</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">select id from t where c = 10 lock in share mode;</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">update t set d = d + 1 where c = 10;</td></tr><tr><td style="text-align:center">insert into t values (8, 8, 8)</td><td style="text-align:center"></td></tr></tbody></table><ul><li>A在c上加了<code>(5, 10]</code>临键锁和<code>(10, 15)</code>间隙锁</li><li>B要在c上加<code>(5, 10]</code>临键锁，所以等待A释放</li><li>A 想插入8，需要加锁，等待B释放，死锁</li><li>最后B回滚</li><li>B的临键锁没有申请成功，但是B加锁<code>(5, 10]</code>先加间隙锁，加锁成功，再加c=10的行锁，阻塞，两段执行</li></ul><h2 id="总结">总结</h2><ul><li>RR才有间隙锁，并且两阶段提交，事务<code>commit</code>了，锁释放</li><li>RC没有间隙锁，并且语句执行完就会释放不满足条件的行的行锁</li><li>RC在外键也会有间隙锁</li></ul><h1>优化</h1><ul><li><code>show variables like '%connections%;查看max_connections</code>，也就是最大连接数，超过最大连接数的就会被阻止，最大连接数不是越大越好。</li></ul><ol><li>处理掉占用连接但是没有工作的线程<ul><li><code>show variables like 'wait_timeout';</code>查看超时时间，超过时间以后就会断开连接</li><li>可以使用<code>kill connection + id</code>，但是这样客户端不会马上知道，只有在发起下一个请求以后才会报错，就变成了<code>MySQL</code>一直都没有恢复，但是再次 调用接口就可以访问了</li></ul></li><li>减少连接消耗<ul><li>用<code>–skip-grant-tables</code>跳过权限验证，但是<strong>风险极高，不建议使用</strong>，找回密码可以用</li><li><strong>8.0版本</strong>如果使用跳过权限验证，会同时<code>--skip-networking</code>打开这个，保证数据库只有本地访问</li></ul></li><li>性能问题导致短链接增加<ul><li>慢查询<ul><li>索引没设计好<ul><li><strong>5.6版本后</strong>可以使用<code>Online DDL</code>创建索引，<code>alert table</code>即可</li><li>如果一主一备，在从库处理，<code>set sql_log_bin=off</code>，不写<code>binlog</code>，加索引</li><li>主备切换</li><li>再在从库<code>set sql_log_bin=off</code>，加索引</li></ul></li><li>语句有问题<ul><li>使用存储过程<code>query_rewrite</code>重写某一个语句</li></ul></li><li>选错索引<ul><li>使用<code>query_rewrite</code>加上索引即可，或者语句加索引</li></ul></li><li>可以在上线前处理好，上线前将<code>slow log</code>打开，<code>long_query_time=0</code>记录查询语句</li><li>测试表模拟线上数据，回归测试</li><li>留意<code>row_examined</code>数据</li><li>全量回归测试可以使用开源工具<code>pt-query-digest</code></li></ul></li><li><code>QPS</code>暴增<ul><li>如果是全新业务有<code>bug</code>，下掉业务，数据库端去除白名单</li><li>新功能是单独数据库用户，删除用户，断开现有连接</li><li>如果和现有业务部署在一起，查询重写功能重写语句，压力最大的<code>SQL</code>直接<code>select 1</code>返回<ul><li>但是会有误伤，如果别的业务也用了这个SQL，或者这个语句还有别的用处，都会导致其他业务失败</li></ul></li></ul></li><li>更新语句</li></ul></li></ol><h1>数据更新</h1><ul><li><p><code>binlog</code>在事务执行时写入<code>binlog cache</code>，事务提交时写入<code>binlog</code>，清空<code>cache</code></p></li><li><p><code>binlog_cache_size</code>控制<code>cache</code>大小，超过大小的暂时写入磁盘</p></li><li><p>多个线程有自己的<code>binlog cache</code>，但是共用一个<code>binlog</code></p></li><li><p><code>write</code>是写入<code>cache</code>，速度快，<code>fsync</code>是写<code>binlog</code>文件，<code>sync_binlog</code>参数控制时机</p><ul><li><code>sync_binlog = 0</code>，每次提交只<code>write</code>，不<code>fsync</code></li><li><code>sync_binlog = 1</code>每次提交都会<code>fsync</code></li><li><code>sync_binlog = N</code>(<code>N &gt; 1</code>)，每次都<code>write</code>，累计<code>N</code>个事务再<code>fsync</code></li><li>IO非常大的话，可以适当调大这个值，<code>100 - 1000</code>，但是如果重启了，就会丢失N条<code>binlog</code>，如果容错率很低，不能设置为1</li></ul></li><li><p><code>redo log</code>三种状态，分别是<code>redo log buffer</code>，<code>write</code>到<code>page cache</code>，没有持久化和<code>fsync</code>到磁盘，<code>innodb_flush_log_at_trx_commit</code>控制</p><ul><li><code>= 0</code> 表示每次都只保存再<code>buffer</code>中</li><li><code>= 1</code> 表示每次提交都持久化到磁盘</li><li><code>= 2</code> 表示每次提交都<code>write</code>到<code>page cache</code></li><li><code>InnoDB</code>后台线程每隔1s都会将<code>redo log buffer</code>中的内容<code>write</code>到<code>pagecache</code>再<code>fsync</code>到磁盘，所有的线程共用一个<code>redo log buffer</code>，与<code>binlog</code>不同，所以没有提交的事务的<code>redo log</code>，也有可能被持久化到磁盘</li><li>同样，如果<code>redo log buffer</code>占用<code>innodb_log_buffer_size</code>即将到达一半，就会触发主动写盘，但是只<code>write</code>，没有<code>fysnc</code></li><li>如果并行事务，并且<code>innodb_flush_log_at_trx_commit=1</code>，那么别的事务提交的时候，会把自己没有提交的<code>redo log</code> 持久化到磁盘</li><li>如果=1，那么<code>prepare</code>阶段就会持久化一次，所以只需要每隔1s的刷盘，崩溃恢复的逻辑，只需要<code>binlog</code>写入磁盘，<code>redo log prepare write</code>了，就不需要<code>fsync</code>了</li><li>如果<code>sync_binlog=1， innodb_flush_log_at_trx_commit=1</code>，那么事务提交前，现需要等两次刷盘，一次是<code>redo log</code>的<code>prepare</code>，一次是<code>binlog</code></li><li>也就是如果<code>MySQL``TPS</code>两万，就会有四万次写磁盘，所以使用了组提交的方法减少写盘。</li></ul></li><li><p>日志逻辑序列号是<code>LSN</code>，单调递增，对应<code>redo log</code>的写入点，写入长度为<code>len</code>，那么<code>LSN + len</code>，可以避免多次重复提交<code>redo log</code></p><ul><li>比如三个事务同时在<code>redo log buffer</code>中，事务1写盘的时候，会带上事务23写盘，这样<code>LSN</code>之前的事务都完成了写盘，只需要看<code>LSN</code>后的事务即可</li><li><code>binlog</code>也是有组提交，但是效果不如<code>redo log</code>，因为<code>redo log</code>时间较短，所以<code>binlog</code>等不到那么多</li></ul></li></ul><ol><li>设置<code>binlog_group_commit_sync_delay</code>和<code>binlog_group_commit_sync_no_delay_count</code>，满足一个即可，减少<code>binlog</code>的写盘次数，故意等待时间，跟<code>sync_binlog</code>不同，<code>sync</code>是没有写盘就<code>commit</code>事务，但是这两个参数是直到写盘了，才<code>commit</code>事务，会增加响应时间，但是不会像<code>sync</code>一样丢数据<ul><li><code>innodb_flush_log_at_trx_commit</code>不建议为0，这样<code>redo log</code>只会在内存中，宕机了会丢数据</li><li><code>innodb_flush_log_at_trx_commit</code>设置成2，性能差不多，只有在主机关机才会丢数据，如果服务宕机，重启以后数据还在</li></ul></li></ol><ul><li><p>binlog不能中断，必须连续写，所以每个线程一个<code>binlog cache</code>，不然主从不一致；<code>redo log</code>甚至可以跟着别的线程一块写，所以都是一个<code>redo log buffer</code></p></li><li><p>所以可以<code>sync_binlog=1,innodb_flush_log_at_trx_commit=2</code>,这样<code>redo log</code>如果丢失了，就通过<code>binlog</code>恢复就可以</p></li><li><p>一般设置非双一，就是<code>innodb_flush_log_at_trx_commit=2</code>、<code>sync_binlog=1000</code></p><ul><li>业务高峰期，会有预案主库改写为非双1</li><li>从库延迟，为了让从库赶上主库，减少<code>binlog</code>生成频率，赶上了可以改回来</li><li>用备份恢复主库的副本，也就是使用<code>binlog</code>的时候</li><li>批量导入数据也可以修改，不然<code>binlog=row</code>产生内容太多</li></ul></li><li><p>主从首先保证了最终一致性，只要主库正确提交，就有<code>binlog</code>，那么从库正常就会重放<code>binlog</code></p></li><li><p>主从延迟就是从库执行完的时间点-主库执行完的时间点</p></li><li><p>从库上执行<code>show slave status</code>，可以看到<code>seconds_behind_master</code>，表示延迟了多少</p></li><li><p>主从延迟最主要是从库消费<code>relay log</code>的速度比主库生成<code>binlog</code>的速度更慢</p></li><li><p>主从延迟来源</p><ul><li>从库性能比主库机器性能差(但是现在一般不会)</li><li>从库压力大，CPU资源占用较多，导致重放<code>relay log</code>速度变慢<ul><li>一主多从，让多个从库分担压力</li><li><code>binlog</code>输出到外部，比如<code>Hadoop</code>，让外部提供查询能力</li></ul></li><li>大事务，比如一个事务再主库上执行了十分钟，就延迟了十分钟</li><li>大表上<code>DDL</code></li></ul></li></ul><h2 id="主从复制">主从复制</h2><ol><li>5.6版本之前，支持单线程，但是会导致应用日志较慢，造成延迟</li><li>多线程就是拆<code>sql thread</code>为多个线程<br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/MySQL/45_sqlthread.png" alt="45_sqlthread"><ul><li>比如<code>coordinator</code>就是原来的<code>sql thread</code>，但是不更新了，只是负责读中转日志，并分发日志，<code>work</code>线程才更新日志，<code>worker</code>线程个数根据<code>slave_parallel_workers</code>决定，一般32核设置8-16即可，</li><li><code>coordinator</code>分发规则：<ul><li>不能更新覆盖，同一行的两个事务必须在同一个<code>worker</code>中</li><li>不能拆分事务，同一个事务必须在同一个<code>worker</code>中</li></ul></li></ul></li><li>按表分发策略<ul><li>如果两个事务更新不同的表，就可以分发到不同的<code>worker</code>中</li><li>如果事务跨表，需要将两张表一起考虑</li><li>每个<code>worker</code>中对应一张<code>hash</code>表，保存当前<code>worker</code>中正在执行的事务里面涉及的表，值是多少个事务在更新这个表</li><li>如果<code>coordinator</code>收到事务T，判断其中修改的表<ul><li>没有<code>worker</code>中包含这些表，那就分给最空闲的<code>worker</code></li><li>如果跟多于一个<code>worker</code>冲突，就等待</li><li>如果只跟一个<code>worker</code>冲突，那就分给这个<code>worker</code></li></ul></li><li>所以如果热点表，就变成了单线程，如果负载均衡，就很好解决问题</li></ul></li><li>按行分发策略<ul><li>需要<code>binlog = row</code></li><li>必须有主键，不能有外键</li><li>但是对于大事务，耗费内存，耗费CPU资源更大</li></ul></li><li>5.6版本，按库分发并行</li><li>5.7版本<code>slave-parallel-type</code>控制并行策略，配置为<code>DATABASE</code>就是按库并行，配置<code>LOGICAL_CLOCK</code><ul><li>同处于<code>prepare</code>的事务，备库可以并行</li><li>处于<code>prepare</code>和<code>commit</code>的事务可以并行</li></ul></li></ol><p>一主多从基本架构<br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/MySQL/45_ms.png" alt="45_ms"></p><ol><li>主库负责写入和一部分读，从库负责读<br>切换主库的时候需要找同步位点，5.6版本使用<code>GTID</code>，全局事务ID，在事务提交时生成<br>两个部分，格式为<code>server_uuid:gno</code><ul><li><code>server_uuid</code>是实例启动产生的，全局唯一</li><li><code>gno</code>是整数，初始值为1，每次提交事务的时候分配给这个事务，就加1</li><li>启动<code>GTID</code>在启动时加上参数<code>gtid_mode=on</code> 和 <code>enforce_gtid_consistency=on</code>即可<br>使用基于<code>GTID</code>的主备切换，就不需要指定位点，因为位点是不精确的。所以建议使用基于<code>GTID</code>的主从复制</li></ul></li></ol><h3 id="主从延迟怎么解决">主从延迟怎么解决</h3><ol><li><p>强制走主库方案；</p><ul><li>比如交易平台，卖家发布商品以后，马上返回主页面，看商品是否发布成功，这个就强制走主库，因为需要拿到最新的结果</li><li>如果是买家，晚几秒看到商品也可以接受，就走从库</li></ul></li><li><p><code>sleep</code>方案</p><ul><li><code>sleep(1)</code>大部分同步1s内能搞定，但是不太稳妥</li></ul></li><li><p>判断主备无延迟方案</p><ol><li><code>show slave status中的seconds_behind_master</code>是否等于0<ul><li>单位是秒，如果精度不够，可以使用位点和<code>GTID</code></li></ul></li><li><code>Master_Log_File</code>和<code>Read_Master_Log_Pos</code>表示读到主库的最新位点<br><code>Relay_Master_Log_File</code>和<code>Exec_Master_Log_Pos</code>表示备库执行的最新位点<br>如果<code>Master_Log_File=Relay_Master_Log_File&amp;&amp;Read_Master_Log_Pos=Exec_Master_Log_Pos</code>表示日志同步完成</li><li><code>GTID</code>中<br><code>Auto_Position=1</code>表示主备使用了<code>GTID</code>协议<br><code>Retrieved_Gtid_Set</code>是备库收到的所有日志<code>GTID</code>集合<br><code>Executed_Gtid_Set</code>是备库已经执行完的<code>GTID</code>集合<br>如果两个集合相同，则日志同步完成</li><li>但是上面的方法是判断备库收到的<code>binlog</code>已经执行完了，但是实际上可能主库有<code>binlog</code>，但是备库还没有收到，这时需要使用半同步复制</li><li>业务高峰期，主库位点和<code>GTID</code>更新很快，位点判断就会一直不成立，那么从库就一直都无法响应</li></ol></li><li><p>配合<code>semi-sync</code>方案</p><ul><li>牺牲一定可用性，保持一致性</li><li>但是因为半同步只要一个从库同步就返回<code>ack</code>，实际上请求可能打到别的没有同步的从库上</li><li>所以半同步配合位点方案，会有问题<ul><li>一主多从，会有过期读的问题</li><li>如果一直有延迟，就一直无法<code>select</code>，但是实际上不需要等待到完全没有延迟，而是只要一个事务完成以后，<code>select</code>到哪个事务即可，不需要等待其他事务也同步完</li></ul></li></ul></li><li><p>等主库位点方案</p><ul><li><code>select master_pos_wait(file, pos[, timeout]);</code><ul><li><code>file pos</code>是主库上的文件名和位置</li><li>从库上执行</li><li><code>timeout</code>可选，表示超时</li><li>返回一个正整数<code>M</code>，表示命令开始执行，到应用完<code>file</code>和<code>pos</code>表示的<code>binlog</code>位置，一共执行了多少个事务</li><li>如果备库挂了，那就返回<code>NULL</code></li><li>如果超时，返回<code>-1</code></li><li>如果执行时，已经执行过这个位置了，返回0</li></ul></li><li>具体流程<ul><li>一个事务执行完，马上在主库上执行<code>show master status</code>得到主库执行到的<code>File</code>和<code>Pos</code>(不需要完全精确)</li><li>选一个从库查询</li><li>从库上执行<code>select master_pos_wait(File, Pos, 1);</code></li><li>如果返回&gt;=0，则再这个从库上执行查询语句</li><li>否则就去主库查询</li></ul></li><li>所以如果不允许过期读的情况出现，那么就超时放弃，或者转到主库查询，并做限流</li></ul></li><li><p>等 <code>GTID</code> 方案</p><ul><li><code>WAIT_FOR_EXECUTED_GTID_SET(gtid_set[, timeout])</code>，超时时间默认为0，如果为0，表示一直等待<ul><li>语句作用：等待，直到这个库执行的事务包含传入的<code>gtid_set</code>，返回0</li><li>超时返回1</li></ul></li><li>5.7版本后，不需要主动执行<code>show master status</code>，而是更新以后返回事务的<code>GTID</code>，减少一次查询<ul><li><code>session_track_gtids = OWN_GTID</code></li><li>通过API从<code>mysql_session_track_get_first</code>解析<code>GTID</code>即可</li></ul></li><li>具体流程<ul><li>事务完成，接受到事务的<code>GTID，gtid1</code></li><li>选一个从库查询，执行<code>WAIT_FOR_EXECUTED_GTID_SET(gtid1, 1)</code></li><li>返回0就在这个从库查询</li><li>否则去主库查询</li></ul></li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;语句耗时&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;如果&lt;code&gt;select&lt;/code&gt;长时间不返回，使用&lt;code&gt;show processlist&lt;/code&gt;查看当前语句处于什么状态
&lt;ul&gt;
&lt;li&gt;比如&lt;code&gt;MDL&lt;/code&gt;写锁阻塞了别的&lt;code&gt;sessi</summary>
      
    
    
    
    <category term="MySQL" scheme="https://sangs3112.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://sangs3112.github.io/tags/MySQL/"/>
    
    <category term="主从延迟解决" scheme="https://sangs3112.github.io/tags/%E4%B8%BB%E4%BB%8E%E5%BB%B6%E8%BF%9F%E8%A7%A3%E5%86%B3/"/>
    
    <category term="幻读" scheme="https://sangs3112.github.io/tags/%E5%B9%BB%E8%AF%BB/"/>
    
    <category term="死锁" scheme="https://sangs3112.github.io/tags/%E6%AD%BB%E9%94%81/"/>
    
    <category term="加锁判断" scheme="https://sangs3112.github.io/tags/%E5%8A%A0%E9%94%81%E5%88%A4%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>MySQL笔记_7</title>
    <link href="https://sangs3112.github.io/posts/b92393e9.html"/>
    <id>https://sangs3112.github.io/posts/b92393e9.html</id>
    <published>2024-12-11T04:42:14.727Z</published>
    <updated>2024-12-11T04:42:14.727Z</updated>
    
    <content type="html"><![CDATA[<h1>主备</h1><ol><li>主备切换流程<br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/MySQL/45_ms.png" alt="45_ms"><br>状态1，客户端读写都只访问节点A，B是从库，同步A的更新，保证AB数据相同<br>需要切换的时候，就变成状态2，客户端只访问节点B</li></ol><ul><li>状态1不会操作B，但是建议将B设置为<code>read only</code><ul><li>防止他人误操作B</li><li>防止切换逻辑出现双写的问题</li><li>判断访问节点的角色</li><li><code>read only</code>对超级管理员无效，所以可以同步更新的线程有超级权限</li></ul></li></ul><ol start="2"><li><p><code>binlog statement</code></p><ul><li><code>statement</code>就是记录<code>SQL</code>语言，甚至会把注释也都记录进去</li><li><code>statement</code>的格式下，<code>delete</code>带有<code>limit</code>，就是<code>unsafe</code>的，会导致主从不一致</li><li>删除条件的两个都有索引，如果主从版本不一，可能选择的索引不一致，所以顺序不同，导致<code>delete</code>的东西不同，本质上就是主从库可能<code>delete</code>的时候用到的索引不同，因为有<code>limit</code>存在，比如只删一条数据，就会导致数据不一致。</li></ul></li><li><p><code>binlog row</code></p><ul><li><code>row</code>里面多了<code>Table_map</code>和<code>Delete_rows</code></li><li><code>Table_map</code>用于说明接下来操作哪个库哪个表</li><li><code>Delete_rows</code>用于定义删除行为</li><li>实际上，<code>row</code>虽然会占用空间，但是有助于恢复数据，比如误删，可以根据<code>binlog</code>看到，直接插入即可；误增误改都可以这么处理</li></ul></li><li><p><code>binlog mixed</code></p><ul><li>如果有大量的删，那么<code>row</code>就会记录大量的内容，导致磁盘IO变多，占用空间变多</li><li><code>statement</code>就不会，只会有一条语句，但是在某些情况下，会导致不一致</li><li>所以<code>mixed</code>判断，如果不会导致不一致就用<code>statement</code>，如果可能会不一致，就切换到<code>row</code></li><li>这个格式用的不多</li></ul></li></ol><h2 id="双M">双M</h2><p><img src="https://gitee.com/sang3112/blog_imgs/raw/master/MySQL/45_2m.png" alt="45_2m"></p><ul><li>建议设置<code>log_slave_updates=ON</code>，从库执行完<code>relay log</code>以后也生成<code>binlog</code></li><li>A更新事务，<code>binlog</code>记录A的<code>server id</code></li><li>B接收到<code>binlog</code>，更新，并记录<code>server id</code>也就是A的<code>server id</code></li><li>再传回A，A判断<code>server id</code>等于自身，所以就不会处理日志</li></ul><h1>并发连接和并发查询</h1><ul><li>线程等待锁的时候，并发线程计数减一</li><li>因为等待锁的时候不吃cpu资源</li><li><code>innodb_thread_concurrency</code>设置最大并发线程数</li></ul><h1>检测MySQL</h1><ul><li><p>再<code>mysql</code>库中创建一个<code>health_check</code>表，只放一行数据，定期执行<br><code>mysql&gt; select * from mysql.health_check; </code></p></li><li><p>可以检测因为并发线程过多导致的数据库不可用的问题</p><ul><li><code>select 1</code>不行，因为不涉及<code>InnoDB</code>引擎，就算超出限制也会返回</li><li>但是这样的话，如果<code>binlog</code>磁盘占满了，也会阻塞<code>commit</code>事务，但是不会阻塞返回，所以这种方法无法判断是否存在磁盘满的情况</li></ul></li><li><p>更新判断：放一个<code>timestamp</code>字段，表示最后一次执行检测的时间：<code>mysql&gt; update mysql.health_check set t_modified=now();</code></p><ul><li>对主从库都需要执行更新检测</li><li>为了主备更新不冲突，再<code>mysql.health_check</code>上存入多行数据，用两个库的serverid作为主键</li><li>但是可能IO已经100%了，此时正好执行到<code>update</code>语句，那么就无法判断这种情况，不能及时切换</li><li>可以通过检测<code>performance_schema</code>里面<code>redolog</code>和<code>binlog</code>的写入时间判断是否存在问题，但是性能损耗10%</li></ul></li></ul><h1>误删数据</h1><ul><li><code>delete</code>误删某一行，那么就用<code>binlog</code>恢复即可，需要<code>binlog=row</code>，<code>binlog_row_image=FULL</code></li><li>可以将<code>sql_safe_updates=ON</code>预防，如果<code>delete</code>或者<code>update</code>没有写<code>where</code>条件，或者<code>where</code>条件没有索引，就会报错</li><li>如果需要删全表，则使用<code>truncate table</code> 或者 <code>drop table</code></li><li>但是如果<code>drop</code>或者<code>truncate</code>，无法使用<code>binlog</code>恢复，只能全量备份+增量恢复</li><li>如果对于核心库，可以使用延迟备份，减慢<code>binlog</code>到从库执行的时间，避免被删</li></ul><h1>kill</h1><ul><li>两个<code>kill</code>命令，<code>kill query + id</code> 和 <code>kill connection + id</code></li><li>发送<code>kill</code>命令以后，<code>session</code>运行状态改为<code>THD::KILL_QUERY</code>，并给<code>session</code>发送一个信号</li><li><code>kill</code>无效<ul><li>线程没有执行到判断线程状态的逻辑</li><li>终止逻辑耗时较长<ol><li>大事务被<code>kill</code>，需要回滚</li><li>大事务回滚包含较大的临时文件，压力过大，耗时长</li><li><code>DDL</code>最后阶段</li></ol></li><li><code>ctrl+c</code>命令是服务器开启一个新的线程发送<code>kill query</code>命令</li></ul></li></ul><h1>全表扫描</h1><ol><li>如果扫描一张大表，就获取一行数据，存储到<code>net_buffer</code>中，内存大小由<code>net_buffer_length</code>控制，默认<code>16K</code></li><li>重复获取行，直到<code>net_buffer</code>写满，发送</li><li>发送成功清空<code>net_buffer</code>，重复</li><li>发送返回<code>EAGAIN</code>或者<code>WSAEWOULDBLOCK</code>，表示本地网络栈写满，进入等待，直到网络栈重新可写，再继续等待</li></ol><ul><li>所以如果客户端接收的慢，事务执行时间就会变长<ul><li>可以使用<code>mysql_store_result</code>，将收到的内容存入客户端内存，加快接收速度</li><li>但是如果是大查询，就会占用大量内存，就需要使用<code>mysql_use_result</code></li></ul></li></ul><p><code>innodb_buffer_pool_size</code>一般设置为可用物理内存的60%-80%，线上服务的内存命中率需要达到99%，可以通过<code>show engine innodb status</code>查看<code>Buffer pool hit rate</code></p><ul><li><code>InnoDB</code>淘汰数据页用的<code>LRU</code>的改进<ul><li>因为如果对一个不常用的表使用全表扫描，这时候就会将别的业务正在使用的内存给顶掉，导致别的业务缓存失效</li><li>所以<code>InnoDB</code>按照<code>5:3</code>的比例将<code>LRU</code>分为了<code>young</code>和<code>old</code>区，<br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/MySQL/45_youngold.png" alt="45_youndold"></li><li>如图，状态1，访问P3，P3在<code>young</code>区，按照<code>LRU</code>，移到链表头部，变成状态2</li><li>此时，要插入新的数据页，淘汰<code>Pm</code>，但是新的数据页Px插入<code>LRU_old</code>处</li><li>处于<code>old</code>区的数据页，每次被访问都要做下面的判断：<ul><li>如果数据页存在超过1s，就移动到链表头</li><li>少于1s，位置不变，<code>innodb_old_blocks_time=1000</code>，表示1s</li><li>这样扫描大表也用到了<code>buffer pool</code>，但是对于<code>young</code>区没有影响</li></ul></li></ul></li></ul><h1>join</h1><ul><li><code>join</code>应该将小表作为驱动表，大表作为被驱动表，因为<code>InnoDB</code>只会用被驱动表上的索引，对于驱动表，也就是<code>join</code>前面的表，用的是全表扫描。如果驱动表是行数N，被驱动表M被驱动表上索引查询，所以如果回表，就需要在普通索引和主键索引上都查询一次，那么时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">2log_2(M)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mclose">)</span></span></span></span>,驱动表上查询<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>行，所以总共是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>+</mo><mn>2</mn><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N+2log_2(M)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mclose">)</span></span></span></span>，这就是<code>NLJ</code></li><li>这是仅限于可以使用被驱动表的索引，如果被驱动表没有索引，就会使用<code>BNL</code><ul><li>将驱动表的数据取出放到<code>join_buffer</code>中，</li><li>将被驱动表的每一行跟<code>join_buffer</code>中的数据对比，满足条件放到结果集中</li><li>总时间复杂度就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>M</mi></mrow><annotation encoding="application/x-tex">NM</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">NM</span></span></span></span></li><li>这样的话，时间复杂度就是两个表的全表扫描<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>+</mo><mi>M</mi><mo>+</mo><mi>N</mi><mi>M</mi></mrow><annotation encoding="application/x-tex">N + M + NM</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">NM</span></span></span></span></li><li>如果驱动表较大，无法放到<code>join_buffer</code>中，就会分段放，<code>join_buffer_size</code>默认<code>256k</code><ul><li>就会将驱动表放一部分行，直到<code>join_buffer</code>放满为止，然后将被驱动表取出比对，再清空<code>join_buffer</code>，放驱动表的下一部分数据，直到比对结束</li><li>假设N行驱动表分<code>K</code>段，<code>N</code>越大，<code>K</code>越大，所以<code>K</code>表示为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo>×</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">\lambda \times N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">λ</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo>∈</mo><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\lambda \in (0, 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">λ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li><li>扫描行数就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>+</mo><mi>λ</mi><mo>×</mo><mi>N</mi><mo>×</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">N + \lambda \times N \times M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">λ</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span></li><li>判断<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>∗</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">N*M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>次</li><li>所以应该让小表当驱动表</li></ul></li></ul></li><li>如果<code>join</code>很慢，就把<code>join_buffer_size</code>改大一些</li><li>尽量让<code>join</code>走<code>NLJ</code>，并且警惕<code>explain</code>检查字段是否出现<code>Block Nested Loop</code></li><li>在决定哪个表做驱动表的时候，应该是两个表按照各自的条件过滤，过滤完成之后，计算参与<code>join</code>的各个字段的总数据量，数据量小的那个表，就是“小表”，应该作为驱动表。</li><li><code>join</code>比强行拆分单表查询性能更好</li></ul><h2 id="Multi-Range-Read-MRR">Multi-Range Read(MRR)</h2><ul><li>如果一张表有主键id索引，普通索引a，通过a索引扫描，有时候需要回表查询主键</li><li>此时a虽然是在索引上顺序查询的，但是因为需要回表，所以在主键id索引上就是乱序查的。但是大都数数据都是通过主键自增顺序插入得到的，所以可以认为按照主键递增顺序查询的话对磁盘接近顺序读，性能会更好</li><li>所以MRR就是先根据索引a找到数据，放到<code>read_rnd_buffer</code>中，(随机读缓冲区)，将缓冲区中的数据按照id递增排序，然后依次在主键中查找。大小由<code>read_rnd_buffer_size</code>控制，如果<code>buffer</code>放满了就会先执行排序，然后查找id返回结果，清空<code>buffer</code>再进行下一步</li><li>如果想要使用<code>MRR</code>，<code>set optimizer_switch=&quot;mrr_cost_based=off&quot;</code>，因为优化器不会判断时使用<code>MRR</code>，所以设置为<code>off</code>，固定使用<code>MRR</code></li></ul><h2 id="Batched-Key-Access-BKA">Batched Key Access(BKA)</h2><ul><li><p>当使用<code>join</code>的时候，驱动表一行一行到被驱动表比对，用不上<code>MRR</code></p></li><li><p>现在将驱动表的内容拿出来，放到<code>join_buffer</code>中，原本<code>join_buffer</code>在<code>BNL</code>里才有暂存驱动表的数据，在<code>NLJ</code>没有用，现在<code>NLJ</code>也会用到</p></li><li><p>然后通过<code>join_buffer</code>跟被驱动表比对</p></li><li><p><code>set optimizer_switch='mrr=on,mrr_cost_based=off,batched_key_access=on';</code>通过这条语句开启<code>MRR</code>和<code>BKA</code>，因为<code>BKA</code>基于<code>MRR</code></p></li><li><p>如果<code>join</code>使用<code>BNL</code>，多次扫描一个冷表，语句执行超过1s，再次扫描冷表就会将数据页放到LRU头部</p></li><li><p>对应的情况就是冷表的数据量小于<code>buffer pool</code>的<code>3/8</code>，能够完全放到<code>old</code>区中。</p></li><li><p>如果冷表很大，业务正常访问的数据页，就没有机会进入<code>young</code>区，这是因为正常访问的数据页要进入<code>young</code>区的话，需要隔1s再被访问到，但是冷表很大，<code>old</code>区在1s内就淘汰了正常数据页，就会导致<code>buffer pool</code>没有这个数据</p></li><li><p>所以大表<code>JOIN</code>不仅会影响IO，IO在<code>join</code>结束也就恢复了，还会影响<code>buffer</code>，需要后面慢慢恢复</p></li></ul><h2 id="BNL对系统的影响">BNL对系统的影响</h2><ol><li>多次扫描被驱动表，影响IO</li><li><code>join</code>条件需要执行<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>×</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">M \times N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>次对比，大表占用非常多资源</li><li>导致<code>buffer pool</code>热数据被淘汰，影响内存利用率</li></ol><ul><li><p>可以尝试给被驱动表添加索引</p></li><li><p>如果不适合加索引，比如次数比较少，添加索引不划算。可以建临时表，给临时表加索引，再<code>join</code>即可，优化很好</p></li><li><p>或者自己在业务端实现<code>hash join</code>，会比临时表优化的还好，<code>select * from t1</code>驱动表t1所有数据存入<code>hash</code>结构，比如set之类，<code>select * from t2 where b&gt;=1 and b&lt;=2000</code>获取被驱动表的<code>2000</code>条数据，然后一条一条在业务端跟<code>hash</code>表内容比对即可。临时表需要比较<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi>k</mi><mo>×</mo><mn>2</mn><mi>k</mi></mrow><annotation encoding="application/x-tex">1k \times 2k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>次，但是<code>hash join</code>只需要比较<code>2k</code>次</p></li><li><p>临时表可以用各种引擎，但是内存表只用<code>memory</code>引擎，一般由mysql自动创建销毁</p></li><li><p>临时表建表语法时<code>create temporary table ...</code></p></li><li><p>一个临时表只能被创建它的<code>session</code>访问，其他<code>session</code>不可见</p></li><li><p>临时表可以与普通表重名</p></li><li><p>如果有同名的，那么<code>show create</code>和增删改查访问临时表</p></li><li><p><code>show tables</code>不显示临时表</p></li><li><p>所以临时表不需要担心重名问题，可以用来给<code>join</code>使用，而且不需要担心数据删除问题</p></li><li><p>分库分表跨库查询就会使用临时表</p></li><li><p>创建临时表的时候，<code>InnoDB</code>创建一个<code>frm</code>文件保存表结构定义，前缀是<code>#sql&#123;进程 id&#125;_&#123;线程 id&#125;_ 序列号</code><br>5.6版本之前，会在临时文件目录下创建一个相同前缀.ibd存放数据文件，5.7版本后有专门的临时表空间存放临时数据，因为前缀不同，所以可以创建同名临时表</p></li><li><p>但是普通表是库名+表名得到的，同一个库创建两个同名表就会报错</p></li><li><p>当<code>session</code>结束的时候，就会执行<code>drop temporary table + 表名</code></p></li><li><p>如果<code>binlog</code>不是<code>row</code>，就会记录临时表的操作，不然会报错，提示临时表不存在。但是<code>row</code>格式只会记录数据，所以不会有对临时表的操作，不会发现临时表不存在这种问题，就不会记录临时表</p></li></ul><h2 id="内存临时表">内存临时表</h2><ol><li><code>union</code>的<code>explain</code>会显示<code>using temporary</code>，表示使用临时表，将<code>union</code>前的结果存在临时表中，然后利用主键唯一性剔除第二个查询中的相同的结果</li></ol><ul><li>如果是<code>union all</code>，就没有去重了，所以也不需要临时表了</li></ul><ol start="2"><li><code>group by</code></li></ol><ul><li><p>创建内存临时表，表上两个字段m和c，主键是m</p></li><li><p>扫描t1上的索引a，取id，并%10记x</p><ul><li>临时表没有x的行，那么插入x,1</li><li>如果有x的行，那么对应的c+1</li><li><code>group by</code>处理完以后默认会对字段m按照自然顺序排序，如果不想排序提高效率，就可以直接加上<code>order by null</code><br><code>tmp_table_size</code>是内存临时表的大小设置参数，默认<code>16M</code>，超过大小会转为磁盘临时表</li></ul></li><li><p>不管是内存临时表还是磁盘临时表，<code>group by</code>都需要构建一个带唯一索引的表，执行代价高</p></li><li><p>5.7版本支持<code>generated column</code>机制，用来实现数据关联更新<code>alter table t1 add column z int generated always as(id % 100), add index(z);</code></p></li><li><p>这样索引z上的数据就是<code>group by</code>有序的数据了<code>group by id %100</code>就可以改写为<code>select z, count(*) as c from t1 group by z;</code>此时不再需要临时表，也不需要排序，直接返回即可</p></li><li><p><code>group by</code>语句使用<code>SQL_BIG_RESULT</code>提示，可以告诉<code>sql</code>数据量很大，直接使用磁盘临时表，然后优化器还会将原本的B+树直接改为数组存储 ，两次优化<br><code>select SQL_BIG_RESULT id%100 as m, count(*) as c from t1 group by m;</code></p></li><li><p>初始化<code>sort_buffer</code>，放入整型字段m</p></li><li><p>扫描t1.a，取id%100放入<code>sort_buffer</code></p></li><li><p>对<code>sort_buffer</code>中字段m排序</p></li><li><p>排完序就是有序数组</p></li><li><p>这样就不会使用临时表</p></li></ul><p><code>InnoDB</code>把数据放在主键索引上，其他索引保存主键id就是索引组织表<code>IOT</code></p><ul><li><p>总是有序</p></li><li><p>有空洞时，插入新数据只能放在固定位置，从而保证有序</p></li><li><p>数据位置改变，只需要修改主键索引</p></li><li><p>主键索引查一次，普通索引查两次</p></li><li><p>变长数据<br><code>Memory</code>数据单独存放，索引上保存数据位置，就是堆组织表<code>HOT</code></p></li><li><p>按照写入顺序</p></li><li><p>有空洞时找到空位就可以插入新数据</p></li><li><p>数据位置改变，需要修改所有索引</p></li><li><p>所有索引地位相同</p></li><li><p>不支持变长，定义<code>varchar</code>，也是 按照<code>char(N)</code></p></li><li><p>内存表锁表，并且丢失会有风险，一般不会用</p><ul><li>但是内存临时表不一样，因为不会被其他<code>session</code>访问，所以没有并发性问题</li><li>本来重启就是要删除的，所以丢失没关系</li><li>备库临时表也不会影响主库</li><li>支持<code>hash</code>索引</li></ul></li><li><p><code>MyISAM</code>主键自增值在数据文件中</p></li><li><p><code>InnoDB</code>主键自增值在内存中，8.0版本实现持久化</p><ul><li>5.7版本前没有持久化，保存在内存，重启后就找表的最大值，最大值+1作为自增值</li><li>如果id=10，则<code>AUTO_INCREMENT=11</code>，删除id=10，还是11，如果删除以后重启，AUTO=10</li><li>8.0版本变更记录在<code>redo log</code>中，重启依靠<code>redo log</code>恢复之前的值</li></ul></li><li><p>插入一行数据，指定为自增，判断id=0，null，或者没有指定，就把表的自增值赋值给他</p></li><li><p>如果id指定了值，就使用指定值；如果指定值小于自增值，则自增值不变；</p><ul><li>如果指定值大于等于自增值，就修改自增值，就是<code>auto_increment_offset</code>开始，<code>auto_increment_increment</code>为步长叠加，找到第一个大于指定值作为新的自增值。两个参数默认都是1</li></ul></li><li><p>如果插入数据，自增主键，但是插入数据失败，数据重复了，那么数据无法插入成功，并且主键自增值也没有改回去（唯一键冲突会导致主键自增不连续）</p></li><li><p>事务回滚也会导致自增主键不连续，为了性能，因为申请id很快，但是回滚id可能会导致主键冲突，没有必要</p></li><li><p>批量<code>insert ... select， replace ...select, load data</code>的场景下设置<code>innodb_autoinc_lock_mode=2</code>可以提升并发性，并且不会出现数据一致性问题</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;主备&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;主备切换流程&lt;br&gt;
&lt;img src=&quot;https://gitee.com/sang3112/blog_imgs/raw/master/MySQL/45_ms.png&quot; alt=&quot;45_ms&quot;&gt;&lt;br&gt;
状态1，客户端读写都只访问节点A</summary>
      
    
    
    
    <category term="MySQL" scheme="https://sangs3112.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://sangs3112.github.io/tags/MySQL/"/>
    
    <category term="主备切换" scheme="https://sangs3112.github.io/tags/%E4%B8%BB%E5%A4%87%E5%88%87%E6%8D%A2/"/>
    
    <category term="InnoDB和Memory" scheme="https://sangs3112.github.io/tags/InnoDB%E5%92%8CMemory/"/>
    
    <category term="join优化" scheme="https://sangs3112.github.io/tags/join%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Go笔记_0</title>
    <link href="https://sangs3112.github.io/posts/f86b96e2.html"/>
    <id>https://sangs3112.github.io/posts/f86b96e2.html</id>
    <published>2024-12-11T04:42:14.723Z</published>
    <updated>2024-12-11T04:42:14.723Z</updated>
    
    <content type="html"><![CDATA[<h1><code>GOROOT</code> VS <code>GOPATH</code> VS <code>GOBIN</code> VS <code>GOPROXY</code></h1><ul><li><code>GOROOT</code>: Go语言安装路径</li><li><code>GOPATH</code>: 若干工作区目录的路径。是我们自己定义的工作空间  <div class="note info flat"><ul><li><code>GO1.8</code>版本之后，开发包安装完成后会自动设置一个<code>GOPATH</code>目录，</li><li><code>GO1.14</code>版本之后，推荐使用<code>Go Module</code>模式，不一定非要将代码写在<code>GOPATH</code>目录下，也不需要自己配置<code>GOPATH</code></li></ul></div></li><li><code>GOBIN</code>: GO程序生成的可执行文件的路径</li><li><code>GOPROXY</code>: 默认为<code>GOPROXY=https://proxy.golang.org,direct</code>，修改为<code>GOPROXY=https://goproxy.cn,direct</code></li></ul><h1>跨平台编译</h1><h2 id="Windows-编译-LINUX或者OSX">Windows 编译 LINUX或者OSX</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SET CGO_ENABLED=0   // 禁用CGO</span><br><span class="line">SET GOOS=linux      // 目标平台, [windows, linux, darwin]</span><br><span class="line">SET GOARCH=amd64    // 目标处理器架构</span><br><span class="line">go build</span><br></pre></td></tr></table></figure><h2 id="LINUX-或者-OSX-编译其他环境">LINUX 或者 OSX 编译其他环境</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGO_ENABLED=0 GOOS=linux|darwin|windows GOARCH=amd64 go build</span><br></pre></td></tr></table></figure><div class="note info flat"><ul><li>只有Windows 需要在cmd窗口中运行<code>SET</code>命令</li></ul></div><h1>编写测试</h1><div class="note info flat"><ol><li>有一个程序名为<code>xxx.go</code>，则其测试程序应该名为<code>xxx_test.go</code></li><li>测试函数的命名以<code>Test</code>开始，例如<code>Testxxx()</code></li><li>测试函数只能有一个参数<code>t *testing.T</code>，参数<code>t</code>是测试的<code>hook</code>，测试失败时可以执行<code>t.Fail()</code>等操作</li></ol></div><h2 id="举例">举例</h2><ul><li>有一个<code>main</code>函数，打印<code>Hello world</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Hello</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Hello world&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">fmt.Println(Hello())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>则对应的测试代码应该为</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello_test.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestHello</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">got := Hello()</span><br><span class="line">want := <span class="string">&quot;Hello world&quot;</span></span><br><span class="line"><span class="keyword">if</span> got != want&#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;got &#x27;%q&#x27; want &#x27;%q&#x27;&quot;</span>, got, want)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在终端直接执行<code>go test</code>命令即可进行测试，如果文件名错误，会报错:<code>?       gogo    [no test files]</code></li></ul><h2 id="重构-t-Helper">重构 <code>t.Helper()</code></h2><p>现在有这两个文件<code>hello.go, hellotest.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> helloPrefix = <span class="string">&quot;Hello &quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Hello</span><span class="params">(name <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> helloPrefix + name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">fmt.Println(Hello(<span class="string">&quot;world&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestHello</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">assertCorrectMessage := <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T, got, want <span class="type">string</span>)</span></span>&#123;</span><br><span class="line">t.Helper()</span><br><span class="line"><span class="keyword">if</span> got != want&#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;got &#x27;%q&#x27; want &#x27;%q&#x27;&quot;</span>, got, want)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 成功</span></span><br><span class="line">t.Run(<span class="string">&quot;saying hello to people&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">got := Hello(<span class="string">&quot;chris&quot;</span>)</span><br><span class="line">want := <span class="string">&quot;Hello chris&quot;</span></span><br><span class="line">assertCorrectMessage(t, got, want)</span><br><span class="line">&#125;)</span><br><span class="line">    <span class="comment">// 失败</span></span><br><span class="line">t.Run(<span class="string">&quot;say hello world when an empty string is supplied&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">got := Hello(<span class="string">&quot;&quot;</span>)</span><br><span class="line">want := <span class="string">&quot;Hello world&quot;</span></span><br><span class="line">assertCorrectMessage(t, got, want)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>将断言单独作为一个函数，由两个子测试进行调用。</li><li>第一个子测试能通过，第二个子测试失败</li><li><code>t.Helper()</code>告诉测试套件这个函数是一个辅助函数，这样测试失败时报告的行号将在函数调用中，而不是在辅助函数内部。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不添加t.Helper()的输出</span></span><br><span class="line">--- FAIL: TestHello (0.00s)</span><br><span class="line">    --- FAIL: TestHello/say_hello_world_when_an_empty_string_is_supplied (0.00s)</span><br><span class="line">        hello_test.go:15: got &#x27;&quot;Hello &quot;&#x27; want &#x27;&quot;Hello world&quot;&#x27; # 断言函数处的行号，但是具体不知道是哪个测试用例出错</span><br><span class="line">FAIL</span><br><span class="line">exit status 1</span><br><span class="line">FAIL    gogo    0.001s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加t.Helper()的输出</span></span><br><span class="line">--- FAIL: TestHello (0.00s)</span><br><span class="line">    --- FAIL: TestHello/say_hello_world_when_an_empty_string_is_supplied (0.00s)</span><br><span class="line">        hello_test.go:28: got &#x27;&quot;Hello &quot;&#x27; want &#x27;&quot;Hello world&quot;&#x27; # 具体测试用例内部的行号</span><br><span class="line">FAIL</span><br><span class="line">exit status 1</span><br><span class="line">FAIL    gogo    0.001s</span><br></pre></td></tr></table></figure><h2 id="命名返回值">命名返回值</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Hello</span><span class="params">(name <span class="type">string</span>, language <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> name == <span class="string">&quot;&quot;</span>&#123;</span><br><span class="line">        name = <span class="string">&quot;world&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> greetingPrefix(language) + name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greetingPrefix</span><span class="params">(language <span class="type">string</span>)</span></span> (prefix <span class="type">string</span>)&#123;</span><br><span class="line">    <span class="keyword">switch</span> language &#123;</span><br><span class="line">        <span class="keyword">case</span> french:</span><br><span class="line">            prefix = frenchHelloPrefix</span><br><span class="line">        <span class="keyword">case</span> spanish:</span><br><span class="line">            prefix = spanishHelloPrefix</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            prefix = englishHelloPrefix</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在函数签名中，使用了命名返回值<code>prefix string</code><ul><li>会自动创建一个名为<code>prefix</code>的变量，并且分配零值，即如果是<code>int</code>，则<code>prefix=0</code>，如果是<code>string</code>，则<code>prefix=&quot;&quot;</code></li><li>会在<code>Go Doc</code>中显示，代码更加清晰</li><li>只需要直接写<code>return</code>即可，不需要<code>return prefix</code></li></ul></li><li>函数如果是小写字母开头，则是私有函数；如果是大写字母开头，则是公共函数</li></ul><h2 id="示例">示例</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// integer.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Add takes two integers and returns the sum of them</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info flat"><ul><li><code>Add</code>函数有两个相同类型的参数，所以可以直接写成<code>x, y int</code></li><li>添加的函数注释<code>Add takes two integers and returns the sum of them</code>会放在Go Doc中</li></ul></div><ul><li>添加示例函数，示例函数同样会更新在Go Doc中，可以反映出代码的实际功能</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// integer_test.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleAdd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sum := Add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    fmt.Println(sum)</span><br><span class="line">    <span class="comment">// Output: 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info flat"><ul><li><code>// Output: 3</code>实际上是<code>ExampleAdd()</code>这个函数的期望输出，如果写5，表明希望1 + 2 = 5，会返回测试失败</li><li>这个语法不能在别的测试中使用，只有<code>Examplexxx()</code>中可以使用</li><li>使用<code>go test -v</code>可以输出每个测试用例的通过情况，以及整体的通过情况，输出结果如下</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">=== RUN   TestAdd</span><br><span class="line">--- PASS: TestAdd (0.00s)</span><br><span class="line">=== RUN   ExampleAdd</span><br><span class="line">--- PASS: ExampleAdd (0.00s)</span><br><span class="line">PASS</span><br><span class="line">ok      integer 0.001s</span><br></pre></td></tr></table></figure></div><h2 id="基准测试">基准测试</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iter.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Repeat</span><span class="params">(a <span class="type">string</span>)</span></span> <span class="type">string</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> repeat <span class="type">string</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++&#123;</span><br><span class="line">        repeat += a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> repeat</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编写基准测试</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iter_test.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkRepeat</span><span class="params">(b *testing.B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++&#123;</span><br><span class="line">        Repeat(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info flat"><ul><li><code>testing.B</code>可以访问隐性命名<code>b.N</code>，表示这个代码的运行次数，并记录时间</li><li>测试框架会选择<code>b.N</code></li><li>使用<code>go test -bench=.</code>来运行基准测试，如果在<code>Windows</code>中则使用<code>go test -bench=&quot;.&quot;</code></li><li>如果直接使用<code>go test [-v]</code>不会运行基准测试</li><li>使用<code>go test -cover</code>查看覆盖率</li></ul></div><h1>数组 VS 切片</h1><ul><li><code>numbers := [5]int&#123;1,2,3,4,5&#125;</code></li><li><code>numbers := [...]int&#123;1,2,3,4,5&#125;</code></li><li>遍历数组的两个方式</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, number := <span class="keyword">range</span> numbers&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// range返回索引和值，使用空白标志符来忽略索引</span></span><br></pre></td></tr></table></figure><div class="note info flat"><ul><li>数组传参，比如需要传入<code>numbers</code>，参数类型应该为<code>numbers [5]int</code></li><li>此时如果传入一个<code>[4]int</code>传入函数，不能通过编译，因为会判定为不同的类型</li><li>所以导致数组没什么用，一般用切片<code>slice</code>，尺寸不固定</li><li>切片就是在声明的时候不指定长度，也就是<code>mySlice := []int{1,2,3}</code>，而不是<code>mySlice := [3]int{1,2,3}</code></li><li>参数是可变数量的切片时，应该写<code>numbers ... []int</code></li><li>不能对切片使用等于号，简单的方法是使用<code>reflect.DeepEqual</code>，用于判断两个变量是否相等</li><li>但是<code>reflect.DeepEqual</code>不是类型安全的，甚至可以比较<code>slice</code>和<code>string</code>。</li><li>使用<code>make</code>创建切片可以指定容量和长度，创建的新切片中所有元素均为<strong>0</strong></li></ul></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;code&gt;GOROOT&lt;/code&gt; VS &lt;code&gt;GOPATH&lt;/code&gt; VS &lt;code&gt;GOBIN&lt;/code&gt; VS &lt;code&gt;GOPROXY&lt;/code&gt;&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;GOROOT&lt;/code&gt;: Go语言安装路径&lt;/li</summary>
      
    
    
    
    <category term="Go" scheme="https://sangs3112.github.io/categories/Go/"/>
    
    
    <category term="Go" scheme="https://sangs3112.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go笔记_1</title>
    <link href="https://sangs3112.github.io/posts/8f6ca674.html"/>
    <id>https://sangs3112.github.io/posts/8f6ca674.html</id>
    <published>2024-12-11T04:42:14.723Z</published>
    <updated>2024-12-11T04:42:14.723Z</updated>
    
    <content type="html"><![CDATA[<h1>方法</h1><div class="note info flat"><ul><li>Go语言中只有不同的<code>package</code>中可以有相同函数名的函数，尽管参数不同，但是如果函数名相同就不能出现在相同的包中(函数重载Go语言没有)</li><li>方法需要通过一个特定的实例调用，比如<code>t.Errorf()</code>，这里的<code>Errorf</code>就是一个方法，通过实例<code>t</code>调用</li><li>函数可以随便调用，没有限制</li></ul></div><h1>接口</h1><ul><li>接口让函数接受不同类型的参数并创造类型安全并且高解耦的代码</li><li>Go语言中 interface resolution 是隐式的。如果传入的类型匹配接口需要的，则编译正确。</li><li>函数实现因此不需要关心参数是什么类型的，只需要声明一个接口，辅助函数就可以从具体类型解耦而只关心本身需要做的工作</li></ul><h1>表格驱动测试</h1><ul><li>如果需要测试一个接口的不同实现，或者传入的数据有很多不同的测试需求，则可以使用表格驱动测试</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestArea</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">areaTests := []<span class="keyword">struct</span>&#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">shape Shape</span><br><span class="line">want <span class="type">float64</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">&#123;name: <span class="string">&quot;Rec&quot;</span>, shape: Rec&#123;Width: <span class="number">12</span>, Height: <span class="number">6</span>&#125;, want: <span class="number">72.0</span>&#125;,</span><br><span class="line">&#123;name: <span class="string">&quot;Circle&quot;</span>, shape: Circle&#123;<span class="number">10</span>&#125;, want: <span class="number">314.15926</span>&#125;,</span><br><span class="line">&#123;name: <span class="string">&quot;Tri&quot;</span>, shape: Tri&#123;<span class="number">12</span>, <span class="number">6</span>&#125;, want: <span class="number">361.0</span>&#125;, </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, tt := <span class="keyword">range</span> areaTests&#123;</span><br><span class="line">got := tt.shape.Area()</span><br><span class="line">want := tt.want</span><br><span class="line"><span class="keyword">if</span> got != want&#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;%#v got &#x27;%.2f&#x27;, want &#x27;%.2f&#x27;&quot;</span>, tt.shape, got, want)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info flat"><ul><li>创建了一个匿名结构体，里面有shape和want，放在一个[]struct切片中</li><li>然后使用两个测试用例填充这个切片</li><li>Go中调用一个函数或者方法的时候，参数会被复制</li><li>使用指针解决这个问题，指向某个值，然后修改</li></ul></div><h1>map</h1><ul><li>Map是引用类型的，拥有对底层数据结构的引用</li><li>因此，Map可以是nil指，如果使用一个nil的map，那么会得到一个nil指针异常，导致程序终止</li><li>永远不要初始化一个空的map变量，比如:<code>var m map[string]string</code></li><li>可以用如下两种方式初始化空的map:</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dict = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;&#125;</span><br><span class="line">dict = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br></pre></td></tr></table></figure><ul><li>上述两种方法绝对不会出现nil指针异常</li></ul><h1>依赖注入</h1><ul><li><code>fmt.Fprintf</code>接受一个<code>Writer</code>参数，将字符串传递过去。</li><li><code>fmt.Printf</code>是标准的默认输出</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// di.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Greet</span><span class="params">(writer io.Writer, name <span class="type">string</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// fmt.Printf(&quot;Hello, %s&quot;, name)</span></span><br><span class="line">fmt.Fprintf(writer, <span class="string">&quot;Hello, %s&quot;</span>, name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Greet(os.Stdout, <span class="string">&quot;Elodie&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// di_test.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bytes&quot;</span></span><br><span class="line"><span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGreet</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">buffer := bytes.Buffer&#123;&#125; <span class="comment">// 注入依赖</span></span><br><span class="line">Greet(&amp;buffer, <span class="string">&quot;Chris&quot;</span>)</span><br><span class="line">got := buffer.String()</span><br><span class="line">want := <span class="string">&quot;Hello, Chris&quot;</span></span><br><span class="line"><span class="keyword">if</span> got != want &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;got %s want %s&quot;</span>, got, want)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info flat"><ul><li>Go中可以使用反引号创建字符串，允许将字符串中的东西放在新的一行，比如<br>`<br>3<br>1<br>2<br>`</li></ul></div><ul><li><p>Go中不会阻塞的操作在成为goroutine的单独进程中运行。使用go关键字声明</p></li><li><p><code>go test -race</code>可以发现<code>goroutine</code>中的竞争条件，比如可能多个进程同时写一个<code>map</code>，但是一次执行并不会触发这种现象。</p></li><li><p>可以通过<code>channels</code>协调<code>goroutine</code>解决数据竞争问题。</p></li><li><p>比如原本需要将多个进程的数据写入<code>map</code>中，现在可以使用<code>channel &lt;- data</code>，将数据发送到<code>channel</code>中，然后再使用<code>for</code>循环，将数据保存保存在新的map中，这样不会产生数据竞争的问题。<code>result := &lt;- channel</code></p></li><li><p>在函数调用之前加上<code>defer</code>前缀会在包含他的函数结束时调用它。</p><ul><li>有时候需要清理资源，比如在函数结束时关闭一个文件，或者关闭一个服务器，但是要把它放在创建服务器语句附近，以便函数内后面的代码仍然可以使用这个服务器，就可以使用<code>defer</code>，等到函数执行完再调用</li></ul></li></ul><h1>进程同步</h1><ul><li><code>select</code>可以轻易实现进程同步</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Racer</span> <span class="params">(a, b <span class="type">string</span>)</span></span> (winner <span class="type">string</span>, err <span class="type">error</span>)&#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;- ping(a):</span><br><span class="line"><span class="keyword">return</span> a, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> &lt;- ping(b):</span><br><span class="line"><span class="keyword">return</span> b, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> M- time.After(<span class="number">10</span> *time.Second):</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span>, fmt.Errorf(<span class="string">&quot;timed out waiting for %s and %s&quot;</span>, a, b)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ping</span><span class="params">(url <span class="type">string</span>)</span></span> <span class="keyword">chan</span> <span class="type">bool</span>&#123;</span><br><span class="line">ch := <span class="built_in">make</span> (<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">http.Get(url)</span><br><span class="line">ch &lt;- <span class="literal">true</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果是<code>v := &lt;- ch</code>等待值发送给<code>channel</code>，则这是一个阻塞调用，因为需要等待值返回</li><li><code>select</code>允许多个<code>channel</code>等待，第一个发送值的<code>channel</code>胜出。</li><li>使用<code>select</code>时，<code>time.After</code>是一个很好用的函数，因为<code>channel</code>可能永远不会返回一个值，那就有可能不会返回，因此使用<code>time.After</code>设置超时时间</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">t.Run(<span class="string">&quot;returns an error if a server doesn&#x27;t respond within 10s&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    serverA := makeDelayedServer(<span class="number">11</span> * time.Second)</span><br><span class="line">    serverB := makeDelayedServer(<span class="number">12</span> * time.Second)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> serverA.Close()</span><br><span class="line">    <span class="keyword">defer</span> serverB.Close()</span><br><span class="line"></span><br><span class="line">    _, err := Racer(serverA.URL, serverB.URL)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        t.Error(<span class="string">&quot;expected an error but didn&#x27;t get one&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1>反射</h1><blockquote><p>编写函数 <code>walk(x interface&#123;&#125;, fn func(string))</code>，参数为结构体x，并对 x 中的所有字符串字段调用 fn 函数</p></blockquote><ul><li>反射提供了程序检查自身结构体的能力。</li><li>允许使用类型<code>interface&#123;&#125;</code>，代表任意类型。但是这样市区了对类型安全的检查，编译器不会再检查类型</li><li>除非真的需要，否则不要使用反射</li><li>如果想要实现多态，可以考虑围绕接口实现。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;方法&lt;/h1&gt;
&lt;div class=&quot;note info flat&quot;&gt;&lt;ul&gt;
&lt;li&gt;Go语言中只有不同的&lt;code&gt;package&lt;/code&gt;中可以有相同函数名的函数，尽管参数不同，但是如果函数名相同就不能出现在相同的包中(函数重载Go语言没有)&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    <category term="Go" scheme="https://sangs3112.github.io/categories/Go/"/>
    
    
    <category term="Go" scheme="https://sangs3112.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Java笔记_9</title>
    <link href="https://sangs3112.github.io/posts/1d15a4a2.html"/>
    <id>https://sangs3112.github.io/posts/1d15a4a2.html</id>
    <published>2024-12-07T01:37:00.000Z</published>
    <updated>2024-12-11T04:42:14.727Z</updated>
    
    <content type="html"><![CDATA[<h1>内部类</h1><h2 id="使用内部类的原因">使用内部类的原因</h2><ol><li>对同一个包中的其他类隐藏</li><li>访问定义这些方法的作用域的数据, 包括原本的私有数据</li></ol><div class="note info flat"><ul><li>内部类对象会有一个隐式引用, 指向实例化这个对象的外部类对象, 可以访问外部对象的全部状态</li><li>但是<code>Java</code>中静态内部类没有这个指针, 所以<code>Java</code>静态内部类等于<code>CPP</code>中的嵌套类</li><li>可以使用<code>OuterClass.this</code>表示外部类的引用, 比如 <code>T.this.b</code></li><li>可以使用<code>outerObject.new InnerClass()</code>编写内部类的构造器, 比如<code>A listen = this.new B();</code></li><li>在外部类的作用域之外, 可以使用<code>OutClass.InnerClass</code>引用</li></ul></div><ul><li>内部类声明的所有静态字段都必须是<code>final</code>, 初始化为一个编译时常量</li><li>内部类不能有<code>static</code>方法</li><li>使用<code>$</code>和<code>javap -private ClassName</code>可以将内部类文件转换为常规类文件</li></ul><h2 id="局部类">局部类</h2><ul><li>可以在一个方法中声明局部类, 这个类不能用<code>public</code>或者<code>private</code>访问修饰符, 对外部完全隐藏, 除了这个方法外都不知道这个局部类的存在</li><li>局部类不仅可以访问外部类的字段, 还可以访问局部变量, 不过这些局部变量都需要是只能赋值一次就不会改变的事实最终变量</li></ul><h2 id="匿名内部类">匿名内部类</h2><ul><li>如果只想要创建类的一个对象, 不需要为类指定名字  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(<span class="type">int</span> interval, <span class="type">boolean</span> flag)</span> &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">listener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActionListener</span>() &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent event)</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (flag) Toolkit.getDefaultToolkit().flag();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建了一个新的对象listener, 这个类实现了ActionListener接口</span></span><br><span class="line"><span class="comment">// 接口实现了actionPerformed方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以是接口, 也可以是一个类</span></span><br><span class="line"><span class="comment">// 因为匿名内部类没有名字, 所以没有构造器</span></span><br></pre></td></tr></table></figure></li><li>对比构造类对象和构造匿名内部类  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"><span class="type">var</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;2&quot;</span>) &#123;...&#125;;</span><br><span class="line"><span class="comment">// a 是类Person的一个对象</span></span><br><span class="line"><span class="comment">// b 是匿名内部类的一个对象, 这个匿名内部类是Person的子类</span></span><br><span class="line"><span class="comment">// 如果构造类的时候小括号后面跟上了大括号, 那么就是一个匿名内部类</span></span><br><span class="line"><span class="type">var</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>() &#123;<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;c&quot;</span>;&#125;</span><br><span class="line">System.out.println(c.name);</span><br><span class="line"><span class="comment">// 如果声明c的类型为Object, c.name就无法编译了, 因为Object是不可指示的</span></span><br></pre></td></tr></table></figure></li></ul><div class="note info flat"><ul><li>如果在一个方法中, 想要打印类名<br><code>System.out.println(getClass())</code></li><li>普通方法可以调用<code>this</code>, 但是静态方法没有<code>this</code></li><li>如果想要打印静态方法的类名, 可以使用匿名内部类<br><code>System.out.println(new Object(){}.getClass().getEnclosingClass())</code></li><li>这里的<code>getEnclosingClass()</code>是得到这个静态方法的外围类</li></ul></div><h2 id="静态内部类">静态内部类</h2><ul><li>如果生成内部类只是为了隐藏这个类, 并不想生成这个内部类的引用, 可以使用<code>static</code>修饰</li><li>比如要计算一个数组的最大值和最小值<ul><li>可以遍历数组两遍</li><li>也可以定义一个类, 其中包含两个私有字段, 分别记录最大值和最小值</li><li>但是这个类的类名可能会重复, 所以可以定义内部类隐藏类名</li><li>可以将内部类声明为<code>static</code>的, 避免包含其他类的引用</li><li>如果内部类是在一个静态方法中构造的, 则这个内部类必须要声明为静态内部类</li></ul></li></ul><h1>代理</h1><ul><li>代理可以在运行时创建一组给定接口的新类</li><li>只有在编译时无法确定需要实现哪个接口的时候才需要使用代理</li><li>代理类可以在运行时创建一个全新的类, 能够实现指定的接口</li><li>一个代理类包含指定接口需要实现的方法, 以及<code>Object</code>类中的所有方法, 比如<code>toString(), equals()</code></li><li>必须提供一个调用处理器, 调用处理器是实现了<code>InvocaitonHandler</code>接口的类对象, 这个接口只有一个方法, <code>Object invoke()</code></li><li>只要调用代理方法, 就会调用这个<code>invoke</code>方法</li></ul><h2 id="创建代理对象">创建代理对象</h2><ul><li><p>需要使用<code>Proxy</code>类的<code>newProxyInstance()</code>, 包含三个参数</p><ol><li>类加载器</li><li><code>Class</code>对象数组</li><li>一个调用处理器</li></ol></li><li><p>使用目的:</p><ol><li>方法调用 路由到远程服务器</li><li>用户界面事件关联运行中的程序动作</li><li>调试跟踪方法调用</li></ol></li><li><p>定义一个<code>TraceHandler</code>包装器类存储一个包装的对象, <code>invoke()</code>打印所调用方法的名字和参数, 然后调用这个方法, 提供包装的对象作为隐式参数</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TraceHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">new</span> <span class="title class_">TraceHandler</span>(Object t) &#123;</span><br><span class="line">        target = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method m, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// print</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> m.invoke(target, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Object</span> <span class="variable">val</span> <span class="operator">=</span> ...;</span><br><span class="line"><span class="type">var</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TraceHandler</span>(val);</span><br><span class="line"><span class="type">var</span> <span class="variable">interfaces</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;Comparable.class&#125;;</span><br><span class="line"><span class="type">Object</span> <span class="variable">proxy</span> <span class="operator">=</span> Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;Comparable.class&#125;, handler);</span><br></pre></td></tr></table></figure></li></ul><h2 id="特性">特性</h2><ol><li>代理类是程序运行过程中动态创建的, 一旦创建就是常规的类</li><li>所有的代理类都扩展<code>Proxy</code>类, 一个代理类只有一个实例字段, 也就是调用处理器, 在<code>Proxy</code>超类中定义<ul><li>完成代理对象任务所需要的任何额外的数据都需要存储在调用处理器中</li></ul></li><li>所有的代理类都需要覆盖<code>Object</code>类的<code>toString(), equals(), hashCode()</code>, 这些方法只是在调用处理器上调用<code>invoke()</code><ul><li><code>Object</code>类中的其他方法, <code>clone(), getClass()</code>没有重新定义</li></ul></li><li>没有定义代理类的名字, 虚拟机中的<code>Proxy</code>类会生成<code>$Proxy</code>开头的类名</li><li>一个特定的类加载器和一组接口, 只能有一个代理类, 同样可以使用<code>Class proxyClass = Proxy.getProxyClass(null, interface)</code>得到这个类</li><li>代理类一定是<code>public, final</code>的, 如果代理类实现的所有接口都是<code>public</code>的, 那么这个代理类就不属于任何包, 否则一定属于某一个包</li><li>可以通过调用<code>Proxy.isProxyClass()</code>检测一个特定的<code>Class</code>对象是否表示一个代理类</li></ol><ul><li>调用一个目标代理的默认方法会触发调用处理器, 使用<code>InvocationHandler</code>接口的静态方法<code>invokeDefault</code>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> (proxy, method, args) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (method.isDefault()) &#123;</span><br><span class="line">        <span class="keyword">return</span> InvocationHandler.invokeDefault(proxy, method, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;内部类&lt;/h1&gt;
&lt;h2 id=&quot;使用内部类的原因&quot;&gt;使用内部类的原因&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;对同一个包中的其他类隐藏&lt;/li&gt;
&lt;li&gt;访问定义这些方法的作用域的数据, 包括原本的私有数据&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;note info flat</summary>
      
    
    
    
    <category term="Java" scheme="https://sangs3112.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://sangs3112.github.io/tags/Java/"/>
    
    <category term="Java核心技术(卷一)" scheme="https://sangs3112.github.io/tags/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%8D%B7%E4%B8%80/"/>
    
  </entry>
  
  <entry>
    <title>Java笔记_7</title>
    <link href="https://sangs3112.github.io/posts/faad89a5.html"/>
    <id>https://sangs3112.github.io/posts/faad89a5.html</id>
    <published>2024-12-01T10:21:00.000Z</published>
    <updated>2024-12-11T04:42:14.723Z</updated>
    
    <content type="html"><![CDATA[<h1>继承</h1><blockquote><p>基本思想: 基于已有的类创建新的类, 复用已有类的方法, 可以增加一些新的方法和字段</p></blockquote><ul><li>反射是程序在运行期间更多地了解类以及属性的能力</li></ul><div class="note info flat"><p><code>CPP</code>中使用<code>:</code>表示继承, 除了公共继承以外, 还存在私有继承和保护继承<br><code>Java</code>中<code>extends</code>关键字表示继承, 所有继承都是<strong>公共继承</strong></p></div><ul><li><code>extends</code>表示正在构造的类(子类, 派生类)派生于一个已经存在的类(超类, 基类, 父类)<ul><li>子类比超类拥有更多的功能</li><li>“声明为私有的类成员不会被这个类的子类继承”, 这里其实是子类不能直接访问这些私有成员, 但是子类的每个实例对象中依然会包含超类中的私有字段</li></ul></li><li>记录不能被扩展, 记录也不能继承别的类</li><li>如果希望使用超类中的方法, 就使用<code>super</code>关键字, <code>super</code>只是用于指示编译器调用超类方法的特殊关键字<ul><li>同时可以使用<code>super()</code>来调用超类中对应的构造器</li><li>不管是<code>this</code>还是<code>super</code>, <strong>在调用其他构造器的时候</strong>, 都必须放在第一行, 否则会报错</li></ul></li></ul><div class="note info flat"><ul><li>一个对象可以指示多种实际类型, 比如一个类的超类以及他的子类都在一个数组中, 使用<code>foreach</code>循环的时候, 循环变量可以同时指示多个不同的类, 那么这就是多态</li><li>运行的时候可以自动的选择适合的方法, 就是动态绑定</li><li><code>CPP</code>中, 如果希望实现动态绑定, 可以将成员函数设置为<code>virtual</code></li><li><code>Java</code>中默认会执行动态绑定, 如果不希望方法是虚拟的, 可以使用<code>final</code>关键字</li><li><code>CPP</code>中, 一个类可以有多个超类</li><li><code>Java</code>中不支持多重继承, 但是可以使用接口实现多重继承的功能</li></ul></div><h2 id="对象方法调用过程">对象方法调用过程</h2><blockquote><p>假设需要<code>x.f(args)</code>, <code>x</code>是类<code>C</code>的一个对象, 具体调用过程如下:</p></blockquote><ol><li>编译器查看对象的声明类型和方法名, 可能存在多个名为<code>f</code>的方法, 他们具有不同的参数类型, 编译器会一一列举出<code>C</code>中的所有名为<code>f</code>的方法, 以及<code>C</code>的超类中所有名为<code>f</code>的<strong>非私有方法</strong></li><li>重载解析: 编译器确定方法调用中提供的参数类型, 如果所有名为<code>f</code>的方法中存在一个与所提供的参数类型完全匹配的方法, 就直接使用这个方法<ul><li>如果找不到匹配的方法, 或者找到了多个匹配的方法, 编译器就会抛出异常</li><li>方法的名字与参数类型会组成签名, 如果子类的签名和超类的重复了, 子类的方法会覆盖超类的方法</li><li>尽管返回类型不是签名的一部分, 但是在覆盖的时候, 需要保证子类的返回类型是超类返回类型的子类型</li></ul></li><li>如果是<code>private</code>, <code>static</code>, <code>final</code>方法 或者 构造器方法, 编译器就可以准确知道调用哪个方法, 这称为静态绑定. 如果调用方法依赖于隐式参数的实际类型, 就是动态绑定. 所以只要不是上述四种方法, 就是动态绑定</li><li>程序使用动态绑定时, 虚拟机必须调用与<code>x</code>引用对象实际类型对应的方法, 比如<code>x</code>的实际类型是<code>D</code>, <code>D</code>是<code>C</code>的子类, 如果<code>D</code>定义了方法<code>f(String)</code>, 那么就会调用这个方法, 否则就会在<code>D</code>的超类中寻找这个方法<ul><li>如果每一次调用方法都需要执行一次搜索的话, 时间消耗非常大, 所以虚拟机预先为每个类计算了一个方法表, 列出了所有方法的签名和需要调用的方法</li><li>虚拟机加载一个类以后就可以构建这个方法表</li></ul></li></ol><div class="note info flat"><ul><li>覆盖一个方法的时候, 子类方法的可见性不能低于超类方法的可见性</li><li>如果超类方法是<code>public</code>, 子类也必须要是<code>public</code>方法, 如果漏了, 就会报错</li></ul></div><h2 id="final方法"><code>final</code>方法</h2><ul><li>使用<code>final</code>修饰一个类, 就可以阻止定义这个类的子类  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">E</span> <span class="keyword">extends</span> <span class="title class_">M</span> &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li><code>final</code>类的方法自动变为<code>final</code>方法</li><li><code>final</code>类的字段<strong>不会自动</strong>变为<code>final</code>字段</li></ul></li><li>如果将类中的某个方法设定为<code>final</code>, 则该类的所有子类都不能覆盖这个方法  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>final</code>字段表示以后都不会改变的字段</li><li>枚举和记录总是<code>final</code>的, 因为他们不允许被扩展</li></ul><h2 id="对象引用的强制类型转换">对象引用的强制类型转换</h2><ul><li>现在有<code>M</code>类是<code>E</code>的子类  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">E</span>[<span class="number">3</span>];</span><br><span class="line">s[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">M</span>();</span><br><span class="line">s[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">E</span>();</span><br><span class="line">s[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">E</span>();</span><br><span class="line"><span class="type">M</span> <span class="variable">b</span> <span class="operator">=</span> (M) s[<span class="number">0</span>]; <span class="comment">// 强制类型转换</span></span><br><span class="line"><span class="type">M</span> <span class="variable">c</span> <span class="operator">=</span> (M) s[<span class="number">1</span>]; <span class="comment">// 抛出异常 ClassCastException</span></span><br></pre></td></tr></table></figure></li><li>为了避免抛出异常, 可以使用<code>instanceof</code>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s[i] <span class="keyword">instanceof</span> M) &#123;</span><br><span class="line">    b = (M) s[i];</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><ul><li><code>Java 16</code>中有更加简单的写法, 可以直接在<code>instanceof</code>语句中声明子类变量<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s[i] <span class="keyword">instanceof</span> M b) &#123;</span><br><span class="line">    b.setB();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><div class="note info flat"><ul><li>只能在继承层次内使用强制类型转换</li><li>将超类转换为子类之前, 需要使用<code>instanceof</code>检查类型</li><li>如果<code>x</code>是<code>null</code>, <code>x instanceof C</code>不会抛出异常, 返回<code>false</code></li><li>一般情况下最好少用强制类型转换和<code>instanceof</code></li></ul></div><h2 id="protected"><code>protected</code></h2><ul><li>将超类中的某个字段声明为<code>protected</code>, 子类就可以进行访问</li><li>受保护的字段只能由同一个包中的类进行访问, 如果子类在不同的包中, 就不能访问了</li><li>相比之下, <code>protected</code>方法更有意义, 表示可以相信子类能够正确的使用这个方法</li><li>所以<code>Java</code>中的<code>protected</code>允许所有子类, 以及同一个包中的所有其他类访问, 不如<code>CPP</code>中的安全</li></ul><h1><code>Object</code></h1><blockquote><p><code>Object</code>类是<code>Java</code>中所有类的超类</p></blockquote><h2 id="写equals方法">写<code>equals</code>方法</h2><ol><li>显式参数命名为<code>otherObject</code></li><li>检测<code>this</code>与<code>otherObject</code>是否相同</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span> == otherObject) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>检测<code>otherObject</code>是否为<code>null</code>, 如果为<code>null</code>, 则返回<code>false</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (otherObject == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>比较<code>this</code>与<code>otherObject</code>的类<br>如果<code>equals</code>的语义可以在子类中改变, 就使用<code>getClass</code>检测</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (getClass() != otherObject.getClass()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">ClassName</span> <span class="variable">other</span> <span class="operator">=</span> (ClassName) otherObject;</span><br><span class="line"><span class="comment">// 这个判断对于匿名子类会失败</span></span><br></pre></td></tr></table></figure><p>如果所有的子类都有相同的相等性语义, 就可以使用<code>instanceof</code>检测</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(otherObject <span class="keyword">instanceof</span> ClassName other)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>使用相等性概念来比较字段, 使用<code>==</code>比较基本类型字段, 使用<code>Objects.equals</code>比较对象字段, 如果所有的字段都匹配, 返回<code>true</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> field1 == other.field1 &amp;&amp; Objects.equals(field2, other.field2) &amp;&amp; ... ;</span><br></pre></td></tr></table></figure><ul><li>对于数组类型, 使用<code>Arrays.equals()</code>方法检查相应的数组元素, 如果是多维数组, 可以使用<code>Arrays.deepEquals()</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(E other)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> other != <span class="literal">null</span> </span><br><span class="line">            &amp;&amp; getClass() == other.getClass() </span><br><span class="line">            &amp;&amp; Objects.equals(name, other.name) </span><br><span class="line">            &amp;&amp; salary == other.salary </span><br><span class="line">            &amp;&amp; Objects.equals(hireDay, other.hireDay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里有错误, 因为参数类型是E, 没有覆盖Object类的equals方法, 而是定义了一个新的方法</span></span><br><span class="line"><span class="comment">// 为了避免这个错误, 可以使用@Override public boolean equals(Object other)</span></span><br><span class="line"><span class="comment">// 此时编译器就会给出报错信息, 因为当前方法没有覆盖Object中的任何方法</span></span><br></pre></td></tr></table></figure><h2 id="hashCode"><code>hashCode</code></h2><blockquote><p><code>hashCode</code>方法定义在<code>Object</code>类中, 所以每个对象都有一个默认的散列码, 由对象的存储地址得出</p></blockquote><ul><li>自定义<code>hashCode</code>方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">7</span> * name.hashCode() </span><br><span class="line">            + <span class="number">11</span> * Double.valueOf(s).hashCode() </span><br><span class="line">            + <span class="number">13</span> * hireDay.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以使用Objects.hashCode(), 这是null安全的, 如果参数为null, 会直接返回0</span></span><br><span class="line"><span class="comment">// 可以使用静态方法Double.hashCode()避免创建一个Double对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">7</span> * Objects.hashCode(name) </span><br><span class="line">            + <span class="number">11</span> * Double.hashCode(s) </span><br><span class="line">            + <span class="number">13</span> * Objects.hashCode(hireDay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果有多个内容需要hash, 可以直接调用Objects.hash()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, s, hireDay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果有数组类型, 可以使用静态<code>Arrays.hashCode()</code>计算一个散列码, 这个散列码由数组元素的散列码组成</li><li>记录类型会自动提供一个<code>hashCode()</code>, 由字段值的散列码得到一个散列码</li></ul><h2 id="toString"><code>toString()</code></h2><ul><li>使用<code>getClass().getName()</code>获得类名的字符串</li><li>每一个子类都应该实现自己的<code>toString()</code>, 如果超类中实现了, 可以直接使用<code>super.toString()</code></li><li>只要一个对象与一个字符串通过<code>+</code>连接, 编译器就会自动调用<code>toString()</code>方法获得这个字符串的描述</li><li>如果<code>x</code>是任意一个对象, 使用<code>System.out.println(x)</code>也会自动调用<code>x.toString()</code></li><li><code>Objects</code>定义了<code>toString()</code>, 会打印对象的类名和散列码</li></ul><h1><code>ArrayList</code></h1><blockquote><p><code>ArrayList</code>是一个有类型参数的泛型类</p></blockquote><ul><li>使用<code>var</code>可以避免重复写类型 <code>var staff = new ArrayList&lt;E&gt;();</code><ul><li>如果使用了<code>var</code>, 就需要声明类型; 如果不使用<code>var</code>, 可以使用菱形语法 <code>ArrayList&lt;E&gt; staff = new Arraylist&lt;&gt;();</code></li></ul></li><li>使用<code>add</code>添加元素, 如果满了会自动扩容</li><li>如果可以估计大小, 可以在添加元素之前使用<code>staff.ensureCapacity(nums)</code>来设置分配的空间<ul><li>也可以使用<code>var staff = new ArrayList&lt;E&gt;(nums)</code>将初始容量传递给构造器</li></ul></li><li>如果数组的大小保持恒定不会发生变化了, 可以使用<code>staff.trimToSize()</code>将内存块的大小调整为当前所需空间, <code>GC</code>回收多余的空间</li></ul><h1>对象包装器</h1><ul><li>有时候需要将<code>int</code>转换为对象, 所有基本类型都有一个与之对应的类</li><li><code>Integer, Long, Float, Double, Short, Byte, Character, Boolean</code> 前六个派生于公共超类<code>Number</code><ul><li>包装类不可变, 一旦构造了包装器, 就不能更改其中的值</li><li>包装器类还是<code>final</code>, 所以不能派生子类</li><li>尖括号中的类型参数不能是基本数据类型, 必须要是包装器类型</li><li>因为每一个值都包装在对象中, 所以<code>ArrayList&lt;integer&gt;</code> 效率低于<code>int[]</code></li></ul></li><li>当使用<code>list.add(3)</code>的时候, 会自动转换为<code>list.add(Integer.valueOf(3))</code>, 这就是自动装箱</li><li>同样的, 当我们使用<code>int n = list.get(i)</code>的时候, 实际上是将<code>Integer</code>对象赋值给<code>int</code>类型, 这是自动拆箱, 等价于<code>list.get(i).intValue()</code></li><li><code>Integer n = 3; n ++;</code>这里面实际上先自动拆箱, 然后<code>+1</code>, 再自动装箱</li><li>不要使用包装器类构造器, 可以使用<code>Integer.valueOf(i)</code>, 也可以依赖自动装箱:<code>Integer a = i</code>, 不要使用<code>new Integer(i)</code>, 这个将会被删除</li><li>包装器类引用可以为<code>null</code>, 所以会触发<code>NPE</code></li><li>如果表达式中混用了<code>Integer, Double</code>, 则<code>Integer</code>会自动拆箱, 提升为<code>double</code>, 再自动装箱为<code>Double</code></li><li>自动装箱和拆箱是编译器做的工作, 不是虚拟机</li></ul><h1>可变参数个数方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> PrintStream <span class="title function_">printf</span><span class="params">(String fmt, Object... args)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> format(fmt, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这里的<code>...</code>表示接受任意数量的对象, 是一个<code>Object</code>数组, 保存着除了<code>fmt</code>之外的其他参数</li><li>如果调用者给了其他类型或者基本类型的值, 就会自动装箱为对象, 现在就只需要<code>fmt</code>中扫描到第<code>i</code>个格式说明, 与<code>args[i]</code>值匹配</li></ul><h1>抽象类</h1><ul><li>如果一个类中存在抽象方法, 类本身必须声明为抽象的; 抽象类<strong>可以没有</strong>抽象方法; 抽象类可以有具体字段和方法  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">P</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">getD</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>抽象类的子类可以保留抽象类中的部分或所有抽象方法, 那么子类依然是抽象的; 也可以全部实现, 则子类不是抽象的</li><li>抽象类不能被实例化, 但是可以存在抽象类的变量, 只是只能引用其非抽象子类  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">P</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">S</span>();</span><br></pre></td></tr></table></figure></li><li>接口是抽象类的泛化</li></ul><h1>密封类</h1><ul><li>比如有一个抽象类<code>JSONValue</code>, 还有两个<code>final</code>子类, 分别是<code>JSONNumber, JSONArray</code></li><li>两个子类是<code>final</code>的, 所以无法被派生了, 但是不能阻止别人派生<code>JSONValue</code></li><li>可以将<code>JSONValue</code>声明为密封类  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">JSONValue</span></span><br><span class="line">    <span class="keyword">permits</span> JSONArray, JSONNumber, JSONString, JSONBoolean, JSONObject, JSONNull &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 这样使用sealed声明为密封类, 可以保证JSONValue只有六个定义好的子类, 无法派生别的子类了</span></span><br></pre></td></tr></table></figure></li><li>一个密封类的子类必须是可以访问的, 不能是嵌套在别的类中的私有类, 也不能位于另一个包中</li><li>密封类允许的公共子类, 必须要在同一个包中, 如果使用了模块, 还必须要在同一个模块中</li><li>声明密封类可以不加<code>permits</code>, 但是这样的话所有子类都必须要在同一个文件中声明, 这样的话, 子类就不是公共的了</li><li>密封类的子类必须声明为<code>sealed, final, non-sealed</code>中的一种，最后一种允许继续派生</li></ul><h1>反射</h1><h2 id="Class类"><code>Class</code>类</h2><ul><li><code>Java</code>始终为所有对象维护一个运行时类型标识, 跟踪每个对象所属的类</li><li>可以用<code>Class</code>类访问这些信息, <code>Object.getClass()</code>返回一个<code>Class</code>对象的实例<ul><li>最常用的方法就是<code>getName()</code>, 返回一个对象类型的名称, 包名也作为类名的一部分</li></ul></li><li>也可以直接使用<code>类名.class</code>的方法访问这个类</li><li>虚拟机为每个类型管理一个唯一的<code>Class</code>对象, 所以可以使用<code>==</code>比较  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (e.getClass() == E.class) &#123;&#125;</span><br><span class="line"><span class="comment">// 如果e是一个E的实例, 则为true, 如果是M的实例, 其中M是E的子类, 则为false</span></span><br><span class="line"><span class="comment">// 如果是 e instanceof E的话, 那么当e是M的实例时, 依然会返回true</span></span><br></pre></td></tr></table></figure></li><li>如果有一个<code>Class</code>类型的对象, 可以用他构造实例  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">className</span> <span class="operator">=</span> <span class="string">&quot;java.uril.Random&quot;</span>;</span><br><span class="line"><span class="type">Class</span> <span class="variable">cl</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> cl.getConstructor().newInstance();</span><br><span class="line"><span class="comment">// 如果这个类没有无参构造器, 则会抛出异常InvocationTargetException</span></span><br></pre></td></tr></table></figure></li><li><code>Class.forName()</code>会抛出一个检查型异常, 没有办法保证指定名字的类一定存在, 所以需要在函数后面加上<code>throws ReflectOperationException</code></li></ul><h2 id="异常">异常</h2><ul><li>分两种: 非检查型异常和检查型异常<ul><li>检查型异常: 编译器会检查你是否知道这个异常, 并做后准备处理</li><li>非检查型异常: 比如数组越界, null引用访问, 编译器不期望你为这些异常提供处理方法</li></ul></li></ul><h2 id="应用">应用</h2><ol><li><p>资源文件加载</p><ul><li>获得拥有资源的类的<code>Class</code>对象, 比如<code>ResourcesTest.class</code></li><li>调用部分可以接受描述资源位置<code>URL</code>的方法, 比如<code>URL url = cl.getResource(&quot;about.txt&quot;);</code></li><li>否则, 使用<code>getResourceStream()</code>得到输入流读取文件</li></ul></li><li><p>国际化</p><ul><li>与语言相关的字符串都放在资源文件中, 每个语言对应一个文件</li></ul></li></ol><h2 id="利用反射分析类">利用反射分析类</h2><ul><li><code>java.util.reflect</code>包中有三个类: <code>Field, Method, Constructor</code>, 分别用于描述类的字段, 方法和构造器<ul><li>三个类都有一个方法, 名为<code>getName()</code></li><li><code>Field.getType()</code>可以返回字段类型的一个对象, 对象的类型同样是<code>Class</code></li><li><code>Method, Constructor</code>有报告类型参数的方法, <code>Method</code>有报告返回类型的方法, 三者都有<code>getModifiers()</code> 返回一个整数, 用不同的<code>0/1</code>位描述修饰符, 比如<code>public, static</code></li><li>可以使用<code>Modifier</code>类的静态方法分析<code>getModifiers()</code>返回的整数, 需要做的就是在返回的整数基础上, 调用<code>Modifier</code>类中适当的方法</li><li>可以用<code>Modifier.toString()</code>打印修饰符</li></ul></li><li><code>Class</code>中的<code>getFields(), getMethods(), getConstructors()</code>分别返回这个类支持的公共字段, 方法和构造器</li><li><code>Class</code>中的<code>getDeclaredFields(), getDeclaredMethods(), getDeclaredConstructors()</code>返回这个类声明的全部字段, 方法和构造器, 包括私有成员， 包成员, <code>protected</code>成员, 有包访问权限的成员, 但是不会包括超类的成员</li></ul><h2 id="利用反射分析对象">利用反射分析对象</h2><ul><li>利用反射可以查看在编译时还不知道的对象字段</li><li>利用<code>Field</code>中的<code>get</code>, 比如<code>f</code>是一个<code>Field</code>类型的对象, <code>obj</code>是包含<code>f</code>字段的类的对象, 则<code>f.get(obj)</code>将会返回一个对象, 值为<code>obj</code>的当前字段值  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">E</span>();</span><br><span class="line"><span class="type">Class</span> <span class="variable">cl</span> <span class="operator">=</span> h.getClass();</span><br><span class="line"><span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> cl.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">v</span> <span class="operator">=</span> f.get(h);</span><br></pre></td></tr></table></figure></li><li>同样可使用<code>f.set(obj, val)</code>设置值, 但是如果<code>name</code>是一个私有字段, 则不能使用<code>get, set</code>, 会抛出<code>IllageAccessException</code></li><li>只能对可以访问的字段使用<code>get, set</code>, <code>Java</code>允许查看一个对象中的字段, 但是无法访问</li><li>不过可以调用<code>f.setAccessible(true)</code>覆盖<code>Java</code>的访问控制</li><li><code>setAccessible()</code>是<code>Field, Method, Constructor</code>的公共超类<code>AccessibleObject</code>中的方法</li></ul><h2 id="通用toString">通用<code>toString()</code></h2><ul><li>使用<code>getDeclaredFields</code>获得实例字段, 使用<code>setAccessible()</code>将字段设置为可以访问的, 再对每个字段调用<code>toString()</code></li><li>不过如果引用循环会导致无限递归, <code>ObjectAnalyzer</code>会跟踪已经访问过的对象</li></ul><h2 id="使用反射编写泛型数组">使用反射编写泛型数组</h2><ul><li><code>java.util.reflect</code>中的<code>Array</code>类, <code>Arrays.copyOf()</code>就使用了这个类, 这个方法可以用来扩展一个数组  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">goodCopyOf</span><span class="params">(Object a, <span class="type">int</span> newLength)</span> &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">cl</span> <span class="operator">=</span> a.getClass();</span><br><span class="line">    <span class="keyword">if</span> (!cl.isArray()) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">componentType</span> <span class="operator">=</span> cl.getComponentType();</span><br><span class="line">    <span class="comment">// 如果对象是一个数组类型, 返回对应元素的Class, 否则返回null</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> Array.getLength(a);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">newArray</span> <span class="operator">=</span> Array.newInstance(componentType, newLength);</span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, newArray, <span class="number">0</span>, Math.min(length, newLength));</span><br><span class="line">    <span class="keyword">return</span> newArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>这个<code>goodCopyOf</code>可以扩展任意数组, 参数声明为<code>Object</code>类型, 而不是<code>Object[]</code>, 因为<code>int[]</code>可以转换为一个<code>Object</code>, 而不是转换成对象数组</li><li>如果是<code>Object[]</code>的话, 在强制类型转换回去的时候会抛出异常: <code>ClassCastException</code></li></ul><h2 id="使用反射调用任意的方法">使用反射调用任意的方法</h2><ul><li>可以使用<code>Field.get()</code>查看一个方法的字段, 使用<code>Method.invoke()</code>调用包装在当前<code>Method</code>中的方法  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Object <span class="title function_">invoke</span><span class="params">(Object obj, Object... args)</span>;</span><br><span class="line"><span class="comment">// 第一个参数是隐式参数, 其他参数是显式参数</span></span><br><span class="line"><span class="comment">// 如果是静态方法, 则第一个参数会被忽略为null</span></span><br><span class="line"><span class="comment">// 比如m1表示E类中的getName()</span></span><br><span class="line"><span class="type">String</span> <span class="variable">n</span> <span class="operator">=</span> (String) m1.invoke(h);</span><br><span class="line"><span class="comment">// 如果返回的是基本数据类型, invoke会返回其包装类型, 需要强制类型转换后使用自动拆箱</span></span><br><span class="line"><span class="comment">// 比如m2表示E类中的getSalary()</span></span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> (Double) m2.invoke(h);</span><br><span class="line"><span class="comment">// 使用getMethod()可以得到一个类中的方法</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">m1</span> <span class="operator">=</span> E.class.getMethod(<span class="string">&quot;getName&quot;</span>);</span><br><span class="line"><span class="type">Method</span> <span class="variable">m2</span> <span class="operator">=</span> E.class.getMethod(<span class="string">&quot;getSalary&quot;</span>, <span class="type">double</span>.class);</span><br><span class="line"><span class="comment">// 可以获得构造器方法</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">cl</span> <span class="operator">=</span> Random.class;</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">cons</span> <span class="operator">=</span> cl.getConstructor(<span class="type">long</span>.class);</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> cons.newInstance(<span class="number">42L</span>);</span><br></pre></td></tr></table></figure></li><li><code>Method, Construtor</code>类扩展了<code>Executable</code>类, 并且<code>Executable</code>是<code>sealed</code>的, 只允许<code>Method, Constructor</code>作为子类</li><li>比如调用<code>Math.sqrt()</code>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">dx</span> <span class="operator">=</span> (to - from) / (n - <span class="number">1</span>);</span><br><span class="line">Math.class.getMethod(<span class="string">&quot;sqrt&quot;</span>, <span class="type">double</span>.class);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> from; x &lt;= to; x += dx) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> <span class="variable">y</span> <span class="operator">=</span> (Double) f.invoke(<span class="literal">null</span>, x);</span><br><span class="line">    <span class="comment">// 因为Math.sqrt是一个静态方法, 所以invoke的第一个参数为null</span></span><br><span class="line">    System.out.printf(<span class="string">&quot;%10.4f | %10.4f%n&quot;</span>, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>反射能完成所有操作, 但是很不方便, <code>invoke</code>参数错误还会抛出异常. 同时<code>invoke</code>返回类型一定是<code>Object</code>的, 所以必须来回强制类型转换</li><li>编译器就丧失了检查代码的机会, 反射获得方法指针的代码比直接调用慢的多</li><li>所以一般只有绝对必要的时候才会引入<code>Method</code>对象, 更好的方法是使用<code>lambda</code>表达式</li><li>不要使用回调函数的<code>Method</code>对象, 要是用回掉的接口, 这样执行速度更快, 也更好维护</li></ul><h1>继承设计技巧</h1><ol><li>公共字段和方法放在超类中</li><li>不要使用<code>protected</code></li><li>使用继承实现<code>is-a</code>关系</li><li>除非所有继承的方法都有意义, 否则不要使用继承</li><li>覆盖方法不要改变预期的行为</li><li>不要滥用反射</li><li>使用多态, 不要使用类型信息 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x is of type <span class="number">1</span>) </span><br><span class="line">    action1(x)</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    action2(x)</span><br><span class="line"><span class="comment">// 这种形式的代码都可以用多态实现</span></span><br><span class="line"><span class="comment">// 如果action1() action2()表示通用的概念, 可以定义为这两个类型的公共超类或接口中的方法, 然后可以调用</span></span><br><span class="line"><span class="comment">// x.action(), 利用多态的动态分配机制执行正确的动作</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;继承&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;基本思想: 基于已有的类创建新的类, 复用已有类的方法, 可以增加一些新的方法和字段&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;反射是程序在运行期间更多地了解类以及属性的能力&lt;/li&gt;
&lt;/ul&gt;
&lt;div cl</summary>
      
    
    
    
    <category term="Java" scheme="https://sangs3112.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://sangs3112.github.io/tags/Java/"/>
    
    <category term="Java核心技术(卷一)" scheme="https://sangs3112.github.io/tags/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%8D%B7%E4%B8%80/"/>
    
  </entry>
  
  <entry>
    <title>Java笔记_8</title>
    <link href="https://sangs3112.github.io/posts/6a129434.html"/>
    <id>https://sangs3112.github.io/posts/6a129434.html</id>
    <published>2024-12-01T10:21:00.000Z</published>
    <updated>2024-12-11T04:42:14.727Z</updated>
    
    <content type="html"><![CDATA[<h1>接口</h1><blockquote><p>接口用来描述类应该做什么, 不指定具体如何做, 一个类可以实现多个接口</p></blockquote><ul><li>接口可以定义常量, 但是绝不能有实例字段</li><li><code>Java 8</code>之前, 接口中的方法都是抽象方法</li></ul><div class="note info flat"><ul><li>定义接口的方法不必指定为<code>public</code>, 因为接口方法自动为<code>public</code></li><li>接口中的字段都是<code>public static final</code>的, 也不需要手动指定</li><li>但是实现接口时, 必须明确写<code>public</code>, 否则编译器会默认认为这个方法的访问属性是包可访问, 就会报错</li></ul></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">E</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;E&gt; &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(E oth)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Double.compare(salary, oth.salary);</span><br><span class="line">    <span class="comment">// 如果x &lt; y 返回 负数</span></span><br><span class="line">    <span class="comment">// 如果x = y 返回 0</span></span><br><span class="line">    <span class="comment">// 如果x &gt; y 返回正数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info flat"><ul><li><code>Comparable</code>接口文档建议<code>compareTo</code>方法与<code>equals</code>方法兼容, 即<code>x.equals(y)</code>时, <code>x.compareTo(y) == 0</code></li><li>大部分都是兼容的, 除了<code>BigDecimal</code><ul><li><code>x = new BigDecimal(&quot;1.0&quot;)</code>和<code>y = new BigDecimal(&quot;1.00&quot;);</code>因为精度不同, 所以<code>x.compareTo(y) == 0</code>但是<code>x.equals(y) == false;</code></li><li>理论上应该不返回<code>0</code>, 但是不知道谁大谁小</li></ul></li></ul></div><ul><li>语言标准规定 <code>x.compareTo(y) == -y.compareTo(x)</code>, 同样如果前者抛出异常, 后者也必须抛出异常</li><li>如果<code>M</code>继承自<code>E</code>, <code>E</code>实现了<code>Comparable&lt;E&gt;</code>, 而没有实现<code>Comparable&lt;M&gt;</code></li><li>如果要在<code>M</code>中重写, 就要做好准备比较<code>M</code>和<code>E</code>, 不能简单的将<code>E</code>转换为<code>M</code></li><li>比如<code>x</code>是<code>M</code>, <code>y</code>是<code>E</code>, 调用<code>y.compareTo(x)</code>不会抛出异常, 调用<code>x.compareTo(y)</code>就会抛出一个<code>ClassCastException</code></li><li>可以在每个<code>compareTo</code>之前都进行检测: <code>if (getClass != oth.getClass()) throw new ClassCastException</code></li></ul><h2 id="接口属性">接口属性</h2><ul><li>接口不是类, 不能使用<code>new Comparable()</code></li><li>但是可以使用接口变量, 必须引用一个实现了这个接口的对象<code>Comparable x = new E()</code></li><li>可以使用<code>instanceof</code>检查某个对象是否实现了一个接口</li><li>可以使用<code>extends</code>扩展接口, 一个类只能有一个超类, 但是可以实现多个接口</li></ul><div class="note info flat"><ul><li>记录和枚举类不能扩展其他类, 因为他们隐式扩展了<code>Record</code>和<code>Enum</code>类, 但是他们可以实现接口</li><li>接口也可以是密封的<code>sealed</code>, 直接子类型, 必须声明在<code>permits</code>中, 或者在一个文件中</li></ul></div><h2 id="默认方法">默认方法</h2><ul><li><p>可以为接口提供一个<code>default</code>方法, 表示方法的默认实现</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(T oth)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>大部分情况没什么用, 因为每个实现的接口都会覆盖这个方法</p></li><li><p>不过有时候也能有用, 比如<code>Iterator</code>接口, 声明了一个<code>remove()</code></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportOperationException</span>(<span class="string">&quot;remove&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>默认方法也可以调用其他方法</p></li><li><p>默认方法可以实现接口演化, 实现代码兼容. 比如以前有一个类<code>class B implements Collection</code>, 后来<code>Java</code>版本更新, <code>Collection</code>接口中添加了新的方法, 如果不用<code>default</code>修饰新的方法就会导致原来的类<code>B</code>无法编译</p></li><li><p>如果在一个接口中定义了一个方法, 在超类或者另一个接口中定义了同样的方法, <code>Java</code>有自己的规则:</p><ol><li>超类优先: 如果超类定义了一个具体方法, 同名且有相同参数类型的默认方法会被忽略</li><li>接口冲突: 如果一个接口提供了一个默认方法, 另一个接口提供了一个同名并且参数类型相同的方法, 不论是否为默认方法, 就需要覆盖这个方法来解决冲突 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Name</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;<span class="keyword">return</span> getClass().getName() + <span class="string">&quot;_&quot;</span> + hashCode();&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果有一个类同时实现了这两个接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Person</span>, Name &#123;&#125;</span><br><span class="line"><span class="comment">// 编译器会报错, 需要在Student类中提供一个getName(), 可以选择两个冲突方法中的一个</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Person</span>, Name &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Person.<span class="built_in">super</span>.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 就算如果Name类中没有定义默认的getName()方法, 编译器还是会报错, 要求程序员解决二义性问题</span></span><br><span class="line"><span class="comment">// 如果两个类都没有提供默认的getName()方法, 就不会有冲突</span></span><br></pre></td></tr></table></figure><ul><li>另一种情况是类扩展了超类, 同时实现了一个接口, 超类和接口继承了相同的方法</li></ul> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Name</span> &#123;&#125;</span><br><span class="line"><span class="comment">// 这种情况下只会考虑超类的方法, 接口所有的默认方法都会被忽略</span></span><br><span class="line"><span class="comment">// 类优先的规则可以确保和Java 7的兼容性</span></span><br><span class="line"><span class="comment">// 如果为一个接口添加默认方法, 对于有默认方法之前的版本代码不会有影响</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><div class="note info flat"><ul><li>绝对不能为<code>Object</code>某个方法定义默认方法, 比如<code>toString(), equals()</code></li><li>因为类优先的规则, 这样的方法绝对无法超越<code>Object.toString()</code>或<code>Objects.equals()</code></li></ul></div><h2 id="Comparator接口"><code>Comparator</code>接口</h2><ul><li><p>如果调用<code>Arrays.sort()</code>对字符串进行排序的话, 会按照字典序</p></li><li><p>现在如果想要按照字符串的长度进行排序, 就不能修改<code>String.compareTo()</code></p></li><li><p>可以使用<code>Arrays.sort()</code>方法的第二个版本, 接受一个数组和一个比较器作为参数, 比较器是实现了<code>Comparator</code>接口的类的实例</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">compare</span><span class="params">(T first, T second)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 比如需要按照长度比较字符串, 可以以如下方法实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LengthComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String first, String second)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> first.length() - second.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 完成比较需要建立一个实例</span></span><br><span class="line"><span class="type">var</span> <span class="variable">comp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LengthComparator</span>();</span><br><span class="line"><span class="keyword">if</span> (comp.compare(words[i], words[j]) &gt; <span class="number">0</span>) &#123;&#125;</span><br><span class="line"><span class="comment">// 如果需要对一个数组进行排序, 可以调用 Arrays.sort()</span></span><br><span class="line">String[] f = &#123;&#125;;</span><br><span class="line">Arrays.sort(f, <span class="keyword">new</span> <span class="title class_">LengthComparator</span>);</span><br></pre></td></tr></table></figure></li><li><p>静态<code>comparing</code>方法接受一个键提取器函数, 将类型<code>T</code>映射为一个可比较的类型, 比如<code>String</code></p><ul><li>要比较的对象引用这个函数, 然后对返回的键完成比较, 比如假设有一个<code>Person</code>数组, 可以按照名字进行排序</li><li><code>Arrays.sort(people, Comparator.comparing(Person::getName));</code></li><li>可以把比较器和<code>thenComparing()</code>串起来, 处理比较相同的结果</li><li><code>Arrays.sort(people, Comparator.comparing(Person::getLastName).thenComparing(Person::getFirstName));</code></li><li>可以给<code>comparing</code>和<code>thenComparing</code>提取的键指定一个比较器, 完成对人名长度的排序</li><li><code>Arrays.sort(people, Comparator.comparing(Person::getName, (s, t) -&gt; Integer.compare(s.length(), t.length())));</code></li><li><code>Arrays.sort(people, Comparator.comparingInt(p -&gt; p.getName().length()));</code></li></ul></li><li><p>如果键函数可能返回<code>null</code>, 就需要用到<code>nullsFirst</code>和<code>nullsLast</code>适配器, 可以修改比较器, 遇到<code>null</code>的时候不会抛出异常, 而是标记当前值小于或大于正常值</p><ul><li><code>Comparator.comparing(Person::getMiddleName(), Comparator.nullsFirst(...));</code></li><li><code>nullsFirst</code>方法需要一个比较器, 就是两个字符串的比较器</li><li><code>naturalOrder</code>方法可以为任何实现了<code>Comparable</code>的类建立一个比较器</li><li><code>Arrays.sort(people, comparing(Person::getMiddleName, nullsFirst(naturalOrder()));</code></li><li>静态<code>reverseOrder</code>方法可以提供逆序, 等同于<code>naturalOrder().reversed()</code></li></ul></li></ul><h2 id="Cloneable接口"><code>Cloneable</code>接口</h2><ul><li><code>clone</code>是<code>Object</code>的<code>protected</code>方法, 不能直接调用这个方法, 子类只能调用受保护的<code>clone()</code>来克隆他自己的对象, 如果其中包含了一些其他对象, 就没有办法<code>clone</code>了</li><li>默认的克隆操作是一个浅拷贝, 没有克隆对象中引用的其他对象</li><li>如果原对象和浅克隆对象共享的子对象是不可变的, 那么这种共享就是安全的, 比如<code>String</code><ul><li>或者在对象生命周期中, 子对象一直保持不变，没有更改器方法改变它, 也没有方法生成他的引用, 这种情况下就是安全的</li></ul></li><li>但是大多数情况下, 子对象都是可变的, 必须重新定义<code>clone</code>方法, 需要确定<ol><li>默认的<code>clone</code>方法能满足要求</li><li>可以在可变子对象上调用<code>clone</code>弥补默认的<code>clone</code></li><li>不能使用<code>clone</code></li></ol><ul><li>如果指定第一项或者第二项, 需要实现<code>Cloneable</code>接口, 重新定义<code>clone</code>方法, 同时指定<code>public</code></li></ul></li></ul><div class="note info flat"><ul><li><code>Cloneable</code>接口是<code>Java</code>中少数的标记接口, 记号接口</li><li>用途是确保一个类实现一个特定的方法或一组方法, 标记接口不包含任何方法, 唯一的作用就是允许在类型查询中使用<code>instabceof</code></li><li>自己写代码<strong>不要</strong>使用标记接口</li></ul></div><ul><li>即使默认的<code>clone()</code>可以满足要求, 还是需要实现<code>Clonebale</code>接口, 将<code>clone</code>重新定义为<code>public</code>, 调用<code>super.clone()</code>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">E</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportException &#123;</span><br><span class="line">        <span class="type">E</span> <span class="variable">cloned</span> <span class="operator">=</span> (E) <span class="built_in">super</span>.clone();</span><br><span class="line">        cloned.Day = (Date) Day.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><div class="note info flat"><ul><li>需要注意子类的克隆, 一旦为<code>E</code>定义了<code>clone()</code>, 别人就可以使用他克隆子类<code>M</code></li><li>所以最好避免使用<code>clone()</code>, 使用另一个方法达到同样的目的</li></ul></div><h1><code>lambda</code>表达式</h1><blockquote><p><code>lambda</code>表达式是一个可传递的代码块, 可以在以后执行一次或多次</p></blockquote><ul><li>以上面的排序为例, <code>first.length() - secode.length()</code> 其中<code>first, second</code>都是字符串  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lambda表达式写法</span></span><br><span class="line">(String first, String second) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (first.length() &lt; second.length()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (first.length() &gt; second.length()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 即使lambda表达式没有参数, 仍然需要提供空括号</span></span><br><span class="line">() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果可以推导出lambda表达式的类型, 就可以忽略类型</span></span><br><span class="line">Comparator&lt;String&gt; comp = (first, second) -&gt; &#123;</span><br><span class="line">    first.length() - second.length();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果只有一个参数, 并且参数类型还可以推导出来, 那么还可以省略小括号</span></span><br><span class="line"><span class="type">ActionListener</span> <span class="variable">listener</span> <span class="operator">=</span> event -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;1111&quot;</span> + Instant.ofEpochMilli(event.getWhen()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不需要指定lambda表达式的返回类型, 因为返回类型一定会根据上下文推导得到</span></span><br><span class="line"><span class="comment">// 可以使用var指示一个推导的类型, 不常用, 一般为了关联注解</span></span><br><span class="line">(<span class="meta">@NonNull</span> <span class="keyword">var</span> first, <span class="meta">@NonNull</span> <span class="keyword">var</span> second) -&gt; first.length() - second.length();</span><br></pre></td></tr></table></figure></li></ul><div class="note info flat"><ul><li>如果一个<code>lambda</code>表达式只有部分分支有返回值, 是不合法的</li></ul></div><h2 id="函数式接口">函数式接口</h2><ul><li>对于只有一个抽象方法的接口, 需要这种接口的对象时, 就可以提供一个<code>lambda</code>表达式, 称为函数式接口  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比如Arrays.sort()第二个参数需要一个Comparator实例</span></span><br><span class="line"><span class="comment">// 只有一个抽象方法的接口, 就可以改成lambda表达式</span></span><br><span class="line">Arrays.sort(words, (first, second) -&gt; first.length() - second.length());</span><br><span class="line"><span class="comment">// 可以把lambda表达式看作一个函数, 而不是一个对象, 同时lambda表达式可以传递到函数式接口</span></span><br><span class="line"><span class="comment">// 不能把lambda表达式赋值给类型为Object的变量, Object不是一个函数式接口</span></span><br><span class="line"><span class="comment">// ArrayList通过lambda表达式删除一个数组列表中所有的null</span></span><br><span class="line">list.removeIf(e -&gt; e == <span class="literal">null</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="方法引用">方法引用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>(<span class="number">1000</span>, event -&gt; System.out.println(event));</span><br><span class="line"><span class="comment">// 方法引用可以直接将println传入timer中</span></span><br><span class="line"><span class="type">var</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>(<span class="number">1000</span>, System.out::println);</span><br><span class="line"><span class="comment">// 这里System.out::println是一个方法引用</span></span><br><span class="line"><span class="comment">// 指示编译器生成一个函数式接口实例, 覆盖这个接口的抽象方法来调用给定的方法</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> System.out::println;</span><br><span class="line"><span class="comment">// 这里的Runnable函数式接口有一个无参数的抽象方法 void run()</span></span><br><span class="line"><span class="comment">// 这里调用task.run() 就会自动选择无参数的println() 打印一个空行</span></span><br><span class="line"><span class="comment">// 如果想要对字符串进行排序, 忽略大小写</span></span><br><span class="line">Arrays.sort(words, String::compareToIgnoreCase);</span><br></pre></td></tr></table></figure><ul><li>使用<code>::</code>操作符分割方法名和对象或者类名, 有三种情况:<ol><li><code>object::instanceMethod</code><ul><li>方法引用等价于一个<code>lambda</code>表达式, 参数传递到方法, 对于<code>System.out::println</code>, 对象是<code>System.out</code>, 方法等价于<code>x -&gt; System.out.println(x)</code></li></ul></li><li><code>Class::instanceMethod</code><ul><li>第一个参数会成为隐式参数, 比如<code>String::compareToIgnoreCase</code>等同于<code>(x, y) -&gt; x.compareToIgnoreCase(y)</code></li></ul></li><li><code>Class::staticMethod</code><ul><li>所有参数都传递到静态方法, <code>Math::pow</code>等价于<code>(x, y) -&gt; Math.pow(x, y)</code></li></ul></li></ol></li></ul><div class="note info flat"><ul><li>只有当<code>lambda</code>表达式的体只调用一个方法而不做其他操作的时候, 才能将其转换为方法引用</li><li><code>s -&gt; s.length() == 0</code>里面只有一个方法调用, 但是还有一个比较, 所以不能使用方法引用</li><li>方法引用不会独立存在, 总是会转换为函数式接口的实例</li><li>如果要删除数组中所有为空的值, 可以使用 <code>list.removeIf(Objects::isNull)</code></li><li>包含对象的方法引用与等价的<code>lambda</code>表达式的区别, 比如<code>separator::equals</code>, 如果<code>separator</code>为<code>null</code>, 构造<code>separator::equals</code>时就会立即抛出<code>NullPointerException</code>异常, <code>lambda</code>表达式<code>x -&gt; separator.equals(x)</code>只会在调用时才会抛出<code>NPE</code></li></ul></div><ul><li>可以在方法引用中使用<code>this</code>参数, 比如<code>this::equals</code> 等同于<code>x -&gt; this.equals(x)</code></li><li>同样使用<code>super</code>也是可以的</li></ul><h2 id="构造器引用">构造器引用</h2><blockquote><p>和方法引用类似, 只不过方法名为<code>new</code>, 比如<code>Person::new</code>是<code>Person</code>的构造器引用, 使用哪一个构造器取决于上下文</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; names = ...;</span><br><span class="line">Stream&lt;Person&gt; stream = names.stream().map(Person::<span class="keyword">new</span>);</span><br><span class="line">List&lt;Person&gt; people = stream.toList();</span><br><span class="line"><span class="comment">// 这里将字符串列表转换为一个Person数组</span></span><br><span class="line"><span class="comment">// map为各个列表元素调用Person(String)构造器</span></span><br></pre></td></tr></table></figure><ul><li><code>int[]::new</code>有一个数组的长度作为参数, 是一个构造器引用</li><li><code>Java</code>中无法构造泛型类型<code>T</code>的数组, 数组构造器可以克服这个限制</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object[] people = stream.toArray();</span><br><span class="line"><span class="comment">// toArray()可以返回一个Object类型数组, 但是如果希望得到一个Person数组, 就需要构造器引用</span></span><br><span class="line">Person[] people = stream.toArray(Person[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure><h2 id="变量作用域">变量作用域</h2><ul><li>一个<code>lambda</code>表达式有三个部分<ol><li>一个代码块</li><li>参数</li><li>自由变量: 指非参数, 并且不在代码中定义的变量</li></ol></li><li><code>lambda</code>会将自由变量的值复制到<code>lambda</code>表达式的数据结构实例对象中</li></ul><div class="note info flat"><ul><li><code>lambda</code>表达式中只能引用不会改变的值, 比如引用<code>int</code>就是不合法的</li><li>如果在<code>lambda</code>表达式中更改变量, 并发执行多个动作的时候就不安全</li><li>就算<code>lambda</code>表达式内部没有修改变量, 但是这个变量也有可能在外部改变, 这也是不合法的</li><li><code>lambda</code>表达式捕获的变量必须是<strong>事实最终变量</strong>, 指的是这个变量初始化以后不会赋新值, 比如<code>String</code></li><li><code>lambda</code>表达式中不能声明和局部变量同名的参数或变量</li></ul></div><ul><li>在<code>lambda</code>表达式中使用<code>this</code>参数的时候, 是指创建这个<code>lambda</code>表达式的方法的<code>this</code>参数  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> event -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="built_in">this</span>.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里的this.toString()调用的是A对象的toString(), 而不是B实例方法</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="处理lambda表达式">处理<code>lambda</code>表达式</h2><blockquote><p><code>lambda</code>表达式的重点是延迟执行</p></blockquote><ul><li>延迟执行的原因<ol><li>单线程</li><li>多次运行代码</li><li>在算法的适当位置运行, 比如排序的比较操作</li><li>发生某种情况的时候运行, 比如点击按钮, 数据到达</li><li>只有必要时才运行代码</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repeat(<span class="number">10</span>, () -&gt; System.out.println(<span class="string">&quot;1&quot;</span>));</span><br></pre></td></tr></table></figure><ul><li>如果设计自己的函数式接口, 里面只有一个抽象方法, 可以使用<code>@FunctionalInterface</code>注解来标记接口<ul><li>这样如果添加了一个新的抽象方法, 可以检查出来并报错</li><li>同时<code>javadoc</code>会标记这个接口是一个函数式接口</li><li>不是必须使用这个注解</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;接口&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;接口用来描述类应该做什么, 不指定具体如何做, 一个类可以实现多个接口&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;接口可以定义常量, 但是绝不能有实例字段&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Java 8&lt;/code&gt;</summary>
      
    
    
    
    <category term="Java" scheme="https://sangs3112.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://sangs3112.github.io/tags/Java/"/>
    
    <category term="Java核心技术(卷一)" scheme="https://sangs3112.github.io/tags/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%8D%B7%E4%B8%80/"/>
    
  </entry>
  
  <entry>
    <title>Docker笔记_0</title>
    <link href="https://sangs3112.github.io/posts/81d2299d.html"/>
    <id>https://sangs3112.github.io/posts/81d2299d.html</id>
    <published>2024-11-30T01:53:35.000Z</published>
    <updated>2024-12-11T04:42:14.723Z</updated>
    
    <content type="html"><![CDATA[<h1><code>Docker</code> 下载安装</h1><blockquote><p>众所周知, 来自中国的程序员往往具有更好的网络相关基础 :(</p><p>因为多次尝试在<code>Ubuntu</code>上安装<code>Docker</code>以及<code>Docker Compose</code>, 中间踩了无数坑, 为此在这里做一个记录总结</p><p>如果有条件, 直接<code>clash</code>, 按照官网的流程, 大抵是可行的 (虽然我尝试了一下还是存在不少问题…)</p><p>哪怕直接<code>sudo apt install docker</code> 也是完全不行的, 软件源中的<code>docker</code>是究极老版本, 几乎用不了</p></blockquote><ol><li>卸载 <code>Docker</code> (有可能叫<code>docker-engine</code> <code>docker.io</code>)</li></ol><blockquote><p><code>Ubuntu</code>大概率会自带老版本的<code>Docker</code>, 很多语法还有命令都不一样了, 所以需要先卸载了</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt remove docker docker-engine docker.io containerd runc</span><br></pre></td></tr></table></figure><ol start="2"><li>更新软件包</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade</span><br></pre></td></tr></table></figure><ol start="3"><li>安装一些依赖</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ca-certificates curl gnupg lsb-release</span><br></pre></td></tr></table></figure><ol start="4"><li>添加<code>Docker</code>官方<code>GPG</code>密钥</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure><ol start="5"><li>添加<code>Docker</code>软件源</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository &quot;deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot;</span><br></pre></td></tr></table></figure><ol start="6"><li>安装<code>Docker</code></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure><ol start="7"><li>配置用户组</li></ol><blockquote><p>如果不配置的话, 运行<code>Docker</code>的时候会一直提示没有<code>root</code>权限</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure><ul><li>配置完以后需要重新登录才能刷新</li></ul><h1><code>Docker Compose</code> 下载安装</h1><ol><li><p>使用<code>docker version</code>查看<code>Docker</code>版本</p></li><li><p>接着按照<a href="https://docs.docker.com/compose/install/">这个链接</a>里面步骤操作即可.</p><ul><li>因为现在我三台<code>Linux</code>服务器已经安装过了, 不想再卸载重新搞了, 以后下一台机器搞的时候再加上截图以及具体步骤</li></ul></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">github: https://github.com/docker/compose/releases/tag/v2.20.2</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">国内下载地址：https://gitee.com/smilezgy/compose/releases/tag/v2.20.2</span></span><br><span class="line">sudo curl -SL \</span><br><span class="line">https://github.com/docker/compose/releases/download/v2.20.2/docker-compose-linux-x86_64 \</span><br><span class="line">-o /usr/local/bin/docker-compose</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者手动下载, 上传到服务器后执行如下指令(use)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在 docker-compose-linux-x86_64 文件同一目录下执行</span></span><br><span class="line">sudo cp docker-compose-linux-x86_64 /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><ol start="3"><li>添加执行权限</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><h1>使用<code>Docker</code>以及<code>Docker Compose</code></h1><blockquote><p>安装好只是第一步. 2024-06 之后<code>Docker</code>国内的绝大部分镜像站都停了</p><p>比如<code>Docker</code>中国, 网易云, 七牛云, 腾讯云, 百度云, 各个大学</p></blockquote><ul><li>可以在<a href="https://gist.github.com/y0ngb1n/7e8f16af3242c7815e7ca2f0833d3ea6">这个链接</a>中找到停止服务的镜像以及还能用的镜像</li></ul><h2 id="2024-10为止还能使用的镜像站">2024-10为止还能使用的镜像站</h2><blockquote><p>不知道还会撑多久 :(</p></blockquote><table><thead><tr><th>镜像站</th><th>链接</th></tr></thead><tbody><tr><td>1Panel</td><td><a href="https://docker.1panel.live">https://docker.1panel.live</a></td></tr><tr><td>耗子面板</td><td><a href="https://hub.rat.dev">https://hub.rat.dev</a></td></tr><tr><td>不知名</td><td><a href="https://docker.zlzlme.cloudns.ph/">https://docker.zlzlme.cloudns.ph/</a></td></tr></tbody></table><h2 id="Docker换源"><code>Docker</code>换源</h2><blockquote><p>如果不换源, 那么<code>docker pull</code>就会失败</p></blockquote><ol><li>编辑<code>/etc/docker/daemon.json</code></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/docker/daemon.json</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">daemon.json</span></span><br><span class="line">&#123;</span><br><span class="line">    &quot;registry-mirrors&quot;: [</span><br><span class="line">        &quot;https://docker.1panel.live&quot;,</span><br><span class="line">        &quot;https://hub.rat.dev&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>重启<code>Docker</code>服务</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><ol start="3"><li>检查是否配置成功</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker info</span><br></pre></td></tr></table></figure><ul><li>如果配置成功了, 镜像信息会显示在最后</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;code&gt;Docker&lt;/code&gt; 下载安装&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;众所周知, 来自中国的程序员往往具有更好的网络相关基础 :(&lt;/p&gt;
&lt;p&gt;因为多次尝试在&lt;code&gt;Ubuntu&lt;/code&gt;上安装&lt;code&gt;Docker&lt;/code&gt;以及&lt;c</summary>
      
    
    
    
    <category term="Docker" scheme="https://sangs3112.github.io/categories/Docker/"/>
    
    
    <category term="Docker" scheme="https://sangs3112.github.io/tags/Docker/"/>
    
    <category term="Docker Compose" scheme="https://sangs3112.github.io/tags/Docker-Compose/"/>
    
    <category term="Docker安装" scheme="https://sangs3112.github.io/tags/Docker%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>Java笔记_6</title>
    <link href="https://sangs3112.github.io/posts/8daab933.html"/>
    <id>https://sangs3112.github.io/posts/8daab933.html</id>
    <published>2024-11-29T01:53:35.000Z</published>
    <updated>2024-12-11T04:42:14.723Z</updated>
    
    <content type="html"><![CDATA[<h1>面向对象编程(<code>OOP</code>)</h1><ul><li><code>Java</code>中对象变量只是包含了一个引用，没有实际包含一个变量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">startTime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="comment">// 这里的startTime只是一个指向Date实例的引用</span></span><br><span class="line"><span class="comment">// 不能看作是CPP中的引用，应该看作CPP中的对象指针，也就是Date* startTime</span></span><br></pre></td></tr></table></figure><ul><li>所有的<code>Java</code>对象都存储在堆中，当一个对象包含了另一个对象的时候，实际上只是包含了另一个对象在堆中的指针</li><li>所以如果需要得到一个对象的副本，不能简单的用<code>=</code>，而是应该用<code>clone()</code>方法</li></ul><h2 id="更改器方法和访问器方法">更改器方法和访问器方法</h2><ul><li>更改器方法: 调用方法以后，对应实例的状态会改变</li><li>访问器方法: 调用方法以后，只访问对象，不会修改他。比如(<code>get()</code>)<ul><li>访问器方法<strong>不要返回</strong>可变对象引用<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">E</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Date hireDay;</span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getHireDay</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> hireDay;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里的hireDay就是一个Date类的对象引用，而Date类本身存在更改器方法setTime</span></span><br><span class="line"><span class="comment">// 所以hireDay是可变的，破坏了封装性</span></span><br><span class="line"><span class="comment">// 如果需要返回一个可变对象引用，需要先clone</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">R</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getHireDay</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (Date) hireDay.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><div class="note info flat"><p><code>CPP</code>中带有<code>const</code>后缀的方法是访问器方法，没有<code>const</code>后缀的方法是更改器方法<br><code>Java</code>中没有这种明显的标识</p></div><ul><li>构造器没有返回值，总是和<code>new</code>一起使用</li><li>所有的方法中都不要使用和实例字段同名的方法，可以同名，但是最好不要出现，除了后面讲到的<code>record</code></li><li>实例字段不要设置成<code>public</code>，这样会破坏封装，要保证数据私有</li><li>在构造类的实例时，推荐使用<code>var</code>来声明这个对象的类型，这样就不用重复写类了</li><li>不要对数值类型写<code>var</code>，<code>var</code>只能用于局部字段，对于参数和实例字段不能使用<code>var</code></li></ul><h2 id="null"><code>null</code></h2><ul><li>对象变量包含一个引用，或者是<code>null</code></li><li>如果对<code>null</code>值变量调用方法会产生<code>NullPointException</code></li><li>初始类型不会是<code>null</code>，尤其需要注意<code>String</code>类型的<code>null</code>，可以检测到以后将其转换为另一个值  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (n == <span class="literal">null</span>) &#123;</span><br><span class="line">    name = <span class="string">&quot;unknown&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    name = n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 也有更简单的方法</span></span><br><span class="line">name = Objects.requireNonNullElse(n, <span class="string">&quot;unknown&quot;</span>);</span><br><span class="line"><span class="comment">// 或者可以直接拒绝null</span></span><br><span class="line">name = Objects.requireNonNull(n, <span class="string">&quot;The name can not be null&quot;</span>);</span><br><span class="line"><span class="comment">// 这样可以直接定位到哪里有空值，如果等程序自动触发NPE的话，可能不是空值存在的地方</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="静态字段">静态字段</h2><h3 id="静态变量">静态变量</h3><ul><li>一个对象定义为<code>static</code>，那么这个字段并不出现在每个类的对象中。每个静态字段只有一个副本</li><li>所以静态字段属于类，但是不属于单个类</li><li>比如对员工分配唯一的标识码  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">E</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">nextId</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">E</span><span class="params">()</span> &#123;</span><br><span class="line">        id = nextId;</span><br><span class="line">        nextId ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这样所有员工共享一个nextId，但是每个员工有自己的id</span></span><br><span class="line"><span class="comment">// 就算没有员工对象，这个nextId也是存在的</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="静态常量">静态常量</h3><ul><li>静态常量相比于静态变量更加常用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Math</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.14</span>...;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">System</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">PrintStream</span> <span class="variable">out</span> <span class="operator">=</span> ...;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 分别使用Math.PI和System.out可以访问</span></span><br><span class="line"><span class="comment">// 如果省略了static，那么PI就需要通过一个MATH的实例来访问</span></span><br></pre></td></tr></table></figure><ul><li>最好不要有公共字段，因为公共字段谁都可以访问，但是如果是final的公共常量就不要紧</li><li>因为<code>out</code>是由<code>final</code>修饰的，所以<code>out</code>本身是不允许重新赋值的。</li><li>但是<code>System</code>中有一个<code>setOut</code>方法，这是因为<code>setOut</code>方法不是<code>Java</code>实现的，是一个原生方法，可以跳过访问控制机制</li></ul><h2 id="静态方法">静态方法</h2><ul><li>静态方法是不操作对象的方法，比如<code>Math.pow(x, a)</code>，不需要使用<code>Math</code>对象，没有隐式参数</li><li>所以上面的<code>E</code>类，静态方法不能访问<code>id</code>字段，因为不操作对象。但是可以访问静态字段</li><li>同样可以使用对象实例调用静态方法，但是没有意义，因为静态方法与对象无关，所以最好直接用类名调用静态方法</li></ul><div class="note info flat"><p>以下两种情况可以使用静态方法:</p><ol><li>方法不需要访问对象状态，所有的参数可以直接通过显示参数提供，比如<code>Math.pow(x, a)</code></li><li>方法只需要访问静态字段</li></ol></div><ul><li><code>main</code>方法就是一个静态方法，可以在每个类都创建一个静态方法，用于演示。</li><li>不演示的时候直接调用<code>Application.main</code>则不会执行内部其他类的<code>main</code>函数</li></ul><h3 id="静态工厂方法">静态工厂方法</h3><div class="note info flat"><p>为什么不用构造器要用静态工厂方法：</p><ol><li>无法为构造器命名，因为构造器的命名总是要与类名相同，但是如果需要得到两个不同的名字，就无法实现了</li><li>构造器无法改变构造对象的类型，静态工厂方法可以返回指定的类型，比如某个类的子类</li></ol></div><h2 id="构造器">构造器</h2><ul><li><p>可以在一个构造器中调用另一个构造器</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">E</span> <span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 调用了E(String, double)的构造方法，这样只需要写一次公共的构造函数</span></span><br><span class="line">        <span class="built_in">this</span> (<span class="string">&quot;123&quot;</span> + nextId, s);</span><br><span class="line">        nextId ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>自动定义的设置所有实例字段的构造器是标准构造器</p></li><li><p>自定义构造器的第一个语句必须调用另一个构造器，最终调用标准构造器</p></li></ul><h1>记录</h1><blockquote><p><code>Java 14</code>引入，<strong>状态不可变</strong>，公共可读。一个记录的实例字段称为组件</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">record</span> <span class="title class_">Point</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> &#123;&#125;;</span><br><span class="line"><span class="comment">// 这个Point就是一个记录，不再需要写class中的很多内容</span></span><br><span class="line"><span class="comment">// 具有一个构造器 Point(double x, double y)</span></span><br><span class="line"><span class="comment">// 具有两个访问器 public double x(); public double y()</span></span><br><span class="line"><span class="comment">// 方法和实例字段可以同名</span></span><br><span class="line"><span class="type">var</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">System.out.Println(p.x() + <span class="string">&quot; &quot;</span> + p.y());</span><br></pre></td></tr></table></figure><ul><li>每个记录都有自动定义的三个方法: <code>toString</code> <code>equals</code> <code>hashCode</code></li><li>记录可以自己定义静态字段和方法，但是不能新增<strong>实例字段</strong>，实例字段应该全部都作为参数</li></ul><h1>包</h1><blockquote><p>包名为了确保类名的唯一性，一般是域名的逆序.项目名.类名</p></blockquote><ul><li>一个类可以使用所属包中的所有类，以及其他包中的公共类</li><li>如果包名写错了，但是他不依赖其他包，就可以顺利编译通过，执行的时候会失败，因为虚拟机无法根据包名找到类</li></ul><h2 id="jar"><code>jar</code></h2><ul><li>使用<code>jar cvf jarFileName file1 file2 ... </code>创建新的<code>jar</code>文件 <code>u</code>选项可以更新<code>jar</code>包</li><li>每个<code>jar</code>都包含一个清单文件<code>manifest</code>用于描述归档文件的特殊性<ul><li>清单文件<code>MANIFEST.MF</code>位于<code>jar</code>文件的<code>META-INF</code>子目录中</li><li>清单文件中包含多个条目，分组成多个节。第一节称为主节，作用于整个<code>JAR</code>文件</li><li>节与节之间使用空行分割，除主节外，随后的每一节中的条目可以指定命名实体的属性，比如单个文件，包或者<code>url</code>，都需要以<code>Name</code>条目开始</li><li>如果需要编辑清单文件，可以将需要添加到清单文件的行放到文本文件中，使用<code>jar cfm jarFileName manifestFileName</code></li><li>如果需要更新清单文件，可以将增加的部分放到文本文件中，使用<code>jar ufm xxx.jar manifest-additions.mf</code></li><li>清单文件的最后一行需要以换行符作为结束，否则无法正确读取</li></ul></li><li>可以使用<code>jar cvfe xxx.jar xxxxxClass</code>来指定程序的入口点<ul><li>或者可以在清单文件中添加主类<code>Main-Class: xxxxxClass</code></li><li>这样就可以使用<code>java -jar xxx.jar</code>来启动程序<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hello.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.Println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 比如上述Hello.java文件，使用javac Hello.java可以编译为Hello.class文件，运行java Hello应该可以直接输出Hello</span></span><br><span class="line"><span class="comment">// 此时如果使用jar cvf Hello.jar Hello.java Hello.class的话，将会生成Hello.jar</span></span><br><span class="line"><span class="comment">// 运行java -jar Hello.jar文件，会报错，提示没有主清单属性</span></span><br><span class="line"><span class="comment">// 第一种解决办法: 重新生成一个jar包，生成的时候指定入口程序</span></span><br><span class="line"><span class="comment">// jar -cvfe Hello.jar Hello Hello.java Hello.class</span></span><br><span class="line"><span class="comment">// 第一个Hello.jar是生成的jar包，第二个Hello是主入口程序为Hello这个类，第三个和第四个是jar包中需要包含的文件</span></span><br><span class="line"><span class="comment">// 第二种解决办法: 修改MANIFEST.mf文件</span></span><br><span class="line"><span class="comment">// 创建一个MANIFEST-ADD.mf文件，添加Main-Class: Hello</span></span><br><span class="line"><span class="comment">// 这里一定需要换行，然后保存文件后，运行 jar -ufm Hello.jar MANIFEST-ADD.mf即可</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="多版本jar">多版本<code>jar</code></h3><blockquote><p><code>JAVA 9</code>引入了多版本<code>jar</code>，将特定于版本的类文件放在了<code>META-INF/versions</code>中</p></blockquote><ul><li>如果要增加不同版本(比如java 9)的类文件，可以使用<code>jar -uf xxx.jar --release 9 xxx.class</code></li><li>如果要从头构建一个多版本<code>jar</code>，可以使用<code>-C</code>，每个对应的版本切换到一个不同的类文件目录<br><code>jar cf xxx.jar -C bin/8 . --release 9 -C bin/9 xxx.class</code></li><li>不同版本的编译，需要使用<code>--release</code>和<code>-d</code>指定输出目录</li><li>多版本<code>jar</code>唯一的作用是让你的程序可以使用不同版本的<code>jdk</code></li></ul><h1>注释</h1><h2 id="类注释">类注释</h2><ul><li>放在 <code>import</code> 之后, <code>class</code> 之前</li><li>使用<code>\**  *\</code></li></ul><h2 id="方法注释">方法注释</h2><ul><li>可以对方法的作用，方法的参数，返回值，异常添加注释，使用<code>@param, @return, @throws</code></li></ul><h2 id="字段注释">字段注释</h2><ul><li>只需要对公共字段，静态常量进行注释</li></ul><h2 id="包注释">包注释</h2><ul><li>需要单独写一个文件，比如<code>package-info.java</code>，里面是文档注释</li><li>或者可以写一个<code>package.html</code>，里面抽取标记<code>&lt;body&gt;...&lt;/body&gt;</code>的所有文本</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;面向对象编程(&lt;code&gt;OOP&lt;/code&gt;)&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Java&lt;/code&gt;中对象变量只是包含了一个引用，没有实际包含一个变量&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;</summary>
      
    
    
    
    <category term="Java" scheme="https://sangs3112.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://sangs3112.github.io/tags/Java/"/>
    
    <category term="Java核心技术(卷一)" scheme="https://sangs3112.github.io/tags/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%8D%B7%E4%B8%80/"/>
    
  </entry>
  
  <entry>
    <title>Java笔记_5</title>
    <link href="https://sangs3112.github.io/posts/14a3e889.html"/>
    <id>https://sangs3112.github.io/posts/14a3e889.html</id>
    <published>2024-11-26T01:53:35.000Z</published>
    <updated>2024-12-11T04:42:14.723Z</updated>
    
    <content type="html"><![CDATA[<h1>概述和环境</h1><h2 id="源码文件">源码文件</h2><ol><li>确保安装了<code>JDK</code>，并且配置了环境变量</li><li><code>jdk/lib</code>目录中可以找到<code>src.zip</code>，这个压缩包包含了<strong>所有的公共类库</strong>的源码</li><li>使用<code>jar xvf jdk/lib/src.zip</code>可以将<code>src.zip</code>解压缩到<strong>当前目录</strong>下</li><li>如果是别的源码，比如编译器，原生方法，虚拟机，私有辅助类，需要从<code>openjdk</code>那边拿到</li></ol><h2 id="控制台运行Java">控制台运行Java</h2><ol><li>一个包含<code>Main</code>函数的<code>Java</code>类，使用<code>javac xxx.java</code>可以将<code>.java</code>文件编译为<code>.class</code>文件</li><li>然后再使用<code>java xxx</code>，不需要加<code>.class</code>后缀即可直接运行这个编译后的文件</li></ol><h2 id="JShell"><code>JShell</code></h2><ul><li><code>Java 9</code>引入了另一种使用<code>Java</code>的方法，就是&quot;读取-评估-打印循环&quot; (<code>Read-Evaluate-Print Loop</code>, <code>REPL</code>)</li><li>输入一个<strong>表达式</strong>，<code>JShell</code>会评估输入，打印结果，并等待下一个输入。直接在控制台输入<code>jshell</code>即可开始使用<ul><li>输入<code>&quot;java&quot;.length()</code>就会返回字符个数<code>$1 ==&gt; 4</code></li><li>然后再输入<code>4 * $1 + 1</code>，会返回<code>$2 ==&gt; 17</code></li><li>并不需要手动输入<code>System.out.println()</code>也可以直接返回结果，并自动存储变量</li><li>也可以手动指定变量名，例如<code>int ans = 42</code>，会返回结果<code>ans ==&gt; 42</code></li></ul></li></ul><h1><code>Java</code>规范</h1><ol><li>类名需要驼峰：首字母大写，后面每个单词的首字母均大写</li><li>文件名必须和文件内的公共类相同</li><li><code>main</code>函数一定需要在<code>public</code>类中，虚拟机从<code>main</code>函数开始执行，<code>main</code>方法总是静态的</li><li><code>main</code>函数返回值为<code>0</code>，如果需要以其他的返回值返回，需要使用<code>System.exit(nums)</code></li><li>变量的声明尽可能靠近使用变量的地方</li><li><code>Java 10</code>开始，对于局部变量，可以使用<code>var</code>关键字声明，这样可以从变量的初始值推断出他的类型<ul><li><code>var d = 12; // d is an int</code></li><li><code>var s = &quot;12&quot;; // s is a String</code></li></ul></li><li><code>Java</code>中不区分变量的声明和定义</li></ol><h1>类型</h1><ul><li><code>Java</code>具有8种基本类型，其中4种整型，2种浮点类型，1种字符类型<code>char</code>(用于表示<code>Unicode</code>编码)，1种<code>boolean</code>类型</li><li>同时<code>Java</code>具有一个表示任意精度的算数包，大数<code>big number</code>是一个<code>Java</code>对象，而不是基本<code>Java</code>类型了</li></ul><h2 id="整型">整型</h2><ul><li><code>Java</code>的<code>int</code>无论在什么环境下都是<code>4 Bytes</code>，可以表示<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">2 \times 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span></li><li>可以给数字加上下划线，在编译时会自动去除，方便源码阅读: <code>12_000_000_000</code></li><li><code>Java</code>中没有无符号类型，如果确实需要无符号数，比如<code>short</code>表示范围需要在<code>0~255</code>之间的话，进行计算的时候可以使用<code>Byte.toUnsignedInt(b)</code>来得到一个无符号整数</li></ul><h2 id="浮点型">浮点型</h2><ul><li>一般都使用<code>8 Bytes</code>的<code>double</code>类型，<strong>而不是</strong><code>4 Bytes</code>的<code>float</code>类型。</li><li>可以使用十六进制表示浮点数字面量，例如<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.125</mn><mo>=</mo><msup><mn>2</mn><mrow><mo>−</mo><mn>3</mn></mrow></msup></mrow><annotation encoding="application/x-tex">0.125 = 2^{-3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.125</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span></span>可以写成<code>0x1.0p-3</code>。<ul><li>这里<code>0x</code>表示十六进制，<code>p</code>表示指数。不是<code>e</code>是因为<code>e</code>在十六进制中了，<code>-3</code>表示十进制的<code>-3</code>次方，基数为<code>2</code></li></ul></li><li>浮点数溢出的三种情况：正溢出，负溢出和<code>NaN</code>，如果正数/0就是正溢出，反之负溢出；如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mi mathvariant="normal">/</mi><mn>0</mn></mrow><annotation encoding="application/x-tex">0/0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0/0</span></span></span></span>就是<code>NaN</code></li><li><code>Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NaN</code>表示三个特殊的值，基本不用</li><li><code>if (x == Double.NaN)</code>永远为假，因为<code>NaN</code>是永远不会和其他值相同，(<code>Double.NaN</code>也不会和<code>Double.NaN</code>相同)<ul><li>如果需要判断<code>x</code>是否为<code>NaN</code>，可以使用<code>if (Double.isNaN(x))</code></li></ul></li><li>如果需要精确表示浮点数的话，需要使用<code>BigDecimal</code>类</li><li>整数除<code>0</code>产生异常，浮点数除<code>0</code>得到结果<code>NaN</code></li></ul><h2 id="字符类型">字符类型</h2><ul><li><code>char</code>类型可以表示十六进制值，范围从<code>\u0000~\uFFFF</code></li><li>需要注意注释中尽量不要出现Unicode字符，例如 <code>// \u000A is a newline.</code>，这句话会产生一个语法错误，因为读程序时会将<code>\u000A</code>转换为一个换行符<ul><li><code>// look inside c:\user</code>这里也是会报错的，因为<code>\u</code>后面没有跟着4位十六进制数</li></ul></li><li>原本<code>Unicode</code>字符不超过<code>65536</code>个，所以<code>Java</code>设置了<code>char</code>类型只有16位</li><li>后来字符放不下了，<code>Java</code>设置码点来解决问题，指一个编码表中某个字符对应的代码值</li><li>码点采用十六进制编写，加上前缀<code>U+</code>，比如<code>U+0041</code>就是<code>A</code>的码点</li><li><code>Unicode</code>的码点可以分为17个代码平面，第一个代码平面被称为基本多语言平面，包括了码点范围是<code>U+0000~U+FFFF</code></li><li>其余16个平面的码点范围是<code>U+10000~U+10FFFF</code></li><li>不要在<code>Java</code>代码中使用<code>char</code>类型，一般将字符串作为抽象数据类型处理</li></ul><h2 id="布尔类型">布尔类型</h2><ul><li><code>Java</code>的整型和布尔值<strong>不能</strong>相互转换</li></ul><h2 id="常量">常量</h2><ul><li>使用<code>final</code>关键字定义的，只能被赋值一次，不能再更改，一般用全大写命名</li><li>可能需要创建一个常量在类中的多个方法中使用，称为<strong>类常量</strong>，可以使用<code>static final</code>设置一个类常量</li><li><code>const</code>是<code>Java</code>保留的一个关键字，但是目前并没有使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">100</span>; </span><br><span class="line">    <span class="comment">// b可以被类A中的所有方法访问，因为使用static final修饰</span></span><br><span class="line">    <span class="comment">// 同时因为 b 是 public 的，所以也可以被其他类使用A.b访问</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// a只能被main函数访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="枚举类型">枚举类型</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Size</span> &#123;SMALL, MEDIUM, LARGE, EXTRA_LARGE&#125;;</span><br><span class="line"><span class="type">Size</span> <span class="variable">s</span> <span class="operator">=</span> Size.SMALL; <span class="comment">// s只能存储枚举中的值，或者是null</span></span><br></pre></td></tr></table></figure><h2 id="循环移位">循环移位</h2><ul><li><code>&gt;&gt;</code>表示左移，使用符号位填充；<code>&gt;&gt;&gt;</code>表示左移，永远使用<code>0</code>填充</li><li><code>&lt;&lt;</code>表示右移；不存在<code>&lt;&lt;&lt;</code></li><li>所有移位的右操作数都需要对<strong>32</strong>取模，如果左操作数是<code>Long</code>类型，则右操作数需要对<strong>64</strong>取模  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="number">1</span> &lt;&lt; <span class="number">35</span>; <span class="comment">// 与 1 &lt;&lt; 3等价，结果为8</span></span><br><span class="line">i &lt;&lt; <span class="number">35</span>; <span class="comment">// 与 1 &lt;&lt; 3等价，结果为8</span></span><br><span class="line">j &lt;&lt; <span class="number">35</span>; <span class="comment">// 与 1 &lt;&lt; 35等价，结果为34359738368</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="字符串">字符串</h2><ul><li><p><code>Java</code>中字符串就是<code>Unicode</code>序列，比如<code>&quot;Java\u2122&quot;</code>由五个<code>Unicode</code>字符组成。</p></li><li><p><code>Java</code>没有内置的字符串类型，标准<code>Java</code>类库中提供了一个预定义类</p></li><li><p>任何<code>Java</code>对象都可以转换为字符串，所以<code>&quot;PG&quot; + 12 = &quot;PG12&quot;</code></p></li><li><p>如果多个字符串使用界定符分割的话，可以使用静态<code>join</code>方法</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">all</span> <span class="operator">=</span> String.join(<span class="string">&quot;/&quot;</span>, <span class="string">&quot;S&quot;</span>, <span class="string">&quot;M&quot;</span>, <span class="string">&quot;I&quot;</span>); <span class="comment">// all = &quot;S/M/I&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><code>Java 11</code>中提供了<code>repeat</code>方法</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">rep</span> <span class="operator">=</span> <span class="string">&quot;J&quot;</span>.repeat(<span class="number">3</span>); <span class="comment">// rep = &quot;JJJ&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><code>Java</code>中字符串不可变，如果需要修改一个字符串的一部分，需要先使用<code>substring</code>提取字符串不需要修改的部分，然后加上其他修改后的结果字符串。</p><ul><li>字符串不可变每次都需要生成新的字符串，会降低效率，但是编译器底层可以实现字符串共享。</li><li>开发者认为字符串共享带来的收益比修改字符串带来的收益明显，因为往往需要比对字符串是否相同，修改频率较少</li><li>只会共享字符串字面量，由<code>+</code>或者<code>substring</code>得到的字符串无法共享</li><li>因此比较两个字符串相等的时候务必使用<code>&quot;A&quot;.equals(&quot;A&quot;)</code>，如果使用<code>==</code>，则会比较两个字符串是否相等</li><li>如果要检查字符串不是空串也不是<code>null</code>的话，需要先检查<code>null</code>: <code>if (s != null &amp;&amp; s.length() != 0)</code>，否则如果字符串为<code>null</code>的话，调用这个字符串的<code>length()</code>函数会报错</li></ul></li><li><p><code>Java</code>中最常用的<code>Unicode</code>由一个代码单元表示，但是辅助字符需要两个代码单元，所以如果使用<code>charAt</code>，会返回指定索引的代码单元</p><ul><li>如果正好某个索引需要两个代码单元，但是使用<code>charAt</code>指定了前一个单元，就会出现问题。因此，<code>charAt</code>一般不要用</li><li>为了测试，需要提前设置<code>cmd</code>窗口内编码格式为<code>Unicode</code>，在<code>cmd</code>内输入<code>chcp 65001</code>将当前窗口的编码格式切换为<code>Unicode</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;123\uD835\uDD46&quot;</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;当前字符串是：&quot;</span> + s);</span><br><span class="line">    System.out.println(<span class="string">&quot;s.length() = &quot;</span> + s.length());</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;使用s.charAt()打印每一个元素：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i ++) &#123;</span><br><span class="line">        System.out.print(s.charAt(i) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line"></span><br><span class="line">    System.out.print(<span class="string">&quot;s的实际长度(码点个数)为：&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">trueLen</span> <span class="operator">=</span> s.codePointCount(<span class="number">0</span>, s.length());</span><br><span class="line">    System.out.println(trueLen);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;使用s.codePointAt()打印每一个元素：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; trueLen; i ++) &#123;</span><br><span class="line">        System.out.print(s.codePointAt(s.offsetByCodePoints(<span class="number">0</span>, i)) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上面代码的输出结果为：<br><img src="https://gitee.com/sang3112/blog_imgs/raw/4c5ed5605556dc05064ff326aca418d72b731cfe/Java/codepoint.png" alt="codepoint"></li></ul></li></ul></li><li><p>如果需要拼接多个较短的字符串，可以使用<code>StringBuilder</code></p><ul><li><code>StringBuffer</code>效率不如<code>StringBuilder</code>，不过<code>StringBuffer</code>可以支持多线程添加删除字符</li><li>如果所有操作都在单线程，则使用<code>StringBuilder</code></li></ul></li><li><p><code>Java 15</code>中存在文本块，以三个引号开头结尾，可以更加方便的写换行，例如</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Hello</span></span><br><span class="line"><span class="string">World</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;Hello\nWorld\n&quot;</span>;</span><br><span class="line"><span class="comment">// a == b</span></span><br><span class="line"><span class="comment">// 文本块最适合放SQL语句或者HTML语句，但是如果所有的反斜线都需要转义</span></span><br><span class="line"><span class="comment">// 如果不转义就会变成不换行</span></span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Hello\</span></span><br><span class="line"><span class="string">World</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> <span class="string">&quot;HelloWorld\n&quot;</span>;</span><br><span class="line"><span class="comment">// c == d</span></span><br></pre></td></tr></table></figure></li></ul><h1>输入输出</h1><ul><li>如果是密码相关的内容，建议不要使用<code>println</code>，可以使用<code>Console.readPassword</code>方法</li><li><code>printf(&quot;%+f&quot;, d)</code>可以打印<code>d</code>的正负号</li><li><code>printf(%,f, d)</code>可以对<code>d</code>增加三个数一组的分割符</li><li><code>printf(&quot;%1$d,%1$x&quot;, d)</code>分别以十进制和十六进制打印第一个参数<code>d</code></li><li><code>printf(&quot;%d%&lt;x&quot;, d)</code>分别以十进制和十六进制打印<strong>同一个数</strong></li><li>使用<code>String.format</code>方法可以格式化字符串，不打印输出  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> String.format(<span class="string">&quot;Hello, %s. Next year, you&#x27;ll be %d&quot;</span>, name, age + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// Java 15版本以后可以使用下面这种更加简单的方法</span></span><br><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello, %s. Next year, you&#x27;ll be %d&quot;</span>.formatted(name, age + <span class="number">1</span>);</span><br></pre></td></tr></table></figure></li><li>写入文件使用  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="string">&quot;tmp.txt&quot;</span>, StandardCharsets.UTF_8);</span><br><span class="line">out.write(<span class="string">&quot;werwr&quot;</span>);</span><br><span class="line">out.flush();</span><br><span class="line"><span class="comment">// 如果tmp.txt不存在，则会自动创建一个</span></span><br><span class="line"><span class="comment">// 写入以后需要使用flush才能保存</span></span><br></pre></td></tr></table></figure></li></ul><h1>控制流程</h1><ul><li><code>Java</code>中两个嵌套的块不能重复定义相同的变量</li><li>在 <code>for</code>循环中不能检测了两个浮点数是否相等，因为误差的存在，可能会导致死循环</li></ul><h2 id="switch-case"><code>switch-case</code></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种</span></span><br><span class="line"><span class="keyword">switch</span> (s) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;yes&quot;</span>, <span class="string">&quot;y&quot;</span> -&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;no&quot;</span>, <span class="string">&quot;n&quot;</span> -&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span> -&gt; &#123;</span><br><span class="line">        ... </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种</span></span><br><span class="line"><span class="keyword">switch</span> (s) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;y&quot;</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;n&quot;</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第二种方法如果不使用break会导致执行多个分支</span></span><br><span class="line"><span class="comment">// 使用javac -Xlint:fallthrough xxx.java编译可以得到这个方面的警告</span></span><br><span class="line"><span class="comment">// 但是如果本身就想执行多个分支，可以在整个函数外加上</span></span><br><span class="line"><span class="comment">// @SuppressWarnings(&quot;fallthrough&quot;)，这样就不会产生警告了</span></span><br></pre></td></tr></table></figure><ul><li>不能混用<code>:</code>和<code>-&gt;</code>，同时<code>-&gt;</code>也<strong>不</strong>存在直通的行为</li><li><code>yield</code>也会终止<code>switch</code>语句，但是还会生成一个值<ul><li><code>switch</code>表达式的关键是生成一个值，或者抛出异常，<strong>不允许</strong>使用<code>return</code>跳出</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">switch</span>(s) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;y&quot;</span> -&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;n&quot;</span> -&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span> -&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">nums</span> <span class="operator">=</span> <span class="keyword">switch</span>(s) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Spring&quot;</span>, <span class="string">&quot;Summer&quot;</span>, <span class="string">&quot;Winter&quot;</span> -&gt; <span class="number">6</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Fall&quot;</span> -&gt; <span class="number">4</span></span><br><span class="line">    <span class="keyword">default</span> -&gt; -<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面表达式优于下面的表达式</span></span><br><span class="line"><span class="keyword">switch</span>(s) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Spring&quot;</span>, <span class="string">&quot;Summer&quot;</span>, <span class="string">&quot;Winter&quot;</span> -&gt; &#123;</span><br><span class="line">        nums = <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Fall&quot;</span> -&gt; &#123;</span><br><span class="line">        nums = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span> -&gt; &#123;</span><br><span class="line">        nums = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 除非是需要直通式，才会使用`break`和`yield`</span></span><br></pre></td></tr></table></figure><h1>大数</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用valueOf()静态方法可以将一个普通的数转换为大数</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">a</span> <span class="operator">=</span> BigInteger.valueOf(<span class="number">123</span>);</span><br><span class="line"><span class="comment">// 对于一个很长的数，使用带有字符串参数的构造器生成</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;1231231231231231231231231&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>对于 <code>BigDecimal</code>类，总应该使用带有字符串参数的构造器生成。尽管有<code>BigDecimal(double)</code>，但是传入的时候会产生浮点数精度误差</li><li><code>Java</code>不能通过编程实现运算符的重载，所以只能使用<code>add(), multiply()</code>等方法实现加减乘除</li><li><code>Java</code>设计者只重载了<code>+</code>来实现字符串拼接</li></ul><h1>数组</h1><ul><li><code>Java</code>中<strong>允许</strong>长度为0的数组存在</li><li>数组创建时，数字数组初始化为0，对象数组初始化为<code>null</code>，<code>boolean</code>数组初始化为<code>false</code></li><li>如果想要打印数组a，可以直接写<code>Arrays.toString(a)</code>，这个返回值包含了数组中所有元素的字符串</li><li>如果想要快速打印一个二维数组，可以使用<code>Arrays.deepToString(a)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">System.out.println(Arrays.toString(a));</span><br></pre></td></tr></table></figure><h2 id="数组拷贝">数组拷贝</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] b = a;</span><br><span class="line"><span class="comment">// b和a引用同一个数组</span></span><br><span class="line"><span class="comment">// 如果需要拷贝一个副本到新的数组，可以使用copyOf</span></span><br><span class="line"><span class="type">int</span>[] c = Arrays.copyOf(a, a.length);</span><br><span class="line"><span class="comment">// 第二个参数是新数组的长度，一般用于扩充新数组</span></span><br><span class="line"><span class="comment">// 如果需要扩充，则数组数组自动填充0，boolean数组自动填充false</span></span><br><span class="line"><span class="comment">// 如果新数组长度更小，则只拷贝前面的部分</span></span><br></pre></td></tr></table></figure><ul><li><code>main</code>函数的参数，是<code>String[] args</code>，接受一个字符串数组，也就是命令行指定的参数</li><li><code>java Message -h hello</code> 这里面<code>args[0]=-h</code> <code>args[1] = hello</code></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;概述和环境&lt;/h1&gt;
&lt;h2 id=&quot;源码文件&quot;&gt;源码文件&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;确保安装了&lt;code&gt;JDK&lt;/code&gt;，并且配置了环境变量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;jdk/lib&lt;/code&gt;目录中可以找到&lt;code&gt;src.zip&lt;/code&gt;，这个压</summary>
      
    
    
    
    <category term="Java" scheme="https://sangs3112.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://sangs3112.github.io/tags/Java/"/>
    
    <category term="Java核心技术(卷一)" scheme="https://sangs3112.github.io/tags/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%8D%B7%E4%B8%80/"/>
    
  </entry>
  
  <entry>
    <title>设计模式笔记_1</title>
    <link href="https://sangs3112.github.io/posts/b406aa8c.html"/>
    <id>https://sangs3112.github.io/posts/b406aa8c.html</id>
    <published>2024-05-04T06:37:35.000Z</published>
    <updated>2024-12-11T04:42:14.723Z</updated>
    
    <content type="html"><![CDATA[<h1>简单工厂模式</h1><blockquote><p>需要实例化谁,以后可能会添加实例化的对象,就要用一个单独的类来做这个创造实例的过程,就是<strong>工厂</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Operation.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Operation</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">getResult</span><span class="params">(<span class="type">double</span> numberA, <span class="type">double</span> numberB, String operation)</span>&#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span> (operation) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                ans = numberA + numberB;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                ans = numberA - numberB;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                ans = numberA * numberB;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                ans = numberA / numberB;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;not support operation&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info flat"><p>问题:</p><ol><li>如果需要增加函数,就需要添加新的<code>case</code>,有可能会改变原有的函数;</li><li>如果代码只需要调用除法,却需要编译其他的加,减,乘函数<br>解决办法:<br>实现一个运算抽象类,都有一个方法<code>getResult()</code>,用来得到结果.然后加减乘除都写成运算类的子类</li></ol></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Operation.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Operation</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getResult</span><span class="params">(<span class="type">double</span> numberA, <span class="type">double</span> numberB)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0d</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Add</span> <span class="keyword">extends</span> <span class="title class_">Operation</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getResult</span><span class="params">(<span class="type">double</span> numberA, <span class="type">double</span> numberB)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numberA + numberB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sub.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Operation</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getResult</span><span class="params">(<span class="type">double</span> numberA, <span class="type">double</span> numberB)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numberA - numberB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mul.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mul</span> <span class="keyword">extends</span> <span class="title class_">Operation</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getResult</span><span class="params">(<span class="type">double</span> numberA, <span class="type">double</span> numberB)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numberA * numberB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Div.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Div</span> <span class="keyword">extends</span> <span class="title class_">Operation</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getResult</span><span class="params">(<span class="type">double</span> numberA, <span class="type">double</span> numberB)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numberB == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;除数不能为0&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArithmeticException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numberA / numberB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OperationFactory.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperationFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Operation <span class="title function_">createOperation</span><span class="params">(String opertaion)</span>&#123;</span><br><span class="line">        <span class="type">Operation</span> <span class="variable">oper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (opertaion) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                oper = <span class="keyword">new</span> <span class="title class_">Add</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                oper = <span class="keyword">new</span> <span class="title class_">Sub</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                oper = <span class="keyword">new</span> <span class="title class_">Mul</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                oper = <span class="keyword">new</span> <span class="title class_">Div</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;we didnt implement this operation&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> oper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="type">Operation</span> <span class="variable">oper</span> <span class="operator">=</span> OperationFactory.createOperation(flag);</span><br><span class="line"><span class="type">double</span> <span class="variable">ans</span> <span class="operator">=</span> oper.getResult(a, b);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/sang3112/blog_imgs/raw/master/DesignPattern/SFP.png" alt="SFP"></p><div class="note info flat"><p>三个角色:</p><ol><li>抽象类: 定义所有支持算法的公共接口,比如运算抽象类</li><li>具体算法类: 具体的算法,比如加减乘除运算类</li><li>简单工厂类: 用来维护对运算类的应用</li></ol><ul><li>可以将类类比为产品,使用者在不清楚类生产的具体过程的情况下,可以使用不同的产品.</li></ul></div><h1>策略模式</h1><blockquote><p>定义算法家族,分别封装,让他们之间可以相互替换.这样可以保证算法的变化不会影响到客户<br>一系列算法都完成相同的工作,只是实现不同,可以以相同的方式调用所有的算法,减少耦合.<br>只需要在不同的时间应用不同的业务规则,就可以考虑使用策略模式进行处理</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CashSuper.java</span></span><br><span class="line"><span class="comment">// 收费抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CashSuper</span> &#123;</span><br><span class="line">    <span class="comment">// 收费的抽象方法,参数为单价和数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">acceptCash</span><span class="params">(<span class="type">double</span> price, <span class="type">int</span> num)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CashNormal.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CashNormal</span> <span class="keyword">extends</span> <span class="title class_">CashSuper</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">acceptCash</span><span class="params">(<span class="type">double</span> price, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> price * num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CashRebate.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CashRebate</span> <span class="keyword">extends</span> <span class="title class_">CashSuper</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> <span class="variable">moneyRebate</span> <span class="operator">=</span> <span class="number">1d</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CashRebate</span><span class="params">(<span class="type">double</span> moneyRebate)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.moneyRebate = moneyRebate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">acceptCash</span><span class="params">(<span class="type">double</span> price, <span class="type">int</span> num)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price * num * moneyRebate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CashReturn.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CashReturn</span> <span class="keyword">extends</span> <span class="title class_">CashSuper</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> <span class="variable">moneyCondition</span> <span class="operator">=</span> <span class="number">0d</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> <span class="variable">moneyReturn</span> <span class="operator">=</span> <span class="number">0d</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CashReturn</span><span class="params">(<span class="type">double</span> moneyCondition, <span class="type">double</span> moneyReturn)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.moneyCondition = moneyCondition;</span><br><span class="line">        <span class="built_in">this</span>.moneyReturn = moneyReturn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">acceptCash</span><span class="params">(<span class="type">double</span> price, <span class="type">int</span> num)</span>&#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">ans</span> <span class="operator">=</span> price * num;</span><br><span class="line">        <span class="keyword">if</span> (moneyCondition &gt; <span class="number">0</span> &amp;&amp; ans &gt;= moneyCondition)&#123;</span><br><span class="line">            ans -= Math.floor(ans / moneyCondition) * moneyReturn;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CashContext.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CashContext</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> CashSuper cs;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CashContext</span><span class="params">(CashSuper cs)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.cs = cs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getResult</span><span class="params">(<span class="type">double</span> price, <span class="type">int</span> num)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cs.acceptCash(price, num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;输入策略: 1 - 正常收费; 2 - 打八折; 3 - 打七折; 4 - 满300减100&quot;</span>);</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">discount</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;输入产品的单价:&quot;</span>);</span><br><span class="line">        <span class="type">double</span> <span class="variable">price</span> <span class="operator">=</span> in.nextDouble();</span><br><span class="line">        System.out.println(<span class="string">&quot;输入产品的数量:&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">        in.close();</span><br><span class="line">        <span class="type">CashContext</span> <span class="variable">cs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (discount) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                cs = <span class="keyword">new</span> <span class="title class_">CashContext</span>(<span class="keyword">new</span> <span class="title class_">CashNormal</span>());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                cs = <span class="keyword">new</span> <span class="title class_">CashContext</span>(<span class="keyword">new</span> <span class="title class_">CashRebate</span>(<span class="number">0.8d</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                cs = <span class="keyword">new</span> <span class="title class_">CashContext</span>(<span class="keyword">new</span> <span class="title class_">CashRebate</span>(<span class="number">0.7d</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                cs = <span class="keyword">new</span> <span class="title class_">CashContext</span>(<span class="keyword">new</span> <span class="title class_">CashReturn</span>(<span class="number">300d</span>, <span class="number">100d</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;we dont support this strategy&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> <span class="variable">totalPrice</span> <span class="operator">=</span> cs.getResult(price, num);</span><br><span class="line">        System.out.println(totalPrice);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>策略模式,使用<code>CashContext</code>计算不同策略下的收费及结果,但是会发现在<code>Main</code>中进行了判断需要使用哪一个策略</li><li>可以使用工厂模式+策略模式的方法进行调整</li></ul><h2 id="策略-工厂模式">策略 + 工厂模式</h2><blockquote><p>只需要将<code>Main</code>中的<code>switch</code>部分移动到<code>CashContext</code>中即可</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CashContext.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CashContext</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> CashSuper cs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CashContext</span><span class="params">(<span class="type">int</span> discount)</span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (discount) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                cs = <span class="keyword">new</span> <span class="title class_">CashNormal</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                cs = <span class="keyword">new</span> <span class="title class_">CashRebate</span>(<span class="number">0.8d</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                cs = <span class="keyword">new</span> <span class="title class_">CashRebate</span>(<span class="number">0.7d</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                cs = <span class="keyword">new</span> <span class="title class_">CashReturn</span>(<span class="number">300d</span>, <span class="number">100d</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;we dont support this strategy&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getResult</span><span class="params">(<span class="type">double</span> price, <span class="type">int</span> num)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cs.acceptCash(price, num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在导航中,不同的路径规划算法,比如步行,骑行,搭乘公共交通的,开车的.主要导航类的主要工作是渲染路径,不会在意算法生成的路径,因此可以将路径规划算法使用策略模式进行封装,方便交互</p></blockquote><p><img src="https://gitee.com/sang3112/blog_imgs/raw/master/DesignPattern/SP.png" alt="SP"></p><ul><li>策略模式不适合算法极少变化的场景,这样会使得程序整体变得复杂</li><li>同时要求客户知晓策略的不同</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;简单工厂模式&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;需要实例化谁,以后可能会添加实例化的对象,就要用一个单独的类来做这个创造实例的过程,就是&lt;strong&gt;工厂&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight j</summary>
      
    
    
    
    <category term="DesignPattern" scheme="https://sangs3112.github.io/categories/DesignPattern/"/>
    
    
    <category term="DesignPattern" scheme="https://sangs3112.github.io/tags/DesignPattern/"/>
    
    <category term="简单工厂模式" scheme="https://sangs3112.github.io/tags/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="策略模式" scheme="https://sangs3112.github.io/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式笔记_0</title>
    <link href="https://sangs3112.github.io/posts/c3019a1a.html"/>
    <id>https://sangs3112.github.io/posts/c3019a1a.html</id>
    <published>2024-05-03T06:37:35.000Z</published>
    <updated>2024-12-11T04:42:14.723Z</updated>
    
    <content type="html"><![CDATA[<h1>单一职责原则 <code>SRP</code></h1><blockquote><p>一个类应该只有一个更改它的原因,也就是这个类只有一个职责</p></blockquote><ul><li>每个类的职责都有清晰明确的定义</li><li>一个类的修改只对自身有影响,对其他类没有影响</li></ul><h1>开闭原则 <code>OCP</code></h1><blockquote><p>软件实体(类 模块 函数)应该可以扩展,但是不能修改.对于扩展是开放的,对于修改是封闭的.<br>对于要怎讲爱新功能或者需要调整的改动,应该扩展新的代码而不是修改原有的代码.</p></blockquote><ul><li>对程序中频繁变化的部分抽象</li><li>不要刻意的对每一个部分都进行抽象,拒绝不成熟的抽象,这和抽象本身一样重要.</li></ul><h1>依赖倒置原则 <code>DIP</code></h1><blockquote><p>程序不应该依赖细节,细节应该依赖于抽象. 针对接口编程 而不是针对实现编程</p></blockquote><ul><li>使用接口或者抽象类的目的是制定好规范,不涉及任何具体的操作,把细节任务交给实现类去完成</li><li>让程序中所有的依赖关系都终止于抽象类或者接口</li><li>高层模块不应该依赖底层模块,二者都应该依赖抽象</li><li>抽象不应该依赖细节,细节应该依赖抽象</li></ul><h1>里氏替换原则 <code>LSP</code></h1><blockquote><p>一个软件实体如果适用于父类,必定适用于子类,并且察觉不出子类和父类的区别,也就是子类必须能够替换父类</p></blockquote><ul><li>父类一般使用抽象类或者接口</li><li>抽象类定义公共对象和状态;接口定义公共行为</li><li>子类通过继承父类和接口进行扩展</li><li>子类的方法参数类型 返回值类型 异常 都应该跟父类相匹配;子类不应该强加参数条件限制;子类不能修改父类的私有成员</li></ul><h1>迪米特原则 <code>LoD</code></h1><blockquote><p>最小知识原则.如果两个类不必彼此互相通信,那么这两个类就不应该发生直接的相互作用;如果其中一个类需要调用另一个类的某一个方法,则可以通过第三者转发这个调用</p></blockquote><ul><li>类设计上,每一个类都应该尽量降低成员的访问权限,不要让别的类知道字段或行为就不要公开</li><li>类之间不建立联系,而是通过中间类来中转</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;单一职责原则 &lt;code&gt;SRP&lt;/code&gt;&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;一个类应该只有一个更改它的原因,也就是这个类只有一个职责&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;每个类的职责都有清晰明确的定义&lt;/li&gt;
&lt;li&gt;一个类的修改只对自身</summary>
      
    
    
    
    <category term="DesignPattern" scheme="https://sangs3112.github.io/categories/DesignPattern/"/>
    
    
    <category term="DesignPattern" scheme="https://sangs3112.github.io/tags/DesignPattern/"/>
    
    <category term="设计原则" scheme="https://sangs3112.github.io/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>Java笔记_4</title>
    <link href="https://sangs3112.github.io/posts/63a4d81f.html"/>
    <id>https://sangs3112.github.io/posts/63a4d81f.html</id>
    <published>2024-04-22T06:37:35.000Z</published>
    <updated>2024-12-11T04:42:14.723Z</updated>
    
    <content type="html"><![CDATA[<h1>垃圾回收算法(四种)</h1><div class="note info flat"><ul><li>垃圾回收需要找到内存中存活的对象</li><li>还需要释放不再存活的对象，使程序可以再次利用这部分空间</li></ul></div><ol><li>标记-清除算法</li><li>复制算法</li><li>标记-整理算法</li><li>分代GC</li></ol><div class="note info flat"><ul><li><p>垃圾回收会有单独的<code>GC</code>线程来完成，但是不管哪一种<code>GC</code>算法，都会有部分阶段需要停止所有用户线程，称之为<code>Stop The World</code>，简称<code>STW</code>，如果<code>STW</code>的时间过长，则会影响用户使用</p></li><li><p>为什么一定需要<code>STW</code>?</p><ul><li>分析工作必须在能够确保一致性的快照中进行</li><li>一致性指整个分析期间系统被冻结在某个时间点上</li><li>如果分析过程中对象的引用关系还在不断地变化,那么分析的准确性就没有办法保证</li><li>如果不暂停业务线程的话,在垃圾回收期间新创建的对象会被错误的回收,这是因为业务陈晓晨和垃圾回收线程都是并行执行的</li></ul></li><li><p>评价标准:</p><ol><li><strong>吞吐量</strong>：CPU用于执行用户代码的时间与CPU总执行时间的比值，吞吐量=执行用户代码的时间/(执行用户代码的时间+<code>GC</code>时间)，吞吐量越高表示垃圾回收效率越高</li><li><strong>最大暂停时间</strong>：垃圾回收过程中<code>STW</code>时间的最大值，越小越好</li><li><strong>堆使用效率</strong>：不同垃圾回收算法，堆内存使用效率不同。比如标记清除算法，可以完整的使用堆内存，复制算法会将堆内存一分为二，每次只能使用一半内存。从堆使用效率上来说，标记清除算法要优于复制算法</li></ol></li><li><p>三者不可兼得，堆内存越大，最大暂停时间就越大，减少最大暂停时间，就会降低吞吐量</p></li></ul></div><h2 id="标记-清除算法">标记-清除算法</h2><blockquote><p>两个阶段</p><ol><li>标记阶段，将所有存活对象标记，使用可达性算法，从<code>GC Root</code>开始通过引用链遍历出所有的存活对象</li><li>清除阶段，从内存中删除没有被标记，也就是非存活对象</li></ol></blockquote><div class="note info flat"><ul><li>优点：实现简单，只需要在第一阶段维护每个对象的标志位，第二阶段删除即可</li><li>缺点：<ol><li><strong>碎片化问题</strong>：内存是连续的，所以对象被删除之后，内存中可能会出现很多细小的可用内存单元。如果我们需要一个比较大的空间，这些内存单元会无法进行分配</li><li><strong>分配速度比较慢</strong>：因为内存碎片存在，需要维护一个空闲链表，有可能发生每次遍历链表的最后才能获得合适的内存空间</li></ol></li></ul></div><h2 id="复制算法">复制算法</h2><blockquote><p>核心思想</p><ol><li>准备两块空间<code>From</code>和<code>To</code>空间，每次在对象分配阶段，只能使用其中一块空间(<code>From</code>空间)</li><li><code>GC</code>阶段，将<code>From</code>中存活的对象复制到<code>To</code>空间中</li><li>将两块空间的名字互换，也就是<code>From</code>和<code>To</code>互换名字，因为只有<code>From</code>空间存储对象</li></ol></blockquote><div class="note info flat"><ul><li>完整复制算法<ol><li>将堆内存分隔成两块<code>From</code>空间和<code>To</code>空间，对象分配阶段，创建对象</li><li><code>GC</code>阶段开始，将<code>GC Root</code>搬运到<code>To</code>空间</li><li>将<code>GC Root</code>关联的对象，搬运到<code>To</code>空间，<code>From</code>空间剩下的是没有被<code>GC Root</code>关联的对象了</li><li>清理<code>From</code>空间，并把名称互换</li></ol></li><li>优点：<ol><li>吞吐量高，只需要遍历一次存活对象复制到<code>To</code>空间即可，比标记-整理算法少了一次遍历过程。但是性能比标记-清除算法低，因为标记-清除算法不需要进行对象的移动</li><li>不会出现碎片化的问题，复制算法复制后有序排列对象，所以不会出现内存碎片</li></ol></li><li>缺点：每次只能用一半的堆内存，让一半的空间来创建对象使用</li></ul></div><h2 id="标记-整理算法-标记-压缩算法">标记-整理算法(标记-压缩算法)</h2><blockquote><p>对标记-清理算法中容易产生内存碎片的问题的一种解决方案<br>两个阶段</p><ol><li>标记阶段，将所有的存活对象标记，使用可达性分析算法，从<code>GC Root</code>开始通过引用链遍历出所有存活对象</li><li>整理阶段，将存活对象移动到堆的一端，清理掉非存活对象的内存空间</li></ol></blockquote><div class="note info flat"><ul><li>优点：<ol><li>内存使用率高，整个堆内存都可以使用，复制算法只能用半个堆内存</li><li>不会出现碎片化的问题，整理阶段可以将对象往内存的一侧进行移动，剩下的空间都是可以分配对象的有效空间</li></ol></li><li>缺点：整理阶段的效率不高，整理算法有很多，比如<code>Lisp2</code>整理算法需要对整个堆中的对象搜索三次，整体性能不佳。可以通过<code>Two-Finger</code>，表格算法，<code>ImmixGC</code>等高效的整理算法优化这个阶段的性能</li></ul></div><h2 id="分代GC-Generational-GC">分代<code>GC</code>(<code>Generational GC</code>)</h2><blockquote><p>分代垃圾回收将整个内存区域划分为年轻代(<code>Young</code> 区，新生代)和老年代(<code>Old</code> 区)<br>年轻代存放存活时间比较短的对象，老年代存放存活时间比较长的对象<br>年轻代中有<code>Eden</code>区，<code>Survivor</code>区(<code>S0,S1</code>)<br><code>JDK8</code>中，添加<code>-XX:+UserSerialGC</code>参数使用分代回收的垃圾回收器，运行程序，使用<code>Arthas</code>中的<code>memory</code>命令可以查看三个区域的内存情况，分别是<code>eden_space, survivio_space, tenured_gen</code>，就是伊甸园区，幸存者区，老年代</p></blockquote><div class="note info flat"><ul><li><code>-Xmn</code>：设置新生代的大小，也就是伊甸园区和幸存者区的大小</li><li><code>-XX:SurvivorRatio</code>伊甸园区和幸存区的比例，默认为8。新生代1G内存，伊甸园区就是800MB，<code>S0</code>和<code>S1</code>各100MB</li><li><code>-XX:+PrintGCDetails verbose:gc</code>打印GC日志，前者打印信息详细一些，后者简单一些。</li><li>老年代大小就是堆大小与新生代大小的差</li></ul></div><ul><li>使用分代回收时，创建出来的对象首先放入<code>Eden</code>伊甸园区，如果对象在<code>Eden</code>区越来越多，直到<code>Eden</code>区满，新创建的对象无法放入，就会触发年轻代<code>GC</code>，称为<code>Minor GC</code>或者<code>Young GC</code>，<code>Minor GC</code>会把需要<code>Eden</code>中和<code>From</code>需要回收的对象回收，把没有回收的对象放在<code>To</code>区域中<ul><li>所以<code>Minor GC</code>就是一个复制算法，初始<code>S0</code>是<code>From</code>，<code>S1</code>是<code>To</code>，接下来<code>S0</code>变成了<code>To</code>,<code>S1</code>变成了<code>From</code></li><li>当<code>Eden</code>再次满时，此时会回收<code>Eden</code>区和<code>S1From</code>中的对象，，并把<code>Eden, From</code>中的剩余的对象放在<code>S0</code>中</li></ul></li><li>每次<code>Minor GC</code> 都会为对象记录他的年龄，初始值为0，每次GC完都要加1</li><li>年龄到达15以后(15是最大值)，默认值和垃圾回收器有关，对象就会<strong>晋升</strong>到老年代</li><li>老年代空间不足，无法放入新的对象时，先会尝试<code>Minor GC</code>(为了尽量避免对象放入老年代，比如新生代中年龄都是2或者3，只是被占用满了，需要将对象放在老年代中，如果新生代空间没有满，也可以不用放入老年代，所以先进行<code>Minor GC</code>，尽量避免对象放入老年代)，如果还是不足，就会触发<code>Full GC</code>，对整个堆进行垃圾回收<ul><li>如果<code>Full GC</code>没有释放足够的老年代的空间，就会产生<code>OutOfMemory</code>错误</li></ul></li></ul><div class="note info flat"><ul><li>为什么分代<code>GC</code>要把堆分成年轻代和老年代</li></ul><blockquote><p>系统中的大部分对象，都是创建出来以后不再使用可以被回收，比如用户获取订单数据，订单数据返回给用户之后就可以释放了<br>老年代中会存放长期存活的对象，比如<code>Spring</code>中的大部分<code>bean</code>对象，在程序启动之后就不会被回收了<br>在虚拟机的默认设置中，新生代的大小要远小于老年代的大小</p></blockquote><ol><li>可以通过调整新生代和老年代的比例来适应不同类型的应用程序，提高内存的利用率和性能。比如一个用户很多的网站，有很多人需要访问订单数据，那如果新生代较小，则会有很多年龄较小的对象进入老年代，导致<code>gc</code>时间延长，此时可以将新生代的内存区调大一些，直接可以通过<code>Minor GC</code>回收</li><li>新生代和老年代可以使用不同的垃圾回收算法，新生代一般使用复制算法，减少内存碎片；老年代可以使用标记-清除或者标记-整理算法，由程序员自己调整(因为老年代空间比较大，使用了复制算法就只能使用一半空间了，就不合理了)，标记清除算法效率较高，但是会有内存碎片，而标记整理算法没有内存碎片，但是<code>STW</code>较长</li><li>分代设计中允许只回收新生代<code>Minor GC</code>，如果能满足对象分配的要求就不需要堆整个堆进行回收了，<code>STW</code>时间减少(最核心)，尽可能做<code>Minor GC</code>，减少<code>Full GC</code></li></ol></div><h1>垃圾回收器</h1><ul><li>垃圾回收器是垃圾回收算法的具体实现，由于垃圾回收器分为年轻代和老年代，所以出了G1之外的其他垃圾回收器必须成对使用<br><img src="https://gitee.com/sang3112/blog_imgs/raw/6d55251373589f7b63584fece6808ec3cbcdad27/Java/GC.png" alt="GC"></li></ul><blockquote><p>年轻代的<code>Serial</code>以及老年代的<code>Serial Old</code><br>年轻代的<code>ParNew</code>以及老年代的<code>CMS</code><br>年轻代的<code>Parallel Scavenge</code>以及老年代的<code>Parallel Old</code><br>G1可以同时控制年轻代和老年代(<code>JDK9</code>之后主流推荐)<br><code>JDK9</code>废弃了年轻代的<code>Serial</code>以及老年代的<code>CMS</code>；年轻代的<code>ParNew</code>以及老年代的<code>Serial Old</code><br><code>JDK14</code>中废弃了<code>Parallel Scavenge</code>以及老年代的<code>Serial Old</code>(为什么？)</p></blockquote><h2 id="Serial垃圾回收器-年轻代"><code>Serial</code>垃圾回收器-年轻代</h2><blockquote><p><strong>单线程串行</strong>回收年轻代的垃圾回收器<br><img src="https://gitee.com/sang3112/blog_imgs/raw/6d55251373589f7b63584fece6808ec3cbcdad27/Java/Serial.png" alt="Serial"></p></blockquote><ul><li>回收年轻代，使用复制算法</li><li>优点：单CPU处理器下吞吐量出色</li><li>缺点：多CPU下吞吐量不如其他垃圾回收器，堆偏大会让用户线程处于长时间等待(因为回收的时候只有单线程进行<code>GC</code>)</li><li>适合<code>Java</code>编写的客户端程序，或者硬件配置有限的场景</li></ul><h2 id="SerialOld垃圾回收器-老年代"><code>SerialOld</code>垃圾回收器-老年代</h2><blockquote><p><strong>单线程串行回收</strong>，是<code>Serial</code>的老年代版本</p></blockquote><ul><li><code>-XX:+UseSerialGC</code> 新生代、老年代都使用串行回收器</li><li>回收老年代，使用标记-整理算法</li><li>优缺点跟<code>Serial</code>算法相同</li><li>一般配合<code>Serial</code>使用，或者在特殊情况下调用<code>CMS</code>使用，实际使用不多，一般在<code>CPU</code>资源比较匮乏的时候使用</li></ul><h2 id="ParNew垃圾回收器-年轻代"><code>ParNew</code>垃圾回收器-年轻代</h2><blockquote><p>本质上就是对<code>Serial</code>在多线程CPU下的优化，使用多线程进行垃圾回收<br><img src="https://gitee.com/sang3112/blog_imgs/raw/6d55251373589f7b63584fece6808ec3cbcdad27/Java/ParNew.png" alt="ParNew"><br><code>-XX:+UseParNewGC</code>新生代使用<code>ParNew</code>回收器，老年代使用串行回收器</p></blockquote><ul><li>回收年轻代，使用复制算法</li><li>优点：多CPU处理器下停顿时间较短</li><li>缺点：吞吐量和停顿时间不如<code>G1</code>，所以在<code>JDK9</code>之后不建议使用</li><li>适合<code>JDK8</code>以及之前的版本中，与<code>CMS</code>老年代垃圾回收器配合使用</li></ul><h2 id="CMS-Concurrent-Mark-Sweep-垃圾回收器-老年代"><code>CMS(Concurrent Mark Sweep)</code>垃圾回收器-老年代</h2><blockquote><p>关注的是系统的<strong>暂停时间</strong>，允许用户线程和垃圾回收线程在某些步骤中同时执行，减少用户线程的等待<br><code>-XX:+UseConcMarkSweepGC</code><br><img src="https://gitee.com/sang3112/blog_imgs/raw/6d55251373589f7b63584fece6808ec3cbcdad27/Java/CMS.png" alt="CMS"></p></blockquote><ul><li>使用标记-清除算法回收老年代</li><li>优点：系统由于垃圾回收停顿时间较短，所以用户体验好</li><li>缺点：内存碎片问题，退化问题(会退化为<code>Serial Old</code>单线程)，浮动垃圾问题</li><li>适合大型互联网系统中，用户请求数据量大，频率高的场景，比如订单接口，商品接口等</li></ul><div class="note info flat"><p><code>CMS</code>执行步骤</p><ol><li>初始标记，用极短的时间标记出<code>GC Roots</code>能够直接关联到的对象</li><li>并发标记，标记所有的对象，用户线程不需要暂停</li><li>重新标记，由于并发标记阶段有些对象会发生变化，存在错标和漏标的情况，需要重新标记(这也是<code>STW</code>的原因)</li><li>并发清理，清理死亡对象，用户线程不需要暂停(会有浮动垃圾,不能完全垃圾回收)</li></ol><blockquote><p>只有初始标记和重新标记两个阶段用户线程需要暂停，但是这两个线程执行时间较短，是并发执行的，所以<code>STW</code>较短</p></blockquote><ul><li><code>CMS</code>问题<ol><li>使用标记-清除算法，会有大量内存碎片，在<code>Full GC</code>时进行碎片整理，导致用户线程暂停，可以使用<code>-XX:CMSFullGCsBeforeCompation=N</code>(默认为0)调整<code>N</code>次<code>Full GC</code>之后再整理</li><li>无法处理在并发清理过程中产生的<strong>浮动垃圾</strong>，不能做到完全的垃圾回收, 也就是在并发清理阶段，如果用户产生了对象，并且很快就失效了，则不能在并发清理阶段被回收</li><li>如果老年代内存不足无法分配对象，<code>CMS</code>就会退化为<code>Serial Old</code>单线程回收老年代</li></ol></li></ul></div><h2 id="Parallel-Scavenge垃圾回收器-年轻代"><code>Parallel Scavenge</code>垃圾回收器-年轻代</h2><ul><li>是<code>JDK8</code>默认的垃圾回收器，多线程并行回收，关注系统的吞吐量，具备自动调整堆内存大小的特点</li><li>年轻代的复制算法</li><li>优点：吞吐量高，手动可控，为了提高吞吐量，虚拟机会动态调整堆的参数(不需要关注最大堆内存，年轻代的大小了)</li><li>缺点：不能保证单次的停顿时间(可以设置最大单次暂停时间)</li><li>适合后台任务，不需要与用户进行交互，并且容易产生大量的对象，比如大数据的处理，大文件的导出</li></ul><blockquote><p>允许手动设置最大暂停时间和吞吐量，官方建议<strong>不要设置堆内存的最大值</strong>，垃圾回收器会根据最大暂停时间和吞吐量自动调整内存大小<br>最大暂停时间<code>-XX:MaxGCPauseMillis=n</code>设置每次垃圾回收时的最大停顿毫秒数<br>吞吐量<code>-XX:GCTimeRatio=n</code>设置吞吐量为n，也就是用户线程执行时间=n/(n+1)<br>自动调整内存大小<code>-XX:+UseAdaptiveSizePolicy</code>设置可以让垃圾回收器根据吞吐量和最大停顿毫秒数自动调整内存大小<br>实际上，当我们把最大暂停时间减小的时候，垃圾回收器会主动减少堆内存，从而减少最大暂停时间<br><img src="https://gitee.com/sang3112/blog_imgs/raw/6d55251373589f7b63584fece6808ec3cbcdad27/Java/PS.png" alt="PS"></p></blockquote><h2 id="Parallel-Old垃圾回收器-老年代"><code>Parallel Old</code>垃圾回收器-老年代</h2><ul><li>是<code>PS</code>收集器的老年代版本，利用多线程并发收集</li><li><code>-XX:+UseParallelGC</code>或者<code>-XX:+UseParallelOldGC</code>可以使用<code>PS + PO</code>这种组合</li><li>回收老年代的标记-整理算法，(<code>Arthas</code>上面显示<code>MarkSweep</code>也就是标记清除，这是因为老年代垃圾回收器不会单独使用标记清除算法，官方没有将整理放上来，所以显示<code>MarkSweep</code>，包括<code>CMS</code>用的也不是单纯的标记清除算法)</li><li>优点：并发收集，在多核CPU下效率较高</li><li>缺点：暂停时间较长</li><li>适合与<code>PS</code>一起使用</li></ul><h2 id="G1垃圾回收器"><code>G1</code>垃圾回收器</h2><blockquote><p><code>JDK9</code>之后默认使用<code>G1</code>垃圾回收器，<code>PS</code>关注吞吐量，允许用户设置最大暂停时间，但是会减少年轻代的可用空间大小<br><code>CMS</code>关注暂停时间，但是吞吐量方面会有下降<br><code>G1</code>设计目标就是将上述两种垃圾回收器的优点融合：</p><ol><li>支持巨大的堆空间回收，具有较高的吞吐量</li><li>支持多CPU并行垃圾回收</li><li>允许用户设置最大暂停时间<br>所以强烈建议使用<code>G1</code>垃圾回收器</li></ol></blockquote><h3 id="内存结构">内存结构</h3><ul><li><code>G1</code>之前的垃圾回收器，一般内存结构是连续的<br><img src="https://gitee.com/sang3112/blog_imgs/raw/6d55251373589f7b63584fece6808ec3cbcdad27/Java/beforeg1.png" alt="beforeg1"></li><li><code>G1</code>将整个堆划分为多个大小相等的区域，称为区<code>Region</code>，区域不要求连续，分为<code>eden, Survivor, Old</code>区。<code>Region</code>的大小通过堆空间大小/2048计算得到，也可以通过<code>-XX:G1HeapRegionSize=32m</code>指定(<code>region</code>大小为32M)，<code>Region size</code>必须是2的指数幂，取值范围从1M到32M</li></ul><h3 id="垃圾回收方式">垃圾回收方式</h3><ol><li>年轻代回收(<code>Young GC</code>)</li><li>混合回收(<code>Mixed GC</code>)(回收年轻代加上老年代)</li></ol><h3 id="年轻代回收-YoungGC">年轻代回收(<code>YoungGC</code>)</h3><blockquote><p>回收<code>Eden</code>区和<code>Survivor</code>区中不再使用的对象，会导致<code>STW</code>，<code>G1</code>会尽可能的保证暂停时间，可以通过<code>-XX:MaxGCPauseMillis=n</code>(默认为200)设置最大暂停时间的毫秒数</p></blockquote><ol><li>新创建的对象放在<code>Eden</code>区，如果<code>Eden + Survivor</code>超过年轻代区的60%，就会判断年轻代空间不足，无法分配对象的时候会执行<code>Young GC</code></li><li>标记处<code>Eden</code>和<code>Survivor</code>区域中的存活对象</li><li>根据最大暂停时间选择某些区域将存活对象复制到一个新的<code>Survivor</code>区域，并且年龄+1，并清空这些区域(所以使用了复制方法，不会产生内存碎片)</li></ol><blockquote><p>进行<code>Young GC</code>的时候会记录每次垃圾回收的<code>Eden</code>区域和<code>Survivor</code>区域的<strong>平均耗时</strong>，从而作为下次回收时的参考依据，这样就可以根据配置的最大暂停时间计算出本次回收最多能回收多少个<code>Region</code>区域了<br>比如<code>-XX:MaxGCPauseMillis=n</code>(默认为200)，每个<code>Region</code>回收耗时40ms，所以这次最多只能回收4个<code>Region</code></p></blockquote><ol start="4"><li>后面如果再发生<code>Young GC</code>，步骤相同，只是<code>Survivor</code>会搬运到另一个<code>Survivor</code>区</li></ol><blockquote><p>如果一个对象年龄达到阈值(默认是15)，就会被放入老年代</p></blockquote><ol start="5"><li>如果部分对象大小超过<code>Region</code>的一半，那么就会直接放到老年代中，称为<code>Humongous</code>区(巨大的)。</li></ol><blockquote><p>比如堆内存4G，每个<code>Region</code>2M，只要一个对象超过1M，就会被放入<code>Humongous</code>区中，如果对象过大，就会横跨多个<code>Region</code></p></blockquote><ol start="6"><li>多次回收之后，会有很多老年代区，如果达到阈值(<code>-XX:InitiatingHeapOccupancyPercent</code>)占用总堆空间的默认的45%，就会触发<code>Mixed GC</code>，回收所有年轻代和部分老年代对象以及大对象区，采用复制算法完成</li></ol><h3 id="混合回收-Mixed-GC">混合回收(<code>Mixed GC</code>)</h3><blockquote><p>分为初始标记<code>Initial Mark</code>，并发标记<code>Concurrent Mark</code>，最终标记<code>Remark</code>或者<code>Finalize Marking</code>，并发清理(<code>Cleanup</code>)<br><code>G1</code>对老年代的清理会选择存活度最低的区域来进行回收，可以保证回收效率最高，也就是<code>G1</code>的由来(判断哪个区域存活对象最少，就优先清除哪个区域)<br><img src="https://gitee.com/sang3112/blog_imgs/raw/6d55251373589f7b63584fece6808ec3cbcdad27/Java/G1old.png" alt="G1old"></p></blockquote><ul><li>初始标记：标记<code>GC Roots</code>引用的对象为存活，并行执行，暂停用户线程，速度较快</li><li>并发标记：将第一步中标记对象的引用对象标记为存活，和用户线程一起执行(可能会出现错标漏标)</li><li>最终标记：标记一些引用改变漏标的对象，不管新创建、不再关联的对象(但是上一步，有些对象不再使用了，<code>G1</code>不再处理)</li><li>并发复制清理：使用复制算法，将存活对象复制到别的<code>Region</code>中，不会产生内存碎片</li></ul><div class="note info flat"><ul><li>如果清理过程中没有足够的空<code>Region</code>存放转移的对象，就会出现<code>Full GC</code>，单线程执行标记-整理算法，此时会导致用户线程暂停。所以尽量保证堆中有一定的空间</li></ul></div><blockquote><p><code>-XX:+UseG1GC</code>，打开<code>G1</code>的开关，<code>JDK9</code>之后不需要打开<br><code>-XX:MaxGCPauseMillis=n</code>设置最大暂停时间</p></blockquote><ul><li>使用<strong>复制算法</strong>回收年轻代+老年代</li><li>优点：<ol><li>对较大的堆如果超过6G对回收时，延迟也可控</li><li>不会产生内存碎片</li><li>并发标记的<code>SATB</code>算法效率高</li></ol></li><li>缺点：<code>JDK8</code>之前还不够成熟</li></ul><h2 id="总结">总结</h2><ul><li>组合</li></ul><ol><li><code>JDK8</code>以及之前：<code>ParNew + CMS</code>(关注暂停时间); <code>PS + PO</code>(关注吞吐量); <code>G1</code>(<code>JDK8</code>之前不建议使用，较大堆并且关注暂停时间)</li><li><code>JDK9</code>之后，使用<code>G1</code></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;垃圾回收算法(四种)&lt;/h1&gt;
&lt;div class=&quot;note info flat&quot;&gt;&lt;ul&gt;
&lt;li&gt;垃圾回收需要找到内存中存活的对象&lt;/li&gt;
&lt;li&gt;还需要释放不再存活的对象，使程序可以再次利用这部分空间&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;标记</summary>
      
    
    
    
    <category term="Java" scheme="https://sangs3112.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://sangs3112.github.io/tags/Java/"/>
    
    <category term="垃圾回收算法" scheme="https://sangs3112.github.io/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"/>
    
    <category term="垃圾回收器" scheme="https://sangs3112.github.io/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Java笔记_3</title>
    <link href="https://sangs3112.github.io/posts/fdc04dbc.html"/>
    <id>https://sangs3112.github.io/posts/fdc04dbc.html</id>
    <published>2024-04-21T06:37:35.000Z</published>
    <updated>2024-12-11T04:42:14.727Z</updated>
    
    <content type="html"><![CDATA[<h1>垃圾回收器</h1><blockquote><p>主要负责在<strong>堆</strong>上进行内存回收</p></blockquote><ul><li>自动垃圾回收可以降低实现难度，降低回收bug的可能性</li><li>但是程序员无法控制内存回收的及时性, 也无法完全避免内存溢出</li></ul><h2 id="应用场景">应用场景</h2><ol><li>解决系统僵死(因为频繁的垃圾回收)</li><li>性能优化</li><li>常见垃圾回收，四种引用等</li></ol><h2 id="方法区回收">方法区回收</h2><blockquote><p>线程不共享的程序计数器和<code>Java</code>虚拟机栈以及本地方法栈，都只需要等待线程销毁自己就销毁了，不需要垃圾回收</p></blockquote><h3 id="方法区回收的条件-三个">方法区回收的条件(三个)</h3><blockquote><p>方法区中的类不再使用，即可被回收</p></blockquote><ol><li>类的<strong>所有实例</strong>都已经被回收了，在堆中不存在任何该类的实例对象以及子类对象 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = loader.loadClass(<span class="string">&quot;类的全限定名&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">o = <span class="literal">null</span>; <span class="comment">// 此时对象o不再使用，就可以让gc自动回收clazz类</span></span><br></pre></td></tr></table></figure></li><li>加载该类的类加载器已经被回收了 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">URLClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URLClassLoader</span>(<span class="keyword">new</span> <span class="title class_">URL</span>[]&#123;<span class="keyword">new</span> <span class="title class_">URL</span>(spec:<span class="string">&quot;路径&quot;</span>)&#125;);</span><br><span class="line">loader = <span class="literal">null</span>; </span><br></pre></td></tr></table></figure></li><li>该类对应的<code>java.lang.Class</code>对象没有任何地方被引用 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = loader.loadClass(<span class="string">&quot;类的全限定名&quot;</span>);</span><br><span class="line">clazz = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>使用<code>System.gc()</code>可以手动触发垃圾回收</p></blockquote><div class="note info flat"><ul><li>开发过程中此类场景出现较少，主要在<code>OSGI, JSP</code>的热部署等场景中</li><li>每个<code>jsp</code>文件对应一个类加载器，一个<code>jsp</code>文件被修改了，直接写在这个<code>jsp</code>类加载器，创建新的类加载器，重新加载<code>jsp</code>文件</li></ul></div><h2 id="堆回收">堆回收</h2><blockquote><p>堆上的对象主要看是否还被<strong>引用</strong>，如果被引用，说明不能回收</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Demo</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">        d = <span class="literal">null</span>; <span class="comment">// 此时没有引用，可以被回收</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceCounting</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        <span class="type">B</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        a1.b = b1;</span><br><span class="line">        b1.a = a1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// A实例要回收，需要消除两个引用关系，分别是栈中a1对对象的引用，以及B对象中b1.a对对象的引用</span></span><br><span class="line">    <span class="comment">// a1 = null;</span></span><br><span class="line">    <span class="comment">// b1.a = null;</span></span><br><span class="line"><span class="comment">// 如果单纯的执行a1 = null; b1 = null; A和B对象也可以被回收，因为方法里面没有办法访问到AB对象了</span></span><br></pre></td></tr></table></figure><div class="note info flat"><ul><li>如果想要查看垃圾回收的信息，可以使用<code>-verbose:gc</code></li></ul></div><h2 id="判断堆上的对象是否被引用-两种方法">判断堆上的对象是否被引用(两种方法)</h2><ol><li><strong>引用计数法</strong>：每个对象维护一个计数器，初始值为0，对象被引用就加1，取消引用就减1<ul><li>缺点:</li></ul><blockquote><p>引用和取消引用需要维护计数器，对性能有一定影响<br>循环引用，比如A引用B，B引用A，就会导致对象无法回收(上面的例子如果用引用计数法，就无法回收了)</p></blockquote></li><li>可达性分析法(<code>Java</code>使用，性能更高，解决了循环引用的问题)<ul><li>可达性分析算法将对象分为两类: 垃圾回收的根对象(<code>GC Root</code>)；普通对象，对象与对象之间存在引用关系</li><li><code>GC Root</code>对象一般不可以被回收，<code>JVM</code>也会维护一个<code>GC Root</code>对象列表</li><li>每次从某个<code>GC Root</code>遍历引用链，如果某个普通对象可以从<code>GC Root</code>到达，说明不可被回收<br><img src="https://gitee.com/sang3112/blog_imgs/raw/6d55251373589f7b63584fece6808ec3cbcdad27/Java/achieve.png" alt="achieve"></li></ul></li></ol><div class="note info flat"><p>什么样的对象可以作为<code>GC Root</code>对象</p><ol><li>线程<code>Thread</code>对象，引用线程栈帧中的方法参数、局部变量等</li><li>系统类加载器加载的<code>java.lang.Class</code>对象，引用类中的静态变量 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceCounting</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">A</span> <span class="variable">a2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// sun.misc.Launcher是一个GC Root对象，可以找到应用程序类加载器，以及扩展类加载器。</span></span><br><span class="line"><span class="comment">// 自定义的ReferenceCounting是由应用程序类加载器加载的，所以可以由GC Root找到</span></span><br><span class="line"><span class="comment">// a2 引用了A，所以GC Root可以找到a2，所以不会回收</span></span><br></pre></td></tr></table></figure></li><li>监视器对象，用来保存同步锁<code>synchronized</code>关键字持有的对象<br><code>synchronized(Reference.class)</code> 只要这个关系建立起来，监视器对象就可以找到<code>ReferenceCounting</code>，就无法回收</li><li>本地方法调用时使用的全局对象(不需要程序员过多关注)</li></ol></div><ul><li>通过<code>Arthas</code>以及<code>eclise MAT(Memory Analyzer)</code>工具可以查看<code>GC Root</code></li><li><code>Arthas</code>使用<code>heapdump &lt;dir/文件名.hprof&gt;</code>命令将堆内存快照保存到本地磁盘中</li><li>使用<code>MAT</code>工具打开堆内存的快照文件</li><li>使用<code>GC Roots</code>功能查看所有的<code>GC Root</code></li></ul><h3 id="对象引用-五种">对象引用(五种)</h3><blockquote><p>强引用，软引用，弱引用，虚引用，终结器引用</p></blockquote><ol><li><p>强引用</p><blockquote><p>可达性算法中的对象引用一般指强引用，就是<code>GC Root</code>对象对普通对象有引用关系，那么普通对象就不会被回收</p></blockquote></li><li><p>软引用</p><blockquote><p>如果一个对象只有软引用关联到它，如果程序内存不足，则会将软引用进行回收<br><code>JDK1.2</code>提供<code>SoftReference</code>实现软引用，经常用于缓存中<br>因此使用软引用应该创建两个对象，一个是<code>SoftReference</code>对象，引用真正使用的对象，而<code>SoftReference</code>本身应该被<code>Gc Root</code>引用，保证可以找到</p></blockquote> <div class="note info flat"><p>软引用的执行过程</p><ol><li>对象使用软引用包装起来，<code>new SoftReference&lt;对象类型&gt;(对象);</code></li><li>内存不足时，<code>JVM</code>进行垃圾回收</li><li>垃圾回收仍然不能解决内存不足的问题，回收软引用中的对象</li><li>如果依然内存不足，会抛出<code>OutOfMemory</code>异常</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">100</span>];</span><br><span class="line">SoftReference&lt;<span class="type">byte</span>[]&gt; softReference = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;<span class="type">byte</span>[]&gt;(bytes);</span><br><span class="line"><span class="comment">// 这段代码将100M的数据放在软引用中</span></span><br></pre></td></tr></table></figure><ul><li><code>Java</code>中的<code>Caffeine</code>可以在创建缓存的过程中将缓存对象设置成<code>softValues()</code>也就是软引用</li></ul></div> <div class="note info flat"><ul><li>软引用中的对象如果内存不足会被回收，<code>SoftReference</code>对象本身也需要被回收，但是<code>SoftReference</code>一旦被回收了，就无法知道其引用的对象是否真的被回收了，所以<code>SoftReference</code>提供了一套<strong>队列机制</strong>来进行判断:<ol><li>软引用创建时，通过构造器传入引用队列(程序员自定义)</li><li>软引用中包含对象被回收时，该软引用对象会被放入引用队列</li><li>通过代码遍历引用队列，将<code>SoftReference</code>的强引用删除</li></ol></li></ul></div><ul><li>软引用可以继承<code>SoftReference</code>类的方式来实现，<code>SoftReference</code>类就是一个软引用对象，通过构造器传入软引用包含的对象，以及引用队列</li><li>使用软引用实现学生数据的缓存，软引用如果被回收了，则要清理<code>HashMap</code>中的<code>key</code><br><img src="https://gitee.com/sang3112/blog_imgs/raw/6d55251373589f7b63584fece6808ec3cbcdad27/Java/stucac.png" alt="stucache"></li></ul> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentCache</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">StudentCache</span> <span class="variable">cache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StudentCache</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; ; ++ i)&#123;</span><br><span class="line">            StudentCache.getInstance().cacheStudent(<span class="keyword">new</span> <span class="title class_">Student</span>(i, String.valueOf(i)))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, StudentRef&gt; StudentRefs; <span class="comment">// 用于Cache内容的存储</span></span><br><span class="line">    <span class="keyword">private</span> ReferenceQueue&lt;Student&gt; q; <span class="comment">// 垃圾Reference队列</span></span><br><span class="line">    <span class="comment">// 继承SoftReference，每个实例都具有一个可识别的标识</span></span><br><span class="line">    <span class="comment">// 并且标识与在HashMap中的key相同</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">StudentRef</span> <span class="keyword">extends</span> <span class="title class_">SoftReference</span>&lt;Student&gt;&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">_key</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">StudentRef</span><span class="params">(Student em, ReferenceQueue&lt;Student&gt; q)</span>&#123;</span><br><span class="line">            <span class="built_in">super</span>(em, q); <span class="comment">// 调用父类的构造方法</span></span><br><span class="line">            _key = em.getId();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造一个缓存器实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">StudentCache</span><span class="params">()</span>&#123;</span><br><span class="line">        StudentRefs = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, StudentRef&gt;();</span><br><span class="line">        q = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;Student&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取得缓存器实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StudentCache <span class="title function_">getInstance</span><span class="params">()</span> &#123;<span class="keyword">return</span> cache;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以软引用的方式对一个Student对象的实例进行引用并保存该引用(放入缓存)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">cacheStudent</span><span class="params">(Student em)</span>&#123;</span><br><span class="line">        cleanCache(); <span class="comment">// 清除垃圾引用</span></span><br><span class="line">        <span class="type">StudentRef</span> <span class="variable">ref</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StudentRef</span>(em, q);</span><br><span class="line">        StudentRefs.put(em.getId(), ref);</span><br><span class="line">        System.out.println(StudentRefs.size());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 依据指定的ID，重新获取相应的Student对象的实例</span></span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">getStudent</span><span class="params">(Integer id)</span>&#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">em</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 缓存中是否有该Student实例的软引用，如果有就从软引用中获得</span></span><br><span class="line">        <span class="keyword">if</span> (StudentRefs.containsKey(id))&#123;</span><br><span class="line">            <span class="type">StudentRef</span> <span class="variable">ref</span> <span class="operator">=</span> StudentRefs.get(id);</span><br><span class="line">            em = ref.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有这个软引用，或者这个软引用得到的实例为空，则重新构建一个实例，保存对这个实例的软引用</span></span><br><span class="line">        <span class="keyword">if</span> (em == <span class="literal">null</span>)&#123;</span><br><span class="line">            em = <span class="keyword">new</span> <span class="title class_">Student</span>(id, String.valueOf(id));</span><br><span class="line">            System.out.println(<span class="string">&quot;Retrieve From StudentInfoCenter. ID = &quot;</span> + id);</span><br><span class="line">            <span class="built_in">this</span>.cacheStudent(em);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> em;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除那些软引用的所有Student对象已经被回收的StudentRef对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">cleanCache</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">StudenRef</span> <span class="variable">ref</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>((ref = (StudentRef)q.poll() != <span class="literal">null</span>))&#123;</span><br><span class="line">            StudentRefs.remove(ref._key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> id, String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;<span class="keyword">return</span> id;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;<span class="built_in">this</span>.id = id;&#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;<span class="keyword">return</span> name;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;<span class="built_in">this</span>.name = name;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>弱引用</p><blockquote><p>关联的对象在垃圾回收时，不管内存够不够，都会被直接回收<br><code>JDK1.2</code>版本之后提供了<code>WeakReference</code>类来实现弱引用，主要用在<code>ThreadLoacl</code>中，弱引用本身也可以使用引用队列回收<br>除了<code>ThreadLocal</code>以外，基本上不会使用这个，<code>Caffeine</code>中也有弱引用的实现，但是一般不用</p></blockquote></li><li><p>虚引用(幽灵引用，幻影引用)</p><blockquote><p>在常规开发中<strong>不会</strong>使用<br>不能通过虚引用对象获取包含的对象，唯一的用途是当对象被垃圾回收器回收时可以接收到对应的通知<br>使用<code>PhantomReference</code>实现了虚引用<br>直接内存为了及时知道直接内存中的对象不再使用，从而回收内存，就会用虚引用实现<code>Cleaner</code>类(解决了直接内存中内存的释放问题)</p></blockquote></li><li><p>终结器引用</p><blockquote><p>在常规开发中不会使用<br>对象需要被回收的时候，终结器引用会关联对象并且放在<code>Finalizer</code>类中的引用队列，由一条<code>FinalizerThread</code>线程从队列中获取对象，然后执行对象的<code>finalize</code>方法(这个方法实际上重写了<code>Object</code>中的方法，作用是回收对象时做一些收尾的工作)，在对象第二次被回收时，该对象才会被真正的回收。这个过程中<code>finalize</code>方法再将自身对象使用强引用关联上，但是不建议这么做，因为这个<code>finalize</code>方法什么时候调用，甚至可能不调用，都是<code>GC</code>决定的，不是程序员决定的。(不管是实现自救，也就是用强引用关联；还是实现清理工作都是不合适的，所以基本不会用)</p></blockquote></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;垃圾回收器&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;主要负责在&lt;strong&gt;堆&lt;/strong&gt;上进行内存回收&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;自动垃圾回收可以降低实现难度，降低回收bug的可能性&lt;/li&gt;
&lt;li&gt;但是程序员无法控制内存回收的及</summary>
      
    
    
    
    <category term="Java" scheme="https://sangs3112.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://sangs3112.github.io/tags/Java/"/>
    
    <category term="方法区 堆的垃圾回收" scheme="https://sangs3112.github.io/tags/%E6%96%B9%E6%B3%95%E5%8C%BA-%E5%A0%86%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
    <category term="五种引用关系" scheme="https://sangs3112.github.io/tags/%E4%BA%94%E7%A7%8D%E5%BC%95%E7%94%A8%E5%85%B3%E7%B3%BB/"/>
    
  </entry>
  
  <entry>
    <title>Java笔记_2</title>
    <link href="https://sangs3112.github.io/posts/8ac77d2a.html"/>
    <id>https://sangs3112.github.io/posts/8ac77d2a.html</id>
    <published>2024-04-20T06:37:35.000Z</published>
    <updated>2024-12-11T04:42:14.727Z</updated>
    
    <content type="html"><![CDATA[<h1>运行时数据区</h1><h2 id="分类">分类</h2><ol><li>线程不共享：程序计数器、<code>Java</code>虚拟机栈、本地方法栈</li><li>线程共享：方法区、堆区</li></ol><h2 id="程序计数器">程序计数器</h2><blockquote><p><code>Program Counter Register</code>，也叫做<code>PC</code>寄存器，每个线程会通过程序计数器记录当前<strong>要执行</strong>的字节码指令的地址</p></blockquote><h3 id="作用">作用</h3><ol><li>控制程序指令的执行，比如跳转，分支，异常</li><li>多线程情况下<code>JVM</code>通过程序计数器记录CPU切换前执行到哪一句，切换回来后执行并继续解释运行</li></ol><div class="note info flat"><p>程序计数器会产生内存溢出的问题吗</p><ul><li>内存溢出指在使用某一块内存区域时，存放的数据需要占用的内存大小超过了虚拟机能够提供的内存上限</li><li>每个线程只存储一个固定长度的内存地址，<code>PC</code>不会产生内存溢出</li><li><code>PC</code>不用程序员修改</li></ul></div><h2 id="Java虚拟机栈"><code>Java</code>虚拟机栈</h2><blockquote><p>先进后出(<code>FILO</code>)，每个方法调用一个栈帧来保存</p></blockquote><ul><li><code>Java</code>虚拟机栈随着线程的创建而创建，线程销毁则栈回收，由于方法可能会在不同的线程中执行，所以每个线程都有自己的虚拟机栈</li></ul><h3 id="栈帧组成">栈帧组成</h3><blockquote><p>局部变量表，操作数栈，帧数据</p></blockquote><ol><li>局部变量表：方法执行过程中存放所有的局部变量，与字节码局部变量表不太一样</li></ol><blockquote><p>栈帧中的局部变量表是一个数组，每一个位置成为槽<code>slot</code>，<code>long, double</code>占用两个槽，其他类型占用一个槽<br>实例方法中的序号为<code>0</code>的位置存放的是<code>this</code>，指的是当前调用方法的对象，运行时会在内存中存放实例对象的地址<br>方法参数也会保存在局部变量表中，顺序与参数定义顺序一致<br>所以局部变量表保存了实例方法的<code>this</code>对象，方法的参数，方法体中声明的局部变量。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> m)</span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 占用了6个槽，为了节省空间，槽是可以复用的，一旦某个局部变量不再生效，则当前的槽可以再次使用</span></span><br><span class="line"><span class="comment">// ab在代码块中，代码块结束以后，ab就释放了</span></span><br></pre></td></tr></table></figure><ol start="2"><li>操作数栈：存放中间数据的一块区域，如果一条指令将一个值压入操作数栈，则后面的指令可以弹出并使用该值</li></ol><blockquote><p><strong>编译期</strong>就可以确定操作数栈的最大深度，从而在执行时正确分配内存大小</p></blockquote><ol start="3"><li>帧数据：包含动态链接，方法出口，异常表的引用</li></ol><blockquote><p>动态链接保存的是符号引用到运行时常量池中内存地址的映射关系(比如引用其他类)<br>方法出口：方法在正确或异常结束时，栈帧会被弹出，PC应该指向那个<strong>上一个栈帧中的下一条指令的地址</strong>，所以在当前栈帧中，需要存储此方法的出口的地址<br>异常表引用：存放代码中的异常处理信息，包含异常捕获的生效范围以及异常发生以后跳转到的字节码指令位置</p></blockquote><div class="note info flat"><p>栈内存溢出</p><ul><li>如果栈帧过多，占用内存超过栈内存可以分配的最大大小以后就会出现内存溢出</li><li>会报<code>StackOverflowError</code>错误</li><li>比如递归的时候没有设置递归出口，则会内存溢出</li></ul><p>设置栈内存</p><ul><li>通过参数<code>-Xss&lt;值&gt;</code>设置虚拟机栈大小，单位是[字节，必须是1024的倍数，默认] [k或者K] [m或者M] [g或者G]</li><li>也可以用<code>-XX:ThreadStackSize=&lt;大小&gt;</code>，但是比较复杂</li><li><code>HotSpot JVM</code>对栈的大小的最大值和最小值有要求，超过范围会自动调整</li><li>局部变量过多，操作数栈深度过大也会影响栈内存大小</li><li>可以手动指定<code>-Xss256k</code>节省内存</li></ul></div><h2 id="本地方法栈">本地方法栈</h2><blockquote><p><code>Java</code>虚拟机栈存储了<code>Java</code>方法调用时的栈帧，本地方法栈存储的是本地方法的栈帧，用<code>cpp</code>编写的</p></blockquote><ul><li>在<code>Hotspot</code>虚拟机中，<code>Java</code>虚拟机栈和本地方法栈实现上用了同一个栈空间，本地方法栈会在栈内存上生成一个栈帧，临时保存方法参数的同时,方便出现异常时也把本地方法的栈信息打印出来</li></ul><h2 id="堆">堆</h2><blockquote><p>堆内存是最大的内存区域，<strong>创建出来的对象都在堆上</strong><br>栈上的局部变量表中可以存放堆上对象的引用，静态变量也可以存放堆对象的引用，通过静态变量可以实现对象在线程之间共享</p></blockquote><div class="note info flat"><p>堆内存溢出</p><ul><li>堆内存大小有上限，如果一直向堆中放入对象达到上限后，就会抛出<code>OutOfMemory</code>错误</li><li>有三个需要关注的值: <code>used, total, max</code>，在<code>Arthas</code>中可以使用<code>dashbord -i </code> 或者 <code>memory</code>命令查看<ul><li><code>used</code>：当前已经使用的堆内存</li><li><code>total</code>：<code>Java</code>虚拟机已经分配的可用堆内存</li><li><code>max</code>：是可以分配的最大堆内存</li><li><code>total</code>内存不足的时候，<code>Java</code>会扩大<code>total</code>，直到达到<code>max</code>为止</li></ul><blockquote><p>但是，<strong>不是</strong>在<code>total = used = max</code>的时候堆内存溢出，这是因为有垃圾回收器存在的原因</p></blockquote><ul><li>默认情况下，<code>max</code>默认是系统内存的<code>1/4</code>，<code>total</code>默认是系统内存的<code>1/64</code>，实际应用中需要单独设置</li><li><code>-Xmx值 -Xms值</code>，分别表示<code>max</code>和<code>total</code>的大小，<code>max</code>必须大于<code>2MB</code>，<code>total</code>必须大于<code>1MB</code></li><li>但是实际上<code>Arthas</code>堆内存显示的比实际上分配的要小一点，这是因为使用了<code>JMX</code>技术，与垃圾回收器有关，计算的是可以<strong>分配对象的内存，而不是整个内存</strong></li><li>一般设置的时候，将<code>total</code>设置成<code>max</code>相同的大小，减少申请内存和压缩内存的开销。</li></ul></li></ul></div><h2 id="方法区">方法区</h2><blockquote><p>存放基础信息的位置(类的元信息，运行时常量池，字符串常量池)，线程共享，是一个虚拟概念</p></blockquote><ul><li>用来存放每个类的基本信息(元信息)，一般称为<code>InstanceKlass</code>对象，在类的加载阶段完成</li><li>还用来存放了字节码中的运行时常量池，通过<strong>编号查表</strong>的方式找到常量，称为<strong>静态常量池</strong>。常量池<strong>加载</strong>到内存中之后，可以通过内地址快读定位到常量池中的内容，就是<strong>运行时常量池</strong>。</li></ul><h3 id="JDK7以及之前"><code>JDK7</code>以及之前</h3><ul><li>方法区存放在<strong>堆的永久代空间</strong>，堆的大小由虚拟机参数控制</li><li>在<code>Arthas</code>中可以看见<code>ps_perm_gen</code>就是永久代，因为在堆上，所以设置了<code>max</code>，存储空间大小有限制</li></ul><h3 id="JDK8以及之后"><code>JDK8</code>以及之后</h3><ul><li>方法区存放在<strong>元空间</strong>中，位于<strong>操作系统内存</strong>中，独立于<code>JVM</code>内存之外，默认情况下只要不超过操作系统上限，可以一直分配</li><li>在<code>Arthas</code>中可以看见<code>metaspace</code>，就是元空间，<code>max=-1</code>，表示没有上限，只要不超过操作系统的上限即可。</li></ul><div class="note info flat"><p>方法区溢出</p><ul><li><code>JDK7</code>在堆上，十几万个类会出现错误。<code>JDK8</code>运行上百万次，不会出现错误。</li><li><code>JDK7</code>方法区存储在堆区中的永久代空间，可以设置<code>-XX:MaxPermSize=值</code>来控制</li><li><code>JDK8</code>方法区位于元空间中，默认不超过操作系统上限即可，同样可以使用<code>-XX:MaxMetaspaceSize=值</code>设置元空间大小<ul><li>启动程序的时候最好设置元空间的最大大小，没有特殊情况设置成<code>256M</code>，以免占用其他程序的内存，能够容纳三十多万个类的加载</li></ul></li></ul></div><h3 id="字符串常量池">字符串常量池</h3><blockquote><p>存储代码中定义的常量字符串内容，比如<code>&quot;123&quot;</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译成字节码以后，&quot;abc&quot;会加入到静态常量池中</span></span><br><span class="line"><span class="comment">// s1通过new创建，所以&quot;abc&quot;放在堆内存中，由s1保存</span></span><br><span class="line"><span class="comment">// s2没有使用new，所以s2存放的是字符串常量池中的&quot;abc&quot;</span></span><br><span class="line"><span class="comment">// 所以最后打印s1 == s2两个地址不同，返回false</span></span><br></pre></td></tr></table></figure><div class="note info flat"><ul><li>早期的设计中，字符串常量池是运行时常量池的一部分，存储位置相同。后续将字符串常量池和运行时常量池进行拆分</li><li><code>JDK7</code>之前，运行时常量池包含字符串常量池，都在永久代中</li><li><code>JDK7</code>版本的时候，字符串常量池从方法区拿到了堆中，运行时常量池剩下的东西还在永久代中</li><li><code>JDK8</code>之后，没有永久代了，所以运行时常量池在元空间中，而字符串常量池仍然在堆中</li></ul></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;2&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;12&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> a + b;</span><br><span class="line">    System.out.println(c == d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译成字节码以后，字符串常量池中会有&quot;1&quot;, &quot;2&quot;, &quot;12&quot;</span></span><br><span class="line"><span class="comment">// c指向的是字符串常量池中的&quot;12&quot;</span></span><br><span class="line"><span class="comment">// d 中的 + 变成了使用StringBuilder方法进行连接</span></span><br><span class="line"><span class="comment">// d指向的是堆内存中的&quot;12&quot;</span></span><br><span class="line"><span class="comment">// 所以是false</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;2&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;12&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span> + <span class="string">&quot;2&quot;</span>;</span><br><span class="line">    System.out.println(c == d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此时cd都是在字符串常量池中</span></span><br><span class="line"><span class="comment">// 所以返回true</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>().append(<span class="string">&quot;think&quot;</span>).append(<span class="string">&quot;123&quot;</span>).toString();</span><br><span class="line">    System.out.println(s1.intern() == s1);</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>().append(<span class="string">&quot;ja&quot;</span>).append(<span class="string">&quot;va&quot;</span>).toString();</span><br><span class="line">    System.out.println(s2.inter() == s2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// String.intern()是手动将字符串放在字符串常量池中</span></span><br><span class="line"><span class="comment">// 比如多次输入，每次Scanner.next().intern()，如果有两次输入相同的字符串，就可以减少存储的消耗，只需要往字符串常量池中存储一份字符串即可</span></span><br><span class="line"><span class="comment">// JDK6这个版本中，intern()会把第一次遇到的字符串实例复制到永久代字符串常量池中，返回的也是永久代字符串实例的引用。JVM启动时会把java加入到常量池中</span></span><br><span class="line">    <span class="comment">// 所以JDK6中，s1.intern()方法在字符串常量池中，s1在堆上，返回false</span></span><br><span class="line">    <span class="comment">// s2.intern()在字符串常量池中，s2在堆上，所以返回false</span></span><br><span class="line"><span class="comment">// JDK7之后的版本，由于字符串常量池在堆上，所以intern()方法会把第一次遇到的字符串引用放在字符串常量池中</span></span><br><span class="line">     <span class="comment">// s1.intern()返回的就是s1在堆上的引用，也就是地址，所以返回true</span></span><br><span class="line">     <span class="comment">// s2.intern()由于java已经在字符串常量池中有了，所以s2.intern()是字符串常量池中的地址，s2是堆中的地址，因此返回false</span></span><br></pre></td></tr></table></figure><div class="note info flat"><p>静态变量存储在哪里？</p><ul><li><code>JDK6</code>以及之前，静态变量存储在方法区中，也就是永久代中</li><li><code>JDK7</code>以及之后的版本中，静态变量存储在<code>Class</code>对象中，脱离了永久代。</li></ul></div><h2 id="直接内存">直接内存</h2><blockquote><p>不属于<code>Java</code>运行时的内存区域，在<code>JDK1.4</code>中引入了<code>NIO</code>机制，使用了直接内存，比如<code>Netty</code>网络框架</p></blockquote><ul><li><p>直接内存解决两个问题</p><ol><li><code>Java</code>堆中的对象如果不再使用要回收，回收时会影响对象的创建和使用</li><li><code>IO</code>操作比如读文件，需要先把文件读入直接内存(缓冲区)，然后再把数据复制到<code>Java</code>堆中</li></ol></li><li><p>现在直接放入直接内存即可，同时<code>Java</code>堆上维护直接内存的引用，减少了数据复制的开销，写文件也是同样的思路</p></li><li><p>所以现在不需要从直接内存上复制到堆中了，减少回收对象的影响，提升读写文件的效率</p></li><li><p>可以使用<code>ByteBuffer</code>在直接内存上创建数据，在<code>Arthas</code>中的<code>memory</code>可以查看<code>direct</code>部分的相关信息</p><ul><li><code>ByteBuffer directBuffer = ByteBuffer.allocateDirect(size);</code></li></ul></li></ul><div class="note info flat"><p>直接内存存在溢出现象</p><ul><li><code>-XX:MaxDirectMemorySize=值</code>修改直接内存的大小，如果不设置这个参数，则会自动选择最大分配的大小</li><li>如果底层使用了<code>NIO</code>，则需要设置这个参数；如果没有用到直接内存，也可以不设置这个参数</li><li>具体设置的大小需要进行压力测试以后，确定最大内存</li></ul></div><h2 id="总结">总结</h2><ol><li>运行时数据区分为了哪几个部分，每个部分的作用是什么</li></ol><ul><li>程序计数器，<code>Java</code>虚拟机栈，本地方法栈。线程不共享，每个线程有一块独立的区域<ul><li>程序计数器，记录当前要执行的字节码指令的地址，不会出现内存溢出的问题</li><li>Java虚拟机栈和本地方法栈。每个方法的调用会使用一个栈帧来保存数据，会内存溢出，一般因为递归没有出口</li></ul></li><li>方法区，堆。线程共享的<ul><li>堆中存放创建的对象，最容易内存溢出，与垃圾回收有关</li><li>方法区存放类的元信息，以及常量池，会出现内存溢出</li></ul></li></ul><ol start="2"><li>不同<code>JDK</code>版本之间运行时区域的区别是什么</li></ol><ul><li><code>JDK6</code>方法区放在堆里面，称为永久代，字符串常量池放在方法区中</li><li><code>JDK7</code>字符串常量池从方法区中独立，放在了堆上</li><li><code>JDK8</code>字符串常量池依然在堆里面，但是方法区称为元空间，从堆中独立</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;运行时数据区&lt;/h1&gt;
&lt;h2 id=&quot;分类&quot;&gt;分类&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;线程不共享：程序计数器、&lt;code&gt;Java&lt;/code&gt;虚拟机栈、本地方法栈&lt;/li&gt;
&lt;li&gt;线程共享：方法区、堆区&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;程序计数器&quot;&gt;程序计数器&lt;/h</summary>
      
    
    
    
    <category term="Java" scheme="https://sangs3112.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://sangs3112.github.io/tags/Java/"/>
    
    <category term="运行时数据区" scheme="https://sangs3112.github.io/tags/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Java笔记_1</title>
    <link href="https://sangs3112.github.io/posts/13ce2c90.html"/>
    <id>https://sangs3112.github.io/posts/13ce2c90.html</id>
    <published>2024-04-19T06:37:35.000Z</published>
    <updated>2024-12-11T04:42:14.727Z</updated>
    
    <content type="html"><![CDATA[<h1>类加载器</h1><ul><li>类加载器(<code>ClassLoader</code>)是<code>JVM</code>给应用程序实现类和接口字节码数据的技术</li><li>本地接口<code>JNI</code>允许<code>Java</code>调用其他语言编写的方法，在<code>hotspot</code>类加载器中，主要用于调用<code>JVM</code>中使用<code>CPP</code>编写的方法</li></ul><h2 id="应用">应用</h2><ol><li><code>SPI</code>机制</li><li>类的热部署</li><li><code>Tomcat</code>类的隔离</li><li>类的双亲委派机制(怎么打破双亲委派机制)</li><li>自定义类加载器</li><li>使用<code>Arthas</code>不停机解决线上故障</li></ol><h2 id="分类">分类</h2><ol><li><code>Java</code>代码中实现的 or <code>JDK</code>默认提供或者自定义的，所有实现的类加载器都需要继承抽象类<code>ClassLoader</code></li><li><code>JVM</code>底层源码实现的，跟虚拟机实现语言一致，比如<code>Hotspot</code>使用<code>cpp</code>实现。作用是加载运行时的基础类，保证运行中基础类可以被正确的加载，比如<code>java.lang.String</code>，确保可靠性</li></ol><h3 id="JDK8之前"><code>JDK8</code>之前</h3><ul><li><code>JVM</code>底层实现的类加载器，<strong>启动类加载器</strong><code>Bootstrap</code>，加载<code>Java</code>中<strong>最核心</strong>的类，在<code>jre/lib</code>目录下的所有类文件，比如<code>rt.jar, tools.jar, resources.jar</code></li></ul><div class="note info flat"><ul><li>如果打印看到类加载器为<code>null</code>，则就是启动类加载器。因为为了安全性考虑，不允许在代码中获得启动类加载器。</li><li>用户自己如果写了一些底层的<code>jar</code>包可以由启动类加载器加载，有两种方式<ol><li>放在<code>jre/lib</code>目录下(但是不推荐这么做)</li><li>使用<code>-Xbootclasspath/a:&lt;jar包目录&gt;/&lt;jar包名&gt;</code>进行扩展</li></ol></li></ul></div><ul><li><code>Java</code>代码中实现了<strong>扩展类加载器</strong><code>Extension</code>，允许扩展<code>Java</code>中比较通用的类；<strong>应用程序类加载器</strong><code>Application</code>，加载应用使用的类，比如由第三方<code>jar</code>包引入的类。<ul><li>源码都位于<code>sun.misc.Launcher</code>中，是一个静态内部类，继承自<code>URLClassLoader</code>，可以通过目录或指定<code>jar</code>包将字节码文件加载到内存中</li><li><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Java/extends.png" alt="extends"></li><li>扩展类加载器<code>Extension ClassLoader</code>默认加载<code>jre/lib/ext</code>下的类文件<ol><li>所以同样可以将自定义的<code>jar</code>包放在<code>jre/lib/ext</code>目录下(但是不推荐)</li><li>使用<code>-Djava.ext.dirs=&lt;jar包目录&gt;</code>进行扩展，会覆盖原始目录，<code>windows</code>上可以使用分号分隔，<code>macos</code>或者<code>linux</code>上使用冒号分隔，追加上原始目录</li></ol></li><li>应用程序类加载器<code>Application</code>加载<code>classpath</code>下的类文件，项目中的类或者是第三方依赖中的类</li></ul></li><li><code>Arthas</code>中使用<code>classloader</code>命令可以查看<ul><li><code>classloader -l</code>查看所有类加载器的哈希值</li><li><code>classloader -c &lt;hash&gt;</code>其中<code>&lt;hash&gt;</code>表示某一个类加载器的哈希值，就可以把所有加载的<code>jar</code>包都打印出来，</li><li>可以看到扩展类加载器加载的都是扩展类加载器的<code>jar</code>包，但是应用程序类加载器加载了不止<code>maven</code>第三方<code>jar</code>包，还加载了扩展类加载器，以及启动类加载器加载的<code>jar</code>包的内容，这是因为双亲委派机制</li></ul></li></ul><h1>双亲委派机制</h1><blockquote><p>解决了一个类到底由谁来加载的问题</p></blockquote><h2 id="作用">作用</h2><ol><li>保证类加载的安全性，避免恶意代码替换<code>JDK</code>的核心类库，确保核心类库的<strong>完整性</strong>和<strong>安全性</strong></li><li>避免重复加载</li></ol><h2 id="含义">含义</h2><ul><li>一个类加载器接收到加载类的任务时，会自底向上查找是否加载过，再自顶向下加载。自顶向下依次是启动类加载器，扩展类加载器，应用程序类加载器。<ul><li>先自底向上查找一个类是否被加载过<ul><li>如果已经加载过，则这个类的加载任务就结束了</li><li>如果没有加载过，则会自顶向下逐个加载</li></ul></li><li>双亲委派机制就是向上查找和向下加载的过程<ul><li>比如一个定义的类A，先由应用程序类加载器查找，没有加载过则再由扩展类加载器查找，没有加载过则再由启动类加载器进行查找，如果启动类加载器加载过了，则加载过程结束</li><li>比如一个类B，没有被三个类加载器加载，则由启动类加载器加载，查看加载路径，发现不在启动类加载器的加载路径中，则会由扩展类加载器尝试加载，判断路径</li></ul></li><li>所以向上查找的过程避免了重复加载，向下加载的过程起到了加载优先级的作用</li></ul></li></ul><div class="note info flat"><ol><li>如果一个类重复出现在三个类加载器的加载位置处，则由谁来加载？<ul><li>根据双亲委派机制，应该是由启动类加载器加载的，因为他的优先级是最高的</li></ul></li><li><code>String</code>类能否被覆盖，如果自定义了一个<code>java.lang.String</code>类，那么这个类是否会被加载<ul><li>启动类加载器在向上查找阶段已经会发现<code>rt.jar</code>包中的<code>String</code>类已经加载过了，所以不会加载自定义的<code>String</code>类，会返回已经加载过的<code>String</code>类</li></ul></li><li>如何使用代码主动加载一个类(两种方法)<ul><li>使用<code>Class.forName()</code>，使用当前类的类加载器去加载指定的类</li><li>通过<code>getClassLoader()</code>获取到类加载器，通过类加载器的<code>loadClass()</code>方法指定某个类加载器的加载，这种方式更加明确一些，比如:  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取main方法所在类的类加载器，应用程序类加载器</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> D.class.getClassLoader();</span><br><span class="line">System.out.println(cl);</span><br><span class="line"><span class="comment">// 使用应用程序类加载器加载指定的类</span></span><br><span class="line">Class&lt;?&gt; clazz = cl.loadClass(<span class="string">&quot;类名&quot;</span>);</span><br><span class="line">System.out.println(clazz.getClassLoader());</span><br></pre></td></tr></table></figure></li></ul></li></ol><ul><li>每一个类加载器都有一个父类加载器，在代码中都是<code>parent</code>，类型是<code>ClassLoader</code>，比如应用程序类加载器的<code>parent=扩展类加载器</code>，但是扩展类加载器的<code>parent=null</code>，这是因为启动类加载器是无法获得的，所以是<code>null</code><ul><li><code>Arthas</code>使用<code>classloader -t</code>查看父子关系</li></ul></li></ul><ol start="4"><li>如果一个类无法被三个类加载器加载呢？<ul><li>会报<strong>类无法找到</strong>的错误</li></ul></li></ol></div><h2 id="总结-类的双亲委派机制是什么">总结-类的双亲委派机制是什么</h2><ol><li>类加载器加载某个类的时候，会自底向上向父类查找是否加载过，如果加载过就直接返回，如果一直到最顶层的类加载器都没有加载，再由自顶向下进行加载</li><li>应用程序类加载器的父类加载器是扩展类加载器，扩展类加载器的父类加载器是启动类加载器</li><li>双亲委派机制的好处有两点:<ul><li>避免恶意代码替换<code>JDK</code>中核心类库，比如<code>java.lang.String</code>，确保安全性，完整性</li><li>避免重复加载类</li></ul></li></ol><h2 id="打破双亲委派机制">打破双亲委派机制</h2><ol><li>自定义类加载器</li><li>线程上下文类加载器</li><li><code>Osgi</code>框架的类加载器</li></ol><h3 id="场景">场景</h3><ul><li>有两个<code>Web</code>应用，都具有一个名为<code>MyServlet</code>的类，只有名字相同，内容不同。<code>Tomcat</code>想去加载这两个类，这两个类都位于<code>classpath</code>上，应用1的类可以正常加载，但是应用2的类，<code>Tomcat</code>无法加载，因为这个时候<code>MyServlet</code>类已经存在了。这样只能加载一个类</li><li>实际上<code>Tomcat</code>对每个应用都有一个类加载器，这样就不会走双亲委派机制。应用1和应用2都加载自己的类，因此实现了使用自定义类加载器打破双亲委派机制，实现应用类的隔离</li></ul><h3 id="自定义类加载器">自定义类加载器</h3><ul><li><code>ClassLoader</code>中包含了四个核心方法，双亲委派机制的核心代码在<code>loadClass</code>方法中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) </span><br><span class="line"><span class="comment">// 类加载的入口，提供了双亲委派机制，内部会调用findClass</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) </span><br><span class="line"><span class="comment">// 抽象类，加载字节码二进制信息的核心方法，由类加载器子类实现，获取二进制数据调用defineClass</span></span><br><span class="line"><span class="comment">// 比如URLClassLoader会根据文件路径获取类文件中的二进制数据</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass (String name, <span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len) </span><br><span class="line"><span class="comment">// 调用了虚拟机底层的方法，做一些类名的校验，将字节码信息加载到虚拟机内存当中</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">resolveClass</span><span class="params">(Class&lt;?&gt; c)</span> </span><br><span class="line"><span class="comment">// 执行类生命周期的连接阶段</span></span><br></pre></td></tr></table></figure><ul><li>双亲委派机制</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parent == null 说明父类加载器是启动类加载器，直接调用findBootstrapClassOrNull</span></span><br><span class="line"><span class="comment">// 否则调用父类加载器的加载方法</span></span><br><span class="line"><span class="keyword">if</span> (parent != <span class="literal">null</span>)&#123;</span><br><span class="line">    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    c = findBootstrapClassOrNull(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父类加载器不行的话，就自己加载</span></span><br><span class="line"><span class="keyword">if</span> (c == <span class="literal">null</span>) c = findClass(name);</span><br></pre></td></tr></table></figure><ul><li>自定义的类加载器，如果不手动指定父类加载器，则默认指向应用程序类加载器</li><li>两个自定义类加载器，加载相同的限定名的类，是否会冲突？<ul><li>不会冲突，只有<strong>相同的类加载器+相同的类限定名</strong>才会被认为是同一个类，在<code>Arthas</code>中使用<code>sc -d 类名</code>可以查看具体情况</li></ul></li><li>为了实现多种不同的渠道加载字节码的方式，不应该打破双亲委派机制，应该重写<code>findClass</code>方法</li></ul><h3 id="线程上下文类加载器">线程上下文类加载器</h3><blockquote><p>以<code>JDBC</code>为例，使用了<code>DriverManager</code>来管理项目中引入的不同数据库的驱动，比如<code>MySQL</code>驱动，或者<code>Oracle</code>驱动</p></blockquote><ul><li><code>DriverManager</code>类位于<code>rt.jar</code>中，所以由<strong>启动类加载器加载</strong></li><li>但是不同数据库的驱动是在用户的<code>jar</code>包中，由<strong>应用程序类加载器加载</strong>，因此违反了双亲委派机制</li><li>所以在初始化<code>DriverManager</code>时，通过<code>SPI</code>机制加载<code>jar</code>包中的<code>MySQL</code>驱动</li><li><code>SPI</code>利用了线程上下文类加载器(应用程序类加载器)加载类并创建对象<br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Java/spi.png" alt="spi"></li></ul><h2 id="DriverManager如何知道驱动类已经引入"><code>DriverManager</code>如何知道驱动类已经引入</h2><blockquote><p><code>SPI(Service Provider Interface)</code>机制，是<code>JDK</code>内置的服务提供发现机制，类似于<code>Spring</code>的依赖注入</p></blockquote><h3 id="SPI原理"><code>SPI</code>原理</h3><ol><li>在<code>ClassPath</code>路径下的<code>META-INF/services</code>目录中，以接口的全限定名来命名文件，对应的文件里面写了接口的实现</li><li>使用<code>ServiceLoader</code>类加载实现类,<code>ServiceLoader&lt;Driver&gt; lD = ServiceLoader.load(Driver.class);</code>获取<code>Driver</code>对象</li></ol><h3 id="SPI如何获取应用程序类加载器"><code>SPI</code>如何获取应用程序类加载器</h3><blockquote><p>使用了线程上下文中保存的类加载器进行类的加载，一般是应用程序类加载器</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; ServiceLoader&lt;S&gt; <span class="title function_">load</span><span class="params">(Class&lt;S&gt; service)</span>&#123;</span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();  </span><br><span class="line">    <span class="keyword">return</span> ServiceLoader.load(service, cl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li><p>在《深入理解Java虚拟机》一书中认为<code>JDBC</code>打破了双亲委派机制，因为由启动类加载器加载的类，委派应用程序类加载器去加载类的方式打破了双亲委派机制。</p></li><li><p>也有一种说法，认为<code>JDBC</code>没有打破双亲委派机制，因为单独的启动类加载器在<code>DriverManager</code>加载完了之后，通过<strong>初始化阶段</strong>触发了驱动类的加载，依然遵循的是双亲委派机制。因为驱动类加载器自底向上查找后，再自顶向下进行判断，发现启动类加载器和扩展类加载器都无法加载，所以由应用程序类加载器进行加载，这个过程也没有打破双亲委派机制。这两个类加载器都没有重写<code>loadClass</code>方法，打破双亲委派机制的唯一方法就是重写<code>loadClass</code>方法</p></li></ul></blockquote><h3 id="OSGI模块化"><code>OSGI</code>模块化</h3><blockquote><p><code>JDK9</code>之后有另一种模块化方法，因此不再使用了。<code>OSGI</code>也使用了类加载器实现了热部署的功能，即在服务不停止的情况下，动态更新字节码文件到内存中。现在可以使用<code>Arthas</code>实现热部署，本质上还是类加载器</p></blockquote><ul><li><code>Arthas</code>不停机解决线上问题</li></ul><ol><li>出问题服务器上部署一个<code>Arthas</code></li><li><code>jad --source-only &lt;类全限定名&gt; &gt; &lt;dir/文件名.java&gt;</code>： <code>jad</code>命令反编译，用其他编译器，比如<code>vim</code>来修改源代码</li><li><code>mc -c &lt;类加载器的hash&gt; &lt;dir/文件名.java&gt; -d &lt;输出目录&gt;</code>： <code>mc</code>命令用来编译修改过的代码<ul><li>这里的类加载器的<code>hash</code>可以使用<code>sc -d &lt;对应的类名&gt;</code>来查看</li></ul></li><li><code>retransform class</code>文件所在的&lt;目录/xxx.class&gt;：用<code>retransform</code>命令加载新的字节码</li></ol><div class="note info flat"><p>注意事项:</p><ol><li>如果程序重启，则字节码文件会恢复，因为只是通过<code>retransform</code>这个命令将字节码文件放在了内存中。因此要将字节码文件放在<code>jar</code>包中进行更新</li><li>使用<code>retransform</code>不能添加方法或者字段，也不能更新正在执行中的方法</li></ol></div><h1><code>JDK9</code>之后</h1><blockquote><p>引入了<code>module</code>概念</p></blockquote><ol><li>启动类加载器由<code>Java</code>编写了，不再由<code>CPP</code>编写，位于<code>jdk.internal.loader.ClassLoaders</code>类中。<ul><li><code>Java</code>中的<code>BootClassLoader</code>继承自<code>BuiltinClassLoader</code>实现从模块中找到要加载的字节码资源文件</li><li>但是启动类加载器依然无法通过<code>Java</code>代码获取，这是为了保证统一，所以返回的内容依然是<code>null</code></li><li><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Java/891.png" alt="891"></li></ul></li><li>扩展类加载器被替换成了平台类加载器(<code>Platform ClassLoader</code>)<ul><li>平台类加载器遵循模块化方式加载字节码文件，所以继承关系从<code>URLClassLoader</code>变成了<code>BuiltinClassLoader</code>，实现了从模块中加载字节码文件</li><li>平台类加载器的存在更多是为了与老版本兼容，自身没啥特殊的逻辑。如果使用了模块化的思想，平台类加载器基本上就不需要了</li><li><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Java/892.png" alt="892"></li></ul></li></ol><h1>总结</h1><ol><li>类加载器的作用<ul><li>类加载器(<code>CLassLoader</code>)负责在类加载的过程中的字节码获取并加载到内存，通过加载字节码数据放入内存转换成<code>byte[]</code>，接下来调用虚拟机底层方法将<code>byte[]</code>转换成方法区和堆中的数据</li></ul></li><li>有几种类加载器<ul><li>启动类加载器<code>Bootstrap</code> 加载核心类</li><li>扩展类加载器<code>Extension</code> 加载扩展类</li><li>应用程序类加载器<code>Application</code> 加载应用<code>classpath</code>中的类</li><li>自定义类加载器，重写<code>findClass</code>方法</li><li><code>JDK9</code>之后从扩展类加载器变成了平台类加载器<br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Java/cl.png" alt="cl"></li></ul></li><li>什么是双亲委派机制<ul><li>每个<code>Java</code>实现的类加载器中保存了一个成员变量叫做父 类加载器，自底向上查找是否加载过，再自顶向下加载，避免核心类被应用程序重写覆盖的问题，提升安全性</li></ul></li><li>如何打破双亲委派机制<ul><li>重写<code>loadClass</code>方法</li><li><code>JNDI, JDBC, JCE, JBI</code>等框架使用了<code>SPI</code> + 线程上下文类加载器</li><li><code>OSGI</code>实现了一整套类加载逻辑，允许同级类加载器之间互相调用</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;类加载器&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;类加载器(&lt;code&gt;ClassLoader&lt;/code&gt;)是&lt;code&gt;JVM&lt;/code&gt;给应用程序实现类和接口字节码数据的技术&lt;/li&gt;
&lt;li&gt;本地接口&lt;code&gt;JNI&lt;/code&gt;允许&lt;code&gt;Java&lt;/code&gt;调用</summary>
      
    
    
    
    <category term="Java" scheme="https://sangs3112.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://sangs3112.github.io/tags/Java/"/>
    
    <category term="类加载器" scheme="https://sangs3112.github.io/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    
    <category term="双亲委派机制" scheme="https://sangs3112.github.io/tags/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Java笔记_0</title>
    <link href="https://sangs3112.github.io/posts/64c91c06.html"/>
    <id>https://sangs3112.github.io/posts/64c91c06.html</id>
    <published>2024-04-18T06:37:35.000Z</published>
    <updated>2024-12-11T04:42:14.727Z</updated>
    
    <content type="html"><![CDATA[<h1>面向对象的特性</h1><h2 id="封装">封装</h2><ul><li>将数据和行为组合在一个包中，并对使用者隐藏具体的实现细节</li><li>关键在于不能让别的类调用到当前类的实例字段</li></ul><h2 id="继承">继承</h2><ul><li>实现了<code>IS-A</code>的关系，子类可以获得父类<strong>非</strong><code>private</code>的属性和方法</li><li>应该要遵循里氏替换原则</li></ul><div class="note info flat"><ul><li>里氏替换原则：子类必须能够替换掉所有的父类对象，父类引用指向子类对象称为<strong>向上转型</strong></li></ul></div><h3 id="举例">举例</h3><ul><li><code>Cat</code>和<code>Animal</code>就是一种<code>IS-A</code>关系，所以<code>Cat</code>可以继承<code>Animal</code>，并且获得<code>Animal</code>的所有非<code>private</code>的属性和方法</li><li><code>Cat</code>可以当做<code>Animal</code>使用，所以<code>Animal</code>可以引用<code>Cat</code>对象：<code>Animal a = new Cat()</code>，这就是向上转型</li></ul><div class="note info flat"><p>类常见的关系</p><ul><li>依赖 <code>USES-A</code>: 只要一个类需要使用或操作另一个类，就说明前者依赖后者。需要尽可能减少相互依赖的类, (减少耦合)</li><li>聚合 <code>HAS-A</code>: 类A的对象包含类B的对象</li><li>继承 <code>IS-A</code></li></ul></div><h2 id="多态">多态</h2><ul><li>分为编译时多态和运行时多态</li></ul><div class="note info flat"><ul><li>编译时多态：指方法的<strong>重载</strong></li><li>运行时多态：指对象引用的具体类型在运行期间才能确定<ul><li>运行时多态具有三个条件：继承、覆盖(重写)、向上转型</li></ul></li><li>重载指的是多个方法具有相同的方法名，以及不同的参数(或者参数顺序)。编译器查找匹配更适合的方法的过程是重载解析</li><li>所以如果需要完整的描述一个方法，则需要他们的方法名，参数类型，称为方法的签名</li><li>返回类型不是签名的一部分，所以重载不允许存在(方法名相同，参数类型相同，返回值不同的多个函数)</li></ul></div><h1>JVM</h1><h2 id="功能">功能</h2><ol><li>解释运行：<code>javac</code>编译源代码，得到<code>class</code>字节码，<code>JVM</code>将其<strong>实时</strong>解释成机器码，让计算机执行，这是为了实现跨平台</li><li>内存管理：自动为对象方法分配内存，自动垃圾回收不再使用的对象</li><li>即时编译<code>JIT</code>：对热点代码进行优化，提升执行效率</li></ol><h2 id="组成">组成</h2><ol><li>类加载器</li><li>运行时数据区域(<code>JVM</code>管理的内存)</li><li>执行引擎(即编译器，解释器，垃圾回收等)</li><li>本地接口</li></ol><h1>字节码文件</h1><ul><li><code>jclasslib</code>可以打开字节码文件<code>.class</code></li><li><code>javap -v 路径名/类名.class &gt; 输出文件</code>命令同样可以反编译<code>.class</code>文件，并输出到指定文件中</li><li><code>jar -xvf</code>可以解压<code>jar</code>包</li><li><code>Arthas</code>可以使用<code>java -jar arthas-boot.jar</code>命令启动<ul><li><code>dashbord -i &lt;time (ms)&gt; -n &lt;num&gt;</code> 可以查看服务器各项指标，<code>-i</code>后面指定刷新的时间(<code>ms</code>)，<code>-n</code>后面指定刷新的次数</li><li><code>dump -d &lt;dir&gt; 包名.类名</code> 可以将指定类名的字节码文件导出到指定的<code>dir</code>中</li><li><code>jad 包名.类名</code> 可以将字节码反编译成源代码，然后可以确定代码是否可以满足要求。比如可以确定版本</li></ul></li></ul><h2 id="组成-2">组成</h2><ol><li><strong>基本信息</strong>：魔数，版本号，访问标识(<code>public final</code>)，父类和接口</li><li><strong>常量池</strong>：字符串常量，类或接口名、字段名，主要在字节码指令中使用</li><li><strong>字段</strong>：类或者接口声明的字段信息</li><li><strong>方法</strong>：类或者接口声明的方法信息</li><li><strong>属性</strong>：类的属性，比如源码的文件名，内部类的列表</li></ol><div class="note info flat"><ul><li>字节码文件，文件头是<code>0xCAFEBABE</code>，这个就是魔数</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>主版本号</mtext><mo>−</mo><mn>44</mn></mrow><annotation encoding="application/x-tex">主版本号 - 44</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord cjk_fallback">主版本号</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">44</span></span></span></span> 就是1.2版本之后的大版本计算方法，比如52是JDK8，主版本号为61则是JDK17</li><li>常量池作用：避免相同的内容重复定义，节省空间<ul><li>符号引用：字节码指令通过编号引用到常量池的过程</li></ul></li><li>方法：<ul><li><code>iconst_&lt;i&gt;</code> 就是将<code>i</code>放在操作数栈中</li><li><code>istore_&lt;i&gt;</code> 将操作数栈中的数字放到局部变量表的<code>i</code>号位置</li><li><code>iload_&lt;i&gt;</code> 将局部变量表中的数据<strong>复制</strong>一份放到操作数栈中</li><li><code>iadd</code> 将操作数栈顶的两个数字相加，只保留一个数据</li><li><code>iinc &lt;i&gt; by &lt;j&gt;</code> 将局部变量表中的<code>i</code>号位置的元素加<code>j</code>，直接在局部变量表上操作</li><li>局部变量数组表就是一个数组，存放所有的局部变量，并且位置<code>0</code>是<code>args</code>参数</li></ul></li></ul></div><h2 id="i-i-1-VS-i-VS-i-1-VS-i"><code>i = i + 1</code> VS <code>i ++</code> VS <code>i += 1</code> VS <code>++ i</code></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">iconst_0</span><br><span class="line">istore_1</span><br><span class="line">iconst_0</span><br><span class="line">istore_2</span><br><span class="line">iconst_0</span><br><span class="line">istore_3</span><br><span class="line">iconst_0</span><br><span class="line">istore 4</span><br><span class="line">iinc 1 by 1</span><br><span class="line">iinc 2 by 1</span><br><span class="line">iinc 3 by 1</span><br><span class="line">iload 4</span><br><span class="line">iconst_1</span><br><span class="line">iadd</span><br><span class="line">istore 4</span><br><span class="line">return</span><br></pre></td></tr></table></figure><ul><li>除了<code>i = i + 1</code>以外，都只需要一条指令<code>iinc 1 by 1</code>，即可完成自增操作</li><li><code>i = i + 1</code>需要四条指令才能完成，即<code>12~15</code></li></ul><h1>类的生命周期</h1><ol><li>加载</li><li>连接<ol><li>验证</li><li>准备</li><li>解析</li></ol></li><li>初始化</li><li>使用 (<code>new</code>)</li><li>卸载 (<code>GC</code>)</li></ol><h2 id="加载">加载</h2><ol><li><strong>类加载器</strong>根据<strong>类的全限定名</strong>通过不同的渠道以<strong>二进制流</strong>的方式获取字节码信息</li><li>类加载器加载完类以后，会将字节码信息保存到内存的<strong>方法区</strong>中</li><li>生成一个<code>InstanceKlass</code>对象，保存所有类的信息，包含特定功能比如多态的信息(虚方法表)</li><li>在<strong>堆区</strong>中生成一份与方法区数据类似的<code>java.lang.Class</code>对象，为了在Java代码中获取类的信息以及存储静态字段的数据(JDK8之后放在堆区)</li></ol><div class="note info flat"><p>为什么需要分别在<strong>方法区</strong>和<strong>堆区</strong>中同时保留两份代码？</p><ul><li>方法区中的<code>InstanceKlass</code>对象是用<code>cpp</code>编写的，<code>Java</code>不能直接操作，所以要在堆区放一个<code>Java</code>编写的<code>java.lang.Class</code></li><li>堆区的字段少于方法区的字段，因为方法区中有<strong>虚方法表</strong>，开发者不需要用，因此开辟了一块堆区，只包含了方法的内容，开发者只能访问堆区，提升安全性</li></ul></div><ul><li><code>JDK</code>自带<code>hsdb</code>工具可以查看<code>JVM</code>的内存信息，<code>hsdb</code>位于安装目录下的<code>lib/sa-jdi.jar</code>中</li><li><code>java -cp sa-jdi.jar sun.jvm.hotspot.HSDB</code>用于启动<code>hsdb</code>工具，启动后需要输入进程号，可以通过<code>jps</code>命令查找</li></ul><h2 id="连接">连接</h2><h3 id="验证">验证</h3><ol><li>验证内容是否满足<code>JVM</code>规范，比如文件头是否满足<code>CAFEBABE</code>，主次版本号是否满足要求</li><li>验证元信息，比如类必须要有父类，<code>super</code>不能为空</li><li>验证程序语义是否正确，不能跳转到不正确的位置</li><li>符号引用验证，比如是否访问了其他类中的<code>private</code>方法</li></ol><div class="note info flat"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查版本号是否满足要求</span></span><br><span class="line"><span class="comment">// 检查版本号的具体逻辑：</span></span><br><span class="line">    <span class="comment">// 主版本号不能高于运行环境主版本号;</span></span><br><span class="line">    <span class="comment">// 如果主版本号相同，那么副版本号也不能超过</span></span><br><span class="line"><span class="keyword">return</span> (major &gt;= JAVA_MIN_SUPPORTED_VERSION) </span><br><span class="line">    &amp;&amp; (major &lt;= max_version) </span><br><span class="line">    &amp;&amp; ((major != max_version) || (minor &lt;= JAVA_MAX_SUPPORTED_MINOR_VERSION));</span><br><span class="line"><span class="comment">// major 主版本号</span></span><br><span class="line"><span class="comment">// minor 副版本号</span></span><br><span class="line"><span class="comment">// JAVA_MIN_SUPPORTED_VERSION 支持的最低版本号，jdk8是45 表示jdk1.0</span></span><br><span class="line"><span class="comment">// max_version 支持的最高版本号，jdk8是52</span></span><br><span class="line"><span class="comment">// JAVA_MAX_SUPPORTED_MINOR_VERSION 支持的最高副版本号，jdk8未使用，为0</span></span><br></pre></td></tr></table></figure></div><h3 id="准备">准备</h3><ul><li>给<strong>静态变量</strong>分配内存和设置<strong>初始值</strong></li></ul><div class="note info flat"><ul><li>设置初始值是所有的变量都赋值为<code>0</code>，或者<code>null</code>，或者<code>'\u0000'</code></li><li>只有用<code>final</code>修饰的变量，会将其直接赋值为定义的值，因为<code>final</code>的值不会修改了</li></ul></div><h3 id="解析">解析</h3><ul><li>将符号引用替换为直接引用，<strong>就是使用地址替换编号</strong></li></ul><h2 id="初始化">初始化</h2><ul><li><code>public static int v = 1;</code>这句代码在<strong>连接准备</strong>阶段会将<code>v = 0</code>，然后在<strong>初始化</strong>阶段会<code>v = 1</code></li><li>初始化阶段就是执行<strong>静态代码块</strong>中的代码，为<strong>静态变量</strong>赋值，执行字节码文件中<code>clinit</code>部分的字节码指令</li><li><code>putstatic</code> 从操作数栈中获取值，设置<strong>静态变量</strong></li><li><code>clinit</code>方法执行顺序跟<code>Java</code>中的编写顺序一样</li><li>使用<code>-XX:+TraceClassLoading</code>参数可以打印出加载并初始化的类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">D</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        v = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这段代码最终的v=1，因为v是static变量，所以在连接准备阶段v=0</span></span><br><span class="line"><span class="comment">// 经过初始化阶段，v首先经过静态代码块，v=2</span></span><br><span class="line"><span class="comment">// 然后v经过静态设置，v=1</span></span><br></pre></td></tr></table></figure><div class="note info flat"><p><strong>触发</strong>初始化：</p><ol><li>访问一个类的<strong>静态变量</strong>或者<strong>静态方法</strong>，如果变量是<code>final</code>修饰的并且等号右边是<strong>常量</strong>，则不会触发初始化(在准备阶段就已经完成赋值了)</li><li>调用<code>Class.forName(String className)</code>，如果只传入类名，那么会<strong>默认</strong>进行初始化，也可以传入参数指定不初始化</li><li><code>new</code>一个类的对象</li><li>执行<code>main</code>方法的<strong>当前类</strong></li></ol></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Test1</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Test1</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;D&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出DACBCB </span></span><br><span class="line"><span class="comment">// main方法执行之前，首先会执行static静态代码块，因此输出D</span></span><br><span class="line"><span class="comment">// 然后执行main函数，输出A</span></span><br><span class="line"><span class="comment">// 接下来调用构造方法，但是字节码中构造代码块比构造函数先执行，所以输出CB</span></span><br><span class="line"><span class="comment">// 调用了两次构造方法，因此输出CBCB</span></span><br></pre></td></tr></table></figure><div class="note info flat"><p><strong>不触发</strong>初始化：</p><ol><li><strong>没有</strong>静态代码块，并且<strong>没有</strong>静态变量赋值语句</li><li><strong>有</strong>静态变量声明，但是<strong>没有</strong>赋值语句</li><li>静态变量使用<code>final</code>关键字，等号右边是常量，会在<strong>准备阶段</strong>直接进行赋值，则不会有初始化</li></ol></div><ul><li>直接访问父类的静态变量，<strong>不会</strong>触发子类的初始化</li><li>子类的初始化<code>clinit</code>调用之前，会先调用父类的<code>clinit</code>初始化方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">B</span>(); <span class="comment">// 如果有这个new B()，则会初始化B，就会优先初始化父类，</span></span><br><span class="line">        <span class="comment">// 如果没有new B()，则直接调访问父类的静态变量。</span></span><br><span class="line">        System.out.println(B.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        a = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果有new B(), 输出2</span></span><br><span class="line"><span class="comment">// 如果没有new B(), 输出0</span></span><br></pre></td></tr></table></figure><div class="note info flat"><ul><li>访问父类的静态变量不需要初始化子类，初始化子类之前一定会初始化父类</li></ul></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        A[] arr = <span class="keyword">new</span> <span class="title class_">A</span>[<span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AAA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出空</span></span><br><span class="line"><span class="comment">// 数组的创建不会导致数组元素中的类初始化</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(A.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Integer.valueOf(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AAA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AAA 1</span></span><br><span class="line"><span class="comment">// final修饰的变量，如果等号右边需要执行指令才能得出结果，则会执行clinit初始化</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;面向对象的特性&lt;/h1&gt;
&lt;h2 id=&quot;封装&quot;&gt;封装&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;将数据和行为组合在一个包中，并对使用者隐藏具体的实现细节&lt;/li&gt;
&lt;li&gt;关键在于不能让别的类调用到当前类的实例字段&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;继承&quot;&gt;继承&lt;/h2&gt;
&lt;ul</summary>
      
    
    
    
    <category term="Java" scheme="https://sangs3112.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://sangs3112.github.io/tags/Java/"/>
    
    <category term="面向对象的特性" scheme="https://sangs3112.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E6%80%A7/"/>
    
    <category term="JVM" scheme="https://sangs3112.github.io/tags/JVM/"/>
    
    <category term="类的生命周期" scheme="https://sangs3112.github.io/tags/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes笔记_0</title>
    <link href="https://sangs3112.github.io/posts/64a0ba43.html"/>
    <id>https://sangs3112.github.io/posts/64a0ba43.html</id>
    <published>2024-04-05T12:25:31.000Z</published>
    <updated>2024-12-11T04:42:14.727Z</updated>
    
    <content type="html"><![CDATA[<h1>架构</h1><p>一个<code>Kubernetes</code>集群至少包含一个控制平面，以及一个或多个工作节点</p><h2 id="控制平面">控制平面</h2><p><img src="https://gitee.com/sang3112/blog_imgs/raw/a76c53b22b402ccf7186b9efa53546500f90932e/Kubernetes/controlplane.png" alt="controlplane"></p><ul><li>负责管理工作节点和维护集群状态，所有任务的分配都来自控制平面</li><li>为集群做出去全局决策，比如资源的调度、检测和响应集群事件</li></ul><h3 id="kube-apiserver"><code>kube-apiserver</code></h3><ul><li>如果与<code>Kubernetes</code>集群进行交互，需要通过API</li><li><code>apiserver</code>是<code>Kubernetes</code>控制平面的前端，用于处理内部和外部请求</li></ul><h3 id="kube-scheduler"><code>kube-scheduler</code></h3><ul><li>集群状态是否良好，如果需要创建新的容器，需要将他们放在哪里，由调度程序关注</li><li><code>scheduler</code>调度程序考虑容器集的资源需求，比如<code>CPU</code>或者内存，以及集群的运行状态，然后将容器集安排到适当的计算节点</li></ul><h3 id="kube-controller-manager"><code>kube-controller-manager</code></h3><ul><li>控制器负责实际运行集群，<code>controller-manager</code>控制器管理器将多个控制器功能合并，降低了程序的复杂性</li></ul><div class="note info flat"><p><code>controller-manager</code>包含以下控制器:</p><ol><li>节点控制器(<code>Node Controller</code>): 负责在节点出现故障时进行通知和响应</li><li>任务控制器(<code>Job Controller</code>): 检测代表一次性任务的<code>Job</code>对象，然后创建<code>Pods</code>来运行这些任务直到完成</li><li>端点控制器(<code>Endpoints Controller</code>): 填充端点<code>Endpoints</code>对象，即加入<code>Service</code>和<code>Pod</code></li><li>服务账户和令牌控制器(<code>Service Account &amp; Token Controllers</code>): 为新的命名空间创建默认账户和<code>API</code>访问令牌</li></ol></div><h3 id="etcd"><code>etcd</code></h3><ul><li>键值对数据库，存储配置数据和集群状态信息</li></ul><h3 id="可选组件cloud-controller-manager">可选组件<code>cloud-controller-manager</code></h3><ul><li>云控制管理器，允许将集群了解到云提供商的<code>API</code>之上，将该云平台交互的组件与自己的集群交互组件分离开。如果在自己的环境中运行<code>Kubernetes</code>或者在本地计算机中运行学习环境，则所部署的集群不需要有云控制管理器</li></ul><h3 id="各组件之间的关系">各组件之间的关系</h3><p><img src="https://gitee.com/sang3112/blog_imgs/raw/a76c53b22b402ccf7186b9efa53546500f90932e/Kubernetes/relationship.png" alt="relationship"></p><h2 id="工作节点">工作节点</h2><ul><li>负责执行由控制平面分配的请求任务，运行实际的应用和工作负载</li></ul><h3 id="Node组件"><code>Node</code>组件</h3><p><img src="https://gitee.com/sang3112/blog_imgs/raw/a76c53b22b402ccf7186b9efa53546500f90932e/Kubernetes/node.png" alt="node"></p><ul><li>节点组件会在每个工作节点上运行，负责维护运行的<code>Pod</code>并提供<code>Kubernetes</code>运行环境</li></ul><h1><code>Pod</code></h1><ul><li><code>Pod</code>是包含一个或者多个容器的容器组，是<code>Kubernetes</code>中创建和管理的最小对象</li></ul><h2 id="特点">特点</h2><ol><li>是<code>Kubernetes</code>的最小调度单位(原子单元)，<code>Kubernetes</code>直接管理<code>Pod</code>而不是容器</li><li>同一个<code>Pod</code>中的容器总是会被自动安排到集群中的同一个节点(物理机或者虚拟机上)，并且<strong>一起调度</strong></li><li><code>Pod</code>可以理解为运行特定应用的<strong>逻辑主机</strong>，容器共享存储、网络和配置声明(比如资源限制)</li><li>每个<code>Pod</code>有唯一的<code>IP</code>地址，<code>IP</code>地址分配给<code>Pod</code>，在同一个<code>Pod</code>内，所有容器共享一个<code>IP</code>地址和端口空间，<code>Pod</code>内的容器可以使用<code>localhost</code>相互通信</li></ol><h2 id="创建和管理">创建和管理</h2><ol><li>创建<code>Pod</code>: <code>kubectl run &lt;Pod名称&gt; --imgae=&lt;容器镜像&gt;</code><ul><li>执行一次性任务，退出<code>Pod</code>时自动删除容器: <code>kubectl run &lt;Pod名称&gt; --image=&lt;容器镜像&gt; -it --rm</code></li></ul></li><li>查看容器状态: <code>kubectl get pod</code><ul><li>显示详细<code>Pod</code>信息: <code>kubectl get pod -owide</code></li></ul></li><li>查看<code>Pod</code>运行日志: <code>kubectl logs -f &lt;Pod名称&gt;</code></li><li>查看<code>Pod</code>的一些信息: <code>kubesctl describe pod &lt;Pod名称&gt;</code><ul><li>创建分为四个步骤<ol><li>分配节点 <code>Successfully assigned default/Pod名称 to k8s-worker2</code></li><li>拉取镜像 <code>Container image &quot;容器镜像&quot; already present on machine</code></li><li>创建容器 <code>Created container Pod名称</code></li><li>启动容器 <code>Started container Pod名称</code></li></ol></li></ul></li><li>进入<code>Pod</code>容器: <code>kubectl exec -it Pod名称 -- /bin/bash</code></li><li>删除容器: <code>kubectl delete pod Pod名称</code></li></ol><h1><code>Deployment</code>部署和<code>ReplicaSet</code>副本集</h1><ul><li><code>Deployment</code>是对<code>ReplicaSet</code>和<code>Pod</code>的更高级别的抽象，使<code>Pod</code>拥有多副本，自愈，扩缩容，滚动升级等能力</li><li><code>ReplicaSet</code>副本集是一个<code>Pod</code>的集合，设置运行<code>Pod</code>的数量，确保任何时间都有指定数量的<code>Pod</code>副本在运行。</li></ul><div class="note info flat"><ul><li>通常，我们不直接使用<code>ReplicaSet</code>，而是在<code>Deployment</code>中声明</li></ul></div><ul><li>创建<code>Deployment</code>: <code>kubectl create deployment &lt;部署名称&gt; --imgae=&lt;镜像名称&gt; --replicas=&lt;副本数量&gt;</code><ul><li><code>Deployment</code>通过副本集控制<code>Pod</code>的数量</li><li>如果手动删除一个<code>Pod</code>，副本集会自动生成一个新的<code>Pod</code>，维持副本数量不变。这就是自愈</li></ul></li><li>查看<code>Deployment</code>状态: <code>kubectl get deploy</code></li></ul><h2 id="缩放">缩放</h2><ul><li>查看副本集: <code>kubectl get replicaSet</code><ul><li>查看副本集缩放过程: <code>kubectl get replicaSet --watch</code></li></ul></li></ul><h3 id="手动缩放">手动缩放</h3><ul><li>手动修改<code>Deployment</code>中的副本集数量: <code>kubectl scale deploy &lt;部署名称&gt; --replicas=&lt;新的副本数量&gt;</code></li></ul><h3 id="自动缩放">自动缩放</h3><ul><li><code>kubectl autoscale deployment/&lt;部署名称&gt; --min=&lt;最小副本数&gt; --max=&lt;最大副本数&gt; --cpu-percent=75</code><ul><li><code>--cpu-percent=75</code>是使得自动缩放保持所有的<code>Pod</code>的平均cpu占用维持在75%以下</li></ul></li><li>查看自动缩放: <code>kubectl get hpa</code></li><li>删除自动缩放: <code>kubectl delete hpa &lt;部署名称&gt;</code></li></ul><h2 id="滚动更新">滚动更新</h2><ul><li>滚动更新部署版本: <code>kubectl set image deploy/部署名称 容器名=镜像版本</code></li><li>如果一个<code>Deployment</code>中有三个<code>Pod</code>，运行滚动更新命令时，会创建一个新的副本集。<ul><li>当新的副本集有一个<code>Pod</code>就绪了，就会下线旧副本集中的一个<code>Pod</code>，直到旧副本集中所有的<code>Pod</code>均下线</li></ul></li><li>版本回滚:<ul><li>查看历史版本: <code>kubectl rollout history deploy/部署名称</code></li><li>查看历史版本详情: <code>kubectl rollout history deploy/部署名称 --revision=版本号</code></li><li>回滚到指定的版本: <code>kubectl rollout  undo deploy/部署名称 --to-revision=版本号</code></li></ul></li></ul><h1>Service</h1><ul><li>将一组<code>Pods</code>上的应用程序公开为网路服务的抽象方法</li><li>将一组<code>Pod</code>提供相同的<code>DNS</code>名，并进行负载均衡</li><li><code>Kubernetes</code>为<code>Pod</code>提供分配了<code>IP</code>地址，但是<code>IP</code>地址可能发生变化，集群内的容器可以通过<code>service</code>名称访问服务，不需要担心<code>Pod</code>的<code>IP</code>发生变化</li></ul><div class="note info flat"><p><code>Service</code>定义的抽象:</p><ul><li>逻辑上一组可以互相替换的<code>Pod</code>，通常称为微服务</li><li><code>Service</code>对应的<code>Pod</code>集合通过选择符关联</li><li>在一个<code>Service</code>上运行了三个<code>Nginx</code>副本，副本之间可以相互替换，我们不需要关心它调用了哪一个<code>Nginx</code>，也不需要关注<code>Pod</code>的运行装填，只需要调用这个服务就可以了</li></ul></div><ul><li>将部署公开为服务: <code>kubectl expose deploy/部署名称 --name=服务名称 --port=服务端口 --target-port=对应pod端口</code></li></ul><h2 id="ServiceType"><code>ServiceType</code></h2><h3 id="ClusterIP-默认"><code>ClusterIP</code>(默认)</h3><ul><li>将服务公开在集群内部，<code>Kubernetes</code>会给服务分配一个集群内部的<code>IP</code>，集群内的所有主机都可以通过这个<code>Cluster-IP</code>访问服务。集群内部的<code>Pod</code>可以通过<code>Service</code>名称访问服务。</li></ul><h3 id="NodePort"><code>NodePort</code></h3><ul><li>通过每个节点的主机和静态端口(<code>NodePort</code>)暴露服务，集群外部的主机可以使用节点<code>IP</code>和<code>NodePort</code>访问服务</li></ul><h3 id="ExternalName"><code>ExternalName</code></h3><ul><li>将集群外部的网络引入集群内部</li></ul><h3 id="LoadBalancer"><code>LoadBalancer</code></h3><ul><li>使用云提供商的负载均衡器向外部暴露服务</li></ul><div class="note info flat"><p>使用<code>--type=NodePort</code>即可，本地集群不需要使用<code>LoadBalancer</code></p></div><p><img src="https://gitee.com/sang3112/blog_imgs/raw/a76c53b22b402ccf7186b9efa53546500f90932e/Kubernetes/port.png" alt="port"></p><h1>命名空间</h1><ul><li>一种资源隔离机制，将同一个集群中的资源划分为互相隔离的组。命名空间可以在多个用户之间划分集群资源(通过资源配额)</li><li>比如可以设置开发、测试、生产多个命名空间</li><li>同一个命名空间内资源名称唯一，跨命名空间时没有这个要求</li><li>命名空间作用域仅仅针对带有名字空间的对象，比如<code>Deployment、Service</code>等</li><li>作用域对集群访问对象不适用，比如<code>StorageClass、Node、PersistentVolume</code>等</li><li>查看命名空间: <code>kubectl get namespace</code><ul><li><code>Kubernetes</code>默认创建四个命名空间:</li><li><code>default</code>: 默认命名空间，不可删除，没有指定命名空间的对象都会分配到这里</li><li><code>kube-system</code>: 系统对象(控制平面和<code>Node</code>组件)使用的命名空间</li><li><code>kube-public</code>: 自动创建的公共命名空间，所有用户(包括没有身份验证的用户)都可以读取，将集群中公用的可见和可读的资源放在这个空间中</li><li><code>kube-node-lease</code>: 租约(<code>Lease</code>)对象使用的命名空间。每个节点都有一个关联的<code>Lease</code>对象，<code>Lease</code>是一种轻量级的资源，通过发送心跳，检测集群中的每个节点是否发生故障<ul><li>查看<code>lease</code>对象: <code>kubectl get lease -A</code></li></ul></li></ul></li><li>查看指定命名空间的<code>Pod</code>: <code>kubectl get pod -n=命名空间名称</code></li><li>创建命名空间: <code>kubectl create ns 命名空间名称</code></li><li>运行容器指定命名空间: <code>kubectl run pod名称 --image=镜像名称 -n=命名空间名称</code></li><li>修改默认命名空间的名称(<code>default</code>): <code>kubectl config set-context $(kubectl config current-context) --namespace=新的名称</code></li><li>删除命名空间: <code>kubectl delete ns 命名空间名称</code><ul><li>删除命名空间会删除其中所有内容，如果有些对象无法被删除(对象处于错误状态，或者对象资源被占用)，则命名空间也无法被删除。需要手动删除对象以后才能删除命名空间</li></ul></li></ul><h1>管理对象</h1><h2 id="命令行指令">命令行指令</h2><ul><li>使用<code>kubectl</code>创建和管理<code>Kubernetes</code>对象。简单高效，但是功能有限，不适合复杂场景，不容易追溯操作，用于开发和调试。</li></ul><h2 id="声明式配置">声明式配置</h2><ul><li><code>Kubernetes</code>使用<code>yaml</code>文件描述<code>Kubernetes</code>对象，学习难度大并且配置麻烦，但是操作留痕，适合操作复杂的对象，多用于生产。</li><li>使用命令行指令，无法指定<code>NodePort</code>端口，是随机生成的。但是<code>yaml</code>文件中可以指定<code>NodePort</code></li></ul><h2 id="常用命令缩写">常用命令缩写</h2><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">缩写</th><th style="text-align:center">Kind</th></tr></thead><tbody><tr><td style="text-align:center">namespace</td><td style="text-align:center">ns</td><td style="text-align:center">Namespace</td></tr><tr><td style="text-align:center">nodes</td><td style="text-align:center">no</td><td style="text-align:center">Node</td></tr><tr><td style="text-align:center">pods</td><td style="text-align:center">po</td><td style="text-align:center">Pod</td></tr><tr><td style="text-align:center">services</td><td style="text-align:center">svc</td><td style="text-align:center">Service</td></tr><tr><td style="text-align:center">deployment</td><td style="text-align:center">deploy</td><td style="text-align:center">Deployment</td></tr><tr><td style="text-align:center">replicasets</td><td style="text-align:center">rs</td><td style="text-align:center">ReplicaSet</td></tr><tr><td style="text-align:center">statefulsets</td><td style="text-align:center">sts</td><td style="text-align:center">StatefulSet</td></tr></tbody></table><h2 id="使用yaml文件配置KUbernetes对象">使用<code>yaml</code>文件配置<code>KUbernetes</code>对象</h2><ul><li><code>apiVersion</code>: <code>Kubernetes API</code>版本</li><li><code>kind</code>: 对象类别，比如<code>Pod、Deployment、Service、ReplicaSet</code>等</li><li><code>metadata</code>: 描述对象的元数据，包括一个<code>name</code>字符串，<code>UID</code>(系统自动生成)和可选的<code>namespace</code></li><li><code>spec</code>: 对象的配置</li></ul><div class="note info flat"><p><code>yaml</code>内容在官网都可以找到</p></div><ul><li>使<code>yaml</code>文件生效: <code>kubectl apply -f xxx.yaml</code></li><li>删除<code>yaml</code>文件: <code>kubectl delete -f xxx.yaml</code></li></ul><h2 id="标签">标签</h2><ul><li>附加在对象<code>Pod</code>上的键值对，用于补充对象的描述信息。标签使用户可以以松散的方式管理对象映射，不需要客户端存储这些映射。</li><li>格式<ul><li>键:<ul><li>前缀(可选) / 名称(必须)</li></ul></li><li>有效的名称和值:<ul><li>字符数量小于等于63</li><li>如果不为空，以字母和数字字符开头结尾</li><li>包含破折号-，下划线_，点和字母或者数字</li></ul></li></ul></li><li>查看所有<code>Pod</code>的标签: <code>kubectl get pod --show-labels</code><ul><li>查看指定<code>Pod</code>的标签: <code>kubectl get pod -l &quot;指定的Pod描述&quot;</code></li></ul></li></ul><h2 id="选择器">选择器</h2><ul><li>标签通常配合选择器使用，标签选择器可以识别一组对象，标签不支持唯一性</li><li>标签选择器最常见的用法是为<code>Service</code>选择一组<code>Pod</code>作为后端</li><li>标签选择运算，基于等值的和基于集合的<ul><li>多个条件使用逗号分割，相当于<code>AND</code></li><li>基于等值的直接使用键值对即可</li><li>基于集合的可以使用<code>IN, NOT IN</code></li></ul></li></ul><h1>容器运行时接口(<code>CRI</code>)</h1><ul><li><code>Kubelet</code>运行在每个节点上，用于管理和维护<code>Pod</code>和容器的状态</li><li>容器运行时接口是<code>Kubelet</code>和容器运行时之间通信的主要协议，将<code>Kubelet</code>于容器运行时解耦，实现了<code>CRI</code>接口的容器引擎，都可以所谓<code>Kubernetes</code>的容器运行时。</li><li><code>Docker</code>没有实现<code>CRI</code>接口，<code>Kubernetes</code>使用<code>dockershim</code>来兼容<code>docker</code></li><li><code>crictl</code>是一个兼容<code>CRI</code>的容器运行时命令，跟<code>docker</code>命令一个样，可以用来检查和调试底层的运行时容器<ul><li>比<code>docker</code>命令稍微少一些，比如无法实现导入导出</li><li>因此导入导出使用<code>ctr</code>命令，也只用来导入导出，因为<code>ctr</code>也不是很好用<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker pull alpine:3.15 </span><br><span class="line">docker save apline:3.15 &gt; alpine-3.15.tar # 保存成tar</span><br><span class="line">ctr -n k8s.io images import alpine-3.15.tar --platform linux/amd64 # 导入镜像</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">kubernetes 中所有的镜像都在k8s.io这个命名空间中</span></span><br><span class="line">ctr -n k8s.io images export alpine.tar docker.io/library/alpine:3.15 --platform linux/amd64 # 导出镜像</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1>金丝雀发布(<code>canary deployment</code>)</h1><ul><li>生产环境中小范围部署新的应用代码，一旦应用签署发布，只有少数用户被路由到他，最大限度降低影响。如果没有错误发生，则将新版本逐渐推广到整个基础设施</li><li>默认的金丝雀发布有一定的局限<ul><li>不能根据用户的注册时间、地区等请求中的内容属性进行流量分配</li><li>同一个用户如果多次调用该<code>Service</code>，可能第一次请求到了旧版本的<code>Pod</code>，第二次请求到了新版本的<code>Pod</code></li><li>因为<code>Kubernetes Service</code>只在<code>TCP</code>层面解决负载均衡问题，不对请求响应的消息内容做任何解析和识别，如果更完善的实现金丝雀日发布，可以考虑<code>Istio</code>灰度发布</li></ul></li></ul><h1>搭建<code>MySQL</code></h1><h2 id="创建mysql-pod-yaml">创建<code>mysql-pod.yaml</code></h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mysql-pod</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">mysql</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:5.7</span></span><br><span class="line">    <span class="attr">env:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_ROOT_PASSWORD</span></span><br><span class="line">        <span class="attr">value:</span> <span class="string">&quot;123456&quot;</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/var/lib/mysql</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">data-volume</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">data-volume</span></span><br><span class="line">      <span class="attr">hostPath:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/home/mysql/data</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">Directory</span></span><br></pre></td></tr></table></figure><h2 id="挂载数据卷">挂载数据卷</h2><ul><li><code>hostPath</code>卷: 将主机节点上的文件或目录挂在到<code>Pod</code>中</li></ul><table><thead><tr><th style="text-align:center">type</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">DirectoryOrCreate</td><td style="text-align:center">目录不存在则自动创建</td></tr><tr><td style="text-align:center">Directory</td><td style="text-align:center">挂载已经存在的目录，不存在会报错</td></tr><tr><td style="text-align:center">FileOrCreate</td><td style="text-align:center">文件不存在则自动创建，不会自动创建文件的父目录，必须确保文件路径存在</td></tr><tr><td style="text-align:center">File</td><td style="text-align:center">挂载已经存在的文件，不存在会报错</td></tr><tr><td style="text-align:center">Socket</td><td style="text-align:center">挂在UNIX套接字，比如挂载/var/run/docker.sock 进程</td></tr></tbody></table><h2 id="ConfigMap"><code>ConfigMap</code></h2><ul><li><code>Docker</code>中可以使用绑定挂载的方式将配置文件挂载到容器里，但是在<code>Kubernetes</code>集群中，容器可能被调度到任意的节点中，配置文件需要能在集群的任意节点上访问、分发和更新</li><li><code>ConfigMap</code>用来在etcd中保存非加密的数据，一般用来保存配置文件<ul><li>可以用作环境变量，命令行参数或者存储卷</li><li>将配置信息与容器镜像解耦，便于配置的修改</li><li>在设计上不是用来保存大量数据的</li><li>保存的数据不能超过1MB</li><li>超出这个限制，需要考虑存储卷或者访问文件存储服务</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;架构&lt;/h1&gt;
&lt;p&gt;一个&lt;code&gt;Kubernetes&lt;/code&gt;集群至少包含一个控制平面，以及一个或多个工作节点&lt;/p&gt;
&lt;h2 id=&quot;控制平面&quot;&gt;控制平面&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/sang3112/blog_im</summary>
      
    
    
    
    <category term="Kubernetes" scheme="https://sangs3112.github.io/categories/Kubernetes/"/>
    
    
    <category term="Kubernetes" scheme="https://sangs3112.github.io/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Kafka笔记_1</title>
    <link href="https://sangs3112.github.io/posts/afe3e258.html"/>
    <id>https://sangs3112.github.io/posts/afe3e258.html</id>
    <published>2024-04-05T09:05:56.000Z</published>
    <updated>2024-12-11T04:42:14.727Z</updated>
    
    <content type="html"><![CDATA[<h1>消费</h1><ul><li><code>watermark</code>水位线以下的数据是消费者可以消费的数据</li></ul><h2 id="消费者组中的消费者和分区之间的分配关系">消费者组中的消费者和分区之间的分配关系</h2><ol><li>同一个消费者组中的消费者都订阅同一个主题，所以消费者组中的多个消费者可以共同消费同一个主题中的所有数据</li><li>为了避免数据被重复消费，所以主题一个分区的数据只能被组中的一个消费者消费，所以两个消费者不能同时消费一个分区的数据。但是一个消费者可以同时消费多个分区的数据。</li></ol><h2 id="消费者分区分配策略-4种">消费者分区分配策略(4种)</h2><div class="note info flat"><ul><li>具体的分配策略实际上是由消费者组中的<code>Leader</code>决定的，<code>Leader</code>就是群主，是第一个加入消费者组的消费者</li><li>消费者加入群组时，发送一个<code>JoinGroup</code>，群主负责给每一个消费者分配一个分区</li></ul></div><h3 id="轮询分配策略-RoundRobinAssignor">轮询分配策略(<code>RoundRobinAssignor</code>)</h3><ul><li>每个消费者组中的消费者都含有一个自动生成的<code>UUID</code>作为<code>memberid</code></li><li>轮询策略会将每个消费者按照<code>memberid</code>进行排序，所有<code>member</code>消费的主题分区根据主题名称进行排序</li><li>将主题分区轮询分配给对应的订阅用户，未订阅当前轮询主题的消费者会跳过<br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Kafka/RRA1.png" alt="RRA1"><br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Kafka/RRA2.png" alt="RRA2"><br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Kafka/RRA3.png" alt="RRA3"><br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Kafka/RRA4.png" alt="RRA4"></li></ul><h3 id="范围分配策略-RangeAssignor">范围分配策略(<code>RangeAssignor</code>)</h3><ul><li>每个<code>Topic</code>的<code>partition</code>数计算出每个消费者应该分配的分区数量，分配原则就是一个主题的分区尽可能平分，如果不能平均分配，则按照顺序向前补齐。</li></ul><div class="note default flat"><ul><li>假设目前有五个分区分给两个消费者，<code>5 / 2 = 2, 5 % 2 = 1</code>。则剩下一个分区补在第一个消费者中，则分配结果为<code>[123][45]</code></li><li>假设目前有五个分区分配给三个消费者，<code>5 / 3 = 1, 5 % 3 = 2</code>，最后分配结果是<code>[12][34][5]</code></li><li>范围分配策略针对单个<code>Topic</code>的情况下比较均衡，如果多个<code>Topic</code>，则<code>member</code>靠前的排序可能比靠后的排序负载多很多，也不够理想</li></ul></div><p><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Kafka/RA1.png" alt="RA1"></p><h3 id="粘性分区-StickyAssignor">粘性分区(<code>StickyAssignor</code>)</h3><ul><li>第一次分配后，每个组成员都保留分配给自己的分区信息。如果消费者加入或者退出，则进行分区再分配时(一般是消费者退出45s以后，才会进行再分配，因为又要考虑可能恢复的情况)，尽可能保证消费者原有分区不变，重新对加入或者退出消费者的分区进行分配。<br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Kafka/SA1.png" alt="SA1"><br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Kafka/SA2.png" alt="SA2"></li></ul><h3 id="优化的粘性分配策略-CooperativeStickyAssignor">优化的粘性分配策略(<code>CooperativeStickyAssignor</code>)</h3><ul><li>前三种分配策略在进行重分配的时候使用的是<code>EAGER</code>协议，让当前的所有消费者放弃当前分区，关闭连接，资源清理，重新加入组和等待分配策略，效率较低</li><li>从2.4版本开始，粘性分配策略的基础上，优化了重分配的过程，使用的是<code>COOPERATIVE</code>协议。粘性分区分配策略分配的会更加均匀和高效一些</li><li><code>COOPERATIVE</code>协议将一次全局重平衡，改成每个小规模的重平衡，直到最终收敛平衡的过程</li></ul><div class="note info flat"><ul><li><code>Kafka</code>消费者默认的分区分配就是<code>RangeAssignor</code>(第一次分区分配)，<code>CooperativeStickyAssinor</code>(后续的分区分配)</li></ul></div><h1>集群的脑裂问题</h1><ul><li>首先<code>ZooKeeper</code>具有三个<code>Broker</code>，其中有一个<code>Controller</code>，由<code>Broker1</code>创建的</li><li>但是此时网络不稳定，<code>Broker1</code>掉线了。<code>ZooKeeper</code>中的<code>Controller</code>临时节点被删除了，同时选举了<code>Broker3</code>作为新的<code>Controller</code>，创建了新的临时节点</li><li>此时<code>Broker1</code>恢复了链接，由于是<code>Broker3</code>创建了<code>Controller</code>。所以<code>Broker3</code>才是真正的管理者</li><li>但是<code>Broker1</code>此时仍然认为自己是管理者，两个<code>Broker</code>都会向<code>Broker2</code>同步消息，<code>Broker2</code>不知道应该同步谁的消息，这就是脑裂问题</li></ul><h2 id="解决">解决</h2><ul><li><code>ZooKeeper</code>引入了<code>epoch</code>纪元，有一个<code>controller_epoch</code>(不是临时节点)，记录的是当前的<code>controller</code>是出现的第几个<code>controller</code>。这样<code>Broker2</code>就可以判断出最新的管理者是谁，从而完成同步消息</li></ul><h1>总结</h1><h2 id="Kafka组件">Kafka组件</h2><ul><li>通信用组件 <code>SocketServer</code>，<code>NetworkClient</code>，生产者中的缓冲区, <code>ZooKeeper</code>等等</li></ul><h2 id="LSO、LEO、HW含义"><code>LSO、LEO、HW</code>含义</h2><ol><li><code>LSO (Log Start Offset, Log Stable Offset)</code><ul><li>第一个是数据文件的起始偏移量</li><li>第二个表示的位移值是用来判断事务型消费者的可见性，就是事务的隔离级别<ul><li>一个是<code>read_committed</code>, 另一个是<code>read_uncommitted</code>，如果没有使用事务，则这个偏移量没有意义</li></ul></li></ul></li><li><code>LEO (Log End Offset)</code> 下一个要写入的数据偏移量，<strong>是不存在的</strong>。水位线靠这个推动增长</li><li><code>HW</code> 高水位线的意思，是<code>Kafka</code>为了数据一致性增加的一种数据隔离方式，消费者只能消费到小于高水位线的数据</li></ol><h2 id="Controller选举如何实现"><code>Controller</code>选举如何实现</h2><ul><li><code>Kafka</code>在4.0版本以后，将会完全抛弃<code>ZooKeeper</code>，现在<code>Controller</code>选举还是依赖<code>ZooKeeper</code>实现的，所有的<code>Broker</code>都会监听<code>ZooKeeper</code>中的一个<code>Controller</code>临时节点。如果没有创建，则<code>Broker</code>会申请创建，创建成功，则该<code>Broker</code>就是集群的<code>Controller</code>。一旦失去和<code>ZooKeeper</code>的通信，临时节点就会消失，就会重新进行选举，并且<code>Controller纪元</code>就会更新</li></ul><h2 id="AR-ISR-OSR的含义"><code>AR ISR OSR</code>的含义</h2><ol><li><code>AR</code> 是分区的所有副本集合</li><li><code>ISR</code> 是正在同步数据的副本列表，列表的第一个就是分区的<code>Leader</code>副本，其他就是<code>Follower</code>副本</li><li><code>OSR</code> 就是没有处于同步数据的副本列表，一旦副本拉去数据满足了特定的条件。则<code>OSR</code>会移除并增加到<code>ISR</code>中。同样如果副本没有拉取数据满足特定的条件，就会从<code>ISR</code>中移除，放到<code>OSR</code>中。这些就是<code>ISR</code>列表的收缩和扩张，权衡数据的可靠性和性能之间的关系</li></ol><h2 id="Producer消息重复或者消息丢失的原因"><code>Producer</code>消息重复或者消息丢失的原因</h2><ul><li>主要就是<code>Kafka</code>为了提高数据可靠性提供的重试机制，数据一旦发送失败了，数据就丢失了</li><li>数据重复，恰恰是因为开启重试机制以后，如果网络阻塞或者不稳定，导致数据需要重新发送，数据就有可能会重复</li><li>幂等性操作要求必须开启<strong>重试功能和</strong><code>ACKS = -1</code>，这样可以确保数据不会丢失<ul><li><code>Kafka</code>提供幂等性操作只能保证同一个生产者会话中同一个分区中的数据不会重复，一旦数据发送过程中，生产者对象重启，幂等性操作失效，此时需要使用事务功能解决跨会话的幂等性操作，但是跨分区的幂等性操作是无法实现的。</li></ul></li></ul><h2 id="Consumer消息重复或消息丢失的原因"><code>Consumer</code>消息重复或消息丢失的原因</h2><ul><li>是消费者提交偏移量的问题，消费者为了防止意外情况下，重启后不知道从哪里开始消费，会每5s自动保存偏移量，但是这种自动保存偏移量的操作是基于时间的，一旦未到达时间，消费者重启了，那么消费者可能重复消费数据</li><li><code>Kafka</code>提供自动保存偏移量的功能的同时，也提供了手动保存偏移量的两种方式，一个同步提交，另一个是异步提交。本质上都是提交一批数据的最后一个偏移的值，但是可能会出现，偏移量已经提交完毕了，但是拉取的数据还没有处理完毕，消费者重启了，此时有些数据就无法消费到，造成了数据丢失</li></ul><h2 id="Kafka数据如何保证有序"><code>Kafka</code>数据如何保证有序</h2><ul><li>有序需要考虑<strong>生产有序，存储有序和消费有序</strong>。</li><li><strong>生产有序</strong> 就是生产者对象需要给数据增加序列号，用于标记数据的顺序，在服务端进行缓存数据的比对，一旦发现数据是乱序的，就需要让生产者客户端进行数据排序，然后重新发送数据，从而保证数据的有序。不过这里缓存的比对，最多只能有5条数据的比对，所以生产者客户端需要配置<strong>在途请求缓冲区的请求队列</strong>数据设置成5，否则数据依然可能乱序。因为服务端的缓存数据是以分区为单位的，所以需要生产者客户端将数据发送到一个分区中，如果数据发送到多个分区中，无法保证顺序，这就是生产有序的意思</li><li><strong>存储有序</strong> <code>Kafka</code>的服务端获取数据以后会将数据顺序写入日志文件，保证了存储有序，也只能保证一个分区的数据有序</li><li><strong>消费有序</strong> <code>Kafka</code>在存储数据时会给数据增加一个访问的偏移量值，消费者只能按照偏移量的方式顺序访问，并且一个分区的数据只能被消费者组中的一个消费者消费，那么按照偏移量方式读取的数据就不会出现乱序的情况，从而实现消费有序</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;消费&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;watermark&lt;/code&gt;水位线以下的数据是消费者可以消费的数据&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;消费者组中的消费者和分区之间的分配关系&quot;&gt;消费者组中的消费者和分区之间的分配关系&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;同一个</summary>
      
    
    
    
    <category term="Kafka" scheme="https://sangs3112.github.io/categories/Kafka/"/>
    
    
    <category term="Kafka" scheme="https://sangs3112.github.io/tags/Kafka/"/>
    
    <category term="消费者分区分配策略" scheme="https://sangs3112.github.io/tags/%E6%B6%88%E8%B4%B9%E8%80%85%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/"/>
    
    <category term="集群脑裂" scheme="https://sangs3112.github.io/tags/%E9%9B%86%E7%BE%A4%E8%84%91%E8%A3%82/"/>
    
  </entry>
  
  <entry>
    <title>Kafka笔记_0</title>
    <link href="https://sangs3112.github.io/posts/d8e4d2ce.html"/>
    <id>https://sangs3112.github.io/posts/d8e4d2ce.html</id>
    <published>2024-04-04T07:05:56.000Z</published>
    <updated>2024-12-11T04:42:14.727Z</updated>
    
    <content type="html"><![CDATA[<h1>消费模式</h1><h2 id="点对点模式-P2P">点对点模式(<code>P2P</code>)</h2><ul><li>队列中<strong>只有一个消费者</strong>可以消费数据，用后即销毁，因此数据有且只有一次消费。</li><li>适合用于<strong>短信业务</strong>，发送一次，消费一次。  <div class="note info flat"><p>特点:<br>- 每个消息只有一个接收者<br>- 发送和接收之间没有依赖，发送者成功发送消息后，不管接收有没有运行，都可以再次发送消息<br>- 接收者在成功接收后需要向队列应答成功，以便消息队列删除当前消息</p></div><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Kafka/p2p.png" alt="p2p"></li></ul><h2 id="发布订阅模式-PS">发布订阅模式(<code>PS</code>)</h2><ul><li>数据会在队列中存储<strong>7天</strong>，每个订阅都可以消费到相应的数据，可以<strong>重复进行</strong>消费数据。</li><li>大部分都是发布订阅模式。  <div class="note info flat"><p>特点:<br>- 每个消息有多个订阅者<br>- 发布者和订阅者之间有时间上的依赖性。针对某个<code>Topic</code>的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息<br>- 为了消费消息，订阅者需要提前订阅该角色主题，并保持在线运行</p></div><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Kafka/ps.png" alt="ps"></li></ul><h1>基础架构</h1><div class="note info flat"><ul><li><code>Kafka</code><strong>不是主从集群</strong>，因此每一个节点都可以是主节点，如果一个节点宕机了，那么其他的节点可以被选举为主节点</li><li><code>Kafka</code>中每一个节点都称为<code>Broker</code>，每个节点都存在一个<code>Kafka_controller</code>组件</li><li>但是只有一台节点的<code>controller</code>组件是活跃状态，其他都是<code>standby</code>状态</li><li>主节点宕机时，从节点通过<code>ZooKeeper</code>进行集群选举，得到新的主节点</li></ul></div><h1><code>Feed</code>流实现方案</h1><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">拉模式</th><th style="text-align:center">推模式</th><th style="text-align:center">推拉结合</th></tr></thead><tbody><tr><td style="text-align:center">写比例</td><td style="text-align:center">低</td><td style="text-align:center">高</td><td style="text-align:center">中</td></tr><tr><td style="text-align:center">读比例</td><td style="text-align:center">高</td><td style="text-align:center">低</td><td style="text-align:center">中</td></tr><tr><td style="text-align:center">用户读取延迟</td><td style="text-align:center">高</td><td style="text-align:center">低</td><td style="text-align:center">低</td></tr><tr><td style="text-align:center">实现难度</td><td style="text-align:center">复杂</td><td style="text-align:center">简单</td><td style="text-align:center">很复杂</td></tr><tr><td style="text-align:center">使用场景</td><td style="text-align:center">较少使用</td><td style="text-align:center">用户量少，没有大V</td><td style="text-align:center">过千万的用户量，有大V</td></tr></tbody></table><h1>消息队列应用</h1><h2 id="线程与线程之间的数据交互">线程与线程之间的数据交互</h2><div class="note info flat"><ul><li>栈内存是<strong>线程独享</strong>的，堆内存是共享的</li></ul></div><p><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Kafka/threaddata.png" alt="threaddata"></p><h2 id="进程与进程之间的数据交互">进程与进程之间的数据交互</h2><div class="note info flat"><ul><li>进程有自己独立的内存，<strong>无法</strong>通过堆内存共享数据</li></ul></div><p><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Kafka/processdata.png" alt="processdata"></p><h2 id="传统数据交互的问题">传统数据交互的问题</h2><ul><li>如果线程1发送数据的速度是<code>50 条/s</code>，但是线程2处理数据的速度是<code>30 条/s</code>，就会导致<strong>每秒有20条数据</strong>积压在内存中，最后导致内存溢出，服务终止</li><li>如果放在磁盘文件中，磁盘文件也是有上限的，并且速度较慢</li></ul><h2 id="消息中间件">消息中间件</h2><ul><li>进程之间直接进行交互，可以在进程之间添加一个缓冲区，用于解耦合</li><li>发送数据的进程只需要考虑往缓冲区中存放数据，也就是<strong>消息中间件</strong>，从而实现降低系统之间的耦合性</li><li>消息一般包含<strong>消息头，消息属性和消息主体内容</strong><br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Kafka/JMS.png" alt="JMS"></li></ul><h1><code>Kafka</code>基本概念</h1><h2 id="基本命令参数">基本命令参数</h2><div class="note info flat"><ul><li>连接<code>Kafka</code>必须要的参数: <code>--bootstrap-server ip:port(9092)</code> <code>9092</code>是<code>Kafka</code>默认的端口号</li><li><code>Kafka</code>创建新<code>topic</code>需要在后面跟上: <code>--topic 主题名 --create</code></li><li>查看<code>topic</code>: <code>--list</code></li><li>查看某个具体的<code>topic</code>: <code>--topic 主题名 --describe</code></li><li>修改<code>topic</code>: <code>--topic 主题名 --alter --修改的内容</code></li><li>删除<code>topic</code>: <code>--topic 主题名 --delete</code></li></ul></div><h2 id="单节点架构">单节点架构</h2><p><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Kafka/kafka.png" alt="kafka"></p><ul><li>消息称为<code>record</code></li><li><code>App</code>通过调用<code>Kafka</code>的接口实现生产和消费，会将数据保存到<code>.log</code>文件中，增加标记<code>offset</code>，固定顺序</li></ul><h2 id="集群架构">集群架构</h2><p><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Kafka/arch.png" alt="arch"></p><div class="note default flat"><ul><li>中间单个节点容易成为性能瓶颈，如果宕机，则数据无法访问</li><li>两种方式解决: 1. 横向扩展 2. 纵向扩展</li></ul></div><h3 id="横向扩展">横向扩展</h3><ul><li>增加服务节点，搭建集群，降低单点故障带来的问题<br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Kafka/horizontal.png" alt="horizontal">  <div class="note info flat"><ul><li>在<strong>一定程度上缓解</strong>，不是真正完全解决，因为主题在指定的<code>Broker</code>上，所以依然必须要访问某一个特定的<code>Broker</code></li><li>因此真正解决需要将一个<code>topic</code>分成多个部分，所有生产数据可以指向不同的<code>Broker</code>，但是都是同一个<code>topic</code></li></ul></div></li></ul><h3 id="纵向扩展">纵向扩展</h3><ul><li>增加系统的资源配置，更快的网络，更大的硬盘  <div class="note info flat"><ul><li><code>topic</code>是一个整体，但是划分了不同的数据块<ul><li>通过添加不同的编号，即为不同的分区(<code>partition</code>)</li><li>生产者就可以将数据发向不同的<code>partition</code>，消费者可以消费同一个<code>topic</code>不同的<code>partition</code></li></ul></li><li><code>Kafka</code>设置了消费者组<code>Consumer Group</code>，专门用来消费不同<code>partition</code>的消息，这样避免发送多次消费请求</li></ul></div></li><li>为了数据的可靠性，可以将数据进行备份，但是<code>Kafka</code>没有备份的概念，只有<strong>副本</strong>的概念。</li><li>多个副本同时只有一个能进行读写操作，称为<code>Leader</code>副本，其他副本称为<code>Follower</code>副本</li><li><strong>副本个数不应该超过broker数量 - 1</strong></li></ul><p><code>Kafka</code>有一个管理的<code>Broker</code>，称为控制器(<code>Controller</code>)</p><div class="note info flat"><p>如果<code>Controller</code>宕机了，如何解决</p><ol><li>给<code>Controller</code>添加备份</li><li>每一个<code>Broker</code>都可以做备份，如果<code>Controller</code>宕机了，则会使用<code>ZooKeeper</code>选取一个新的<code>Controller</code></li></ol></div><p><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Kafka/jiqun.png" alt="jiqun"></p><div class="note default flat"><p><code>ZooKeeper</code>选举流程</p><ol><li><code>ZooKeeper</code>首先没有任何的节点，启动<code>Broker1</code>，则会产生临时节点<code>Controller</code>，<code>id=1</code></li><li>然后启动<code>Broker2</code>和<code>Broker3</code>后，不能再产生临时节点，就会创建一个监听器，监听节点的变化</li><li><code>Controller</code>失去连接了以后，监听器就会发生作用，选举出新的<code>Controller</code></li></ol></div><h1><code>Broker</code>启动流程</h1><h2 id="Broker1启动流程"><code>Broker1</code>启动流程</h2><ol><li>在<code>ZooKeeper</code>注册<code>Broker</code>节点，创建临时节点<code>ids</code></li><li>监听<code>/controller</code>节点</li><li>注册<code>/controller</code>节点</li><li>注册成功，选举称为<code>Controller</code>，监听临时节点<code>/brokers/ids</code>，从而可以对后面加入的节点进行响应</li></ol><h2 id="Broker2启动流程"><code>Broker2</code>启动流程</h2><ol><li>在<code>ZooKeeper</code>注册<code>Broker</code>节点，在<code>ids</code>里面创建临时节点2</li><li>监听<code>/controller</code>临时节点</li><li>注册<code>/controller</code>临时节点，因为<code>ZooKeeper</code>中已经存在<code>Controller</code>，所以不会注册成功</li><li>通知集群变化</li><li>连接<code>Broker</code>，发送集群的相关数据</li></ol><h2 id="Broker3启动流程"><code>Broker3</code>启动流程:</h2><ol><li>注册<code>Broker</code>节点，在<code>ids</code>里面创建临时节点3</li><li>监听<code>/controller</code>临时节点</li><li>注册<code>/controller</code>临时节点，注册不成功</li><li>通知集群变化</li><li>连接<strong>所有的<code>Broker</code></strong>，发送集群的相关信息</li></ol><h2 id="删除Controller节点-宕机">删除<code>Controller</code>节点(宕机):</h2><ol><li>由监听器通知节点删除</li><li>注册<code>Controller</code>临时节点，只有一个节点能注册成功</li><li>增加<code>ids</code>监听器，删除曾经的<code>Controller</code>监听器</li><li>连接所有的<code>Broker</code>，发送集群的相关数据</li></ol><h2 id="底层实现">底层实现</h2><ol><li><code>Broker</code>和<code>ZooKeeper</code>之间的通信: 节点带有<code>ZooKeeperClient</code>实现通信</li><li><code>Controller</code>和<code>Broker</code>之间的通信: <code>NIO</code>的<code>Channel, Buffer, Selector, SelectionKey</code></li></ol><h1>生产</h1><h2 id="创建主题">创建主题</h2><ul><li>生产消息的时候如果不存在对应的主题，<code>Kafka</code>会自动创建主题(可以通过配置关闭)</li><li>要关注每个<code>Broker</code>中的<code>Leader</code>的数量，平衡分配会更合理一些</li><li><code>Kafka</code>默认的副本分配未必是平均分配，所以只能尽可能的合理分配，也可以自己指定副本的分配方案</li></ul><h2 id="分区计算">分区计算</h2><ol><li>如果发送消息中指定了分区编号，则会直接向分区中发送消息，并且不会检查分区编号是否有问题。如果写了一个不存在的编号，则消息一直阻塞</li><li>自定义分区器实现<code>Partitioner</code>，会检查编号是否小于0，但是过大依然不会检查</li><li>把<code>key</code>做了一个非哈希散列算法<code>murmur2</code>，取余分区数量，得到的结果就是分区编号。所以指定的<code>key</code>主要用来做分区计算的</li></ol><div class="note info flat"><ul><li>为了节省网络资源消耗，设计了<code>RecordAccumulator</code>数据收集器，将多个消息一起发送，而不是简单的一条一条发送</li><li>数据收集器内部都是一些批次对象，如果批次对象的容量足够，则会自动往里面<code>append</code>数据</li><li>如果批次对象的容量不够了，则会将批次对象锁定关闭，不再接收新的数据，开启一个新的批次对象，用于接收数据</li><li>批次对象中有一个<code>16K</code>的阈值，不是不能超过<code>16K</code>，而是超过<code>16K</code>再关闭</li></ul></div><p><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Kafka/produce.png" alt="produce"></p><h2 id="应答处理-三个级别">应答处理(三个级别)</h2><ol><li><code>ACKS = 0</code>: 优先考虑数据传送效率，数据是否真的发送过去是不关心的。假设网络是没有任何问题的，发送完一条数据立马发送下一条</li><li><code>ACKS = 1</code>: 可靠性和发送效率折中，<code>Leader</code>保存数据到磁盘后，就响应发送成功。但是如果<code>Leader</code>宕机了，<code>Follower</code>没有来得及备份，则数据无法访问</li><li><code>ACKS = -1 or ALL</code>: 优先考虑数据的安全性，<code>Leader</code> 和 <code>Follower</code>把数据都保存了，然后才响应发送成功，效率很低</li></ol><ul><li>这里的<code>Follower</code>是<code>ISR</code>中的所有副本，而不是本身的所有副本</li></ul><h2 id="重试机制Retry">重试机制<code>Retry</code></h2><ul><li><code>ACKS = 1</code>: 如果一个数据，从主线程出发到<code>Buffer</code>缓冲区后到<code>Sender</code>线程中，发送到<code>NetworkClient</code>网络客户端，再发送到<code>SocketServer</code>服务器。如果这个时候数据没有到<code>ReplicaManager</code>，<code>Leader</code>宕机，则无法进行副本保存。此时<code>NetworkClient</code>客户端有一份数据，<code>SocketServer</code>有一份数据，但是由于宕机，导致<code>SocketServer</code>的数据丢失，没有保存则不会有响应，此时会有超时时间。如果超时了会进行<code>Retry</code>。<ol><li>将<code>NetworkClient</code>的数据重新传送到<code>Buffer</code>中，再经过<code>Sender</code>线程，再回到<code>NetworkClient</code>进行发送</li><li>默认是不断重试，重试次数是整型的最大值</li></ol></li></ul><h3 id="重试机制的问题-重复和乱序">重试机制的问题(重复和乱序)</h3><ol><li>数据重试机制可能会导致数据重复(超时时间过少导致的)</li><li><code>Buffer</code>有三条数据，被网络客户端发送到<code>Broker</code>中，生产者可同时处理五个请求，所以三个数据可以一起处理。<ul><li>但是如果三条数据中有一条处理失败了，则会重新发送那一条数据，但是此时会导致乱序问题</li></ul></li></ol><h3 id="如何解决重复和乱序-幂等性">如何解决重复和乱序(幂等性)</h3><ul><li>开启幂等性: 配置<code>ENABLE_IDEMPOTENCE_CONFIG</code>(默认不启用)</li></ul><div class="note default flat"><p>开启幂等性要求</p><ul><li><code>ACKS = -1</code></li><li>开启重试机制</li><li>在途请求缓冲区不能超过5(默认就是5)</li></ul></div><ul><li>给数据开启<strong>唯一</strong>的标识，包括两个部分，分别是<strong>生产者ID，数据的顺序号</strong><ul><li><p>不同的<code>partition</code>数据可能有相同的标号，但是同一个<code>partition</code>内序号一定是唯一的</p></li><li><p>所以幂等性只能保证<strong>对同一个</strong><code>partition</code>起作用</p></li><li><p><code>Broker</code>可以保存生产者状态，里面只有五条数据。如果是同一个<code>Producer</code>，同一个<code>partition</code>，就可以对比唯一标识判断数据是否<strong>重复</strong></p></li><li><p><strong>乱序</strong>是判断当前的序号是否连续</p><ul><li>如果6失效了，会尝试将7插入进去，发现前面是5后面是7，不连续，则6和7都会重发</li><li>如果5后面的6正常，则会将1弹出后，再将6传入，保证数据按序输出</li><li>这个队列的大小为五，所以要求在途请求缓冲区不能超过5</li></ul><div class="note default flat"><p>幂等性跨会话问题</p><ul><li>生产者ID是随机生成的，如果生产者重启了，则生产者ID也会发生改变。此时比对序号的操作时会发现比对不成功</li><li>可以通过<strong>事务</strong>解决</li><li>数据唯一标识中添加事务ID，事务是基于幂等性操作，保证一次提交。因此事务可以解决跨会话的幂等性问题，但是<strong>不能解决跨分区</strong>的问题</li></ul></div></li></ul></li></ul><h2 id="数据传输语义">数据传输语义</h2><table><thead><tr><th style="text-align:center">数据传输语义</th><th style="text-align:center">含义</th><th style="text-align:center">场景</th></tr></thead><tbody><tr><td style="text-align:center">at most once</td><td style="text-align:center">最多一次，不管是否能够接收到，数据最多传输一次，可能丢失</td><td style="text-align:center">Socket ACK = 0</td></tr><tr><td style="text-align:center">at least once</td><td style="text-align:center">最少一次，数据不会丢失，如果接收不到，则继续发送直到接收，可能会出现数据重复</td><td style="text-align:center">ACK = 1</td></tr><tr><td style="text-align:center">exactly once</td><td style="text-align:center">精准一次，消息只会传送一次，不会丢也不会重复</td><td style="text-align:center">幂等 + 事务 + ACK = 1</td></tr></tbody></table><h2 id="事务流程">事务流程</h2><p><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Kafka/tx.png" alt="tx"></p><h2 id="文件存储类型">文件存储类型</h2><ul><li>数据写入<code>Leader</code>节点时，<strong>不会</strong>立即将数据写入磁盘文件中，因为这样效率太低了。</li><li><code>Kafka</code>将一个文件切分成一个一个文件段。当大于<code>1G</code>时，就会产生一个新的文件段。</li><li>如果一份数据超过7天，也会生成一个新的文件段</li><li><code>.log</code>就是数据的日志文件，当前文件中起始偏移量</li><li><code>.index</code>偏移量索引文件，将偏移量与文件中的数据的具体位置进行关联，称之为<strong>稀疏索引文件</strong></li><li><code>.timeindex</code>保存时间戳和数据偏移量之间的关系</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;消费模式&lt;/h1&gt;
&lt;h2 id=&quot;点对点模式-P2P&quot;&gt;点对点模式(&lt;code&gt;P2P&lt;/code&gt;)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;队列中&lt;strong&gt;只有一个消费者&lt;/strong&gt;可以消费数据，用后即销毁，因此数据有且只有一次消费。&lt;/li&gt;
&lt;li&gt;适合用于&lt;s</summary>
      
    
    
    
    <category term="Kafka" scheme="https://sangs3112.github.io/categories/Kafka/"/>
    
    
    <category term="Kafka" scheme="https://sangs3112.github.io/tags/Kafka/"/>
    
    <category term="应答处理机制" scheme="https://sangs3112.github.io/tags/%E5%BA%94%E7%AD%94%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    
    <category term="重试机制" scheme="https://sangs3112.github.io/tags/%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6/"/>
    
    <category term="幂等性" scheme="https://sangs3112.github.io/tags/%E5%B9%82%E7%AD%89%E6%80%A7/"/>
    
    <category term="事务流程" scheme="https://sangs3112.github.io/tags/%E4%BA%8B%E5%8A%A1%E6%B5%81%E7%A8%8B/"/>
    
  </entry>
  
</feed>
