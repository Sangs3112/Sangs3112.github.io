<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sangs Blog</title>
  
  
  <link href="https://sangs3112.github.io/atom.xml" rel="self"/>
  
  <link href="https://sangs3112.github.io/"/>
  <updated>2024-03-23T00:16:00.121Z</updated>
  <id>https://sangs3112.github.io/</id>
  
  <author>
    <name>Sangs</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis笔记_2</title>
    <link href="https://sangs3112.github.io/posts/d8d127a4.html"/>
    <id>https://sangs3112.github.io/posts/d8d127a4.html</id>
    <published>2024-03-22T13:01:20.000Z</published>
    <updated>2024-03-23T00:16:00.121Z</updated>
    
    <content type="html"><![CDATA[<h1>数据持久化</h1><h2 id="RDB"><code>RDB</code></h2><div class="note info flat"><ul><li><code>Redis Database Backup file</code>(<code>Redis</code>数据备份文件)，也叫做<code>Redis</code>数据快照。把内存中的所有数据都记录到磁盘中，故障重启后，从磁盘读取快照文件，恢复数据。</li><li><code>RDB</code>文件称为快照文件，默认保存当前运行目录</li></ul></div><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis-cli</span><br><span class="line">save # 使用save命令来进行快照保存，由Redis主进程执行RDB，阻塞所有命令</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">所以一般不使用save，Redis在停机退出的时候会自动执行save，再次启动会读取RDB，实现默认的持久化</span></span><br><span class="line">bgsave # 开启子进程执行RDB，避免主进程受到影响</span><br></pre></td></tr></table></figure><ul><li><code>redis.conf</code>配置<code>RDB</code>机制</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">save 900 1 # 表示如果900s内至少有1个key被修改，则执行bgsave</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000 </span><br><span class="line"># 如果是save &quot;&quot; 表示禁用RDB</span><br><span class="line"></span><br><span class="line">rdbcompression yes # 是否压缩，建议不开启，因为压缩也会消耗CPU</span><br><span class="line">dbfilename dump.rdb # RDB文件名称</span><br><span class="line">dir ./ # 文件保存路径目录</span><br></pre></td></tr></table></figure><div class="note info flat"><ul><li><code>RDB</code>的<code>bgsave</code>开始时会<code>fork</code>主进程得到子进程，子进程共享主进程的内存数据。完成<code>fork</code>后读取内存数据并写入<code>RDB</code>文件</li><li>但是<code>fork</code>的过程是阻塞的，主进程此时不能处理别的请求。所以要加快<code>fork</code>过程</li></ul></div><ul><li>主进程操作虚拟内存，虚拟内存根据页表的映射关系到物理内存中真正的数据</li><li><code>fork</code>仅仅是把页表做拷贝，即对映射关系做拷贝，因此子进程可以读取相同的数据，写入行的<code>RDB</code>文件</li><li>为了避免在子进程读的时候主进程写，<code>fork</code>采用的是<code>copy-on-write</code>技术<ul><li>主要是将物理内存标记成<code>read-only</code></li><li>主进程读，则访问共享内存</li><li>主进程写，则拷贝一份数据，对副本执行写操作，写完后页表映射关系修改到副本</li><li>极端情况下就是所有数据都要拷贝一份，内存翻倍。所以一般情况下<code>Redis</code>需要预留内存<br><img src="https://gitee.com/sang3112/blog_imgs/raw/dffcbbcd0438066a55be0c2d47d6caf381416a6f/Redis/copyonwrite.png" alt="copyonwrite"></li></ul></li></ul><div class="note info flat"><ul><li><p><code>RDB</code>方式<code>bgsave</code>的基本流程</p><ul><li><code>fork</code>主进程得到一个子进程，共享内存空间</li><li>子进程读取内存数据并写入新的<code>RDB</code>文件</li><li>用新的<code>RDB</code>文件替换旧的<code>RDB</code>文件</li></ul></li><li><p><code>RDB</code>缺点</p><ul><li><code>RDB</code>执行间隔时间长，两次<code>RDB</code>之间写入数据有丢失风险</li><li><code>fork</code>子进程、压缩、写出<code>RDB</code>文件比较耗时</li></ul></li></ul></div><h2 id="AOF"><code>AOF</code></h2><div class="note info flat"><ul><li><code>Apppend Only File</code>(追加文件)，每一个写命令都会记录在<code>AOF</code>中，可以看作是命令日志文件</li><li>默认关闭</li></ul></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes # 是否开启AOF功能，默认为no</span><br><span class="line">appendfilename &quot;appendonly.aof&quot; # AOF文件名</span><br><span class="line"></span><br><span class="line">appendfsync always # 每次执行一次写命令，立即记录到AOF文件中</span><br><span class="line">appendfsync everysec # 写命令执行完写放入AOF缓存，每隔1s将缓冲区数据写到AOF文件，默认方案</span><br><span class="line">appendfsync no # 写命令执行完先放入AOF缓存，操作系统决定何时将缓冲区内容写回磁盘</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">配置项</th><th style="text-align:center">刷盘时机</th><th style="text-align:center">优点</th><th style="text-align:center">缺点</th></tr></thead><tbody><tr><td style="text-align:center">always</td><td style="text-align:center">同步刷盘</td><td style="text-align:center">可靠性高，几乎不丢数据</td><td style="text-align:center">性能影响大</td></tr><tr><td style="text-align:center">everysec</td><td style="text-align:center">每秒刷盘</td><td style="text-align:center">性能适中</td><td style="text-align:center">最多丢失1s数据</td></tr><tr><td style="text-align:center">no</td><td style="text-align:center">操作系统控制</td><td style="text-align:center">性能最好</td><td style="text-align:center">可靠性较差，可能丢失大量数据</td></tr></tbody></table><div class="note info flat"><ul><li>因为同时记录了命令和数据，所以<code>AOF</code>会比<code>RDB</code>文件大很多，并且会记录同一个<code>key</code>的多次写操作，但是只有最后一次的写才有意义，因此可以执行<code>bgrewriteaof</code>命令，让<code>AOF</code>执行重写，用最少的命令达到原来操作相同的结果</li><li>可以在<code>redis.conf</code>中配置<code>AOF</code>重写机制</li></ul></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto-aof-rewrite-percentage 100 # AOF文件比上次文件增占了多少百分比则触发重写</span><br><span class="line">auto-aof-rewrite-min-size 64mb # AOF文件体积最小多大以上才触发重写</span><br></pre></td></tr></table></figure><h2 id="RDB-VS-AOF"><code>RDB</code> VS <code>AOF</code></h2><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">RDB</th><th style="text-align:center">AOF</th></tr></thead><tbody><tr><td style="text-align:center">持久化方式</td><td style="text-align:center">定时对整个内存快照</td><td style="text-align:center">记录每次执行命令</td></tr><tr><td style="text-align:center">数据完整性</td><td style="text-align:center">不完整，两次备份之间会丢失</td><td style="text-align:center">相对完整，取决于刷盘策略</td></tr><tr><td style="text-align:center">文件大小</td><td style="text-align:center">会有压缩，文件体积小</td><td style="text-align:center">记录命令，文件体积大</td></tr><tr><td style="text-align:center">宕机恢复速度</td><td style="text-align:center">很快</td><td style="text-align:center">慢</td></tr><tr><td style="text-align:center">数据恢复优先级</td><td style="text-align:center">低，因为数据完整性不如AOF</td><td style="text-align:center">高，因为数据完整性更高</td></tr><tr><td style="text-align:center">系统资源占用</td><td style="text-align:center">高，大量CPU和内存消耗</td><td style="text-align:center">低，主要是磁盘IO资源，但是AOF重写会占用大量的CPU和内存资源</td></tr><tr><td style="text-align:center">使用场景</td><td style="text-align:center">可以容忍数分钟的数据丢失，更快启动速度</td><td style="text-align:center">对数据安全性要求较高时常见</td></tr></tbody></table><h1><code>Redis</code>主从集群</h1><ul><li>单节点<code>Redis</code>并发能力有上限，进一步提高<code>Redis</code>的并发能力，就需要搭建主从集群，实现读写分离</li><li>启动三个<code>Redis</code>服务，需要配置三台主从关系<ul><li>临时配置: <code>replicaof &lt;masterip&gt; &lt;masterport&gt;</code></li><li>永久配置: 在<code>redis.conf</code>中添加一行: <code>replicaof &lt;masterip&gt; &lt;masterport&gt;</code></li></ul></li></ul><h2 id="数据同步原理">数据同步原理</h2><ul><li>主从第一次同步是全量同步，<code>slave</code>重启后同步，则执行增量同步</li><li>如何判断是否第一次同步:<ul><li><code>replication ID</code>: 简称<code>replid</code>是数据集的标记，<code>ID</code>一致则说明是同一个数据集，每个<code>master</code>都有唯一的<code>replid</code>,<code>slave</code>则会继承<code>master</code>节点的<code>replid</code></li><li><code>offset</code>偏移量，随着记录在<code>repl_baklog</code>中的数据增多而逐渐增大，<code>slave</code>完成同步时也会记录当前同步的<code>offset</code>，如果<code>slave</code>的<code>offset</code>小于<code>master</code>的<code>offset</code>，则说明<code>slave</code>数据落后于<code>master</code>，需要更新</li><li>基于<code>replid</code>判断主从是否一致，如果不一致则表明是第一次同步</li></ul></li></ul><p><img src="https://gitee.com/sang3112/blog_imgs/raw/dffcbbcd0438066a55be0c2d47d6caf381416a6f/Redis/first.png" alt="first"></p><div class="note info flat"><p>全量同步的流程:</p><ol><li><code>slave</code>节点请求增量同步</li><li><code>master</code>节点判断<code>replid</code>，不一致，则拒绝增量同步</li><li><code>master</code>将完整内存数据生成<code>RDB</code>，发送到<code>slave</code></li><li><code>slave</code>清空本地数据，加载<code>master</code>的<code>RDB</code></li><li><code>master</code>将<code>RDB</code>期间的命令记录在<code>repl_backlog</code>，持续将<code>log</code>中的命令发送给<code>slave</code></li><li><code>slave</code>执行接收到的命令，保持与<code>master</code>之间的同步</li></ol></div><p><img src="https://gitee.com/sang3112/blog_imgs/raw/dffcbbcd0438066a55be0c2d47d6caf381416a6f/Redis/second.png" alt="second"></p><ul><li><code>repl_baklog</code>大小有上限，写满后会覆盖最早的数据，如果<code>slave</code>断开时间过久，导致尚未备份的数据被覆盖，则无法基于<code>log</code>做增量同步，只能再次进行全量同步</li></ul><div class="note info flat"><p>优化主从集群:</p><ol><li>在<code>master</code>中配置<code>repl-diskless-sync yes</code>启用无磁盘复制，避免全量同步时的磁盘IO(一般是用于磁盘比较慢，但是网络较快的场景)</li><li><code>Redis</code>单节点上的内存占用不要太大，减少<code>RDB</code>导致的过多的磁盘IO</li><li>减少全量同步的次数: 提高<code>repl_baklog</code>的大小，发现<code>slave</code>宕机则尽快实现故障恢复，避免全量同步</li><li>限制一个<code>master</code>上的<code>slave</code>数量，如果很多<code>slave</code>则使用主从从的链式结构，减少<code>master</code>压力</li></ol></div><div class="note info flat"><p>增量同步 VS 全量同步</p><ol><li>全量同步: <code>master</code>将完整内存数据生成<code>RDB</code>，发送到<code>slave</code>，后续命令记录在<code>repl_baklog</code>中，逐个发送给<code>slave</code></li><li>增量同步: <code>slave</code>提交自己的<code>offset</code>到<code>master</code>，获取<code>repl_baklog</code>中从<code>offset</code>之后的命令给<code>slave</code></li></ol></div><h2 id="哨兵Sentinel">哨兵<code>Sentinel</code></h2><h3 id="作用">作用</h3><ol><li>监控: <code>Sentinel</code>不断检查<code>master</code>和<code>slave</code>是否按照预期工作</li><li>自动故障恢复: 如果<code>master</code>故障，则<code>Sentinel</code>将<code>slave</code>提升为<code>master</code>，故障实例恢复后也会以新的<code>master</code>为主</li><li>通知: <code>Sentinel</code>充当<code>Redis</code>客户端的服务发现来源，集群发生故障转移时，将最新的信息推送给<code>Redis</code>客户端</li></ol><h3 id="判断Redis是否健康">判断<code>Redis</code>是否健康</h3><p>基于心跳机制监测服务状态，每隔1s向集群的每个实例发送<code>PING</code>命令:</p><ul><li>主观下线<code>sdown</code>: 某个<code>sentinel</code>发现节点实例没有在规定时间内响应，则认为其主观下线</li><li>客观下线<code>odown</code>: 超过指定数量<code>quorum</code>的<code>sentinel</code>都认为该实例主观下线，则其客观下线，<code>quorum</code>最好超过<code>sentinel</code>的一半</li></ul><h3 id="主从切换选择依据">主从切换选择依据</h3><ol><li>判断<code>slave</code>节点与<code>master</code>节点断开时间长短，超过指定值<code>down-after-milliseconds * 10</code>会排除该<code>slave</code>节点</li><li>判断<code>slave</code>节点的<code>slave-prority</code>越小优先级越高，如果为0则永不选举</li><li>如果<code>slave-prority</code>则判断<code>slave</code>的<code>offset</code>值，越大越新，优先级越高</li><li>最后判断<code>slave</code>节点的运行<code>ID</code>大小，越小优先级越高</li></ol><h3 id="故障转移">故障转移</h3><ol><li><code>sentinel</code>给<code>slave1</code>发送<code>slaveof no one</code> ，让节点称为<code>master</code></li><li><code>sentinel</code>给其他<code>slave</code>发送<code>slaveof ip port</code>命令，让这些<code>slave</code>称为新的<code>master</code>从节点，开始从新的<code>master</code>上同步数据</li><li><code>sentinel</code>将故障节点标记为<code>slave</code>，故障节点恢复后悔自动成为新的<code>master</code>的<code>slave</code></li></ol><h1><code>Redis</code>分片集群</h1><div class="note info flat"><p>主从集群的问题:</p><ol><li>海量数据存储</li><li>高并发写</li></ol></div><h2 id="分片集群特征">分片集群特征</h2><ol><li>集群中有多个<code>master</code>，每个<code>master</code>保存不同数据(并发写)</li><li>每个<code>master</code>可以有多个<code>slave</code>(并发读)</li><li><code>master</code>通过<code>PING</code>监测彼此健康状态</li><li>客户端请求可以访问集群的任意节点，最终都会被转发到正确的节点<br><img src="https://gitee.com/sang3112/blog_imgs/raw/dffcbbcd0438066a55be0c2d47d6caf381416a6f/Redis/Clustering.png" alt="cluster"></li></ol><div class="note info flat"><p><code>Redis</code>会把每一个<code>master</code>映射到0~16383共16384个<code>hash slot</code>上，查看集群信息就可以看到<br>数据<code>key</code>不是与节点绑定，而是与插槽绑定。<code>redis</code>会根据<code>key</code>的有效部分计算插槽值，分两种情况</p><ul><li><code>key</code>中包含&quot;{}“，且”{}“中至少包含一个字符，”{}&quot;中的部分是有效部分</li><li><code>key</code>中国不包含&quot;{}&quot;，整个<code>key</code>都是有效部分<br>利用<code>CRC16</code>算法得到一个哈希值，然后对16384取余，得到的结果就是<code>slot</code>值<br>如何将同一类数据固定的保存在同一个<code>Redis</code>实例中:</li><li>这一类数据使用相同的有效部分，比如<code>key</code>都以<code>{typeID}</code>为前缀</li></ul></div><h2 id="故障转移-2">故障转移</h2><p>集群中一个<code>master</code>宕机会发生什么?</p><ol><li>实例与其他实例失去链接</li><li>疑似宕机</li><li>确定下线，自动提升一个<code>slave</code>成为新的<code>master</code></li></ol><h2 id="数据迁移">数据迁移</h2><ul><li>利用<code>cluster failover</code>命令可以手动让集群中的某个<code>master</code>宕机，切换到执行<code>cluster failover</code>命令的这个<code>slave</code>及诶单，实现无感知的数据迁移，具体流程为:<br><img src="https://gitee.com/sang3112/blog_imgs/raw/dffcbbcd0438066a55be0c2d47d6caf381416a6f/Redis/movedate.png" alt="movedata"></li><li>手动的<code>failover</code>支持三种不同的模式:<ul><li>默认的流程，例如1~6</li><li><code>force</code>省略了对<code>offset</code>的一致性校验</li><li><code>takeover</code>直接执行第五步，忽略数据一致性，忽略<code>master</code>状态和其他<code>master</code>意见</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;数据持久化&lt;/h1&gt;
&lt;h2 id=&quot;RDB&quot;&gt;&lt;code&gt;RDB&lt;/code&gt;&lt;/h2&gt;
&lt;div class=&quot;note info flat&quot;&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Redis Database Backup file&lt;/code&gt;(&lt;code&gt;Redis&lt;/</summary>
      
    
    
    
    <category term="Redis" scheme="https://sangs3112.github.io/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://sangs3112.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis笔记_1</title>
    <link href="https://sangs3112.github.io/posts/41d8761e.html"/>
    <id>https://sangs3112.github.io/posts/41d8761e.html</id>
    <published>2024-03-21T15:29:26.000Z</published>
    <updated>2024-03-23T00:16:00.121Z</updated>
    
    <content type="html"><![CDATA[<div class="note info flat"><p>全局唯一<code>ID</code>: 经常会需要全局唯一<code>ID</code>，比如订单表的生成。因为</p><ul><li>如果<code>ID</code>自增，则规律性太明显</li><li>并且表中可能存在大量的数据，会受到表单数据量的限制</li></ul></div><div class="note info flat"><p>全局唯一<code>ID</code>生成器特性:</p><ol><li>唯一性</li><li>高可用</li><li>高性能</li><li>递增性</li><li>安全性</li></ol></div><h1>超卖问题</h1><ul><li>原本库存为1，线程1查询后发现库存满足要求。要去扣除库存，但在此之前，线程2，线程3同时查询，发现库存充足。同样满足扣除库存的要求，此时产生了超卖问题</li><li><img src="https://gitee.com/sang3112/blog_imgs/raw/4de21bf55caff74e4e42766859d0389dca4b4b93/Redis/oversell.png" alt="oversell"></li></ul><h2 id="解决方法-加锁">解决方法: 加锁</h2><ol><li><p>乐观锁: 认为线程安全问题不一定发生，因此不加锁，只是在<strong>更新数据时判断有没有其他线程对数据进行了修改</strong></p><ul><li>如果没有修改则认为自己安全，才能更新数据</li><li>如果已经被其他线程修改说明发生了安全问题，此时重试或返回异常</li></ul></li><li><p>悲观锁: 认为线程安全问题一定会发生，因此操作数据之前先获取数据，确保线程串行执行。(性能差)</p><ul><li>比如<code>Synchronized、Lock</code>都是悲观锁</li></ul></li></ol><h3 id="乐观锁">乐观锁</h3><ol><li>版本号法<ul><li>用版本标识数据更新，如果版本<code>version</code>更新了，则表示数据已经被更新了。</li></ul></li><li>CAS法<ul><li>用之前查询到的数据判断是否存在相同的数据，如果不存在，则表示数据已经更新。实际上就是简化了版本字段。</li></ul></li></ol><div class="note info flat"><p>这样存在问题，因为如果有一百个线程，初始情况下<code>stock=100</code>，第一个线程首先执行查询，满足，然后修改数据库<code>stock - 1</code>。在修改数据库之前，其他线程查询<code>stock=100</code>，也满足查询条件，但是实际上查询数据库只有<code>stock=99</code>了，发现被修改了，因此直接错误退出。<br>所以应该使用<code>stock&gt;0</code>而不是等于前一个值</p></div><h1>分布式锁</h1><div class="note info flat"><ul><li>满足分布式系统或集群模式下<strong>多进程可见</strong>并且<strong>互斥的锁</strong></li></ul></div><h2 id="要求">要求</h2><ol><li>多进程可见即所有<code>JVM</code>可见</li><li>互斥</li><li>高可用</li><li>高性能</li><li>安全性</li></ol><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">MySQL</th><th style="text-align:center">Redis</th><th style="text-align:center">Zookeeper</th></tr></thead><tbody><tr><td style="text-align:center">互斥</td><td style="text-align:center">利用MySQL本身互斥锁机制</td><td style="text-align:center">利用SETNX互斥命令</td><td style="text-align:center">利用节点的唯一性和有序性实现互斥</td></tr><tr><td style="text-align:center">高可用</td><td style="text-align:center">好</td><td style="text-align:center">好</td><td style="text-align:center">好</td></tr><tr><td style="text-align:center">高性能</td><td style="text-align:center">一般</td><td style="text-align:center">好</td><td style="text-align:center">一般</td></tr><tr><td style="text-align:center">安全性</td><td style="text-align:center">断开连接，自动释放锁</td><td style="text-align:center">利用锁超市时间，到期释放</td><td style="text-align:center">临时节点，断开连接自动释放</td></tr></tbody></table><h2 id="基于Redis的分布式锁">基于<code>Redis</code>的分布式锁</h2><div class="note info flat"><p>分布式锁需要实现两个方法：获取锁和释放锁</p></div><p><img src="https://gitee.com/sang3112/blog_imgs/raw/4de21bf55caff74e4e42766859d0389dca4b4b93/Redis/distributedlock.png" alt="distributedlock"></p><ol><li>获取锁<ul><li>互斥: 确保只有一个线程能够获取锁<code>setnx lock thread1</code>，<code>expire lock 5</code></li><li>但是上面这种两条语句的方法不是原子的，有可能执行了一条后线程中断</li><li>可以使用<code>set lock thread1 nx ex 5</code>合并成一条语句</li></ul></li><li>释放锁<ul><li>手动释放: <code>del key</code></li><li>超时释放: 获取锁的时候设置超时时间</li></ul></li></ol><h3 id="Redisson分布式锁原理"><code>Redisson</code>分布式锁原理</h3><ol><li>可重入: 利用<code>hash</code>结构记录线程<code>ID</code>和重入次数</li><li>可重试: 利用信号量和<code>pubsub</code>功能实现等待、唤醒，获取锁失败的重试机制</li><li>超时续约: 利用<code>watchDog</code>，每隔一段时间重置超时时间</li></ol><h1><code>Redis</code>消息队列</h1><h2 id="基于List的消息队列的优缺点">基于<code>List</code>的消息队列的优缺点</h2><ul><li>优点:<ol><li>利用<code>Redis</code>存储，不受限与<code>JVM</code>内存上限</li><li>基于<code>Redis</code>持久化机制，保证数据安全性</li><li>满足消息有序性</li></ol></li><li>缺点:<ol><li>无法避免消息丢失</li><li>只支持单消费者</li></ol></li></ul><h2 id="基于PubSub的消息队列">基于<code>PubSub</code>的消息队列</h2><ul><li>发布订阅，一个消费者可以订阅一个或多个<code>channel</code>，生产者向对应的<code>channel</code>发送消息后，所有订阅者可以收到相关信息</li><li><code>subscribe channel [channel]</code>: 订阅一个或多个频道</li><li><code>publish channel msg</code>: 向一个频道发送消息</li><li><code>psubscribe pattern [pattern]</code>: 订阅与pattern格式匹配的所有频道</li><li>优点:<ol><li>采用发布订阅模型，支持多生产，多消费</li></ol></li><li>缺点:<ol><li>不支持持久化</li><li>无法避免消息丢失，不安全</li><li>消息堆积有上限，超出时数据丢失</li></ol></li></ul><h2 id="基于Stream的消息队列">基于<code>Stream</code>的消息队列</h2><ul><li>发送消息: <code>xadd key [NOMKSTREAM] [MAXLEN|MINID [=|~] threadhold [LIMIT count]] *|ID field value [field value ...]</code><ul><li><code>[NOMKSTREAM]</code>: 如果队列不存在，是否自动创建队列，默认是动创建</li><li><code>[MAXLEN|MINID [=|~] threadhold [LIMIT count]]</code>: 设置消息队列的最大消息数量</li><li><code>*|ID</code>: 消息的唯一<code>ID</code>，*代表由<code>Redis</code>自动生成，格式是<code>时间戳-递增数字</code></li><li><code>field value [field value ...]</code>: 发送到队列中的消息，称为<code>Entry</code>，格式就是多个键值对</li></ul></li><li>读取消息: <code>XREAD [COUNT count] [BLOCK milliseconds] STREAMS key[key ...] ID [ID ...]</code><ul><li><code>[COUNT count]</code>: 每次读取消息的最大数量</li><li><code>[BLOCK milliseconds]</code>: 没有消息时，是否阻塞，阻塞时长</li><li><code>STREAM key [key ...]</code>: 要从哪个队列读取消息，<code>key</code>就是队列名</li><li><code>ID [ID ...]</code>: 起始<code>ID</code>，只返回大于该<code>ID</code>的消息。0表示从第一条消息开始，$表示从最新的消息开始</li></ul></li></ul><p>指定<code>$</code>表示读取最新的消息，但是如果一下到来几条消息，依然只会读取最新的消息，导致漏读</p><ul><li>优点:<ol><li>消息可回溯</li><li>一个消息可以被多个消费者读取</li><li>可以阻塞读取</li></ol></li><li>缺点:<ol><li>有消息漏镀的风险</li></ol></li></ul><h3 id="消费者组">消费者组</h3><ul><li><p>将多个消费者划分到一个组中，监听同一个队列</p></li><li><p>特点:</p><ol><li>消息分流: 队列中的消息会分流给组内不同的消费者，不是重复的消费，从而加快消息处理的速度</li><li>消息标识: 消费者组维护一个标识，记录最后一个被处理的消息，哪怕消费者宕机，还会从标识之后读取消息，确保每一个消息都会被消费</li><li>消息确认: 消费者获取消息后，消息处于<code>pending</code>状态，存入<code>pending-list</code>。当处理完成后需要通过<code>XACK</code>来确认消息，标记消息为已处理，才会从<code>pending-list</code>中移除(可以确保所有的消息都能被消费到)</li></ol></li><li><p>创建消费者组: <code>xgroup create key groupName ID [MKSTREAM]</code></p><ul><li><code>key</code>: 队列名称</li><li><code>groupName</code>: 消费者组名称</li><li><code>ID</code>: 起始<code>ID</code>标识，<code>$</code>标识队列中最后一个消息，<code>0</code>标识队列中第一个消息</li><li><code>MKSTREAM</code>: 队列不存在时自动创建队列</li></ul></li><li><p>删除消费者组: <code>xgroup destroy key groupName</code></p></li><li><p>删除消费者组中指定的消费者: <code>xgroup delconsumer key groupname consumername</code></p></li><li><p>给指定的消费者组添加消费者: <code>xgroup createconsumer key groupname consumername</code></p></li><li><p>从消费者组读取消息: <code>xreadgroup GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] ID [ID ...]</code></p><ul><li><code>group</code>: 消费者组名称</li><li><code>consumer</code>: 消费者名称，如果消费者不存在，则会自动创建一个</li><li><code>count</code>: 本次查询的最大数量</li><li><code>BLOCK milliseconds</code>: 当没有消息时最长等待时间</li><li><code>NOACK</code>: 无需手动ACK，获取到消息后自动确认</li><li><code>STREAMS key</code>: 指定队列名称</li><li><code>ID</code>: 获取消息的起始ID<ul><li>‘&gt;’: 从下一个未消费的消息开始</li><li>其他: 根据指定ID从<code>pending-list</code>中获取已经消费但是没有确认的消息，比如0，是从<code>pending-list</code>中的第一个消息开始</li></ul></li></ul></li><li><p>特点:</p><ol><li>消息可回溯</li><li>可以多消费者争抢消息，加快消费速度</li><li>可以阻塞读取</li><li>没有消息漏读风险</li><li>有消息确认机制，保证消息至少被消费一次</li></ol></li></ul><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">List</th><th style="text-align:center">PubSub</th><th style="text-align:center">Stream</th></tr></thead><tbody><tr><td style="text-align:center">消息持久化</td><td style="text-align:center">支持</td><td style="text-align:center">-</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">阻塞读取</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">消息堆积处理</td><td style="text-align:center">受限于内存空间，可以利用多消费者加快处理</td><td style="text-align:center">受限于消费者缓冲区</td><td style="text-align:center">受限于队列长度，可以利用消费者组提高消费速度，减少堆积</td></tr><tr><td style="text-align:center">消息确认机制</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">消息回溯</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">支持</td></tr></tbody></table><h1><code>GEO</code></h1><ul><li><code>GEOADD</code>: 添加一个地理空间信息，包括经度、纬度、值</li><li><code>GEODIST</code>: 计算指定两个点之间的距离并返回</li><li><code>GEOHASH</code>: 将值的坐标转为哈希字符串形式并返回</li><li><code>GEOPOS</code>: 返回指定值的坐标</li><li><code>GEORADIUS</code>: 指定圆心、半径，找到院内包含的所有值，按照圆心之间的距离排序后返回，6.2版本以后废弃</li><li><code>GEOSEARCH</code>: 指定范围内搜索值，按照与指定点之间的距离排序后返回，范围可以是圆形或矩形</li><li><code>GEOSEARCHSTORE</code>: 与<code>GEOSEARCH</code>功能一致，不过可以把结果存储到一个指定的key中</li></ul><h1><code>BitMap</code></h1><ul><li><code>Redis</code>中使用<code>String</code>类型实现<code>BitMap</code>，最大上限512M，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup><mi>b</mi><mi>i</mi><mi>t</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">2^{32} bits</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32</span></span></span></span></span></span></span></span></span><span class="mord mathnormal">bi</span><span class="mord mathnormal">t</span><span class="mord mathnormal">s</span></span></span></span></li><li><code>SETBIT</code>: 向指定位置<code>offset</code>存入一个0 or 1</li><li><code>BITCOUNT</code>: 统计<code>BitMap</code>中值为1的<code>bit</code>位的数量</li><li><code>BITFIELD</code>: 操作<code>BitMap</code>中bit数组中的指定位置<code>offset</code>的值，实现了查询修改以及自增，一般用来查询</li><li><code>BITFIELD_RO</code>: 获取<code>BitMap</code>中bit数组，并以十进制形式返回</li><li><code>BITOP</code>: 将多个<code>BitMap</code>的结果位运算</li><li><code>BITPOS</code>: 查找bit数组中指定范围内第一个0 or 1出现的位置</li></ul><h1><code>HyperLogLog(HLL)</code></h1><ul><li><p><code>UV</code>: <code>Unique Visitor</code>独立访客量，通过互联网访问，浏览这个网页的自然人。一天内同一个用户多次访问，只记录一次</p></li><li><p><code>PV</code>: <code>Page View</code>页面访问量或点击量，用户没访问网站的一个页面，记录次<code>PV</code>，用来衡量网站的流量</p></li><li><p><code>UV</code>在服务端做会麻烦，因为要判断该用户是否统计过了，所以需要保存用户信息。但是如果每个访问的用户都保存到<code>Redis</code>中，则数据量很大</p></li><li><p><code>HLL</code>是一种概率算法，用于确定非常大的集合的基数，不需要存储其所有的值。基于<code>String</code>实现，单个<code>HLL</code>内存永远小于16K，测量结果是概率性的，误差小于81%。对于<code>UV</code>统计完全可以忽略</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;note info flat&quot;&gt;&lt;p&gt;全局唯一&lt;code&gt;ID&lt;/code&gt;: 经常会需要全局唯一&lt;code&gt;ID&lt;/code&gt;，比如订单表的生成。因为&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果&lt;code&gt;ID&lt;/code&gt;自增，则规律性太明显&lt;/li&gt;
&lt;li&gt;并</summary>
      
    
    
    
    <category term="Redis" scheme="https://sangs3112.github.io/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://sangs3112.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis笔记_0</title>
    <link href="https://sangs3112.github.io/posts/36df4688.html"/>
    <id>https://sangs3112.github.io/posts/36df4688.html</id>
    <published>2024-03-16T15:29:26.000Z</published>
    <updated>2024-03-23T00:16:00.121Z</updated>
    
    <content type="html"><![CDATA[<h1><code>SQL</code> VS <code>NoSQL</code></h1><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">SQL</th><th style="text-align:center">NoSQL</th></tr></thead><tbody><tr><td style="text-align:center">数据结构</td><td style="text-align:center">结构化</td><td style="text-align:center">非结构化</td></tr><tr><td style="text-align:center">数据关联</td><td style="text-align:center">关联的</td><td style="text-align:center">无关联</td></tr><tr><td style="text-align:center">查询方式</td><td style="text-align:center">SQL查询</td><td style="text-align:center">非SQL</td></tr><tr><td style="text-align:center">事务特性</td><td style="text-align:center">ACID</td><td style="text-align:center">BASE</td></tr><tr><td style="text-align:center">存储方式</td><td style="text-align:center">磁盘</td><td style="text-align:center">内存</td></tr><tr><td style="text-align:center">扩展性</td><td style="text-align:center">垂直</td><td style="text-align:center">水平</td></tr><tr><td style="text-align:center">使用场景</td><td style="text-align:center">数据结构固定且对安全性，一致性要求较高</td><td style="text-align:center">数据结构不固定，对一致性安全性要求不高，对性能有一定要求</td></tr></tbody></table><div class="note info flat"><p>特征:</p><ol><li>键值型，值支持多种不同的数据结构，功能丰富</li><li>单线程，每个命令具有原子性。现在多线程仅仅在网络连接请求方面，内部核心命令依然是单线程的</li><li>低延迟，速度快</li><li>支持数据持久化</li><li>支持主从集群，分片集群</li><li>支持多语言</li></ol></div><div class="note info flat"><p>为什么<code>Redis</code>单线程，但是速度快?</p><ol><li>基于内存(最重要的原因)</li><li>IO多路复用</li><li>使用C语言，良好的编码</li></ol></div><h1><code>Redis</code>安装</h1><p>使用<code>Docker</code>安装:</p><ol><li>在<code>docker-data/redis/</code>中执行命令<code>wget http://download.redis.io/redis-stable/redis.conf</code>下载config</li><li>修改权限</li><li>修改配置信息 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bind 127.0.0.1          # 注释掉这行，表示其他机器也可以链接</span><br><span class="line">protected-mode no       # 默认为yes，表示只允许本机的回环连接</span><br><span class="line">daemonize no            # 默认为no，不守护进程，不是docker部署需要改为yes</span><br><span class="line">                        # 如果是Docker部署不需要改为yes，因为docker run -d本身就是后台启动</span><br><span class="line">requirepass xxxxxx      # 密码</span><br><span class="line">appendonly yes          # 持久化</span><br><span class="line">port 6379               # 默认，监听的端口</span><br><span class="line">dir .                   # 默认，表示当前目录即为工作目录</span><br><span class="line">database 16             # 默认，表示数据库数量</span><br><span class="line">maxmemory 512mb         # 表示redis能使用的最大内存</span><br><span class="line"># logfile &quot;redis.log&quot;   # 日志文件，默认为空，表示不记录日志，存储在dir指定的目录中</span><br></pre></td></tr></table></figure></li><li>运行<code>Redis</code>: (网上的方法99%都是有问题的)以<code>redis:7.2.4-alpine3.19</code>为例</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name redis -p 6379:6379 -v /&#123;USER_DIR&#125;/docker-data/redis/redis.conf:/usr/local/etc/redis/redis.conf -v /&#123;USER_DIR&#125;/docker-data/redis:/data -d redis:7.2.4-alpine3.19 redis-server /usr/local/etc/redis/redis.conf --appendonly yes --requirepass xxxxxx</span><br></pre></td></tr></table></figure><h1>数据结构</h1><div class="note info flat"><p>通用命令:</p><ol><li><code>KEYS</code>: 查看所有符合模板的key，不建议在生产环境上使用，查询会阻塞其他线程</li><li><code>DEL</code>: 删除一个 or 多个指定的key</li><li><code>EXISTS</code>: 判断key是否存在</li><li><code>EXPIRE</code>: 给key设置有效期(秒)，到期自动删除</li><li><code>TTL</code>: 查看key的剩余有效期，-1表示永久有效， -2表示过期</li></ol></div><h2 id="基本类型">基本类型</h2><ol><li><p><code>String</code></p><ul><li>字符串底层都是字节数组的形式存储的，最大不能超过512M</li><li>格式又可以分为<code>string, int, float</code></li><li>但是对于<code>int, float</code>，都转为二进制的形式存储</li><li><code>Redis</code>的key允许多个单词形成层级结构，使用<code>:</code>分隔，即<code>项目名:业务名:类型:id</code></li></ul> <div class="note info flat"><p>常用命令:</p><ol><li><code>SET</code>: 添加或修改已经存在的一个<code>String</code>类型键值对</li><li><code>GET</code>: 根据key获取<code>String</code>类型的value</li><li><code>MSET, MGET</code>: 批量添加和批量获取多个<code>String</code>类型键值对</li><li><code>INCR</code>: 对int自增1</li><li><code>INCRBY</code>: 让整型的key自增并指定步长，比如<code>incrby num 2</code>表示让<code>num</code>自增2</li><li><code>INCRBYFLOAT</code>: 让float自增指定步长</li><li><code>SETNX</code>: 添加一个<code>String</code>类型键值对，前提是没有key，否则不执行</li><li><code>SETEX</code>: 添加一个<code>String</code>类型键值对，并指定有效期，<code>setex key 有效期 value</code></li></ol></div></li><li><p><code>Hash</code></p><ul><li>value是一个无序字段</li><li><code>String</code>将对象序列化以后存储，修改某个字段不方便。比如value为<code>&#123;name: Jack, age: 21&#125;</code></li><li><code>Hash</code>每个字段独立存储，可以单独处理</li></ul> <div class="note info flat"><p>常用命令:</p><ol><li><code>HSET key field value</code>: 添加或修改已经存在的一个<code>Hash</code>类型键值对</li><li><code>HGET key field</code>: 根据key获取<code>Hash</code>类型的value</li><li><code>HMSET, HMGET</code>: 批量添加和批量获取多个<code>Hash</code>类型键值对</li><li><code>HGETALL</code>: 获取一个<code>Hash</code>类型中所有的field</li><li><code>HKEYS</code>: 获取<code>Hash</code>类型中所有的field</li><li><code>HVALS</code>: 获取<code>Hash</code>类型中所有的value</li><li><code>HINCRBY</code>: 让<code>Hash</code>的key自增并指定步长</li><li><code>HSETNX</code>: 添加一个<code>Hash</code>类型key的field，前提是没有field，否则不执行</li></ol></div></li><li><p><code>List</code></p><ul><li>可以看作双向链表，有序、元素可以重复、插入删除速度快，但是<strong>查询速度一般</strong></li><li>朋友圈点赞，或评论列表</li></ul> <div class="note info flat"><p>常用命令:</p><ol><li><code>LPUSH key element ...</code>: 左侧插入一个 or 多个元素</li><li><code>LPOP key</code>: 左侧移除并返回第一个元素，没有就返回<code>nil</code></li><li><code>RPUSH key element ...</code>: 右侧插入一个 or 多个元素</li><li><code>RPOP key</code>: 右侧移除并返回第一个元素，没有就返回<code>nil</code></li><li><code>LRANGE key start end</code>: 返回一段角标范围内的所有元素</li><li><code>BLPOP</code>, <code>BRPOP</code>: 在没有元素时等待指定的时间，而不是直接范围<code>nil</code></li></ol></div></li><li><p><code>Set</code></p><ul><li>无序，元素不重复，查找快，支持交、并、差集</li></ul> <div class="note info flat"><p>常用命令:</p><ol><li><code>SADD key member</code>: 向<code>Set</code>中添加一个或者多个元素</li><li><code>SREM key member</code>: 移除<code>Set</code>中指定的元素</li><li><code>SCARD key</code>: 返回<code>Set</code>中元素的个数</li><li><code>SISMEMBER key memeber</code>: 判断一个元素是否存在于<code>Set</code>中</li><li><code>SMEMBERS</code>: 获取<code>Set</code>中所有的元素</li><li><code>SINTER key1 key2</code>: 求key1 和 key2的交集</li><li><code>SDIFF key1 key2</code>: 求key1 和 key2的差集</li><li><code>SUNION key1 key2</code>: 求key1 和 key2的并集</li></ol></div></li><li><p><code>SortedSet</code></p><ul><li>可排序集合，每个元素都带有<code>score</code>属性，底层是实现一个跳表和哈希表</li><li>可排序，不重复，查询速度快。用于实现排行榜</li></ul> <div class="note info flat"><p>常用命令:</p><ol><li><code>ZADD key score member</code>: 添加一个 or 多个元素，如果已经存在则更新<code>score</code></li><li><code>ZREM key member</code>: 移除指定的元素</li><li><code>ZSCORE key member</code>: 获取指定元素的<code>score</code>值</li><li><code>ZRANK key member</code>: 获取指定元素排名</li><li><code>ZSCARD key</code>: 返回元素的个数</li><li><code>ZCOUNT key min max</code>: 统计<code>score</code>在给定范围内元素的个数</li><li><code>ZINCRBY key increment member</code>: 让指定元素自增，步长为<code>incrememnt</code></li><li><code>ZRANGE key min max</code>: 按照<code>score</code>排序后，获取指定排名范围内的元素</li><li><code>ZRANGEBYSCORE key min max</code>: 按照<code>score</code>排序后，获取指定<code>score</code>范围内的元素</li><li><code>ZINTER key1 key2</code>: 求key1 和 key2的交集</li><li><code>ZDIFF key1 key2</code>: 求key1 和 key2的差集</li><li><code>ZUNION key1 key2</code>: 求key1 和 key2的并集</li><li>在<code>Z</code>后面添加<code>REV</code>即可实现降序</li></ol></div></li></ol><h2 id="特殊类型">特殊类型</h2><ol><li><code>GEO</code></li><li><code>BitMap</code></li><li><code>HyperLog</code></li></ol><h1>缓存更新策略</h1><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">内存淘汰</th><th style="text-align:center">超时剔除</th><th style="text-align:center">主动更新</th></tr></thead><tbody><tr><td style="text-align:center">说明</td><td style="text-align:center">不用自己维护，利用内存淘汰机制，内存不足时自动淘汰部分数据，下次查询时再更新</td><td style="text-align:center">给缓存数据添加TTL时间，到期后自动删除缓存，下次查询时更新缓存</td><td style="text-align:center">编写业务逻辑，修改数据库的同时更新缓存</td></tr><tr><td style="text-align:center">一致性</td><td style="text-align:center">差</td><td style="text-align:center">一般</td><td style="text-align:center">好</td></tr><tr><td style="text-align:center">维护成本</td><td style="text-align:center">无</td><td style="text-align:center">低</td><td style="text-align:center">高</td></tr></tbody></table><div class="note info flat"><ul><li>对于低一致性需求，使用内存淘汰机制。比如店铺类型这种修改频率很少的内容</li><li>对于高一致性需求，使用主动更新，并且将超时剔除作为兜底方案。比如店铺的详情、优惠券查询缓存</li></ul></div><h2 id="主动更新策略">主动更新策略</h2><ol><li><code>Cache Aside Pattern</code>: 由缓存调用者在更新数据库的同时更新缓存<ul><li>可控性更高，用的更多</li></ul></li><li><code>Read/ Write Through Pattern</code>: 缓存与数据库整合为一个服务，由服务来维护一致性。<strong>调用者调用该服务，无需关心缓存一致性问题</strong></li><li><code>Write Behind Caching Pattern</code>: <strong>调用者只操作缓存</strong>，由其他线程异步将缓存数据持久化到数据库，最终保持一致<ul><li>需要维护异步线程</li><li>一致性难以保证</li></ul></li></ol><h3 id="Cache-Aside-Pattern"><code>Cache Aside Pattern</code></h3><ol><li>删除缓存和更新缓存的选择<ul><li>更新缓存：每次更新数据库都要更新缓存，如果对应的是写多读少的环境，则会产生大量的无效写操作</li><li>删除缓存：每次更新数据库时都让缓存失效，查询时再更新缓存，延迟加载，有效更新更多，因此用的更多</li></ul></li><li>如果保证缓存与数据库的操作同时成功或失败<ul><li>单体系统，将缓存与数据库放在一个事务中</li><li>分布式系统，就需要利用<code>TCC</code>分布式事务方案</li></ul></li><li>先操作缓存还是操作数据库(线程安全问题)<ul><li><p>初始缓存和数据库内容均为10</p></li><li><p>先删除缓存再操作数据库:</p><ul><li><p>线程1删除缓存，线程1更新数据库=20</p></li><li><p>线程2查询缓存未命中，查询数据库得到20，并写入缓存。正常</p></li><li><p><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Redis/cachesqlright.png" alt="cachesqlright"></p></li><li><p>线程1删除缓存</p></li><li><p>线程2查询缓存未命中，查询数据库得到10，并写入缓存</p></li><li><p>线程1更新数据库=20。异常(<strong>概率高</strong>)</p></li><li><p><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Redis/cachesqlerror.png" alt="cachesqlerror"></p></li></ul></li><li><p><strong>先操作数据库再删缓存</strong></p><ul><li><p>线程2更新数据库=20，再删除缓存</p></li><li><p>线程1查询缓存未命中，查询数据库得到20，并写入缓存。正常</p></li><li><p><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Redis/sqlcacheright.png" alt="sqlcacheright"></p></li><li><p>假设<strong>缓存失效了</strong>，线程1查询缓存未命中，查询数据库得到10</p></li><li><p>线程2更新数据库=20，删除缓存</p></li><li><p>线程1写入缓存=10。异常(<strong>概率低</strong>)</p></li><li><p><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Redis/sqlcacheerror.png" alt="sqlcacheerror"></p></li></ul></li></ul></li></ol><div class="note info flat"><ul><li>因此，<strong>先操作数据库再删缓存</strong>用的更多一些，可以加上超时剔除策略兜底<ul><li>读操作:<ul><li>缓存命中则直接返回</li><li>缓存未命中则查询数据库，写入缓存，设定超时时间</li></ul></li><li>写操作：<ul><li>先写数据库，然后删除缓存</li><li>确保数据库与缓存操作的原子性</li></ul></li></ul></li></ul></div><h1>缓存穿透</h1><ul><li>客户端请求的数据在缓存和数据库中都不存在，则永远不会生效，请求永远会打到数据库中</li></ul><h2 id="解决办法">解决办法</h2><ol><li>缓存空对象<ul><li>优点: 实现简单，维护方便</li><li>缺点:<ul><li>额外内存消耗，可以设置短的TTL进行过期删除</li><li>可能造成短期的不一致性，也可以通过短的TTL缓解</li></ul></li></ul></li><li>布隆过滤器<ul><li>客户端请求的时候先请求布隆过滤器，如果存在则放行，不存在则直接拒绝</li><li>布隆过滤器判断不存在说明一定不存在，判断存在但是不一定真的存在，如果实际上不存在，则又发生了穿透</li><li>优点: 内存占用小，没有多余的key</li><li>缺点:<ul><li>实现复杂</li><li>存在误判</li></ul></li></ul></li><li>增加id的复杂度，避免被猜测规律</li><li>数据基础格式校验</li><li>热点参数限流</li></ol><h1>缓存雪崩</h1><ul><li>同一时段大量的缓存同时失效，或者<code>Redis</code>服务宕机，导致大量请求到达服务器，带来巨大压力</li></ul><h2 id="解决办法-2">解决办法</h2><ol><li>给不同的key添加<code>TTL</code>随机值</li><li>利用<code>Redis</code>集群提高可用性</li><li>给缓存业务添加降级限流策略</li><li>给业务添加多级缓存</li></ol><h1>缓存击穿(热点key问题)</h1><ul><li>被高并发访问并且缓存重建业务比较复杂的key失效了，无数请求访问会在瞬间给数据库带来巨大的冲击</li></ul><h2 id="解决办法-3">解决办法</h2><ol><li>互斥锁<ul><li>只有获取锁的人才能重建缓存，其他人就休眠一会再重试</li><li>会出现互相等待的问题，只有一个在获取数据，其他都在等待</li><li><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Redis/lock.png" alt="lock"></li></ul></li><li>逻辑过期<ul><li>不设置<code>TTL</code>，只设置逻辑过期时间，其他用户发现逻辑过期了，就开启独立新线程，查询<strong>数据库数据</strong>，重置逻辑时间</li><li>其他人在没有得到互斥锁的时候直接返回<strong>旧缓存数据</strong></li><li><img src="https://gitee.com/sang3112/blog_imgs/raw/master/Redis/logicexpire.png" alt="logicexpire"></li></ul></li></ol><table><thead><tr><th style="text-align:center">方案</th><th style="text-align:center">优点</th><th style="text-align:center">缺点</th></tr></thead><tbody><tr><td style="text-align:center">互斥锁</td><td style="text-align:center">乜有额外内存消耗；保证一致性；实现简单</td><td style="text-align:center">线程需要等待，性能受影响；有死锁风险</td></tr><tr><td style="text-align:center">逻辑过期</td><td style="text-align:center">线程无需等待，性能较好</td><td style="text-align:center">不能保证一致性；有额外内存消耗；实现复杂</td></tr></tbody></table><div class="note info flat"><ul><li>因此互斥锁和逻辑过期两种方案实际上是<strong>一致性和可用性</strong>之间的取舍</li></ul></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;code&gt;SQL&lt;/code&gt; VS &lt;code&gt;NoSQL&lt;/code&gt;&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;SQL&lt;/</summary>
      
    
    
    
    <category term="Redis" scheme="https://sangs3112.github.io/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://sangs3112.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>MySQL笔记_5</title>
    <link href="https://sangs3112.github.io/posts/572df2c5.html"/>
    <id>https://sangs3112.github.io/posts/572df2c5.html</id>
    <published>2024-03-15T11:39:00.000Z</published>
    <updated>2024-03-23T00:16:00.121Z</updated>
    
    <content type="html"><![CDATA[<h1>日志</h1><div class="note info flat"><ul><li><code>MySQL</code>中日志分为四类: 错误日志、二进制日志、查询日志、慢查询日志</li></ul></div><h2 id="错误日志">错误日志</h2><ul><li>记录了当<code>mysqld</code>启动和停止时，以及服务器在运行过程中发生的任何<strong>严重错误</strong>时的相关信息。服务器出现故障无法使用就看这个日志</li><li>默认开启，存放在<code>/var/log/</code>中，日志文件名为<code>mysqld.log</code></li><li>查看错误日志位置: <code>show variables like '%log_error%';</code></li></ul><h2 id="二进制日志">二进制日志</h2><ul><li><code>binlog</code>记录了所有的<code>DDL, DML</code>语句，<strong>不包含查询语句</strong></li><li><code>binlog</code>默认开启，查看二进制日志位置: <code>show variables like '%log_bin%';</code></li></ul><h3 id="作用">作用</h3><ol><li>灾难时数据恢复</li><li><code>MySQL</code>主从复制</li></ol><h3 id="日志格式">日志格式</h3><ul><li>查看二进制的日志格式: <code>show variables like '%binlog_format%';</code></li></ul><table><thead><tr><th style="text-align:center">日志格式</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">STATEMENT</td><td style="text-align:center">基于<code>SQL</code>语句的日志记录，记录<code>SQL</code>语句，对数据进行修改的<code>SQL</code>都会记录在日志文件中</td></tr><tr><td style="text-align:center">ROW</td><td style="text-align:center">基于行的日志记录，记录的是每一行的数据变更(默认)</td></tr><tr><td style="text-align:center">MIXED</td><td style="text-align:center">混合了STATEMENT与ROW两种格式，默认采用STATEMENT，某些情况下会自动切换为ROW记录</td></tr></tbody></table><div class="note info flat"><ul><li>如果要修改二进制文件的日志格式，就去修改<code>/etc/my.cnf</code>，添加<code>binlog_format=STATMENT</code>后，使用<code>systemctl restart mysqld</code>重新启动服务即可</li></ul></div><h3 id="查看二进制日志">查看二进制日志</h3><p><code>mysqlbinlog [参数] binlog文件名</code><br>参数:<br>-d  指定数据库名称，只列出指定数据库的相关操作<br>-o  忽略日志中前n行命令<br>-v  将行事件(数据变更)重构为<code>SQL</code>语句<br>-vv 将行事件(数据变更)重构为<code>SQL</code>语句，并输出注释信息</p><h3 id="删除二进制日志">删除二进制日志</h3><p>配置二进制日志的过期时间，到了过期时间会自动删除: <code>show variables like '%binlog_expire_logs_seconds%';</code></p><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">reset master</td><td style="text-align:center">删除全部的binlog日志，删除之后日志编号从binlog.000001重新开始</td></tr><tr><td style="text-align:center">purge master logs to ‘binlog.******’</td><td style="text-align:center">删除******之前的所有日志</td></tr><tr><td style="text-align:center">purge master logs before ‘yyyy-mm-dd hh24:mm:ss’</td><td style="text-align:center">删除日志为’yyyy-mm-dd hh24:mm:ss’之前产生的所有日志</td></tr></tbody></table><h2 id="查询日志">查询日志</h2><ul><li>查询日志中记录了客户端的<strong>所有</strong>操作语句，而二进制日志不包含查询语句。</li><li><strong>默认未开启</strong>，使用<code>show variables like '%general%';</code>查看</li></ul><div class="note info flat"><p>按照如下方式修改<code>/etc/my.cnf</code>可以打开查询日志</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">general_log=1</span><br><span class="line">general_log_file=mysql_query.log # 设置日志的文件名，如果没有指定则默认为host_name.log</span><br></pre></td></tr></table></figure><p><code>systemctl restart mysqld</code> # 重启mysql服务</p></div><h2 id="慢查询日志">慢查询日志</h2><ul><li>记录所有执行时间超过参数<code>long_query_time</code>，并且扫描记录数不小于<code>min_examined_row_limit</code>的所有<code>SQL</code>语句的日志，<strong>默认未开启</strong>。</li><li><code>long_query_time</code>默认10秒，最小为0，默认文件名为<code>localhost-slow.log</code></li><li>慢查询默认不会记录管理语句，也不会记录不使用索引进行的查询语句。使用<code>log_slow_admin_statements</code>和<code>log_queries_not_using_indexes</code>更改此行为，即  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 记录执行较慢的管理语句</span><br><span class="line">log_slow_admin_statements=1</span><br><span class="line"># 记录执行较慢的未使用索引的语句</span><br><span class="line">log_queries_not_using_indexes=1</span><br></pre></td></tr></table></figure></li></ul><h1>主从复制</h1><ul><li>主从复制就是将主数据库的<code>DDL, DML</code>语句通过<strong>二进制日志</strong>传到从库服务器中，然后在从库上对这些日志重新执行(重做)，从而使主从库数据同步</li><li><code>MySQL</code>支持一台主库同时向多台从库进行复制，从库也可以作为其他服务器的主库，实现链状复制</li></ul><h2 id="优点">优点</h2><ol><li>主库出现问题，快速切换从库提供服务(高可用)</li><li>实现读写分离，降低主库访问压力</li><li>在从库备份，避免备份期间影响主库服务</li></ol><h2 id="原理">原理</h2><p>主数据库执行<code>DML, DDL</code>语句后，会写入<code>binlog</code>日志中。此时从数据库的<code>IOthread</code>会读取主数据库的<code>binlog</code>，写入自己的中继日志<code>Relay log</code>中，然后从数据库的<code>SQLthread</code>会读取<code>Relay log</code>，并重做其中的<code>DML, DDL</code>语句，实现主从复制</p><div class="note info flat"><p>主从复制分三步:</p><ol><li>Master 在事务提交时，把数据变更记录在二进制日志文件<code>binlog</code>中</li><li>从库读取主库的<code>binlog</code>，写入到从库的中继日志<code>Relay Log</code>中</li><li>slave重做中继日志的事件，改变自己的数据</li></ol></div><h2 id="主库配置">主库配置</h2><ol><li>修改<code>/etc/my.cnf</code> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># MySQL服务ID，保证集群环境中唯一，取值范围为(1 ~ 2^32-1)，默认为1</span><br><span class="line">server-id=1</span><br><span class="line"># 是否只读，1表示只读，0表示读写</span><br><span class="line">read-only=0</span><br><span class="line"># 忽略的数据，指不需要同步的数据库</span><br><span class="line"># binlog-ignore-db=mysql</span><br><span class="line"># 指定同步的数据库</span><br><span class="line"># binlog-do-db=db01</span><br><span class="line"># 不指定这两个设置，则表示所有数据库都需要同步</span><br></pre></td></tr></table></figure></li><li>重启mysql服务: <code>systemctl restart mysqld</code></li><li>登录mysql，创建远程连接账号，授予主从复制权限 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 创建用户，并设置密码，可以在任意主机连接mysql服务</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">with</span> mysql_native_password <span class="keyword">by</span> <span class="string">&#x27;密码&#x27;</span>;</span><br><span class="line"># 为用户分配主从复制权限</span><br><span class="line"><span class="keyword">grant</span> replication slave <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li>查看二进制日志坐标: <code>show master status;</code> <div class="note info flat"><p>字段含义:<br>file: 从哪个日志文件开始推送<br>position: 从日志文件的哪个位置开始推送日志<br>binlog_ignore_db: 指定不需要同步的数据库</p></div></li></ol><h2 id="从库配置">从库配置</h2><ol><li>修改<code>/etc/my.cnf</code> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># MySQL服务ID，保证集群环境中唯一，取值范围为(1 ~ 2^32-1)，和主库不一样即可</span><br><span class="line">server-id=2</span><br><span class="line"># 是否只读，1表示只读，0表示读写</span><br><span class="line">read-only=1</span><br></pre></td></tr></table></figure> <div class="note info flat"><ul><li>从库的<code>read-only=1</code>表示从库只需要查询即可</li><li>但是这个只读只是针对普通用户权限，对超级管理员仍然是可写</li><li>如果需要禁止超级管理员的写权限，则需要在<code>/etc/my.cnf</code>中再指定一个<code>super-read-only=1</code>参数</li></ul></div></li><li>重启mysql服务: <code>systemctl restart mysqld</code></li><li>登录从库的mysql，设置主库配置 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">change replication source <span class="keyword">to</span> source_host<span class="operator">=</span><span class="string">&#x27;主机ip&#x27;</span>, source_user<span class="operator">=</span><span class="string">&#x27;用户名&#x27;</span>, source_password<span class="operator">=</span><span class="string">&#x27;密码&#x27;</span>, source_log_file<span class="operator">=</span><span class="string">&#x27;同步的日志文件&#x27;</span>, source_log_pos<span class="operator">=</span>日志文件开始同步的位置; <span class="comment">--8.0.23</span></span><br><span class="line"></span><br><span class="line">change master <span class="keyword">to</span> master master_host<span class="operator">=</span><span class="string">&#x27;主机ip&#x27;</span>, master_user<span class="operator">=</span><span class="string">&#x27;用户名&#x27;</span>, master_password<span class="operator">=</span><span class="string">&#x27;密码&#x27;</span>, master_log_file<span class="operator">=</span><span class="string">&#x27;同步的日志文件&#x27;</span>, master_log_pos<span class="operator">=</span>日志文件开始同步的位置; <span class="comment">--8.0.23之前</span></span><br></pre></td></tr></table></figure></li><li>开启同步 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> replica; <span class="comment">--8.0.22</span></span><br><span class="line"><span class="keyword">start</span> slave; <span class="comment">--8.0.22之前</span></span><br></pre></td></tr></table></figure></li><li>查看主从同步状态 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> replica status; <span class="comment">--8.0.22</span></span><br><span class="line"><span class="keyword">show</span> slave status; <span class="comment">--8.0.22之前</span></span><br></pre></td></tr></table></figure> <div class="note info flat"><ul><li>文件显示比较乱，可以在后面加上\G，就会按行显示:<code>show replica status\G;</code></li><li>主要看两行:<ul><li><code>Replica_IO_Running: Yes</code></li><li><code>Replica_SQL_Running: Yes</code></li><li>只要这两行开启了，主从复制就没有问题</li></ul></li></ul></div></li></ol><h1>分库分表</h1><div class="note info flat"><ol><li>IO瓶颈: 热点数据太多，数据库缓存不足，产生大量磁盘I/O，请求数据太多，带宽不够</li><li>CPU瓶颈: 排序、分组、连接查询、聚合统计等<code>SQL</code>会消耗大量的CPU资源，请求数太多，CPU出现瓶颈</li></ol></div><ul><li><p>拆分维度分为垂直拆分和水平拆分，拆分粒度方面分为分库和分表</p><ol><li><strong>垂直分库</strong>: 以<strong>表</strong>为依据，将不同的业务拆分到不同数据库中<br>特点: 每个库<strong>表结构不一样</strong>、库中数据不同，所有库的并集才是全部的数据</li><li>垂直分表: 以<strong>字段</strong>为依据，根据字段属性将不同字段拆分到不同的表中<br>特点: 每个<strong>表结构不一样</strong>、每个表的数据不同，一般通过一列(主键/外键)关联、所有表的并集是全部数据</li><li>水平分库: 以<strong>字段</strong>为依据，将一个库的数据拆分到多个库中<br>特点: 每个<strong>库表结构一样</strong>、每个库数据不同、所有库的并集是全部的数据</li><li><strong>水平分表</strong>: 以<strong>字段</strong>为依据，将一个表的数据拆分到多个表中<br>特点: 每个表的<strong>表结构一样</strong>、每个表的数据不同、所有表的并集是全部的数据</li></ol>  <div class="note info flat"><ul><li><code>shardingJDBC</code>: 基于<code>AOP</code>，在应用程序对本地执行的<code>SQL</code>进行拦截，解析，改写，路由处理。只支持<code>Java</code>，性能好</li><li><code>MyCat</code>: 数据库分库分表的中间件，不用调整代码即可实现分库分表，支持多种语言</li><li>使用<code>mysql</code>一样的链接命令可以登录<code>mycat</code>，只有端口不一样，<code>mycat</code>端口是8066</li></ul></div></li></ul><h2 id="MyCat结构"><code>MyCat</code>结构</h2><ul><li><p>所有数据都存储在<strong>物理结构</strong>内<br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/MySQL/Mycat.png" alt="MyCat"></p></li><li><p>分片规则决定了某个数据应该插入到哪一个库的表中，一般水平分表的时候需要指定，默认是<code>auto-sharding-long</code>，其中规则为:根据id选择对应的数据库，但是如果超过了1500万，则直接报错</p></li></ul><h2 id="MyCat配置"><code>MyCat</code>配置</h2><ol><li><code>schema.xml</code>包含三组标签: <code>schema, datanode, datahost</code><ul><li><code>schema</code>核心属性:<ul><li><code>name</code>: 指定自定义的逻辑库库名</li><li><code>checkSQLschema</code>: 在<code>SQL</code>语句操作时指定了数据库名称，执行时是否自动去除。如果为<code>true</code>，表示第一次指定一下，后面就可以不用再指定数据库名称了。如果为<code>false</code>，则表明需要使用<code>use 数据库名;</code>进行指定</li><li><code>sqlMaxLimit</code>: 如果没有指定<code>limit</code>进行查询，列表查询模式返回查询了多少条记录</li></ul></li><li><code>schema.table</code>核心属性:<ul><li><code>name</code>: 定义逻辑表表名，在该逻辑库下唯一</li><li><code>dataNode</code>: 定义逻辑表所属的<code>dataNode</code>，需要与<code>dataNode</code>标签中的<code>name</code>对应，多个<code>dataNode</code>使用逗号分割</li><li><code>rule</code>: 分片规则名字，在<code>rule.xml</code>中定义</li><li><code>primaryKey</code>: 逻辑表对应真实表的主键</li><li><code>type</code>: 逻辑表的类型，只有全局表和普通表，默认为普通表。</li></ul></li><li><code>dataNode</code>核心属性:<ul><li><code>name</code>: 定义数据节点名称</li><li><code>dataHost</code>: 数据库实例主机名称，引用自<code>dataHost</code>标签中的<code>name</code>属性</li><li><code>database</code>: 定义分片需要的数据库</li></ul></li><li><code>dataHost</code>核心属性:<ul><li><code>name</code>: 唯一标识，供上层标签使用</li><li><code>maxCon/minCon</code>: 最大/最小连接数</li><li><code>balance</code>: 负载均衡策略，取值0,1,2,3</li><li><code>writeType</code>: 写操作分发方式，0表示写操作转发到第一个<code>writeHost</code>，第一个挂了就转发到第二个，1表示写操作随机分发到配置的<code>writeHost</code></li><li><code>dbDriver</code>: 数据库驱动，支持<code>native, jdbc</code></li></ul></li></ul></li><li><code>ruler.xml</code>包含两类标签: <code>tableRule、function</code></li><li><code>server.xml</code>主要包含两个标签: <code>system、user</code></li></ol><h2 id="MyCat分片"><code>MyCat</code>分片</h2><div class="note info flat"><ul><li>字典表类型的表可以设置成全局表</li></ul></div><h3 id="分片规则">分片规则</h3><ol><li>范围分片<code>auto-sharding-long</code></li><li>取模<code>mod-long</code></li><li>枚举<code>sharding-by-intfile-enumstatus</code></li><li>一致性哈希<code>sharding-by-murmur</code>: 计算指定的哈希值，根据哈希值计算落在哪一个逻辑表中。相同的哈希因子计算值总是划分到相同的分区表中，不会因为分区节点的增加而改变原来数据的分区位置</li><li>应用指定<code>sharding-by-substring</code>: 运行阶段由应用自主决定路由到哪个分片，并直接根据字符子串(必须是数字)计算分片号</li><li>固定分片哈希算法<code>sharding-by-long-hash</code>: 类似于十进制取模，但是为二进制操作。比如取低10位和1111111111进行位<code>&amp;</code>运算。分片长度最大默认为1024</li><li>字符串哈希解析<code>sharding-by-stringhash</code>: 截取子字符串，进行哈希算法，与<code>1023</code>进行位<code>&amp;</code>运算得出分片</li><li>按天分片<code>sharding-by-date</code></li><li>按月份分片<code>sharding-by-month</code></li></ol><h3 id="固定分片哈希算法-VS-取模">固定分片哈希算法 VS 取模</h3><ol><li>取模运算连续的值会分配到不同的分片，固定分片哈希算法中连续的值会分配到相同的分片，降低事务处理难度</li><li>固定分片哈希算法既可以均匀分配，也可以不均匀分配</li><li>分片字段必须是数字</li></ol><h2 id="MyCat管理"><code>MyCat</code>管理</h2><div class="note info flat"><ul><li>默认有两个端口，分别是8066和9066<ul><li>8066是数据访问端口，进行<code>DML</code>以及<code>DDL</code>操作</li><li>9066是数据库管理端口，即<code>MyCat</code>的服务管理控制功能，用于管理<code>MyCat</code>的整个集群状态</li></ul></li></ul></div><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">show @@help</td><td style="text-align:center">查看管理工具帮助文档</td></tr><tr><td style="text-align:center">show @@version</td><td style="text-align:center">查看mycat的版本</td></tr><tr><td style="text-align:center">reload @@config</td><td style="text-align:center">重新加载mycat的配置文件</td></tr><tr><td style="text-align:center">show @@datasource</td><td style="text-align:center">查看mycat的数据源信息</td></tr><tr><td style="text-align:center">show @@datanode</td><td style="text-align:center">查看mycat现有的分片节点信息</td></tr><tr><td style="text-align:center">show @@threadpool</td><td style="text-align:center">查看mycat线程池信息</td></tr><tr><td style="text-align:center">show @@sql</td><td style="text-align:center">查看执行的sql</td></tr><tr><td style="text-align:center">show @@sql.sum</td><td style="text-align:center">查看执行的sql统计</td></tr></tbody></table><h1>读写分离</h1><ul><li><p>主库写，从库读，配置<code>MyCat</code>的<code>writeHost</code>以及<code>readHost</code></p></li><li><p>读写分离需要修改<code>balance=1 or 3</code>，问题在于主库宕机了，就只能进行查询了(不满足高可用性)</p><table><thead><tr><th style="text-align:center">参数值</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">不开启读写分离机制，所有读操作发送到当前可用的writeHost上</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">全部的readHost与备用的writeHost都参与select语句的负载均衡(主要针对双主双从)</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">所有的读写操作都随机在writeHost，readHost上分发 (没有读写分离)</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">所有的读请求随机分发到writeHost对应的readHost上执行，writeHost不负担读压力</td></tr></tbody></table></li><li><p>为了避免主数据库挂了以后服务宕机的问题，可以使用<strong>双主双从</strong>的设置。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;日志&lt;/h1&gt;
&lt;div class=&quot;note info flat&quot;&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;MySQL&lt;/code&gt;中日志分为四类: 错误日志、二进制日志、查询日志、慢查询日志&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id=&quot;错误日志&quot;&gt;错误日志&lt;/h2&gt;
</summary>
      
    
    
    
    <category term="MySQL" scheme="https://sangs3112.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://sangs3112.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL笔记_4</title>
    <link href="https://sangs3112.github.io/posts/202ac253.html"/>
    <id>https://sangs3112.github.io/posts/202ac253.html</id>
    <published>2024-03-15T09:22:00.000Z</published>
    <updated>2024-03-23T00:16:00.121Z</updated>
    
    <content type="html"><![CDATA[<h1>锁</h1><p><img src="https://gitee.com/sang3112/blog_imgs/raw/master/MySQL/lock.png" alt="lock"></p><h2 id="全局锁">全局锁</h2><div class="note info flat"><ul><li>锁整个数据库的，加锁后<strong>数据库只读</strong>。后续的<code>DML</code>、<code>DDL</code>包括已经更新操作的事务提交都被阻塞</li><li>应用场景:数据库逻辑备份，获得一致性视图，保证完整性</li></ul></div><ul><li><p>加全局锁: <code>flush tables with read lock;</code></p></li><li><p>数据库备份: <code>musqldump -u用户名 -p密码 数据库名 &gt; 路径/数据库名.sql</code></p></li><li><p>解锁: <code>unlock tables;</code></p>  <div class="note info flat"><ul><li>数据库备份的<code>mysqldump</code>命令只是一个工具，不是<code>mysql</code>内部的命令，因此不能在<code>mysql</code>界面中使用。在控制台使用即可，如果备份远程数据库，则需要使用<code>-h 设置ip</code></li></ul></div></li><li><p>缺点:</p><ol><li>主库上备份，则备份期间业务停摆，无法更新</li><li>从库上备份，则备份期间主库可以更新，但是从库无法执行主库同步的二进制日志(<code>binlog</code>)，导致主从延迟</li></ol>  <div class="note info flat"><ul><li><code>InnoDB</code>引擎中为了解决这个问题，加上<code>--single-transaction</code>参数完成不加锁的一致性备份。</li><li><code>mysqldump --single-transaction -u用户 -p密码 数据库名 &gt; 路径/数据库名.sql</code></li><li>实际上通过<strong>快照读</strong>实现，这种方式<strong>不需要</strong>添加全局锁</li></ul></div></li></ul><h2 id="表级锁">表级锁</h2><div class="note info flat"><ul><li>每次锁住整张表，粒度大，<strong>锁冲突的概率最高，并发度最低</strong>。</li><li>表级锁分三类:表锁、元数据锁(MDL)、意向锁</li></ul></div><h3 id="表锁">表锁</h3><div class="note info flat"><ul><li>表锁分两类: 表共享读锁(read lock)、表独占写锁(write lock)<ol><li>表共享读锁，<strong>所有人都只能看，不能写入</strong></li><li>表独占写锁，<strong>其他人不能看也不能写，加锁的人可读可写</strong></li></ol></li></ul></div><ul><li>加锁: <code>lock tables 表名... read / write</code></li><li>解锁: <code>unlock tables;</code>或者关闭客户端</li></ul><h3 id="元数据锁">元数据锁</h3><div class="note info flat"><ul><li>系统自动控制，无需显式使用，访问表的时候自动加上</li><li>维护表元数据的一致性，在表有活动事务的时候，不能对元数据进行写入</li><li>为了<strong>避免<code>DML</code>和<code>DDL</code>的冲突</strong>，保证读写的正确性</li><li>在对一张表进行增删改查，自动加<code>MDL</code>共享读锁</li><li>在对表结构变更的时候，自动加<code>MDL</code>独占写锁</li><li>查看元数据锁: <code>select object_type, object_schema, object_name, lock_type, lock_duration from performance_schema.metadata_locks;</code></li></ul></div><table><thead><tr><th style="text-align:center">对应SQL</th><th style="text-align:center">锁类型</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">lock tables xxx read / write</td><td style="text-align:center">SHARED READ ONLY / SHARED NO READ WRITE</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">select、select … lock in share mode</td><td style="text-align:center">SHARED READ</td><td style="text-align:center">与SHARED READ，SHARED WRITE兼容，与EXCLUSIVE互斥</td></tr><tr><td style="text-align:center">insert、update、delete、select…for update</td><td style="text-align:center">SHARED WRITE</td><td style="text-align:center">与SHARED READ，SHARED WRITE兼容，与EXCLUSIVE互斥</td></tr><tr><td style="text-align:center">alter table …</td><td style="text-align:center">EXCLUSIVE</td><td style="text-align:center">与其他MDL都互斥</td></tr></tbody></table><h3 id="意向锁">意向锁</h3><div class="note info flat"><ul><li>A更新某一行，添加了行锁，B同时想加表锁。这个时候，需要B一行一行检查是否存在行锁，性能极低。</li><li>为了减少<code>DML</code>在执行时，加的<strong>行锁和表锁的冲突</strong>，在<code>InnoDB</code>中引入了意向锁。</li><li>意向锁不用检查每行是否加锁，可以减少表锁的检查。</li><li>A更新某一行，添加了行锁，然后会对表添加意向锁。B同时想加表锁， 就先去检查是否存在意向锁。</li><li>意向锁分为两类: 意向共享锁(IS)、意向排他锁(IX)</li><li>查看<strong>意向锁以及行锁</strong>: <code>select object_schema, object_name, index_name, lock_type, lock_mode, lock_data from performance_schema.data_locks;</code></li></ul></div><ol><li><p>意向共享锁(IS)</p><ul><li>由语句<code>select ... lock in share mode</code>添加</li><li>与表锁中的共享锁(read)兼容，与表锁排他锁(write)互斥</li><li><code>select * form score where id=1 lock in share mode;</code>会加上行共享锁，同时会添加意向共享锁</li></ul></li><li><p>意向排他锁(IX)</p><ul><li>由语句<code>insert、update、delete、select ... for update</code>添加</li><li>与表锁共享锁(read)以及排他锁(write)都互斥，意向锁之间不互斥</li><li><code>update score set math=66 where id = 1</code>会加上行锁，同时会添加意向排他锁。</li></ul></li></ol><h2 id="行级锁">行级锁</h2><div class="note info flat"><ul><li>每次锁住对应的行，粒度小，<strong>锁冲突的概率最低，并发度最高</strong>。</li><li><code>InnoDB</code>数据基于索引组织，行锁通过对索引上的<strong>索引项加锁</strong>实现，<strong>不是对记录加锁</strong>。</li><li>行级分三类: 行锁、间隙锁、临键锁</li></ul></div><h3 id="行锁">行锁</h3><div class="note info flat"><ul><li>锁定单个行记录，防止其他事务进行<code>update</code>或<code>delete</code>，在<code>RC</code>,<code>RR</code>下都支持</li><li>行锁分两类: 共享锁(S)、排他锁(X)</li></ul></div><ol><li><p>共享锁(S)</p><ul><li>允许一个事务读一行，阻止其他事物获得相同数据集的排他锁</li></ul></li><li><p>排他锁(X)</p><ul><li>允许获取排他锁的事务更新数据，阻止其他事物获得相同数据集的排他锁和共享锁</li></ul></li></ol><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">共享锁</th><th style="text-align:center">排他锁</th></tr></thead><tbody><tr><td style="text-align:center">共享锁</td><td style="text-align:center">兼容</td><td style="text-align:center">冲突</td></tr><tr><td style="text-align:center">排他锁</td><td style="text-align:center">冲突</td><td style="text-align:center">冲突</td></tr></tbody></table><table><thead><tr><th style="text-align:center">SQL</th><th style="text-align:center">行锁类型</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">INSERT</td><td style="text-align:center">排他锁</td><td style="text-align:center">自动加锁</td></tr><tr><td style="text-align:center">UPDATE</td><td style="text-align:center">排他锁</td><td style="text-align:center">自动加锁</td></tr><tr><td style="text-align:center">DELETE</td><td style="text-align:center">排他锁</td><td style="text-align:center">自动加锁</td></tr><tr><td style="text-align:center">SELECT</td><td style="text-align:center">不加锁</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">SELECT … LOCK IN SHARE MODE</td><td style="text-align:center">共享锁</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">SELECT … FOR UPDATE</td><td style="text-align:center">排他锁</td><td style="text-align:center"></td></tr></tbody></table><div class="note info flat"><ul><li><code>InnoDB</code>在<code>RR</code>下会使用临键锁进行搜索和索引扫描，防止幻读。</li><li>针对唯一索引进行检索时，对已经存在的记录进行等值匹配时，会自动优化为行锁</li><li><code>InnoDB</code>行锁针对索引加锁，不通过索引条件检索数据，那么<code>InnoDB</code>将对表中所有记录加锁，此时升级为表锁。</li></ul></div><h3 id="间隙锁">间隙锁</h3><ul><li>锁定索引记录间隙(不包含该记录)，确保索引记录间隙不变，防止其他事物在这个间隙<code>insert</code>，导致幻读，在<code>RR</code>隔离级别下支持</li></ul><div class="note info flat"><ul><li><code>InnoDB</code>在<code>RR</code>下会使用临键锁进行搜索和索引扫描，防止幻读。</li><li>索引上的等值查询(唯一索引)，给不存在的记录加锁时，会优化为间隙锁</li><li>索引上的等值查询(普通索引)，向右遍历时最后一个值不满足查询要求时，临键锁退化为间隙锁</li></ul></div><h3 id="临键锁">临键锁</h3><ul><li>行锁和间隙锁的组合，同时锁住数据以及数据前的间隙，在<code>RR</code>隔离级别下支持</li></ul><div class="note info flat"><ul><li><code>InnoDB</code>在<code>RR</code>下会使用临键锁进行搜索和索引扫描，防止幻读。</li><li>索引上的范围查询(唯一索引)，会访问到不满足条件的第一个值为止，生成临键锁</li></ul></div><h1><code>InnoDB</code>引擎</h1><h2 id="逻辑存储结构-表空间-段-区-页-行">逻辑存储结构: 表空间 - 段 - 区 - 页 - 行</h2><ol><li>表空间(<code>ibd</code>文件)，一个<code>MySQL</code>实例可以对应多个表空间，用于存储记录，索引</li><li>段分为数据段(Leaf node segment)，索引段(Non-leaf node segment)，回滚段(Rollback segment)。数据段就是B+树叶子节点，索引段就是非叶子节点，段用来管理多个区</li><li>区默认大小为1M，默认存储64个页</li><li>页默认大小为16K，为了保证页的连续性，<code>InnoDB</code>每次从磁盘申请4~5个区。</li><li>行，数据按行存放。<code>Trx_id</code>就是最后一次事务操作的id;<code>Roll_pointer</code>是某条记录改动时，把旧版本写入<code>undo log</code>中，相当于一个指针，可以找到记录修改前的信息。</li></ol><h2 id="架构">架构</h2><ul><li>左侧是内存结构，右侧是磁盘结构:<br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/MySQL/architecture.png" alt="architecture"></li></ul><h3 id="内存结构">内存结构</h3><ol><li><p><code>Buffer Pool</code></p><ul><li>缓冲池是主内存中的一个区域，可以缓存磁盘上经常操作的真实数据。<strong>增删改查操作缓冲池中的数据，没有数据则从磁盘中加载到缓冲池中</strong>，再以一定的频率刷新到磁盘，减少磁盘I/O，加快处理速度。缓冲池以<strong>页</strong>为单位，底层采用<strong>链表</strong>管理页，页分三类:<br>(1) <code>free page</code>: 空闲页，没有使用<br>(2) <code>clean page</code>: 被使用的页，数据没有修改过<br>(3) <code>dirty page</code>: 脏页，被使用过被修改过，与磁盘不一致的数据(缓冲池中还没有刷新到磁盘的数据)</li></ul></li><li><p><code>Change Buffer</code></p><ul><li>更改缓冲区，(<strong>针对非唯一二级索引页</strong>，主键索引这种唯一索引是<strong>不会</strong>存储在更改缓冲区中)，执行<code>DML</code>语句时，如果这些数据页没有在缓冲池中，不会直接操作磁盘，而是将数据变更存在<code>Change Buffer</code>中，在未来数据被读取时，合并恢复到缓冲池中，再将合并后的数据刷新到磁盘</li><li>因为二级索引通常是非唯一的，以随机顺序插入二级索引。删除和更新可能会影响索引树中不相邻的二级索引页。每一次都操作磁盘则会产生大量的磁盘I/O，更改缓冲区可以在缓冲池中合并处理，减少磁盘I/O</li></ul></li><li><p><code>Adaptive Hash Index</code></p><ul><li>自适应哈希索引，<code>InnoDB</code>本身不支持哈希索引，支持B+树索引。但是B+树索引是等值索引，因此引入自适应哈希索引优化对缓冲池数据的查询。<code>InnoDB</code>会监控表上对各索引页的查询，如果观察到哈希索引可以提高速度，则会<strong>自动</strong>建立哈希索引，即为自适应哈希索引。</li><li>参数: <code>adaptive_hash_index</code>是自适应哈希索引的开关，默认是开启的</li></ul></li><li><p><code>Log Buffer</code></p><ul><li>日志缓冲区，用来保存将要写入到磁盘中的<code>Log</code>日志数据(<code>redo log</code>, <code>undo log</code>)，大小默认为16MB。日志会定期刷新到磁盘中，如果需要更新、插入或删除多行事务，增加日志缓冲区的大小可以节省磁盘I/O</li><li>参数: <code>innode_log_buffer_size</code> 缓冲区大小</li><li><code>innodb_flush_log_at_trx_commit</code> 日志刷新到磁盘的时机<ul><li>0: 日志每秒写入并刷新</li><li>1(<strong>默认</strong>): 日志在每次事务提交时写入并刷新到磁盘</li><li>2: 日志在每次事务提交后写入，并且每秒刷新到磁盘</li></ul></li></ul></li></ol><h3 id="磁盘结构">磁盘结构</h3><ol><li><p><code>System Tablespace</code></p><ul><li>系统表空间，是<strong>更改缓冲区</strong>的存储区域。如果表在系统表空间而不是每个表文件或者通用表空间中创建的，也可能包含表和索引数据</li><li>参数: <code>innodb_data_file_path</code></li></ul></li><li><p><code>File-Per-Table Tablespaces</code></p><ul><li>每个表的文件表空间包含单个表的数据和索引，存储在文件系统的单个数据文件中。</li><li>参数: <code>innodb_file_per_table</code>默认为开启的，如果不开启，则存储在系统表空间中</li></ul></li><li><p><code>General Tablespaces</code></p><ul><li>通用表空间，需要通过<code>create tablespace</code>语法创建，建表时可以指定该表空间</li><li>创建一个表空间: <code>create tablespace 表空间名 add datafile 表名.ibd engine=引擎名;</code></li><li>创建一张表并指定表空间: <code>create table xxx ... tablespae 表空间名;</code></li></ul></li><li><p><code>Undo Tablespaces</code></p><ul><li>撤销表空间，<code>MySQL</code>初始化时自动创建两个默认的<code>undo</code>表空间，初始大小16M，用于存储<code>undo log</code></li></ul></li><li><p><code>Temporary Tablespaces</code></p><ul><li>临时表空间，使用会话临时表空间和全局临时表空间，存储用户创建的临时表等数据</li></ul></li><li><p><code>Doublewrite Buffer Files</code></p><ul><li>双写缓冲区，<code>InnoDB</code>将数据页从缓冲池刷新到磁盘前，将数据页写入双写缓冲区文件中，便于系统异常时恢复数据</li><li>后缀: <code>.dblwr</code></li></ul></li><li><p><code>Redo Log</code></p><ul><li>重做日志，实现事务的<strong>持久性</strong>。日志文件由两部分组成，重做日志缓冲区<code>redo log buffer</code>和重做日志文件<code>redo log</code>。前者在内存中，后者在磁盘中。事务提交以后会把所有的修改信息都存到该日志中用于在刷新脏页到磁盘时，发生错误时进行数据恢复使用。</li><li><code>redo log</code> <strong>不会循环写</strong>，每隔一段时间清理之前没用的内容。</li><li><code>ib_logfile</code></li></ul></li></ol><h3 id="后台线程">后台线程</h3><ol><li><code>Master Thread</code> 核心后台线程，负责调度其他线程，同时将缓冲池中的数据<strong>异步</strong>刷新到磁盘中，保持数据的<strong>一致性</strong>。包括脏页的刷新，合并插入缓存，<code>undo</code>页的回收</li><li><code>IO Thread</code> 使用AIO来处理IO请求，<code>IO Thread</code>主要负责这些I/O请求的回调</li></ol><table><thead><tr><th style="text-align:center">线程类型</th><th style="text-align:center">默认个数</th><th style="text-align:center">职责</th></tr></thead><tbody><tr><td style="text-align:center">Read Thread</td><td style="text-align:center">4</td><td style="text-align:center">负责读</td></tr><tr><td style="text-align:center">Write Thread</td><td style="text-align:center">4</td><td style="text-align:center">负责写</td></tr><tr><td style="text-align:center">Log Thread</td><td style="text-align:center">1</td><td style="text-align:center">负责将日志缓冲区刷新到磁盘</td></tr><tr><td style="text-align:center">Insert Buffer Thread</td><td style="text-align:center">1</td><td style="text-align:center">负责将写缓冲区的内容刷新到磁盘</td></tr></tbody></table><ul><li><code>show engine innodb status;</code>查看<code>Innodb</code>引擎的状态信息</li></ul><ol start="3"><li><code>Purge Thread</code>回收事务已经提交了的<code>undo log</code>，事务提交之后，<code>undo log</code>可能不用了，就用该线程来回收</li><li><code>Page Cleaner Thread</code>是协助 <code>Master Thread</code>刷新脏页到磁盘的线程，减轻<code>Master Thread</code>的工作压力，减少阻塞</li></ol><h3 id="事务原理">事务原理</h3><ul><li><p>一致性是通过<code>redo log, undo log</code>来保证的</p></li><li><p>隔离性通过锁机制，<code>MVCC</code>(多版本并发控制)实现</p></li><li><p>持久性由<code>redo log</code>保证</p></li><li><p>原子性由<code>undo log</code>保证<br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/MySQL/WAL.png" alt="WAL"></p></li><li><p><code>undo log</code>记录数据被修改前的信息，包含回滚和MVCC</p></li><li><p><code>undo log</code>记录逻辑日志，<code>redo log</code>记录物理日志</p></li><li><p>当<code>delete</code>时，<code>undo log</code>会记录一条<code>insert</code>记录；<code>update</code>时，<code>undo log</code>会有一条相反的<code>update</code>。执行<code>rollback</code>时，可以从逻辑记录中读取到相应的内容并回滚</p></li><li><p><code>undo log</code>销毁: <code>undo log</code>在事务执行时产生，事务提交时，不会立即删除，因为可能还要用于MVCC</p></li><li><p><code>undo log</code>存储: 采用<strong>段</strong>的方式进行管理和记录，存放在<code>rollback segment</code>中，内部包含1024个<code>undo log segment</code></p></li></ul><h2 id="MVCC-多版本并发控制">MVCC(多版本并发控制)</h2><div class="note info flat"><ul><li><code>MVCC</code>: 维护一个数据库的多个版本，使得<strong>读写操作没有冲突</strong>。</li><li>快照读为<code>MVCC</code>提供了一个非阻塞读的功能。</li><li>MVCC依赖:数据库记录中的三个隐式字段， <code>undo log</code>，<code>readView</code>实现</li></ul></div><div class="note info flat"><ol><li>当前读: 读取的是记录的<strong>最新版本</strong>，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。<ul><li><code>select ... lock in share mode</code>(共享锁)</li><li><code>select ... for update</code>、<code>update</code>、<code>insert</code>、<code>delete</code>(排他锁)</li><li>上述二者都是一种当前读</li></ul></li><li>快照读: 简单的<code>select</code>(不加锁)就是快照读，读取的是记录数据的可见版本，有可能是历史数据，非阻塞读<ul><li><code>Read Committed</code>: 每次<code>select</code>都生成一个快照读</li><li><code>Repeatable Read</code>: 开启事务后第一个<code>select</code>语句才是快照读的地方，后面实际上查询的都是<strong>第一个读生成的快照</strong></li><li><code>Serializable</code>: 快照读会退化为当前读</li></ul></li></ol></div><ol><li><p>记录中的隐式字段</p><table><thead><tr><th style="text-align:center">隐藏字段</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">DB_TRX_ID</td><td style="text-align:center">最近修改事务的ID，记录插入这条记录或最后一次修改该记录的事务ID</td></tr><tr><td style="text-align:center">DB_ROLL_PTR</td><td style="text-align:center">回滚指针，指向这条记录的上一个版本，用于配合undo log</td></tr><tr><td style="text-align:center">DB_ROW_ID</td><td style="text-align:center">隐藏主键，如果表没有主键才会生成</td></tr></tbody></table> <div class="note info flat"><ul><li>查看表空间<code>ibd</code>文件: <code>ibd2sdi 文件名.idb</code></li></ul></div></li><li><p><code>undo log</code></p><ul><li><code>undo log</code>日志可以被删除，但是不会立即删除<ul><li>当<code>insert</code>的时候，产生的<code>undo log</code>只在回滚时需要，事务提交以后，可以立即被删除</li><li>当<code>update, delete</code>的时候，产生的<code>undo log</code>日志不仅在回滚时需要，在快照读的时候也需要，不会立即被删除</li></ul></li></ul> <div class="note info flat"><p><code>undo log</code> 版本链</p><ul><li>不同事物或相同事务对同一条记录进行修改，导致该记录的<code>undo log</code>生成一条记录版本链表，链表头部是<strong>最新的旧记录</strong>，链表尾部是<strong>最早的旧记录</strong></li></ul></div></li><li><p><code>readView</code></p><ul><li>读视图是快照读<code>SQL</code>执行时<code>MVCC</code>提取数据的依据，记录并维护系统当前活跃的事务(<strong>未提交的</strong>)<code>id</code>，包含四个核心字段</li></ul><table><thead><tr><th style="text-align:center">字段</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">m_ids</td><td style="text-align:center">当前活跃事务ID</td></tr><tr><td style="text-align:center">min_trx_id</td><td style="text-align:center">最小活跃事务ID</td></tr><tr><td style="text-align:center">max_trx_id</td><td style="text-align:center">预分配事务，当前最大事务ID + 1(因为事务ID自增)</td></tr><tr><td style="text-align:center">creator_trx_id</td><td style="text-align:center">ReadView创建者的事务ID</td></tr></tbody></table></li></ol><h3 id="版本链数据访问规则">版本链数据访问规则:</h3><p><code>trx_id</code>表示当前事务ID</p><ol><li><code>trx_id</code> == <code>creator_trx_id</code> ? 可以访问该版本，因为等式成立表示数据是当前事务更改的(自己改的数据自己肯定可以先访问)</li><li><code>trx_id</code> &lt; <code>min_trx_id</code> ? 可以访问该版本，因为这个表明数据已经提交了，所以可以访问</li><li><code>trx_id</code> &gt; <code>max_trx_id</code> ? <strong>不可以</strong>访问该版本，因为表明当前事务是在readView生成后才开启的</li><li><code>min_trx_id</code> &lt;= <code>trx_id</code> &lt;= <code>max_trx_id</code> ? 如果<code>trx_id</code>不在<code>m_ids</code>中是可以访问该版本的。因为如果成立，表示数据已经提交了</li></ol><div class="note info flat"><ul><li><code>Read Committed</code>在事务中每一次执行快照读的时候生成<code>readView</code></li><li><code>Repeatable Read</code>在事务第一次执行快照读的时候生成<code>readView</code>，后序复用该<code>readView</code></li></ul></div><h1>MySQL四个系统数据库</h1><table><thead><tr><th style="text-align:center">数据库</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">mysql</td><td style="text-align:center">存储MySQL服务器正常运行所需要的各种信息(时区，主从，用户，权限等)</td></tr><tr><td style="text-align:center">information_schema</td><td style="text-align:center">提供了访问数据库元数据的各种表和视图，包含数据库、表、字段类型已经访问权限等</td></tr><tr><td style="text-align:center">performance_schema</td><td style="text-align:center">为MySQL服务器运行时状态提供了一个底层监控功能，用于手机数据库服务器性能参数</td></tr><tr><td style="text-align:center">sys</td><td style="text-align:center">一系列方便DBA和开发人员利用performance_schema性能数据库进行性能调优和诊断的视图</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;锁&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/sang3112/blog_imgs/raw/master/MySQL/lock.png&quot; alt=&quot;lock&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;全局锁&quot;&gt;全局锁&lt;/h2&gt;
&lt;div class=&quot;no</summary>
      
    
    
    
    <category term="MySQL" scheme="https://sangs3112.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://sangs3112.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL笔记_3</title>
    <link href="https://sangs3112.github.io/posts/be4e57f0.html"/>
    <id>https://sangs3112.github.io/posts/be4e57f0.html</id>
    <published>2024-03-14T05:38:14.000Z</published>
    <updated>2024-03-23T00:16:00.121Z</updated>
    
    <content type="html"><![CDATA[<h1><code>SQL</code>优化</h1><h2 id="insert优化"><code>insert</code>优化</h2><ol><li>使用批量插入，一次性插入500~1000条数据，而不是一条一条插入，也不能一次性插入过多</li><li>使用手动事务提交</li><li>主键顺序插入</li><li>如果需要插入大批量的数据，可以使用<code>MySQL</code>提供的<code>load</code>指令，而不使用<code>insert</code> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 使用load需要修改</span><br><span class="line"># 客户端链接服务端 加上<span class="comment">--local-infile参数</span></span><br><span class="line">mysql <span class="comment">--local-infile -u root -p</span></span><br><span class="line"># 设置全局参数<span class="keyword">local</span><span class="operator">-</span>infile为<span class="number">1</span>，开启本地加载文件到数据库的开关</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> <span class="keyword">local</span><span class="operator">-</span>infile <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"># 执行load指令 将准备好的数据加载到表结构中</span><br><span class="line">load data <span class="keyword">local</span> infile <span class="string">&#x27;/root/sql1.log&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> <span class="string">&#x27;user&#x27;</span> fields terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span> lines terminated <span class="keyword">by</span> <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"># 每个字段之间使用,分割，每行之间使用<span class="string">&#x27;\n&#x27;</span>分割</span><br></pre></td></tr></table></figure></li><li>对于<code>load</code>命令而言，同样顺序插入比乱序插入更好</li></ol><h2 id="主键优化">主键优化</h2><div class="note info flat"><ul><li>表数据都是根据主键顺序存放的，这种存储方式的表称为索引组织表(<code>index organized table IOT</code>)</li><li><code>InnoDB</code>中的页可以为空，也可以填充一半，或者存满。规定每个页至少包含两行数据，最多包含N行数据。因为如果只有一行数据，相当于形成了一个链表，如果一行数据比较大，超出于阈值后又会形成溢出现象。</li><li>行与行之间根据主键排列</li></ul></div><h3 id="主键顺序插入">主键顺序插入</h3><ul><li>如果主键顺序插入，则一页存放满以后自动开启新页并将数据存放其中<br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/MySQL/primary_key_ordered.png" alt="primary_key_ordered"></li></ul><h3 id="主键乱序插入">主键乱序插入</h3><ul><li>如果主键乱序插入，存放满以后，开启新的数据页，找到本应该要存放的数据页的50%的位置，后面的行移动到新的数据页，再决定要插入的行存放在原来剩下的50%的数据页中还是新数据页中，最后改变链表指针称为<strong>页分裂</strong></li><li>删除一行记录时，没有物理删除，只是标记为删除并且可以被其他记录使用</li><li>页中删除的记录达到<code>MERGE_THRESHOLD</code>，即默认页的50%时，<code>InnoDB</code>就会查找最近的前后两个页是否可以合并，如果可以合并，就会优化空间，称为<strong>页合并</strong><br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/MySQL/primary_key_unordered_1.png" alt="primary_key_unordered_1"><br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/MySQL/primary_key_unordered_2.png" alt="primary_key_unordered_2"><br><img src="https://gitee.com/sang3112/blog_imgs/raw/master/MySQL/primary_key_unordered_3.png" alt="primary_key_unordered_3"></li></ul><h3 id="主键设计原则">主键设计原则</h3><ol><li>满足业务需求的情况下尽量降低主键的长度。因为主键索引只有一个，二级索引的叶子节点中记录的是主键，如果主键较长，会占用较多的磁盘空间。</li><li>插入数据使用<strong>顺序插入</strong>，使用<code>auto_increment</code></li><li>不要使用<code>UUID</code>或者身份证号作为主键</li><li>避免对主键的修改</li></ol><h2 id="order-by优化"><code>order by</code>优化</h2><div class="note info flat"><ol><li><code>Using filesort</code>: 通过<strong>表索引</strong>或<strong>全表扫描</strong>，读取满足条件的数据行。在排序缓冲区中<code>sort buffer</code>完成排序操作，所有不是通过索引直接返回排序结果的排序都是<code>filesort</code>排序</li><li><code>Using index</code>: 通过有序索引顺序扫描直接返回有序数据，就是<code>using index</code>，不需要额外的排序，操作效率高。</li></ol></div><ul><li>当没有<code>(age, phone)</code>这个联合索引的时候，<code>select id, age, phone from user order by age, phone;</code>这个查询语句使用的是<code>using filesort</code></li><li>当有<code>(age, phone)</code>这个联合索引的时候，则该语句使用<code>using index</code><ul><li>若语句改变为<code>select id, age, phone from user order by age desc, phone desc;</code> 依然是<code>using index</code></li><li>但是如果语句改变为<code>select id, age, phone from user order by age, phone desc;</code> 则会出现前一个使用<code>using index</code>，后一个变为<code>using filesort</code>这是因为创建索引的时候值都是从小到大排列的，可以通过<code>show index from user</code>查看其中的<code>Collection</code>列是<code>A</code>就表示升序排列</li><li>为了解决这个问题，只需要在创建索引的时候指定顺序即可，比如<code>create index idx_user_age_phone_ad on user(age asc, phone desc);</code> 此时在进行上一次的排序，就会发现<code>using index</code></li><li>如果排序变为<code>select id, age, phone from user order by phone, age;</code> 就会出现前一个使用<code>using filesort</code>，后一个使用<code>using index</code>，因为这个违背了最左前缀法则，所以会出现两个。这个不像<code>where ... and ...</code>可以自动匹配顺序变化。</li></ul></li></ul><div class="note info flat"><p>如果有联合索引，则全部是升序排序，或者全部是降序排序，均可实现<code>using index</code>；但是如果一个是升序，另一个是降序，则需要在创建一个指定排序的索引才行<br>这些都是建立在覆盖索引，不需要回表查询的基础上。如果需要回表，则一定是<code>using filesort</code>，比如: <code>select * from user order by age, phone;</code></p></div><h3 id="排序设计原则">排序设计原则</h3><ol><li>建立合适的索引，多字段排序也遵循最左前缀法则</li><li>使用覆盖索引</li><li>多字段排序，一个升序一个降序，注意联合索引在创建时的规则</li><li>不可避免出现<code>filesort</code>的情况下，出现大数据排序时可以增大缓冲区的大小，<code>sort_buffer_size</code>默认为<code>256K</code></li></ol><h2 id="limit优化"><code>limit</code>优化</h2><div class="note info flat"><ul><li>由于需要排序记录，并且将其他记录全部丢弃，查询排序的时间非常长。因此，<code>limit</code>越往后时间越长</li><li>可以使用<strong>覆盖索引 + 子查询</strong>的形式优化</li></ul></div><ul><li>原始语句: <code>select * from 表名 order by id limit 9000000, 10;</code></li><li>覆盖索引: <code>select id from 表名 order by id limit 9000000, 10;</code></li><li>子查询: <code>select * from 表名 where id in (select id from 表名 order by id limit 9000000, 10);</code> 这句话会报错，因为不能在<code>in</code>后面使用<code>limit</code></li><li><code>select s.* from 表名 s, (select id from 表名 order by id limit 90000000, 10) a where s.id=a.id;</code> 将limit查询结果作为一个表联合查询</li></ul><h2 id="count优化"><code>count</code>优化</h2><div class="note info flat"><ul><li><code>MyISAM</code>把表的总行数存储在磁盘上，<code>count(*)</code>直接返回这个数，效率高，前提是没有<code>where</code>条件</li><li><code>InnoDB</code>即使没有<code>where</code>条件，也需要将数据一行一行读出，然后累加</li><li>优化只有自己计数，例如使用<code>redis</code></li></ul></div><ul><li><code>count(列名)</code>返回的是列中不为<code>null</code>的个数，</li><li><code>count(主键)</code>遍历整张表，把每一行主键id取出，返回给服务层，服务层拿到主键以后直接累加，因为主键不会为null</li><li><code>count(字段)</code>需要看字段是否有not null约束，如果没有该约束，需要将每行字段值取出，返回给服务层。服务层判断是否为null，不为null才累加计数<ul><li>如果有not null约束，则跟主键处理一样</li></ul></li><li><code>count(1)</code>遍历整张表，但是不取值，服务层对于返回的每一行，都放一个数字1进去，直接按行累加。参数是什么数字都可以，0，-1都可以，返回一样的结果</li><li><code>count(*)</code>不会把全部字段取出来，而是专门优化了，直接在服务层累加</li><li>所以最终的效率<code>count(*)</code>性能最高，类似于<code>count(1)</code>，然后才是<code>count(主键)</code>，性能最差的是<code>count(字段)</code></li></ul><h2 id="update优化"><code>update</code>优化</h2><ul><li>更新数据时，<strong>根据索引字段级进行更新，否则行锁会升级成表锁。</strong></li><li><code>update course set name='Java' where id=1;</code>这句话是行锁，别的事务更新别的行不会被卡住</li><li><code>update course set name='Springboot' where name='kafaka';</code>这句话是表锁，别的事务更新别的行会被卡住，因为<code>name</code>字段没有索引<ul><li>如果建立了<code>name</code>的索引，则上句更新就是行锁了</li></ul></li><li>一定要根据索引字段进行更新！否则表锁会锁住整张表。</li></ul><h1>存储对象: 视图、存储过程、触发器、存储函数</h1><h2 id="视图">视图</h2><div class="note info flat"><ul><li>视图是虚拟存在的表，视图中的数据不在数据库中真实存在，行列数据来自视图查询中使用的表，称为基表，在使用视图时动态生成</li><li>视图只保存<code>SQL</code>逻辑，不保存查询结果。创建视图主要工作在<code>SQL</code>查询语句上</li></ul></div><h3 id="增">增</h3><ul><li>创建视图: <code>create [or replace] view 视图名[(列名列表)] as select语句 [with [cascade | local] check option];</code><ul><li>替换视图就使用<code>or replace</code></li><li><code>select语句</code>关联的表就是<strong>基表</strong></li><li>创建视图的时候指定<code>with cascade check option</code>，并且设置了视图<code>select语句</code>为<code>where id &lt; 20</code>，若此时增加了一条<code>id = 30</code>的数据就会报错，提示无法插入。如果没有设置<code>check option</code>就不会报错，可以正常插入</li></ul></li></ul><h3 id="删">删</h3><ul><li>删除视图: <code>drop view [if exists] 视图名[, 视图名1, ...];</code></li></ul><h3 id="改">改</h3><ul><li>替换视图: <code>create or replace view 视图名[(列名列表)] as select语句 [with [cascade | local] check option];</code></li><li>修改视图: <code>alter view 视图名[(列名列表)] as select语句 [with [cascade | local] check option];</code></li></ul><h3 id="查">查</h3><ul><li>查询创建视图语句: <code>show create view 视图名;</code></li><li>查看视图数据: <code>select * from 视图名;</code>视图就是虚拟存在的表，所以可以跟操作表一样操作视图</li></ul><div class="note info flat"><ul><li>在视图中插入数据会插入到对应的基表中，因为视图不会保存数据。</li><li><code>with check option</code> 就是检查项，在增删改的时候都会检查是否符合视图创建时的定义。<code>MySQL</code>允许创建视图的视图，检查依赖视图规则有两个选项，就是<code>cascade</code>以及<code>local</code></li></ul></div><h3 id="cascade"><code>cascade</code></h3><ul><li><code>create view v1 as select id, name from student where id &lt;= 20;</code> 这里<strong>没有设置</strong><code>check option</code>，所以修改数据不会检查<code>id &lt;= 20</code></li><li><code>create view v2 as select id, name from v1 where id &gt;= 10 with cascade check option;</code> 这里修改了<code>v2</code>的数据时，不仅会检查<code>id &gt;= 10</code>，还会检查<code>id &lt;= 20</code></li><li><code>create view v3 as select id, name from v2 where id &lt;= 15;</code> 这里修改<code>v3</code>的数据<code>&gt; 15</code>也可以插入，但是如果<code>&gt; 20</code>则不能插入，因为不能满足<code>v2</code>的检查项</li></ul><h3 id="local"><code>local</code></h3><ul><li><code>create view v1 as select id, name from student where id &lt;= 15;</code> 修改<code>v1</code>中的数据不会检查<code>id &lt;= 15</code></li><li><code>create view v2 as select id, name from v1 where id &gt;= 10 with local check option;</code> 先检查是否满足<code>v2</code>条件，然后再找<code>v1</code>是否需要检查，发现<code>v1</code>不需要检查，则直接插入。所以插入<code>id = 17</code>也可以</li><li><code>create view v3 as select id, name from v2 where id &lt; 20;</code> 没有定义检查选项，会先找<code>v2</code>的检查项，发现<code>v2</code>需要检查<code>id &gt;= 10</code>，再发现<code>v1</code>没有检查选项，所以最终<code>id &gt;= 10</code>即可</li></ul><div class="note info flat"><ul><li>视图如果要能够更新，必须满足视图中的行与基表中的行<strong>一对一关系</strong>，只要包含下面<strong>任意一项</strong>，则视图不可更新<ol><li>聚合函数或窗口函数<code>sum, min, max, count</code></li><li><code>distinct</code></li><li><code>group by</code></li><li><code>having</code></li><li><code>union</code>, <code>union all</code></li></ol></li></ul></div><h3 id="视图作用">视图作用</h3><ol><li>操作简单，将复杂的经常使用的查询定义在视图中，不需要每次都指定同样的相同操作</li><li>安全，由于<code>MySQL</code>不能授权到特定的行列，只能授权到表。所以可以通过视图修改用户能见到的数据</li><li>数据独立: 可以帮助用户屏蔽真实表结构带来的变化</li></ol><h3 id="例子">例子:</h3><ol><li>为了保证安全性，操作<code>user</code>表时，只能看到用户的基本字段，屏蔽手机号和邮箱两个字段: <code>create view user_view as select id, name, profession, age, gender, status, create_time from user; </code></li><li>为了简化操作，查询每个学生所选修课程，三表联查，定义一个视图: <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> s.name, s.no, c.name <span class="keyword">from</span> student s, student_course sc, course c <span class="keyword">where</span> s.id <span class="operator">=</span> sc.studentid <span class="keyword">and</span> c.id <span class="operator">=</span> sc.courseid;</span><br><span class="line"># 封装成视图</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> stu_course_view <span class="keyword">as</span> <span class="keyword">select</span> s.name studentname, s.no studentno, c.name coursename </span><br><span class="line"><span class="keyword">from</span> student s, student_course sc, course c <span class="keyword">where</span> s.id <span class="operator">=</span> sc.studentid <span class="keyword">and</span> c.id <span class="operator">=</span> sc.courseid;</span><br></pre></td></tr></table></figure></li></ol><h2 id="存储过程">存储过程</h2><div class="note info flat"><ul><li>很多地方<strong>禁止</strong>使用</li><li>事先编译并存储在数据库中的一段<code>SQL</code>语句集合，减少数据库和应用服务器之间的传输，提高数据处理效率</li><li>就是<code>SQL</code>语句封装重用</li><li>特点：封装、复用；可以接收参数和返回数据；减少网络交互，提升效率</li></ul></div><h3 id="增-2">增</h3><ul><li>创建存储过程  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> 存储过程名称([<span class="keyword">in</span><span class="operator">/</span><span class="keyword">out</span><span class="operator">/</span><span class="keyword">inout</span>参数列表])</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="comment">--SQL语句</span></span><br><span class="line"><span class="keyword">end</span>; #这里有个分号</span><br><span class="line"># 如果是在命令行中创建存储过程，遇到分号就自动结束了，所以会报错，需要通过delimiter指定<span class="keyword">sql</span>语句结束符</span><br><span class="line"># delimiter $$</span><br><span class="line"># 会一直到$$才认为是语句结束了</span><br></pre></td></tr></table></figure></li></ul><h3 id="删-2">删</h3><ul><li>删除存储过程: <code>drop procedure if exists 存储过程名;</code></li></ul><h3 id="调用存储过程-call-存储过程名-参数">调用存储过程: <code>call 存储过程名([参数])</code></h3><h3 id="查-2">查</h3><ul><li>查询指定数据库的存储过程以及状态信息: <code>select * from information_schema.routines where routine_schema='xxx';</code></li><li>查询存储过程定义: <code>show create procedure 存储过程名;</code></li></ul><h3 id="变量">变量</h3><p><code>MySQL</code>变量分为三类，系统变量，用户自定义变量以及局部变量</p><div class="note info flat"><ul><li>存储过程的参数类型：<code>in, out, inout</code>三种类型，默认是<code>in</code>类型的，作为输入，<code>out</code>类型作为输出，作为返回值，<code>inout</code>既可以作为输入又可以作为输出</li></ul></div><h4 id="系统变量">系统变量:</h4><ul><li>不需要用户自定义，属于服务器，分为全局变量<code>global</code>以及会话变量<code>session</code></li><li>会话变量表示在当前会话内有效</li><li>查询所有系统变量: <code>show [session | global] variables;</code></li><li>模糊查询: <code>show [session | global] variables like ...;</code></li><li>查询指定的系统变量，不写默认是<code>session</code>: <code>show @@[session | global].系统变量名;</code></li><li><code>MySQL</code>重启后，设置的<code>global</code>会失效，需要在<code>my.cnf</code>中完成设置才能保持</li></ul><h4 id="用户自定义变量">用户自定义变量</h4><ul><li>直接<code>@变量名</code>即可</li><li>赋值自定义变量:  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="variable">@var_name</span> <span class="operator">=</span> expr[, <span class="variable">@var_name</span> <span class="operator">=</span> expr, ...];</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@var_name</span> :<span class="operator">=</span> expr[, <span class="variable">@var_name</span> :<span class="operator">=</span> expr, ...];</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@var_name</span> :<span class="operator">=</span> expr</span><br><span class="line"><span class="keyword">select</span> 字段名 <span class="keyword">into</span> <span class="variable">@var_name</span> <span class="keyword">from</span> 表名;</span><br></pre></td></tr></table></figure></li><li>使用<code>select @varname</code>，如果<code>var_name</code>没有赋值，这个语句不会报错，只会显示<code>null</code></li></ul><h4 id="局部变量">局部变量</h4><ul><li>使用<code>declare</code>申明，存储过程内的局部变量和输入参数，在<code>begin ... end</code>模块内生效</li><li>声明变量: <code>declare 变量名 变量类型 [default ...];</code></li><li>赋值局部变量:  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> 变量名 <span class="operator">=</span> 值;</span><br><span class="line"><span class="keyword">set</span> 变量名 :<span class="operator">=</span> 值;</span><br><span class="line"><span class="keyword">select</span> 字段名 <span class="keyword">into</span> 变量名 <span class="keyword">from</span> 表名;</span><br></pre></td></tr></table></figure></li></ul><h3 id="case"><code>case</code></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> case_value</span><br><span class="line"><span class="keyword">when</span> value1 <span class="keyword">then</span> statement1</span><br><span class="line"><span class="keyword">when</span> value2 <span class="keyword">then</span> statement2</span><br><span class="line"><span class="keyword">else</span> statement3</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">case</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> </span><br><span class="line"><span class="keyword">when</span> condition1 <span class="keyword">then</span> statement1</span><br><span class="line"><span class="keyword">when</span> condition2 <span class="keyword">then</span> statement2</span><br><span class="line"><span class="keyword">else</span> statement3</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">case</span>;</span><br></pre></td></tr></table></figure><h3 id="while"><code>while</code></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while 条件 do</span><br><span class="line"><span class="keyword">sql</span>语句</span><br><span class="line"><span class="keyword">end</span> while;</span><br></pre></td></tr></table></figure><h3 id="repeat"><code>repeat</code></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">repeat</span><br><span class="line"><span class="keyword">sql</span>语句</span><br><span class="line">until 条件</span><br><span class="line"><span class="keyword">end</span> repeat; # 满足条件就退出循环</span><br></pre></td></tr></table></figure><h3 id="loop"><code>loop</code></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">leave: 用于退出循环</span><br><span class="line">iterate: 用于跳过当前循环进行下一次循环</span><br><span class="line">[begin_label:] loop</span><br><span class="line"><span class="keyword">sql</span>语句</span><br><span class="line"><span class="keyword">end</span> loop[end_label];</span><br><span class="line">leave [label]退出指定的循环</span><br><span class="line">iterate [label] 直接进入下一次循环</span><br><span class="line"># 如果不退出就是死循环</span><br></pre></td></tr></table></figure><h3 id="游标">游标</h3><ul><li>用于存储查询结果集的数据类型，在存储过程个函数中可以使用游标对结果集进行循环处理，包括游标声明，<code>open,fetch,close</code></li><li>申明游标: <code>declare 游标名称 cursor for 查询语句;</code></li><li>打开游标: <code>open 游标名称;</code></li><li>打开游标后才能获取游标记录: <code>fetch 游标名称 into 变量[, 变量];</code></li><li>关闭游标: <code>close 游标名称;</code></li></ul><h3 id="例子-2">例子:</h3><ol><li>根据传入参数<code>uage</code>, 查询<code>user</code>表，用户年龄小于等于<code>uage</code>的用户姓名<code>name</code>和专业<code>profession</code>插入到创建的一张表<code>id, name, profession</code>中 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p(<span class="keyword">in</span> uage <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> uname <span class="type">varchar</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">declare</span> upro <span class="type">varchar</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">declare</span> u_cursor <span class="keyword">cursor</span> <span class="keyword">for</span> <span class="keyword">select</span> name, profession <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age <span class="operator">&lt;=</span> uage;</span><br><span class="line">    # 游标的申明应该放在普通变量后面</span><br><span class="line">    <span class="keyword">declare</span> exit handler <span class="keyword">for</span> sqlsatae <span class="string">&#x27;02000&#x27;</span> <span class="keyword">close</span> u_cursor;</span><br><span class="line">    # 满足<span class="keyword">SQL</span>状态码是<span class="number">02000</span>的视乎出发退出操作，关闭游标u_cursor</span><br><span class="line">    # 同样可以将<span class="keyword">sqlstate</span> <span class="string">&#x27;02000&#x27;</span> 替换成<span class="keyword">not</span> found</span><br><span class="line">    <span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> user_pro;</span><br><span class="line">    <span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> user_pro(</span><br><span class="line">        id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">        name <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">        profession <span class="type">varchar</span>(<span class="number">100</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> u_cursor;</span><br><span class="line">    while <span class="literal">true</span> do </span><br><span class="line">        <span class="keyword">fetch</span> u_cursor <span class="keyword">into</span> uname, upro;</span><br><span class="line">        <span class="keyword">insert</span> <span class="keyword">into</span> user_pro <span class="keyword">values</span>(<span class="keyword">null</span>, uname, upro);</span><br><span class="line">    <span class="keyword">end</span> while; # 但是这里是死循环，因为不知道游标什么时候会结束</span><br><span class="line"></span><br><span class="line">    <span class="keyword">close</span> u_cursor;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><ul><li>条件处理程序<code>handler</code>定义在流程遇到问题和相应的处理步骤</li><li><code>declare handler_action handler for condition_value[, condition_value ...] statement;</code></li><li><code>handler_action</code>包括两个内容，<code>continue</code>以及<code>exit</code></li><li><code>condition_value</code>有<code>SQLSTATE sqlstate_value</code>状态码，比如<code>02000</code>; <code>sqlwarning</code>是所有以<code>01</code>开头的<code>sqlstate</code>代码的缩写，<code>not found</code>是所有以<code>02</code>开头的代码的缩写，<code>sqlexception</code>是所有其他的<code>sqlstate</code>代码的缩写</li></ul></li></ol><h2 id="存储函数">存储函数</h2><div class="note info flat"><ul><li>就是有返回值的存储过程，并且参数只能为<code>in</code>类型，可以被存储过程替代</li></ul></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> 存储函数名([参数列表])</span><br><span class="line"><span class="keyword">return</span> type [characteristic ...]</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">SQL</span>语句</span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><p><code>characteristic</code>:</p><ul><li><code>deterministic</code>: 相同的输入参数总是产生相同的结果</li><li><code>no sql</code>: 不包含<code>SQL</code>语句</li><li><code>reads sql data</code>: 包含读取数据的语句，但是不包含写入数据的语句</li></ul><h2 id="触发器">触发器</h2><div class="note info flat"><ul><li>不建议使用</li><li><code>MySQL</code>只支持行级触发器，不支持语句级触发器，因此一次修改多行，就会触发多次</li></ul></div><table><thead><tr><th style="text-align:center">触发器类型</th><th style="text-align:center">NEW 和 OLD</th></tr></thead><tbody><tr><td style="text-align:center">INSERT型</td><td style="text-align:center">NEW表示将要或者已经新增的数据</td></tr><tr><td style="text-align:center">UPDATE型</td><td style="text-align:center">OLD表示修改之前的数据，NEW表示将要或已经修改的数据</td></tr><tr><td style="text-align:center">DELETE型</td><td style="text-align:center">OLD表示将要或已经删除的数据</td></tr></tbody></table><ul><li><p>创建触发器:</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> trigger_name </span><br><span class="line">before<span class="operator">/</span>after <span class="keyword">insert</span><span class="operator">/</span> <span class="keyword">update</span><span class="operator">/</span> <span class="keyword">delete</span> </span><br><span class="line"><span class="keyword">on</span> 表名 <span class="keyword">for</span> eachrow </span><br><span class="line"><span class="keyword">begin</span> </span><br><span class="line">    trigger_stmt; </span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></li><li><p>查看触发器: <code>show triggers;</code></p></li><li><p>删除触发器: <code>drop triggers [schema_name.]trigger_namel</code> 如果没有指定<code>schema_name</code>，默认为当前数据库</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;code&gt;SQL&lt;/code&gt;优化&lt;/h1&gt;
&lt;h2 id=&quot;insert优化&quot;&gt;&lt;code&gt;insert&lt;/code&gt;优化&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;使用批量插入，一次性插入500~1000条数据，而不是一条一条插入，也不能一次性插入过多&lt;/li&gt;
&lt;li&gt;使用手动</summary>
      
    
    
    
    <category term="MySQL" scheme="https://sangs3112.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://sangs3112.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL笔记_2</title>
    <link href="https://sangs3112.github.io/posts/c9496766.html"/>
    <id>https://sangs3112.github.io/posts/c9496766.html</id>
    <published>2024-03-13T02:21:17.000Z</published>
    <updated>2024-03-23T00:16:00.121Z</updated>
    
    <content type="html"><![CDATA[<h1>索引</h1><div class="note info flat"><ul><li>高效获取数据的<strong>有序</strong>数据结构</li><li>提高检索效率，降低IO成本。</li><li>索引列对数据进行<strong>排序</strong>，降低排序成本，减少CPU的消耗</li><li>但是需要占用一些空间，提高查询效率有时候会降低更新表的速度，比如增删改。但是实际上增删改比例较少。</li></ul></div><table><thead><tr><th style="text-align:center">索引结构</th><th style="text-align:center">描述</th><th style="text-align:center"><code>InnoDB</code></th><th style="text-align:center"><code>MyISAM</code></th><th style="text-align:center"><code>Memory</code></th></tr></thead><tbody><tr><td style="text-align:center">B+树索引</td><td style="text-align:center">最常见的索引类型，大部分引擎都支持</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">Hash索引</td><td style="text-align:center">底层使用哈希表实现，只能精确匹配索引列的查询才有效，不支持范围查询</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">R-tree(空间索引)</td><td style="text-align:center">是<code>MyISAM</code>引擎的一个特殊索引类型，用于地理空间数据类型，使用较少</td><td style="text-align:center">-</td><td style="text-align:center">支持</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">Full-text(全文索引)</td><td style="text-align:center">通过建立倒排索引，快速匹配文档的方式，类似于<code>Lucene, Solr, ES</code></td><td style="text-align:center">5.6版本后支持</td><td style="text-align:center">支持</td><td style="text-align:center">-</td></tr></tbody></table><h2 id="B-树">B+树</h2><ul><li><p>B+树的<strong>所有元素都在叶子节点处</strong>，非叶子节点只用于索引，存储都在叶子节点处，<strong>所有叶子节点形成了一个单向链表</strong>。<br><img src="https://gitee.com/sang3112/blog_imgs/raw/d97d1acffa4285fae00105cf631f50575b612f38/MySQL/B+tree.png" alt="B+tree"></p></li><li><p><code>MySQL</code>对B+树进行优化，在原来的B+树基础上，增加了一个指向相邻叶子节点的链表指针，形成了带顺序指针的B+树，提高区间访问性能。<br><img src="https://gitee.com/sang3112/blog_imgs/raw/d97d1acffa4285fae00105cf631f50575b612f38/MySQL/MySQLB+tree.png" alt="MySQLB+tree"></p></li></ul><h3 id="InnoDB为何使用B-树索引，没有选择哈希索引、二叉树或者红黑树索引？"><code>InnoDB</code>为何使用B+树索引，没有选择哈希索引、二叉树或者红黑树索引？</h3><ol><li>如果是二叉树，顺序插入最后会形成链表，搜索性能很低，红黑树可以解决</li><li>但是红黑树本质上还是二叉树，<strong>自平衡二叉树</strong>，某些场景下层级太多了</li><li>B+树相对于二叉树层级更少，搜索效率更高，这也是B树的优点</li><li>但是B树无论叶子还是非叶子节点，都会保存数据，最终导致一页中存储的键值减少，指针也减少。如果要保存大量的数据，只能增加树的高度，导致性能降低。</li><li>对于B+树，找什么都去叶子节点中，所以搜索效率稳定</li><li><code>MySQL</code>中B+树的叶子节点形成了双向链表，便于范围搜索</li><li>哈希索引<strong>不支持</strong>排序和范围匹配，只能等值匹配。</li><li><code>InnoDB</code>也有自适应哈希功能，有的条件下会<strong>自动</strong>将B+树索引转换为哈希索引。(这点在后面会介绍)</li></ol><h2 id="索引分类">索引分类</h2><table><thead><tr><th style="text-align:center">分类</th><th style="text-align:center">含义</th><th style="text-align:center">特点</th><th style="text-align:center">关键字</th></tr></thead><tbody><tr><td style="text-align:center">主键索引</td><td style="text-align:center">针对于表中主键创建的索引</td><td style="text-align:center">默认自动创建，只能有一个</td><td style="text-align:center"><code>PRIMARY</code></td></tr><tr><td style="text-align:center">唯一索引</td><td style="text-align:center">避免同表某数据列中的值重复</td><td style="text-align:center">可以多个</td><td style="text-align:center"><code>UNIQUE</code></td></tr><tr><td style="text-align:center">常规索引</td><td style="text-align:center">快速定位特定数据</td><td style="text-align:center">可以多个</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">全文索引</td><td style="text-align:center">查找文本中关键词，而不是比较索引值</td><td style="text-align:center">可以多个</td><td style="text-align:center"><code>FULLTEXT</code></td></tr></tbody></table><h3 id="按存储形式分类">按<strong>存储形式</strong>分类</h3><table><thead><tr><th style="text-align:center">分类</th><th style="text-align:center">含义</th><th style="text-align:center">特点</th></tr></thead><tbody><tr><td style="text-align:center">聚集索引</td><td style="text-align:center">数据和索引放在一块，索引结构的叶子节点保存了行数据</td><td style="text-align:center">必须有且只有一个</td></tr><tr><td style="text-align:center">二级索引</td><td style="text-align:center">将数据和索引分开存储，索引结构的叶子节点关联的是对应的主键</td><td style="text-align:center">可以多个</td></tr></tbody></table><div class="note info flat"><ul><li>如果存在主键，则主键索引就是聚集索引</li><li>如果没有主键，则<strong>第一个</strong>唯一索引就是聚集索引</li><li>没有主键索引和聚集索引的话，则<code>InnoDB</code>会自动生成一个<code>rowid</code>作为隐藏的聚集索引</li></ul></div><div class="note info flat"><ul><li>聚集索引下面挂的是一整行的数据，二级索引下面挂的是主键</li><li>回表查询: 先走二级索引找到对应的主键，然后再从聚集索引找到需要的数据</li></ul></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">10</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name<span class="operator">=</span>&quot;A&quot;;</span><br><span class="line"># 其中 id 为主键，name也有对应的索引</span><br><span class="line"># 前者性能更高，因为不需要回表查询了，可以直接通过聚集索引找到数据</span><br></pre></td></tr></table></figure><h3 id="InnoDB主键索引中B-树高度为多少？"><code>InnoDB</code>主键索引中B+树高度为多少？</h3><ol><li>假设一行数据为1K，一页中存储16行，<code>InnoDB</code>指针占用6B，主键即使为<code>BIGINT</code>，占用8B</li><li>如果树高为2，假设有n个键，就有n+1个指针，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>∗</mo><mn>8</mn><mo>+</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>∗</mo><mn>6</mn><mo>=</mo><mn>16</mn><mo>∗</mo><mn>1024</mn></mrow><annotation encoding="application/x-tex">n * 8 + (n + 1) * 6 = 16 * 1024</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4653em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">16</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1024</span></span></span></span>计算得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≈</mo><mn>1170</mn></mrow><annotation encoding="application/x-tex">n \approx 1170</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4831em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1170</span></span></span></span></li><li>所以一个节点下面最多1171个指针，一个指针指向下面的子节点，一个子节点表示一个页，最多可以存16行数据。所以如果B+树高2，能够存储数据量为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1171</mn><mo>∗</mo><mn>16</mn><mo>=</mo><mn>18736</mn></mrow><annotation encoding="application/x-tex">1171 * 16 = 18736</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1171</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">16</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">18736</span></span></span></span></li><li>如果树高为3，则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1171</mn><mo>∗</mo><mn>1171</mn><mo>∗</mo><mn>16</mn><mo>=</mo><mn>21939856</mn></mrow><annotation encoding="application/x-tex">1171 * 1171 * 16 = 21939856</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1171</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1171</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">16</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">21939856</span></span></span></span>，所以即使存储两千多万条数据，树结构也只有三层</li></ol><h2 id="索引增删查">索引增删查</h2><h3 id="创建索引">创建索引</h3><p><code>create [unique | fulltext] index 索引名 on 表名 (索引关联字段1, 索引关联字段2, ...);</code></p><div class="note info flat"><ul><li>如果一个索引只关联了一个字段，则称为单列索引</li><li>如果关联了多个字段，则称为联合索引</li></ul></div><h3 id="删除索引">删除索引</h3><p><code>drop index 索引名 on 表名;</code></p><h3 id="查看索引">查看索引</h3><p><code>show index from 表名;</code></p><h2 id="性能分析">性能分析</h2><h3 id="执行频率">执行频率</h3><ul><li><code>show [session | global] status;</code>查看服务器状态信息</li><li><code>show global status like 'Com_______';</code>查看当前数据库的<code>insert, update, delete, select</code>的访问频次 (Com后面是7个下划线)</li></ul><h3 id="慢查询日志">慢查询日志</h3><ul><li>慢查询日志记录了所有执行时间超过指定参数(<code>long_query_time</code>单位: 秒，默认为10秒)的所有语句的日志</li><li><code>show variables like 'slow_query_log';</code>查看慢查询日志是否开启，默认是关闭状态<ul><li>需要在<code>/etc/my.cnf</code>中配置慢查询日志开关，表示超过200ms就是慢查询了<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slow_query_log=1</span><br><span class="line">long_query_time=0.2</span><br></pre></td></tr></table></figure></li></ul></li><li>慢查询日志存放在<code>var/log/mysql/mysql_slow.log</code></li></ul><h3 id="语句耗时">语句耗时</h3><ul><li><code>show profiles;</code>可以查看SQL语句耗时，<code>select @@have_profiling;</code>可以查看当前<code>MySQL</code>是否支持</li><li>确认支持后，还需要查看是否开启了<code>select @@profiling;</code>使用<code>set @@profiling=1</code>开启</li><li>开启后，执行完命令可以使用<code>show profiles;</code>查看一条指令的耗时情况</li><li><code>show profile for query query_id</code>可以查看一条<code>query_id</code>的查询指令的耗时细节</li><li><code>show profile cpu for query query_id</code>可以查看指定指令的CPU耗时细节</li></ul><h3 id="执行计划">执行计划</h3><ul><li>在任意<code>select</code>之前加上<code>explain</code>或者<code>desc</code>就可以查看执行计划<ul><li><code>id</code>: <code>select</code>查询的序列号，表示执行顺序，<code>id</code>相同，从上到下执行；<code>id</code>不同，越大越早执行</li><li><code>select_type</code>: 表示<code>select</code>类型，常见有:<ul><li><code>simple</code>: 简单单表查询</li><li><code>primary</code>: 最外层的主查询</li><li><code>union</code>: 联合查询中的第二个查询</li><li><code>subquery</code>: <code>select/where</code>后的子查询</li></ul></li><li><code>type</code>: 表示连接类型，性能由好到差分别为<code>null, system, const, eq_ref, ref, range, index, all</code><ul><li><code>null</code>: 查询时不访问任何表，比如<code>select 'A';</code></li><li><code>system</code>: 访问系统表</li><li><code>const</code>: 根据主键、唯一索引访问</li><li><code>ref</code>: 根据非唯一索引访问</li><li><code>range</code>: 非唯一索引，但是范围匹配，比如<code>age &gt; 18</code></li><li><code>index</code>: 虽然使用了索引，但是是所有的索引草庙，性能也低</li><li><code>all</code>: 全表扫描，性能最低</li></ul></li><li><code>extra</code>:<ul><li><code>using index condition</code>: 查找使用了索引，但是<strong>需要回表</strong>查询</li><li><code>using where; using index</code>: 查找使用了索引，但是需要的数据在索引列中都能找到，<strong>不需要回表</strong></li></ul></li><li><code>possible_key</code>: 表示这表中可能用到的索引，一个或多个</li><li><code>key</code>: 表示实际用到的索引，<code>null</code>表示没有用到索引</li><li><code>key_len</code>: 表示索引中使用的字节数，是索引字段的最大长度，不是实际使用的长度，不损失精度的前提下越短越好</li><li><code>rows</code>: 表示查询的行数，只是预估值，不是精确值</li><li><code>filtered</code>: 表示查询返回行数占总读取行数的百分比，越大越好</li></ul></li></ul><h2 id="最左前缀法则"><strong>最左前缀法则</strong></h2><ul><li>如果有联合索引，查询从索引的最左列开始，不跳过中间的列。如果跳过某一列，则所有后面的字段都失效</li><li>如果没有索引最左边的列，则索引失效</li><li>只需要<code>where</code>条件有最左边的列即可，只要存在就行，跟在<code>where</code>中的位置无关</li><li>联合索引中出现了范围查询<code>&gt;, &lt;</code>，则右边的索引失效<ul><li><code>select * from user where profession='A' and age &gt; 30 and status='0';</code>则<code>stauts</code>失效</li><li>如果是<code>&gt;=, &lt;=</code> 则不会产生影响，所以尽量少用<code>&gt;, &lt;</code></li></ul></li></ul><h2 id="索引失效">索引失效</h2><div class="note info flat"><ol><li><p>如果在索引列上进行运算，则索引失效</p><ul><li><code>select * from user where phone='12312312312';</code> 走单列索引，<code>type=const</code></li><li><code>select * from user where substring(phone, 10, 2)='15';</code> 走全表扫描，<code>type=all</code></li></ul></li><li><p>字符串不加引号索引就会失效</p><ul><li><code>select * from user where phone=12312312312;</code> 走的是全表扫描，因为没有添加引号</li></ul></li><li><p>仅仅使用尾部模糊匹配，索引不会失效；只要有头部模糊匹配，索引会失效</p><ul><li><code>select * from user where profession like '软件%';</code> 走索引，<code>type=range</code></li><li><code>select * from user where profession like '%软件';</code> 不走索引，<code>type=all</code></li><li><strong>大数据量一定要规避模糊匹配前面加上%的情况</strong></li></ul></li><li><p>使用<code>or</code>分割的条件，只有两侧都有索引，索引才会生效，不然不会生效(实际上经过测试发现必须要有两边的联合索引，or语句的索引才会生效)</p></li><li><p>如果<code>MySQL</code>评估使用索引比全表扫描还要慢，就不会用索引</p><ul><li>比如范围匹配或者判断空或非空，满足要求的条件是表中的绝大部分数据，则不会使用索引，直接走全表扫描了</li></ul></li></ol></div><h2 id="SQL提示"><code>SQL</code>提示</h2><ul><li>一个查询能满足多个索引的时候，<code>MySQL</code>会自动选择一个索引</li><li>可以给<code>MySQL</code>提示，要求选择哪个索引进行查找，从而达到优化的目的</li><li><code>use / ignore / force index;</code> 告诉<code>MySQL</code>使用哪个索引，不使用哪个索引</li><li><code>use index</code>是一个建议，<code>MySQL</code>未必接受；<code>force index</code>是强制<code>MySQL</code>使用这个索引</li></ul><h3 id="如果MySQL取错索引，应该如何操作？">如果<code>MySQL</code>取错索引，应该如何操作？</h3><ol><li>使用<code>use / ignore / force index;</code> 让<code>MySQL</code>使用某个索引</li><li>修改<code>SQL</code>语句，诱导<code>MySQL</code>选择某个索引</li><li>建立合适的索引，删除无效的索引</li></ol><h2 id="覆盖索引">覆盖索引</h2><ul><li>尽量使用覆盖索引，而不用<code>select *</code></li><li>覆盖索引就是查询使用了索引，并且查询的结果返回的列在该索引中能够全部找到，这样不需要回表</li></ul><h2 id="前缀索引">前缀索引</h2><ul><li>如果需要索引很长的字符串，可以使用前缀索引，或者使用<code>ES</code>实现</li><li><code>create index idx_xxx on 表名(字段名(n));</code> 建立前缀索引，<code>n</code>表示要提取这个字段中的前<code>n</code>个字符构建索引</li><li><code>n</code>是前缀长度，可以根据索引<strong>选择性</strong>决定，选择性是<strong>不重复的索引值</strong>(基数)与<strong>数据表的记录总数</strong>的比值。<ul><li>选择性越高，查询效率越高</li><li>唯一索引的选择性就是1，是最高的索引选择性，性能也是最好的<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> email) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> <span class="keyword">user</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="built_in">substring</span>(email, <span class="number">1</span>, <span class="number">5</span>)) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>前缀索引不支持覆盖索引，所以一定会回表</strong></li></ul><h2 id="单列索引-VS-联合索引">单列索引 VS 联合索引</h2><ol><li>如果<code>where</code>有两个部分，分别都只有单列索引，这时候第一个条件会走单列索引，第二个条件不会走索引<br><code>select id, phone, name from user where phone='12312312312' and name='123';</code> 此时只有<code>phone</code>走单列索引，<code>name</code>没有走索引，导致最终回表</li><li>如果这时候有两个部分的单列索引，以及两个部分的联合索引，简单的使用<code>where</code>，依然是只有第一部分使用单列索引。因此需要指定使用联合索引才行</li><li>如果涉及多个查询条件，推荐使用联合索引</li></ol><h2 id="索引设计原则">索引设计原则</h2><ol><li>数据量较大(&gt; 100万)，查询频繁的表需要涉及索引。如果只插入，不查询，就不用建立索引</li><li>针对常常作为查询条件<code>where</code>，排序<code>order by</code>，分组<code>group by</code>这几个字段建立索引</li><li>建立索引使用区分度高的列作为索引，尽量建立唯一索引。如果是性别，状态这种字段没有必要建立索引</li><li>字符串较长考虑使用前缀索引</li><li>尽量使用联合索引，减少单列索引，以达到使用覆盖索引，避免回表</li><li>控制索引的数量，索引越多，增删改的效率越低</li><li>索引列不能存储<code>NULL</code>，建表的时候使用<code>NOT NULL</code>约束，可以更有效的使用索引</li></ol><h2 id="例子">例子:</h2><div class="note info flat"><p>索引命名规范: <code>idx_表名_字段名</code><br>创建联合索引对字段顺序有要求</p></div><ol><li><code>name</code>是姓名字段，可能重复: <code>create index idx_user_name on user(name);</code> 创建常规索引</li><li><code>phone</code>是手机号，非空，唯一，创建索引: <code>create unique index idx_user_phone on user(phone);</code> 创建唯一索引</li><li>为<code>profession, age, status</code>创建索引: <code>create index idx_user_pro_age_status on user(profession, age, status);</code> 创建联合索引</li><li>为<code>email</code>创建合适的索引: <code>create index idx_user_email on user(email);</code> 创建常规索引</li><li>一张表四个字段<code>(id, username, password, status)</code>如何优化<code>select id, username, password from user where username='a';</code>:<ul><li>建立<code>username, password</code>联合索引，并且<code>username</code>放在第一个，从而满足最左前缀法则，可以避免回表</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;索引&lt;/h1&gt;
&lt;div class=&quot;note info flat&quot;&gt;&lt;ul&gt;
&lt;li&gt;高效获取数据的&lt;strong&gt;有序&lt;/strong&gt;数据结构&lt;/li&gt;
&lt;li&gt;提高检索效率，降低IO成本。&lt;/li&gt;
&lt;li&gt;索引列对数据进行&lt;strong&gt;排序&lt;/strong&gt;</summary>
      
    
    
    
    <category term="MySQL" scheme="https://sangs3112.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://sangs3112.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL笔记_1</title>
    <link href="https://sangs3112.github.io/posts/504036dc.html"/>
    <id>https://sangs3112.github.io/posts/504036dc.html</id>
    <published>2024-03-11T16:15:13.000Z</published>
    <updated>2024-03-23T00:16:00.121Z</updated>
    
    <content type="html"><![CDATA[<h1>函数</h1><h2 id="字符串函数">字符串函数</h2><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">CONCAT(S1, S2, …, Sn)</td><td style="text-align:center">字符串拼接，将S1, S2, …, Sn拼接陈一个字符串</td></tr><tr><td style="text-align:center">LOWER(str)</td><td style="text-align:center">将字符串转为小写</td></tr><tr><td style="text-align:center">UPPER(str)</td><td style="text-align:center">将字符串转为大写</td></tr><tr><td style="text-align:center">LPAD(str, n, pad)</td><td style="text-align:center">左填充，用字符串pad对str的左边进行填充，达到长度n</td></tr><tr><td style="text-align:center">RPAD(str, n, pad)</td><td style="text-align:center">右填充，用字符串pad对str的右边进行填充，达到长度n</td></tr><tr><td style="text-align:center">TRIM(str)</td><td style="text-align:center">去掉字符串头部和尾部的空格</td></tr><tr><td style="text-align:center">SUBSTRING(str, start, len)</td><td style="text-align:center">返回从字符串str的start位置起的len个长度的字符串</td></tr></tbody></table><div class="note info flat"><ul><li><code>trim</code>不能去除中间的空格</li><li><code>substring</code>的<code>start</code>从1开始，不是0</li><li><code>substring()</code>可以只输入两个参数，表示从<code>start</code>的位置截取到字符串末尾</li><li><code>start</code>参数可以为负，如果是负数，则自动忽略<code>len</code>参数，表示截取最后几个字符</li><li><code>lpad</code>和<code>rpad</code>如果输入的字符串过长，超过了第二个参数n，则自动变为<strong>从左往右</strong>的n个字符</li></ul></div><h2 id="数值函数">数值函数</h2><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">CEIL(x)</td><td style="text-align:center">向上取整</td></tr><tr><td style="text-align:center">FLOOR(x)</td><td style="text-align:center">向下取整</td></tr><tr><td style="text-align:center">MOD(x,y)</td><td style="text-align:center">取<code>x/y</code>的模</td></tr><tr><td style="text-align:center">RAND()</td><td style="text-align:center">返回0~1内随机数</td></tr><tr><td style="text-align:center">ROUND(x, y)</td><td style="text-align:center">x四舍五入，并保留y位小数</td></tr></tbody></table><h2 id="日期函数">日期函数</h2><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">CURDTE()</td><td style="text-align:center">返回当前日期</td></tr><tr><td style="text-align:center">CURTIME()</td><td style="text-align:center">返回当前时间</td></tr><tr><td style="text-align:center">NOW()</td><td style="text-align:center">返回当前日期和时间</td></tr><tr><td style="text-align:center">YEAR(date)</td><td style="text-align:center">获取指定date的年份</td></tr><tr><td style="text-align:center">MONTH(date)</td><td style="text-align:center">获取指定date的月份</td></tr><tr><td style="text-align:center">DAY(date)</td><td style="text-align:center">获取指定date的日期</td></tr><tr><td style="text-align:center">DATE_ADD(date, INTERVAL expr, type)</td><td style="text-align:center">在date后的日期加上时间长度</td></tr><tr><td style="text-align:center">DATEDIFF(date1, date2)</td><td style="text-align:center">返回起始时间date1和结束时间date2之间的天数</td></tr></tbody></table><div class="note info flat"><p><code>date_add(date, interval expr, type);</code>中，<code>interval</code>是固定的。</p></div><h2 id="流程控制函数">流程控制函数</h2><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">IF(value, t, f)</td><td style="text-align:center">如果value为true，则返回t，否则返回f</td></tr><tr><td style="text-align:center">IFNULL(value1, value2)</td><td style="text-align:center">如果value1<strong>不为空</strong>，则返回value1，否则返回value2</td></tr><tr><td style="text-align:center">CASE WHEN [val1] THEN [res1] … ELSE [default] END</td><td style="text-align:center">如果val1为true，返回res1，…，否则返回default</td></tr><tr><td style="text-align:center">CASE [expr] WHEN [val1] THEN [res1] … ELSE [default] END</td><td style="text-align:center">如果expr值等于val1，返回res1，…，否则返回default</td></tr></tbody></table><div class="note info flat"><ul><li><code>ifnull('OK', 'D');</code> 返回’OK’</li><li><code>ifnull('', 'D');</code> 返回’’</li><li><code>ifnull(null, 'D');</code> 返回’D’</li></ul></div><h1>约束</h1><table><thead><tr><th style="text-align:center">关键字</th><th style="text-align:center">约束</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">NOT NULL</td><td style="text-align:center">非空约束</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">UNIQUE</td><td style="text-align:center">唯一约束</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">PRIMARY KEY</td><td style="text-align:center">主键约束</td><td style="text-align:center">一行数据的唯一标识，非空且唯一</td></tr><tr><td style="text-align:center">DEFAULT</td><td style="text-align:center">默认约束</td><td style="text-align:center">保存数据时，未指定某个字段，则使用默认值</td></tr><tr><td style="text-align:center">CHECK</td><td style="text-align:center">检查约束</td><td style="text-align:center">保证字段值满足某条件</td></tr><tr><td style="text-align:center">FOREIGN KEY</td><td style="text-align:center">外键约束</td><td style="text-align:center">让两张表的数据建立连接，保证数据的完整性和一致性</td></tr></tbody></table><table><thead><tr><th style="text-align:center">删除/更新行为</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">NOT ACTION</td><td style="text-align:center">在父表中删除/更新对应的记录时，首先检查该记录是否有外键，如果有则不允许删除/更新。(与RESTRICT一致)</td></tr><tr><td style="text-align:center">RESTRICT</td><td style="text-align:center">在父表中删除/更新对应记录时，首先检查该记录是否有外键，如果有则不允许删除/更新。(与NOT ACTION一致)</td></tr><tr><td style="text-align:center">CASCADE</td><td style="text-align:center">在父表中删除/更新对应记录时，首先检查该记录是否有外键，如果有，则也删除/更新外键在子表中的记录</td></tr><tr><td style="text-align:center">SET NULL</td><td style="text-align:center">在父表中删除对应记录时，检查该记录是否有对应外键，如果有则设置子表中该外键的值为NULL(这要求该外键允许为NULL)</td></tr><tr><td style="text-align:center">SET DEFAULT</td><td style="text-align:center">父表有变更时，子表将外键列设为一个默认值 (InnoDB不支持)</td></tr></tbody></table><div class="note info flat"><ul><li>自增 <code>auto_increment</code></li><li>外键约束一般不使用</li><li>添加外键约束: <code>alter table 表名 add constraint 外键名 foreign key (外键字段名) references 主表(主表列名);</code>括号是必须要有的</li><li>删除外键约束: <code>alter table 表名 drop foreign key 外键名;</code></li><li>设置外键在删除/更新都是级联的: <code>alter table 表名 add constraint 外键名 foreign key (外键字段) references 主表(主表列名) on update cascade on delete cascade;</code></li></ul></div><h1>多表查询</h1><table><thead><tr><th style="text-align:center">关系</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">一对多</td><td style="text-align:center">多的一方建立外键，指向一，比如员工和部门</td></tr><tr><td style="text-align:center">多对多</td><td style="text-align:center">建立中间表，包含两个外键，分别关联二者主键，比如学生课程</td></tr><tr><td style="text-align:center">一对一</td><td style="text-align:center">随便在一个表中建立外键，主要用于单表拆分，对外建需要设置唯一约束</td></tr></tbody></table><h2 id="内连接">内连接:</h2><ul><li>隐式内连接: <code>select 字段列表 from A, B where 条件;</code></li><li>显式内连接: <code>select 字段列表 from A [inner] join B on 条件;</code></li></ul><div class="note info flat"><ul><li><code>inner</code>可以省略</li><li>查询AB交集，查询不到某张表的<code>NULL</code></li></ul></div><h2 id="外连接">外连接:</h2><ul><li>左外连接:  <code>select 字段列表 from A left [outer] join B on 条件;</code></li><li>右外连接:  <code>select 字段列表 from A right [outer] join B on 条件;</code></li></ul><div class="note info flat"><ul><li>外连接<strong>可以</strong>查找出<code>NULL</code></li><li>左外连接查找左表中所有数据以及两个表的交集</li><li>右外连接查找右表中所有数据以及两个表的交集</li></ul></div><h2 id="自连接">自连接:</h2><p><code>select 字段列表 from A 别名A join A 别名B on 条件;</code></p><div class="note info flat"><ul><li>当前表和自身进行连接查询，自连接需要使用表别名</li></ul></div><h2 id="联合查询">联合查询:</h2><p><code>select 字段列表 from A ... union [all] select 字段列表 from B;</code></p><div class="note info flat"><ul><li>联合查询是将多次查询结果合并起来，形成新查询结果集</li><li><code>all</code>将查询结果合并，如果不使用<code>all</code>，则会去重</li><li>两个不同的<code>select</code>中字段列表必须保持一致</li></ul></div><h2 id="子查询">子查询:</h2><p><code>select * from A where c1 = (select c1 from B);</code></p><div class="note info flat"><ul><li>子查询内部可以使用<code>insert/delete/update/select</code></li><li>标量子查询，列子查询，行子查询，表子查询，分别表示子查询返回的结果数量是一个值，一列，一行，还是一个表</li><li><code>where/from/select</code>之后都可以出现子查询</li><li>列子查询中<code>any</code>与<code>some</code>等价，都表示其中任意一个满足即可</li></ul></div><h2 id="例子">例子:</h2><ol><li>查询员工姓名，年龄，职位，部门信息(隐式内连接): <code>select e.name, e.age e.job d.name from emp e, dept d where e.dept_id = d.id;</code></li><li>查询年龄小于30的员工的姓名年龄，职位，部门信息(显式内连接): <code>select e.name, e.age, e.job d.name from emp e join dept d on e.dept_id = d.id where e.age &lt; 30;</code></li><li>查询拥有员工的部门id和部门名称: <code>select distinct d.id, d.name from emp e, dept d where e.dept_id = d.id;</code> (内连接求交集)</li><li>查询所有年龄大于40的员工，及其归属的部门名称，如果员工没有分配部门，也需要展示: <code>select e.*, d.name from emp e left join dept d on e.dept_id = d.id where e.age &gt; 40;</code></li><li>查询所有员工的工资等级: <code>select e.*, s.grade from emp e, salgrade s where e.salary &gt;= s.losal and e.salary &lt;= s.hisal;</code></li><li>查询研发部所有员工的信息以及工资等级: <code>select e.*, s.grade from emp e, salgrade s, dept d where e.dept_id = d.id and (e.salary between s.losal and s.hisal) and d.name = '研发';</code></li><li>查询研发部员工的平均工资: <code>select avg(e.salary) from emp e, dept d where e.dept_id = d.id and d.name = '研发';</code></li><li>查询工资比A高的员工信息: <code>select * from emp where salary &gt; (select salary from emp where name = 'A';</code></li><li>查询比平均工资高的员工信息: <code>select * from emp where salary &gt; (select avg(salary) from emp);</code></li><li>查询低于本部门平均工资的员工: <code>select * from emp e2 where e2.salary &lt; (select avg(e1.salary) from emp e1 where e1.dept_id = d2.dept_id);</code></li><li>查询所有部门信息，并统计部门员工人数: <code>select d.id , d.name, (select count(*) from emp e where e.dept_id = d.id) '人数' from dept d;</code></li><li>查询所有学生的选课情况，展示出学生名称，学号，课程名称: <code>select s.name, s.no, c.name from student s, student_course sc, course c where s.id = sc.studentid and sc.courseid = c.id;</code></li></ol><h1>事务</h1><div class="note info flat"><ul><li>MySQL事务默认自动提交，执行一条DML语句，会立刻隐式提交事务</li><li><code>select @@autocommit;</code>查看当前事务是否自动提交，如果为1，则表示自动提交</li><li><code>set @@autocommit=0;</code>设置手动提交，需要手动写<code>commit</code>才会提交事务</li><li>出错可以使用<code>rollback;</code>回滚事务</li><li>开启事务<code>start transaction</code>或者<code>begin</code>，这样不需要修改<code>@@autocommit</code></li></ul></div><h2 id="四大特性-ACID">四大特性 <strong>ACID</strong></h2><ul><li>原子性: 事务是不可分割的最小单元，要么全部成功，要么全部失败</li><li>一致性: 事务完成时，所有数据都需要保持一致状态</li><li>隔离性: 数据库提供隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</li><li>持久性: 事务一旦提交或者回滚，对数据库中的数据改变就是永久的</li></ul><h2 id="并发问题与隔离级别">并发问题与隔离级别</h2><h3 id="并发问题">并发问题</h3><ul><li>脏读: 一个事务读到另一个事务还没有提交的数据</li><li>不可重复读: 一个事务先后读取同一条记录，但是两次读取的数据不同</li><li>幻读: 一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现数据已经存在</li></ul><h3 id="隔离级别">隔离级别</h3><table><thead><tr><th style="text-align:center">隔离级别</th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th style="text-align:center">幻读</th></tr></thead><tbody><tr><td style="text-align:center">Read Uncommitted</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">Read Committed</td><td style="text-align:center">解决</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">Repeatable Read (默认)</td><td style="text-align:center">解决</td><td style="text-align:center">解决</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">Serializable</td><td style="text-align:center">解决</td><td style="text-align:center">解决</td><td style="text-align:center">解决</td></tr></tbody></table><div class="note info flat"><ul><li>读未提交的隔离级别下，三种并发问题都有可能出现</li><li>可重复读是MySQL的默认配置，Orical是读可提交</li><li>串行化，性能最差，隔离级别最高，失去并发能力</li><li><code>select @@transaction_isolation;</code>查看事务的隔离级别</li><li><code>set [session|global] transaction isolation level {read uncommitted | read committed | repeatable read | serializable}</code> <code>session</code>表示对当前会话窗口有效，<code>global</code>是对所有窗口有效</li><li>尽管相比于默认的可重复读，读提交不能解决不可重复读的问题，但是可重复读这一隔离级别在并发时会导致死锁，未来打算放一篇专门的笔记分析。</li></ul></div><h1>体系结构</h1><ul><li>连接层: 最上层，客户端和链接服务，链接处理、授权认证、相关安全方案。服务器安全接入每个客户端并验证它所具有的操作权限</li><li>服务层: 完成大多数的核心服务功能，比如SQL接口，完成缓存查询，SQL分析和优化，内置函数执行。所有跨存储引擎的功能也在这层实现，比如过程，函数</li><li>引擎层: 负责MySQL的数据存储和提取，服务器通过API和存储引擎进行通信，不同的存储引擎具有不同功能</li><li>存储层: 将数据存储在文件系统之上，完成与存储引擎的交互</li></ul><div class="note info flat"><ul><li>索引是在存储引擎层实现的</li><li>存储引擎基于表的，不是基于库的，所以存储引擎也被称为表类型</li><li>创建表的时候指定存储引擎，<code>show engines;</code>显示当前支持的存储引擎</li><li>MySQL早期存储引擎为<code>MyISAM</code>，<code>5.5</code>版本后替换为<code>InnoDB</code></li></ul></div><p><img src="https://gitee.com/sang3112/blog_imgs/raw/master/MySQL/InnoDB.png" alt="InnoDB"></p><div class="note info flat"><ul><li><code>page</code>是磁盘操作的最小单元，大小固定为16K;<code>extent</code>区域大小固定为1M，也就是一个区中包含64个页</li></ul></div><h2 id="MyISAM-VS-InnoDB-VS-Memory"><code>MyISAM</code> VS <code>InnoDB</code> VS <code>Memory</code></h2><ul><li><code>MyISAM</code>不支持事务，不支持外键，支持表锁而不支持行锁，访问速度快</li><li><code>InnoDB</code>支持事务，支持外键保证完整性和一致性，支持行锁，提高并发性能。</li><li><code>MyISAM</code>涉及三个格式: <code>MYD MYI sdi</code>分别存储数据 索引和表结构</li><li><code>InnoDB</code>对应文件是<code>表名.idb</code>，每张表都会存储表结构(早期为<code>frm</code>,8.0版本后改为<code>sdi</code>)、数据和索引。<code>innodb_file_per_table</code>是一个开关，表名是否每张表都对应一个表空间文件<code>idb</code></li><li><code>Memory</code> 数据只在内存中，只能临时存储，或作为缓存使用，支持<code>hash</code>索引，只有<code>sdi</code>文件，存储表结构</li></ul><div class="note info flat"><ul><li>如果数据除了插入和查询以外，还包含很多更新、删除操作，那么选择<code>InnoDB</code>可以保证数据一致性</li><li>应用以读和插入操作为主，很少的更新和删除操作，并且给对事物完整性，并发性要求不高，就使用<code>MyISAM</code></li><li><code>Memory</code>将所有数据保存在内存中，访问速度快，通常用于临时表和缓存。但是对表大小有限制，并且无法保障安全性，(不如用<code>Redis</code>)</li></ul></div><table><thead><tr><th style="text-align:center">特点</th><th style="text-align:center">InnoDB</th><th style="text-align:center">MyISAM</th><th style="text-align:center">Memory</th></tr></thead><tbody><tr><td style="text-align:center">存储限制</td><td style="text-align:center">64TB</td><td style="text-align:center">4GB</td><td style="text-align:center">16MB</td></tr><tr><td style="text-align:center">事务安全</td><td style="text-align:center">支持</td><td style="text-align:center">无</td><td style="text-align:center">无</td></tr><tr><td style="text-align:center">锁</td><td style="text-align:center">行锁</td><td style="text-align:center">表锁</td><td style="text-align:center">表锁</td></tr><tr><td style="text-align:center">B+树索引</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">Hash索引</td><td style="text-align:center">无</td><td style="text-align:center">无</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">全文索引</td><td style="text-align:center">支持(5.6)版本后</td><td style="text-align:center">支持</td><td style="text-align:center">无</td></tr><tr><td style="text-align:center">空间使用</td><td style="text-align:center">高</td><td style="text-align:center">低</td><td style="text-align:center">N/A</td></tr><tr><td style="text-align:center">内存使用</td><td style="text-align:center">高</td><td style="text-align:center">低</td><td style="text-align:center">中等</td></tr><tr><td style="text-align:center">批量插入速度</td><td style="text-align:center">低</td><td style="text-align:center">高</td><td style="text-align:center">高</td></tr><tr><td style="text-align:center">支持外键</td><td style="text-align:center">支持</td><td style="text-align:center">无</td><td style="text-align:center">无</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;函数&lt;/h1&gt;
&lt;h2 id=&quot;字符串函数&quot;&gt;字符串函数&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;函数&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;功能&lt;/th&gt;
&lt;/tr&gt;</summary>
      
    
    
    
    <category term="MySQL" scheme="https://sangs3112.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://sangs3112.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL笔记_0</title>
    <link href="https://sangs3112.github.io/posts/fae54f81.html"/>
    <id>https://sangs3112.github.io/posts/fae54f81.html</id>
    <published>2024-03-10T07:05:56.000Z</published>
    <updated>2024-03-23T00:16:00.121Z</updated>
    
    <content type="html"><![CDATA[<h1>创建数据库</h1><h2 id="字符集选择-utf8mb4">字符集选择: <code>utf8mb4</code></h2><ul><li><code>Unicode</code>编码，也称作统一码，万国码。如：<code>utf8, utf16, utf32</code></li><li><code>utf8mb4</code>兼容<code>utf8</code>，并且可以表示更多的字符。具体来说:  <div class="note default flat"><p><code>Unicode</code>中的第<code>1-126</code>行是<code>utf8</code>的区域，<code>utf8mb4</code>同样兼容这一片区域，剩下<code>126</code>行以下的部分是<code>utf8mb4</code>扩充区域。</p></div></li><li>一般不选择<code>utf8</code>，因为其占用三个字节；而实际上很多内容，比如表情，就需要四字节空间，所以一般使用<code>utf8mb4</code></li></ul><h2 id="排序规则选择：">排序规则选择：</h2><ul><li>对于<code>utf8mb4</code>而言，常用的排序规则有<code>utf8mb4_unicode_ci</code>，<code>utf8mb4_general_ci</code>，<code>utf8mb4_bin</code></li></ul><table><thead><tr><th style="text-align:center"><code>utf8mb4_unicode_ci</code></th><th style="text-align:center"><code>utf8mb4_general_ci</code></th><th style="text-align:center"><code>utf8mb4_bin</code></th></tr></thead><tbody><tr><td style="text-align:center"><strong>基于标准的Unicode</strong>规则来排序和比较</td><td style="text-align:center">没有实现Unicode排序规则</td><td style="text-align:center">将字符串的每个字符用二进制数据编译存储</td></tr><tr><td style="text-align:center">各语言<strong>精确排序</strong></td><td style="text-align:center">在某些特殊语言字符集，排序结果可能不一致</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>不区分大小写</strong></td><td style="text-align:center"><strong>不区分大小写</strong></td><td style="text-align:center"><strong>区分大小写</strong></td></tr><tr><td style="text-align:center">为了能够处理特殊字符，实现了略微复杂的排序算法</td><td style="text-align:center">比较和排序的时候更快</td><td style="text-align:center"> </td></tr></tbody></table><h1><code>SQL</code>分类</h1><table><thead><tr><th style="text-align:center">分类</th><th style="text-align:center">全称</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">DDL</td><td style="text-align:center">Data Definition Language</td><td style="text-align:center">数据定义语言，定义数据库、表、字段</td></tr><tr><td style="text-align:center">DML</td><td style="text-align:center">Data Manipulation Language</td><td style="text-align:center">数据操作语言，对数据<strong>增删改</strong></td></tr><tr><td style="text-align:center">DQL</td><td style="text-align:center">Data Query Language</td><td style="text-align:center">数据查询语言，<strong>查</strong></td></tr><tr><td style="text-align:center">DCL</td><td style="text-align:center">Data Control Language</td><td style="text-align:center">数据控制语言，创建数据库用户，设置访问权限</td></tr></tbody></table><h2 id="DDL"><code>DDL</code></h2><h3 id="查">查</h3><ul><li><p>查询<strong>所有</strong>数据库: <code>show databases;</code></p></li><li><p>查询当前数据库: <code>select database();</code></p></li><li><p>查询当前数据库中<strong>所有</strong>的表: <code>show tables;</code></p></li><li><p>查询表结构: <code>desc 表名;</code></p></li><li><p>查询建表语句: <code>show create table 表名;</code></p></li></ul><h3 id="增">增</h3><ul><li><p>创建数据库: <code>create database [if not exists] 数据库名 [default charset 字符集] [collate 排序规则];</code></p></li><li><p>创建表: <code>create table 表名 (字段名 字段类型 [comment '字段注释'], 字段名 字段类型 [comment '字段注释'], ...) [comment '表注释'];</code></p></li><li><p>添加表字段: <code>alter table 表名 add 字段名 类型 [comment '字段注释'];</code></p></li></ul><h3 id="删">删</h3><ul><li><p>删除数据库: <code>drop database [if exists] 数据库名;</code></p></li><li><p>删除表: <code>drop table [if exists] 表名;</code></p></li><li><p>删除并重新创建表: <code>truncate table 表名;</code></p></li><li><p>删除字段: <code>alter table 表名 drop 字段名;</code></p></li></ul><h3 id="改">改</h3><ul><li><p>修改表名: <code>alter table 表名 rename to 新表名;</code></p></li><li><p>修改字段数据类型: <code>alter table 表名 modify 字段名 新类型;</code></p></li><li><p>修改字段名和数据类型: <code>alter table 表名 change 原字段名 新字段名 类型 [comment '字段注释'];</code></p></li></ul><h3 id="类型">类型</h3><table>    <tr>        <th>分类</th><th>类型</th><th>大小</th><th>有符号范围</th><th>无符号范围</th><th>描述</th>    </tr>    <tr>        <td rowspan="8">数值</td>        <td>TINYINT</td><td>1B</td><td>(-128, 127)</td><td>(0, 255)</td><td></td>    </tr>    <tr>        <td>SMALLINT</td><td>2B</td><td>(-32768, 32767)</td><td>(0, 65535)</td><td></td>    </tr>    <tr>        <td>MIDIUMINT</td><td>3B</td><td>(-8388608, 8388607)</td><td>(0, 16777215)</td><td></td>    </tr>    <tr>        <td>INT or INTEGER</td><td>4B</td><td>(-2147483648, 2147483647)</td><td>(0, 4294967295)</td><td></td>    </tr>    <tr>        <td>BIGINT</td><td>8B</td><td>(-2^63, 2^63 - 1)</td><td>(0, 2^64 - 1)</td><td></td>    </tr>    <tr>        <td>FLOAT</td><td>4B</td><td>(-3.4028E+38, 3.4028E+38)</td><td>0 and (1.17549E-38, 3.4028E+38)</td><td></td>    </tr>    <tr>        <td>DOUBLE</td><td>8B</td><td>(-1.79769E+308, 1.79769E+308)</td><td>0 and (2.22507E-308, 1.79769E+308)</td><td></td>    </tr>    <tr>        <td>DECIMAL</td><td></td><td>由M(精度),D(标度)决定</td><td>由M(精度),D(标度)决定</td><td>精确定点数</td>    </tr></table><table>    <tr>        <th>分类</th><th>类型</th><th>大小</th><th>描述</th>    </tr>    <tr>        <td rowspan="10">字符串</td>        <td>CHAR</td><td>(0, 255B)</td><td>定长字符串</td>    </tr>    <tr>        <td>VARCHAR</td><td>(0, 65535B)</td><td>变长字符串</td>    </tr>    <tr>        <td>TINYBLOB</td><td>(0, 255B)</td><td>不超过255个字符的二进制数据</td>    </tr>    <tr>        <td>TINYTEXT</td><td>(0, 255B)</td><td>短文本</td>    </tr>    <tr>        <td>BLOB</td><td>(0, 65535B)</td><td>二进制长文本</td>    </tr>    <tr>        <td>TEXT</td><td>(0, 65535B)</td><td>长文本</td>    </tr>    <tr>        <td>MEDIUMBLOB</td><td>(0, 16777215B)</td><td></td>    </tr>    <tr>        <td>MEDIUMTEXT</td><td>(0, 16777251B)</td><td></td>    </tr>    <tr>        <td>LONGBLOB</td><td>(0, 4294967295B)</td><td></td>    </tr>    <tr>        <td>LONGTEXT</td><td>(0, 4294967295B)</td><td></td>    </tr></table><table>    <tr>        <th>分类</th><th>类型</th><th>大小</th><th>范围</th>    </tr>    <tr>        <td rowspan="5">日期</td>        <td>DATE</td><td>3B</td><td>1000-01-01至9999-12-31</td>    </tr>    <tr>        <td>TIME</td><td>3B</td><td>-838:59:59至838:59:59</td>    </tr>    <tr>        <td>YEAR</td><td>1B</td><td>1901至2155</td>    </tr>    <tr>        <td>DATETIME</td><td>8B</td><td>1000-01-01 00:00:00至9999-12-31 23:59:59</td>    </tr>    <tr>        <td>TIMESTAMP</td><td>4B</td><td>1970-01-01 00:00:01至2038-01-19 03:14:07</td>    </tr></table><div class="note info flat"><ul><li>存储年龄，使用<code>tinyint unsigned</code>，不能写<code>unsigned tinyint</code></li><li>存分数，一位小数，存储钱数，可以使用<code>decimal(4,1)</code>，表示最多四位，小数在最后一位之前</li><li><code>char(10)</code>定长为10，性能好，存储性别可以使用<code>char(1)</code></li><li><code>varchar(10)</code>不定长，性能差一些</li><li><code>timestamp</code>最大时间到2038，所以一般不用</li><li>记录生日使用<code>date</code></li></ul></div><h2 id="DML"><code>DML</code></h2><h3 id="增-2">增</h3><ul><li><p>给指定字段添加数据: <code>insert into 表名 (字段1, 字段2) values (值1, 值2);</code></p></li><li><p>给所有字段添加数据: <code>insert into 表名 values (值1, 值2, ...);</code></p></li><li><p>批量添加数据:</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名 (字段<span class="number">1</span>, 字段<span class="number">2</span>) <span class="keyword">values</span> (值<span class="number">1</span>, 值<span class="number">2</span>), (值<span class="number">3</span>, 值<span class="number">4</span>), ...</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名 <span class="keyword">values</span> (值<span class="number">1</span>, 值<span class="number">2</span>, 值<span class="number">3</span>, 值<span class="number">4</span>, ...), ... </span><br></pre></td></tr></table></figure><ul><li>插入数据为字符串或者日期类型，应使用引号，否则不会走索引</li></ul><h3 id="删-2">删</h3><ul><li>删除数据: <code>delete from 表名 [where 条件];</code></li></ul><h3 id="改-2">改</h3><ul><li>修改数据: <code>update 表名 set 字段1=值1, 字段2=值2,..., [where 条件];</code></li></ul><h2 id="DQL"><code>DQL</code></h2><ul><li><p>查询语句: <code>select 字段列表 from 表名列表 [where 条件] [group by 分组字段列表] [having 分组后过滤条件列表] [order by 排序字段列表] [limit 分页参数];</code></p></li><li><p>查询时可以设置别名: <code>select 字段1 as 别名1, 字段2 as 别名2;</code></p></li><li><p>查询去重: <code>select distinct 字段列表 from 表名;</code></p></li><li><p>条件查询:</p></li></ul><table><thead><tr><th style="text-align:center">比较运算符</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>&lt;&gt; or !=</code></td><td style="text-align:center">不等于</td></tr><tr><td style="text-align:center"><code>BETWEEN...AND...</code></td><td style="text-align:center">在某个范围内,包含边界。一定要写<code>between min and max</code> 写反了查不到值</td></tr><tr><td style="text-align:center"><code>IN(...)</code></td><td style="text-align:center">在列表中多选一</td></tr><tr><td style="text-align:center"><code>LIKE</code></td><td style="text-align:center">模糊匹配(<code>_</code>匹配单个字符, <code>%</code>匹配任意个字符)</td></tr><tr><td style="text-align:center"><code>IS NULL</code></td><td style="text-align:center">为空</td></tr></tbody></table><ul><li><p>聚合函数 <code>count, max, min, avg, sum</code>:</p><ul><li>作用于某一列，所有<code>null</code>不参与聚合函数计算</li><li><code>where</code>是分组之前过滤，在聚合函数之前执行，因此<strong>不能</strong>使用聚合函数；<code>having</code>是分组之后过滤，聚合函数在<code>having</code>之前已经执行了，因此<strong>可以</strong>使用聚合函数</li><li>分组查询一般查询分组之后的字段和聚合函数，其他没有意义</li></ul></li><li><p>排序 <code>order by 字段1 排序方式1, 字段2 排序方式2</code>:</p><ul><li>升序<code>asc</code>，降序<code>desc</code>，默认为升序</li></ul></li><li><p>分页查询 <code>limit 起始索引, 查询记录数</code>:</p><ul><li>起始索引从0开始，起始索引 = (查询页码 - 1) * 每页记录个数</li><li>分页查询是数据库的<strong>方言</strong>，不同数据库关键字不同，MySQL中使用<code>limit</code>，如果查询第一页的数据，则起始索引可以省略</li></ul></li></ul><h3 id="DQL执行顺序"><code>DQL</code>执行顺序:</h3><ul><li><code>from, where, group by, having, select, order by, limit</code></li><li>首先执行<code>from</code>找到表名，然后执行<code>where</code>判断条件，再<code>group by</code>分组和<code>having</code>，再<code>select</code>选择字段列表，最后<code>order by</code>排序和<code>limit</code>分页</li></ul><h2 id="DCL"><code>DCL</code></h2><h3 id="查-2">查</h3><ul><li>查询用户: <code>use mysql; select * from user;</code></li></ul><div class="note info flat"><p>用户信息都存放在<code>mysql</code>系统数据库中</p></div><ul><li>查询用户权限: <code>show grants for '用户名'@'主机名';</code></li></ul><h3 id="增-3">增</h3><ul><li>创建用户: <code>create user '用户名'@'主机名' identified by '密码';</code></li></ul><div class="note info flat"><p>如果需要该用户可以在任意主机上访问该数据库，需要将主机名修改为<code>%</code>即可</p></div><h3 id="删-3">删</h3><ul><li>删除用户: <code>drop user '用户名'@'主机名';</code></li></ul><h3 id="改-3">改</h3><ul><li><p>修改密码: <code>alter user '用户名'@'主机名' identified with mysql_native_password by '新密码';</code></p></li><li><p>授权: <code>grant 权限列表 on 数据库名.表名 to '用户名'@'表名'</code>;</p></li><li><p>撤销权限: <code>revoke 权限列表 on 数据库名.表名 from '用户名'@'表名';</code></p></li></ul><div class="note info flat"><p><code>'用户名'@'表名'</code> 中间不能存在空格</p></div><table><thead><tr><th style="text-align:center">权限</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">ALL, ALL PRIVILEGES</td><td style="text-align:center">所有权限</td></tr><tr><td style="text-align:center">SELECT</td><td style="text-align:center">查询数据</td></tr><tr><td style="text-align:center">INSERT</td><td style="text-align:center">插入数据</td></tr><tr><td style="text-align:center">UPDATE</td><td style="text-align:center">修改数据</td></tr><tr><td style="text-align:center">DELETE</td><td style="text-align:center">删除数据</td></tr><tr><td style="text-align:center">ALTER</td><td style="text-align:center">修改表</td></tr><tr><td style="text-align:center">DROP</td><td style="text-align:center">删除数据库/表/视图</td></tr><tr><td style="text-align:center">CREATE</td><td style="text-align:center">创建数据库/表</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;创建数据库&lt;/h1&gt;
&lt;h2 id=&quot;字符集选择-utf8mb4&quot;&gt;字符集选择: &lt;code&gt;utf8mb4&lt;/code&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Unicode&lt;/code&gt;编码，也称作统一码，万国码。如：&lt;code&gt;utf8, utf16, utf32</summary>
      
    
    
    
    <category term="MySQL" scheme="https://sangs3112.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://sangs3112.github.io/tags/MySQL/"/>
    
  </entry>
  
</feed>
