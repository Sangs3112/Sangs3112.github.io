<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Sangs Blog</title><meta name="author" content="Sangs"><meta name="copyright" content="Sangs"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta property="og:type" content="website">
<meta property="og:title" content="Sangs Blog">
<meta property="og:url" content="https://sangs3112.github.io/index.html">
<meta property="og:site_name" content="Sangs Blog">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://sangs3112.github.io/img/avatar.png">
<meta property="article:author" content="Sangs">
<meta property="article:tag" content="博客,Sangs">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://sangs3112.github.io/img/avatar.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://sangs3112.github.io/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><meta name="google-site-verification" content="https://github.com/Sangs3112/Sangs3112.github.io/blob/master/googlea12c1ab75804fd8f.html"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Sangs Blog',
  isPost: false,
  isHome: true,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2024-11-27 21:22:50'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><meta name="referrer" content="no-referrer" /><!-- hexo injector head_end start --><link rel="stylesheet" href="https://unpkg.zhimg.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.1.1"><link rel="alternate" href="/atom.xml" title="Sangs Blog" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">56</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw fas fa-home faa-tada"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><i class="fa-fw fas fa-folder-open faa-tada"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/tags/"><i class="fa-fw fas fa-tags faa-tada"></i><span> 标签</span></a></div></div></div></div><div class="page" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Sangs Blog"><span class="site-name">Sangs Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw fas fa-home faa-tada"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><i class="fa-fw fas fa-folder-open faa-tada"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/tags/"><i class="fa-fw fas fa-tags faa-tada"></i><span> 标签</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div class="recent-posts" id="recent-posts"><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/posts/f86b96e2.html" title="Go笔记_0">Go笔记_0</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-11-27T13:22:30.090Z" title="发表于 2024-11-27 21:22:30">2024-11-27</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Go/">Go</a></span></div><div class="content">GOROOT VS GOPATH VS GOBIN VS GOPROXY

GOROOT: Go语言安装路径
GOPATH: 若干工作区目录的路径。是我们自己定义的工作空间  
GO1.8版本之后，开发包安装完成后会自动设置一个GOPATH目录，
GO1.14版本之后，推荐使用Go Module模式，不一定非要将代码写在GOPATH目录下，也不需要自己配置GOPATH



GOBIN: GO程序生成的可执行文件的路径
GOPROXY: 默认为GOPROXY=https://proxy.golang.org,direct，修改为GOPROXY=https://goproxy.cn,direct

跨平台编译
Windows 编译 LINUX或者OSX
1234SET CGO_ENABLED=0   // 禁用CGOSET GOOS=linux      // 目标平台, [windows, linux, darwin]SET GOARCH=amd64    // 目标处理器架构go build
LINUX 或者 OSX 编译其他环境
1CGO_ENABLED=0 GOOS=linux| ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/posts/8f6ca674.html" title="Go笔记_1">Go笔记_1</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-11-27T13:22:30.090Z" title="发表于 2024-11-27 21:22:30">2024-11-27</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Go/">Go</a></span></div><div class="content">方法

Go语言中只有不同的package中可以有相同函数名的函数，尽管参数不同，但是如果函数名相同就不能出现在相同的包中(函数重载Go语言没有)
方法需要通过一个特定的实例调用，比如t.Errorf()，这里的Errorf就是一个方法，通过实例t调用
函数可以随便调用，没有限制


接口

接口让函数接受不同类型的参数并创造类型安全并且高解耦的代码
Go语言中 interface resolution 是隐式的。如果传入的类型匹配接口需要的，则编译正确。
函数实现因此不需要关心参数是什么类型的，只需要声明一个接口，辅助函数就可以从具体类型解耦而只关心本身需要做的工作

表格驱动测试

如果需要测试一个接口的不同实现，或者传入的数据有很多不同的测试需求，则可以使用表格驱动测试

123456789101112131415161718func TestArea(t *testing.T)&#123;	areaTests := []struct&#123;		name string		shape Shape		want float64	&#125;&#123;		&#123;name: & ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/posts/ce24a37f.html" title="MySQL笔记_6">MySQL笔记_6</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-11-27T13:22:30.090Z" title="发表于 2024-11-27 21:22:30">2024-11-27</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/MySQL/">MySQL</a></span></div><div class="content">语句耗时

如果select长时间不返回，使用show processlist查看当前语句处于什么状态

比如MDL写锁阻塞了别的session的读
可以查询是什么session阻塞，但是在MySQL启动时需要设置performance_schema = ON，这样会有10%的性能损失





sys.schema_table_lock_waits，查询这张表可以找到导致阻塞的processid，kill掉即可


还有可能被flush阻塞了，一般flush的两个语句是flush table t with read lock锁表t，flush tables with read lock锁所有的表，本身刷脏页的速度很快，但是可能flush命令被别的session阻塞了


或者别的线程占用写锁，那么申请lock in share mode的读锁就会被阻塞。通过查找sys.innodb_lock_waits表即可


如果在RR场景下，或者在一个事务中，使用select，如果此时别的session有一个update语句，update了一百万次，那么自己的select语句就会特别慢，因为是 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/posts/b92393e9.html" title="MySQL笔记_7">MySQL笔记_7</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-11-27T13:22:30.090Z" title="发表于 2024-11-27 21:22:30">2024-11-27</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/MySQL/">MySQL</a></span></div><div class="content">主备

主备切换流程

状态1，客户端读写都只访问节点A，B是从库，同步A的更新，保证AB数据相同
需要切换的时候，就变成状态2，客户端只访问节点B


状态1不会操作B，但是建议将B设置为read only

防止他人误操作B
防止切换逻辑出现双写的问题
判断访问节点的角色
read only对超级管理员无效，所以可以同步更新的线程有超级权限





binlog statement

statement就是记录SQL语言，甚至会把注释也都记录进去
statement的格式下，delete带有limit，就是unsafe的，会导致主从不一致
删除条件的两个都有索引，如果主从版本不一，可能选择的索引不一致，所以顺序不同，导致delete的东西不同，本质上就是主从库可能delete的时候用到的索引不同，因为有limit存在，比如只删一条数据，就会导致数据不一致。



binlog row

row里面多了Table_map和Delete_rows
Table_map用于说明接下来操作哪个库哪个表
Delete_rows用于定义删除行为
实际上，row虽然会占用空间，但是有助于恢复数据 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/posts/14a3e889.html" title="Java笔记_5">Java笔记_5</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-11-26T01:53:35.000Z" title="发表于 2024-11-26 09:53:35">2024-11-26</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/">Java</a></span></div><div class="content">概述和环境
源码文件

确保安装了JDK，并且配置了环境变量
jdk/lib目录中可以找到src.zip，这个压缩包包含了所有的公共类库的源码
使用jar xvf jdk/lib/src.zip可以将src.zip解压缩到当前目录下
如果是别的源码，比如编译器，原生方法，虚拟机，私有辅助类，需要从openjdk那边拿到

控制台运行Java

一个包含Main函数的Java类，使用javac xxx.java可以将.java文件编译为.class文件
然后再使用java xxx，不需要加.class后缀即可直接运行这个编译后的文件

JShell

Java 9引入了另一种使用Java的方法，就是&quot;读取-评估-打印循环&quot; (Read-Evaluate-Print Loop, REPL)
输入一个表达式，JShell会评估输入，打印结果，并等待下一个输入。直接在控制台输入jshell即可开始使用

输入&quot;java&quot;.length()就会返回字符个数$1 ==&gt; 4
然后再输入4 * $1 + 1，会返回$2 ==&gt; 17
并不需要手动输 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/posts/b406aa8c.html" title="设计模式笔记_1">设计模式笔记_1</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-05-04T06:37:35.000Z" title="发表于 2024-05-04 14:37:35">2024-05-04</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/DesignPattern/">DesignPattern</a></span></div><div class="content">简单工厂模式

需要实例化谁,以后可能会添加实例化的对象,就要用一个单独的类来做这个创造实例的过程,就是工厂

123456789101112131415161718192021222324// Operation.javapublic class Operation &#123;    public static double getResult(double numberA, double numberB, String operation)&#123;        double ans = 0;        switch (operation) &#123;            case &quot;+&quot;:                ans = numberA + numberB;                break;            case &quot;-&quot;:                ans = numberA - numberB;                break;            case &quot;*&qu ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/posts/c3019a1a.html" title="设计模式笔记_0">设计模式笔记_0</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-05-03T06:37:35.000Z" title="发表于 2024-05-03 14:37:35">2024-05-03</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/DesignPattern/">DesignPattern</a></span></div><div class="content">单一职责原则 SRP

一个类应该只有一个更改它的原因,也就是这个类只有一个职责


每个类的职责都有清晰明确的定义
一个类的修改只对自身有影响,对其他类没有影响

开闭原则 OCP

软件实体(类 模块 函数)应该可以扩展,但是不能修改.对于扩展是开放的,对于修改是封闭的.
对于要怎讲爱新功能或者需要调整的改动,应该扩展新的代码而不是修改原有的代码.


对程序中频繁变化的部分抽象
不要刻意的对每一个部分都进行抽象,拒绝不成熟的抽象,这和抽象本身一样重要.

依赖倒置原则 DIP

程序不应该依赖细节,细节应该依赖于抽象. 针对接口编程 而不是针对实现编程


使用接口或者抽象类的目的是制定好规范,不涉及任何具体的操作,把细节任务交给实现类去完成
让程序中所有的依赖关系都终止于抽象类或者接口
高层模块不应该依赖底层模块,二者都应该依赖抽象
抽象不应该依赖细节,细节应该依赖抽象

里氏替换原则 LSP

一个软件实体如果适用于父类,必定适用于子类,并且察觉不出子类和父类的区别,也就是子类必须能够替换父类


父类一般使用抽象类或者接口
抽象类定义公共对象和状态;接口定义公共行为
子类通 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/posts/63a4d81f.html" title="Java笔记_4">Java笔记_4</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-04-22T06:37:35.000Z" title="发表于 2024-04-22 14:37:35">2024-04-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/">Java</a></span></div><div class="content">垃圾回收算法(四种)

垃圾回收需要找到内存中存活的对象
还需要释放不再存活的对象，使程序可以再次利用这部分空间



标记-清除算法
复制算法
标记-整理算法
分代GC



垃圾回收会有单独的GC线程来完成，但是不管哪一种GC算法，都会有部分阶段需要停止所有用户线程，称之为Stop The World，简称STW，如果STW的时间过长，则会影响用户使用


为什么一定需要STW?

分析工作必须在能够确保一致性的快照中进行
一致性指整个分析期间系统被冻结在某个时间点上
如果分析过程中对象的引用关系还在不断地变化,那么分析的准确性就没有办法保证
如果不暂停业务线程的话,在垃圾回收期间新创建的对象会被错误的回收,这是因为业务陈晓晨和垃圾回收线程都是并行执行的



评价标准:

吞吐量：CPU用于执行用户代码的时间与CPU总执行时间的比值，吞吐量=执行用户代码的时间/(执行用户代码的时间+GC时间)，吞吐量越高表示垃圾回收效率越高
最大暂停时间：垃圾回收过程中STW时间的最大值，越小越好
堆使用效率：不同垃圾回收算法，堆内存使用效率不同。比如标记清除算法，可以完整的使用堆内存，复制算法 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/posts/fdc04dbc.html" title="Java笔记_3">Java笔记_3</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-04-21T06:37:35.000Z" title="发表于 2024-04-21 14:37:35">2024-04-21</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/">Java</a></span></div><div class="content">垃圾回收器

主要负责在堆上进行内存回收


自动垃圾回收可以降低实现难度，降低回收bug的可能性
但是程序员无法控制内存回收的及时性, 也无法完全避免内存溢出

应用场景

解决系统僵死(因为频繁的垃圾回收)
性能优化
常见垃圾回收，四种引用等

方法区回收

线程不共享的程序计数器和Java虚拟机栈以及本地方法栈，都只需要等待线程销毁自己就销毁了，不需要垃圾回收

方法区回收的条件(三个)

方法区中的类不再使用，即可被回收


类的所有实例都已经被回收了，在堆中不存在任何该类的实例对象以及子类对象 123Class&lt;?&gt; clazz = loader.loadClass(&quot;类的全限定名&quot;);Object o = clazz.newInstance();o = null; // 此时对象o不再使用，就可以让gc自动回收clazz类

加载该类的类加载器已经被回收了 12URLClassLoader loader = new URLClassLoader(new URL[]&#123;new URL(spec:&quot;路径&quot;)&#125; ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/posts/8ac77d2a.html" title="Java笔记_2">Java笔记_2</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-04-20T06:37:35.000Z" title="发表于 2024-04-20 14:37:35">2024-04-20</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/">Java</a></span></div><div class="content">运行时数据区
分类

线程不共享：程序计数器、Java虚拟机栈、本地方法栈
线程共享：方法区、堆区

程序计数器

Program Counter Register，也叫做PC寄存器，每个线程会通过程序计数器记录当前要执行的字节码指令的地址

作用

控制程序指令的执行，比如跳转，分支，异常
多线程情况下JVM通过程序计数器记录CPU切换前执行到哪一句，切换回来后执行并继续解释运行

程序计数器会产生内存溢出的问题吗

内存溢出指在使用某一块内存区域时，存放的数据需要占用的内存大小超过了虚拟机能够提供的内存上限
每个线程只存储一个固定长度的内存地址，PC不会产生内存溢出
PC不用程序员修改


Java虚拟机栈

先进后出(FILO)，每个方法调用一个栈帧来保存


Java虚拟机栈随着线程的创建而创建，线程销毁则栈回收，由于方法可能会在不同的线程中执行，所以每个线程都有自己的虚拟机栈

栈帧组成

局部变量表，操作数栈，帧数据


局部变量表：方法执行过程中存放所有的局部变量，与字节码局部变量表不太一样


栈帧中的局部变量表是一个数组，每一个位置成为槽slot，long, doub ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/posts/13ce2c90.html" title="Java笔记_1">Java笔记_1</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-04-19T06:37:35.000Z" title="发表于 2024-04-19 14:37:35">2024-04-19</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/">Java</a></span></div><div class="content">类加载器

类加载器(ClassLoader)是JVM给应用程序实现类和接口字节码数据的技术
本地接口JNI允许Java调用其他语言编写的方法，在hotspot类加载器中，主要用于调用JVM中使用CPP编写的方法

应用

SPI机制
类的热部署
Tomcat类的隔离
类的双亲委派机制(怎么打破双亲委派机制)
自定义类加载器
使用Arthas不停机解决线上故障

分类

Java代码中实现的 or JDK默认提供或者自定义的，所有实现的类加载器都需要继承抽象类ClassLoader
JVM底层源码实现的，跟虚拟机实现语言一致，比如Hotspot使用cpp实现。作用是加载运行时的基础类，保证运行中基础类可以被正确的加载，比如java.lang.String，确保可靠性

JDK8之前

JVM底层实现的类加载器，启动类加载器Bootstrap，加载Java中最核心的类，在jre/lib目录下的所有类文件，比如rt.jar, tools.jar, resources.jar


如果打印看到类加载器为null，则就是启动类加载器。因为为了安全性考虑，不允许在代码中获得启动类加载器。
用户自 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/posts/64c91c06.html" title="Java笔记_0">Java笔记_0</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-04-18T06:37:35.000Z" title="发表于 2024-04-18 14:37:35">2024-04-18</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/">Java</a></span></div><div class="content">面向对象的特性
封装
继承

实现了IS-A的关系，子类可以获得父类非private的属性和方法
应该要遵循里氏替换原则


里氏替换原则：子类必须能够替换掉所有的父类对象，父类引用指向子类对象称为向上转型


举例

Cat和Animal就是一种IS-A关系，所以Cat可以继承Animal，并且获得Animal的所有非private的属性和方法
Cat可以当做Animal使用，所以Animal可以引用Cat对象：Animal a = new Cat()，这就是向上转型

多态

分为编译时多态和运行时多态


编译时多态：指方法的重载
运行时多态：指对象引用的具体类型在运行期间才能确定

运行时多态具有三个条件：继承、覆盖(重写)、向上转型




JVM
功能

解释运行：javac编译源代码，得到class字节码，JVM将其实时解释成机器码，让计算机执行，这是为了实现跨平台
内存管理：自动为对象方法分配内存，自动垃圾回收不再使用的对象
即时编译JIT：对热点代码进行优化，提升执行效率

组成

类加载器
运行时数据区域(JVM管理的内存)
执行引擎(即编译器，解释器，垃圾回收等) ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/posts/64a0ba43.html" title="Kubernetes笔记_0">Kubernetes笔记_0</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-04-05T12:25:31.000Z" title="发表于 2024-04-05 20:25:31">2024-04-05</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Kubernetes/">Kubernetes</a></span></div><div class="content">架构
一个Kubernetes集群至少包含一个控制平面，以及一个或多个工作节点
控制平面


负责管理工作节点和维护集群状态，所有任务的分配都来自控制平面
为集群做出去全局决策，比如资源的调度、检测和响应集群事件

kube-apiserver

如果与Kubernetes集群进行交互，需要通过API
apiserver是Kubernetes控制平面的前端，用于处理内部和外部请求

kube-scheduler

集群状态是否良好，如果需要创建新的容器，需要将他们放在哪里，由调度程序关注
scheduler调度程序考虑容器集的资源需求，比如CPU或者内存，以及集群的运行状态，然后将容器集安排到适当的计算节点

kube-controller-manager

控制器负责实际运行集群，controller-manager控制器管理器将多个控制器功能合并，降低了程序的复杂性

controller-manager包含以下控制器:

节点控制器(Node Controller): 负责在节点出现故障时进行通知和响应
任务控制器(Job Controller): 检测代表一次性任务的Job对象 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/posts/afe3e258.html" title="Kafka笔记_1">Kafka笔记_1</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-04-05T09:05:56.000Z" title="发表于 2024-04-05 17:05:56">2024-04-05</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Kafka/">Kafka</a></span></div><div class="content">消费

watermark水位线以下的数据是消费者可以消费的数据

消费者组中的消费者和分区之间的分配关系

同一个消费者组中的消费者都订阅同一个主题，所以消费者组中的多个消费者可以共同消费同一个主题中的所有数据
为了避免数据被重复消费，所以主题一个分区的数据只能被组中的一个消费者消费，所以两个消费者不能同时消费一个分区的数据。但是一个消费者可以同时消费多个分区的数据。

消费者分区分配策略(4种)

具体的分配策略实际上是由消费者组中的Leader决定的，Leader就是群主，是第一个加入消费者组的消费者
消费者加入群组时，发送一个JoinGroup，群主负责给每一个消费者分配一个分区


轮询分配策略(RoundRobinAssignor)

每个消费者组中的消费者都含有一个自动生成的UUID作为memberid
轮询策略会将每个消费者按照memberid进行排序，所有member消费的主题分区根据主题名称进行排序
将主题分区轮询分配给对应的订阅用户，未订阅当前轮询主题的消费者会跳过





范围分配策略(RangeAssignor)

每个Topic的partition数计算出 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/posts/d8e4d2ce.html" title="Kafka笔记_0">Kafka笔记_0</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-04-04T07:05:56.000Z" title="发表于 2024-04-04 15:05:56">2024-04-04</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Kafka/">Kafka</a></span></div><div class="content">消费模式
点对点模式(P2P)

队列中只有一个消费者可以消费数据，用后即销毁，因此数据有且只有一次消费。
适合用于短信业务，发送一次，消费一次。  特点:
- 每个消息只有一个接收者
- 发送和接收之间没有依赖，发送者成功发送消息后，不管接收有没有运行，都可以再次发送消息
- 接收者在成功接收后需要向队列应答成功，以便消息队列删除当前消息



发布订阅模式(PS)

数据会在队列中存储7天，每个订阅都可以消费到相应的数据，可以重复进行消费数据。
大部分都是发布订阅模式。  特点:
- 每个消息有多个订阅者
- 发布者和订阅者之间有时间上的依赖性。针对某个Topic的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息
- 为了消费消息，订阅者需要提前订阅该角色主题，并保持在线运行



基础架构

Kafka不是主从集群，因此每一个节点都可以是主节点，如果一个节点宕机了，那么其他的节点可以被选举为主节点
Kafka中每一个节点都称为Broker，每个节点都存在一个Kafka_controller组件
但是只有一台节点的controller组件是活跃状态，其他都是standby状态 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/posts/46b5b207.html" title="Redis笔记_5">Redis笔记_5</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-03-25T11:51:15.000Z" title="发表于 2024-03-25 19:51:15">2024-03-25</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Redis/">Redis</a></span></div><div class="content">QuickList

ZipList虽然节省内存，但是申请的是连续的空间，如果内存占用较多，内存申请效率很低；

这时候需要限制ZipList的长度或者entry大小；
也可以创建多个ZipList分片存储数据
但是拆分后比较分散，不方便管理和查找，所以引入了QuickList





QuickList本质上是一个双端链表，其中的每一个节点都是ZipList

为了避免QuickList中每个ZipList的entry过多，可以配置list-max-ziplist-size来进行限制

如果为正，表示ZipList的允许的entry最大个数
如果为负，表示ZipList的最大内存大小，共五种情况



情况
内存占用




-1
&lt;= 4KB


-2(默认)
&lt;= 8KB


-3
&lt;= 16KB


-4
&lt;= 32KB


-5
&lt;= 64KB






QuickList同时可以对节点ZipList进行压缩，通过配置list-compress-depth控制。因为链表一般都是首尾访问较多，所以首尾不压缩。



情况
含义




0
不压 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/posts/31b28291.html" title="Redis笔记_4">Redis笔记_4</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-03-23T16:11:10.000Z" title="发表于 2024-03-24 00:11:10">2024-03-24</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Redis/">Redis</a></span></div><div class="content">简单动态字符串SDS
传统的C语言字符串存在问题:
1. 获取字符串长度需要通过运算
2. 非二进制安全，如果中间有一个\0则字符串直接结束了
3. 不可修改

set name sangs: 这条命令会在底层创建两个SDS，分别是name 和 sangs的SDS
123456struct __attribute__ ((__packed__)) sdshdr8&#123;    uint8_t len;            // buf已保存的字符串字节数，不包含结束标识    uint8_t alloc;          // buf申请的总字节数，不包含结束标识，第一次触发时，申请内存一般和len一样    unsigned char flags;    // 不同的SDS头类型，用来控制SDS的头大小    char buf[];&#125;;

    
        
        len: 4alloc: 4flags: 1name\0
    


由于通过len判断需要读取多少位，所以是二进制安全的，不会读取到一半终止
之所以叫动态字符串，是因为具备动态扩容的 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/posts/afd61732.html" title="Redis笔记_3">Redis笔记_3</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-03-23T00:16:45.000Z" title="发表于 2024-03-23 08:16:45">2024-03-23</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Redis/">Redis</a></span></div><div class="content">传统缓存的问题
传统缓存策略是请求到达Tomcat后，先查询Redis，如果未命中则查询数据库:

请求经过Tomcat处理，性能成为整个系统的瓶颈
Redis缓存失效时，对数据库产生冲击

多级缓存就是充分利用请求处理每个缓环节，分别添加缓存，减轻Tomcat压力，提升服务性能。
缓存分类

分布式缓存比如Redis:

优点: 存储容量更大，可靠性更好，可以在集群间共享
缺点: 访问缓存有网络开销
场景: 缓存数据量较大，可靠性要求较高，需要在集群间共享


进程本地缓存，比如HashMap、GuavaCache:

优点: 读取本地内存，没有网络开销，速度更快
缺点: 存储容量有限，可靠性较低，无法共享
场景: 性能要求较高，缓存数据量较小




Caffeine
123456789Cache&lt;String, String&gt; cache = Caffeine.newBuilder().build();cache.put(&quot;key&quot;, &quot;value&quot;)// 取数据，如果没有则返回NULL，使用较少String key = cac ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/posts/d8d127a4.html" title="Redis笔记_2">Redis笔记_2</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-03-22T13:01:20.000Z" title="发表于 2024-03-22 21:01:20">2024-03-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Redis/">Redis</a></span></div><div class="content">数据持久化
RDB

Redis Database Backup file(Redis数据备份文件)，也叫做Redis数据快照。把内存中的所有数据都记录到磁盘中，故障重启后，从磁盘读取快照文件，恢复数据。
RDB文件称为快照文件，默认保存当前运行目录


1234redis-clisave # 使用save命令来进行快照保存，由Redis主进程执行RDB，阻塞所有命令# 所以一般不使用save，Redis在停机退出的时候会自动执行save，再次启动会读取RDB，实现默认的持久化bgsave # 开启子进程执行RDB，避免主进程受到影响

redis.conf配置RDB机制

12345678save 900 1 # 表示如果900s内至少有1个key被修改，则执行bgsavesave 300 10save 60 10000 # 如果是save &quot;&quot; 表示禁用RDBrdbcompression yes # 是否压缩，建议不开启，因为压缩也会消耗CPUdbfilename dump.rdb # RDB文件名称dir ./ # 文件保存路径目录

RDB的bgsave开始 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/posts/41d8761e.html" title="Redis笔记_1">Redis笔记_1</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-03-21T15:29:26.000Z" title="发表于 2024-03-21 23:29:26">2024-03-21</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Redis/">Redis</a></span></div><div class="content">全局唯一ID: 经常会需要全局唯一ID，比如订单表的生成。因为

如果ID自增，则规律性太明显
并且表中可能存在大量的数据，会受到表单数据量的限制


全局唯一ID生成器特性:

唯一性
高可用
高性能
递增性
安全性


超卖问题

原本库存为1，线程1查询后发现库存满足要求。要去扣除库存，但在此之前，线程2，线程3同时查询，发现库存充足。同样满足扣除库存的要求，此时产生了超卖问题


解决方法: 加锁


乐观锁: 认为线程安全问题不一定发生，因此不加锁，只是在更新数据时判断有没有其他线程对数据进行了修改

如果没有修改则认为自己安全，才能更新数据
如果已经被其他线程修改说明发生了安全问题，此时重试或返回异常



悲观锁: 认为线程安全问题一定会发生，因此操作数据之前先获取数据，确保线程串行执行。(性能差)

比如Synchronized、Lock都是悲观锁



乐观锁

版本号法

用版本标识数据更新，如果版本version更新了，则表示数据已经被更新了。


CAS法

用之前查询到的数据判断是否存在相同的数据，如果不存在，则表示数据已经更新。实际上就是简化了版本字段。

 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/posts/36df4688.html" title="Redis笔记_0">Redis笔记_0</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-03-16T15:29:26.000Z" title="发表于 2024-03-16 23:29:26">2024-03-16</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Redis/">Redis</a></span></div><div class="content">SQL VS NoSQL




SQL
NoSQL




数据结构
结构化
非结构化


数据关联
关联的
无关联


查询方式
SQL查询
非SQL


事务特性
ACID
BASE


存储方式
磁盘
内存


扩展性
垂直
水平


使用场景
数据结构固定且对安全性，一致性要求较高
数据结构不固定，对一致性安全性要求不高，对性能有一定要求



特征:

键值型，值支持多种不同的数据结构，功能丰富
单线程，每个命令具有原子性。现在多线程仅仅在网络连接请求方面，内部核心命令依然是单线程的
低延迟，速度快
支持数据持久化
支持主从集群，分片集群
支持多语言


为什么Redis单线程，但是速度快?

基于内存(最重要的原因)
IO多路复用
使用C语言，良好的编码


Redis安装
使用Docker安装:

在docker-data/redis/中执行命令wget http://download.redis.io/redis-stable/redis.conf下载config
修改权限
修改配置信息 1234567891011bind 127.0.0.1          # 注 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/posts/572df2c5.html" title="MySQL笔记_5">MySQL笔记_5</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-03-15T11:39:00.000Z" title="发表于 2024-03-15 19:39:00">2024-03-15</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/MySQL/">MySQL</a></span></div><div class="content">日志

MySQL中日志分为四类: 错误日志、二进制日志、查询日志、慢查询日志


错误日志

记录了当mysqld启动和停止时，以及服务器在运行过程中发生的任何严重错误时的相关信息。服务器出现故障无法使用就看这个日志
默认开启，存放在/var/log/中，日志文件名为mysqld.log
查看错误日志位置: show variables like '%log_error%';

二进制日志

binlog是server层日志


binlog记录了所有的DDL, DML语句，不包含查询语句
binlog默认开启，查看二进制日志位置: show variables like '%log_bin%';
最开始MySQL只有MyISAM引擎，只有binlog用于归档，没有crash-safe的能力，后面InnoDB设计了另一套日志系统，利用redo log来实现crash-safe的能力

作用

灾难时数据恢复
MySQL主从复制

日志格式

查看二进制的日志格式: show variables like '%binlog_format%';




日志格式
含义




STATE ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/posts/202ac253.html" title="MySQL笔记_4">MySQL笔记_4</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-03-15T09:22:00.000Z" title="发表于 2024-03-15 17:22:00">2024-03-15</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/MySQL/">MySQL</a></span></div><div class="content">锁

全局锁

锁整个数据库的，加锁后数据库只读。后续的DML、DDL包括已经更新操作的事务提交都被阻塞
应用场景:数据库逻辑备份，获得一致性视图，保证完整性
set global readonly=true也可以实现全库只读

但是readonly的值可能用来处理其他逻辑，比如主从库判断；
并且FTWRL可以再数据库异常退出的时候自动释放，但是readonly不行






加全局锁: flush tables with read lock;(FTWRL)


数据库备份: musqldump -u用户名 -p密码 数据库名 &gt; 路径/数据库名.sql


解锁: unlock tables;
  
数据库备份的mysqldump命令只是一个工具，不是mysql内部的命令，因此不能在mysql界面中使用。在控制台使用即可，如果备份远程数据库，则需要使用-h 设置ip




缺点:

主库上备份，则备份期间业务停摆，无法更新
从库上备份，则备份期间主库可以更新，但是从库无法执行主库同步的二进制日志(binlog)，导致主从延迟

  
InnoDB引擎中为了解决这个问题，加上 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/posts/be4e57f0.html" title="MySQL笔记_3">MySQL笔记_3</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-03-14T05:38:14.000Z" title="发表于 2024-03-14 13:38:14">2024-03-14</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/MySQL/">MySQL</a></span></div><div class="content">SQL优化
insert优化

使用批量插入，一次性插入500~1000条数据，而不是一条一条插入，也不能一次性插入过多
使用手动事务提交
主键顺序插入
如果需要插入大批量的数据，可以使用MySQL提供的load指令，而不使用insert 12345678-- 使用load需要修改-- 客户端链接服务端 加上--local-infile参数mysql \-\-local-infile -u root -p-- 设置全局参数local-infile为1，开启本地加载文件到数据库的开关set global local-infile = 1;-- 执行load指令 将准备好的数据加载到表结构中load data local infile &#x27;/root/sql1.log&#x27; into table &#x27;user&#x27; fields terminated by &#x27;,&#x27; lines terminated by &#x27;\n&#x27;;-- 每个字段之间使用,分割，每行之间使用&#x27;\n&#x27;分割

对于load命令而言，同样顺序插 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/posts/c9496766.html" title="MySQL笔记_2">MySQL笔记_2</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-03-13T02:21:17.000Z" title="发表于 2024-03-13 10:21:17">2024-03-13</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/MySQL/">MySQL</a></span></div><div class="content">索引

高效获取数据的有序数据结构
提高检索效率，降低IO成本。
索引列对数据进行排序，降低排序成本，减少CPU的消耗
但是需要占用一些空间，提高查询效率有时候会降低更新表的速度，比如增删改。但是实际上增删改比例较少。





索引结构
描述
InnoDB
MyISAM
Memory




B+树索引
最常见的索引类型，大部分引擎都支持
支持
支持
支持


Hash索引
底层使用哈希表实现，只能精确匹配索引列的查询才有效，不支持范围查询
-
-
支持


R-tree(空间索引)
是MyISAM引擎的一个特殊索引类型，用于地理空间数据类型，使用较少
-
支持
-


Full-text(全文索引)
通过建立倒排索引，快速匹配文档的方式，类似于Lucene, Solr, ES
5.6版本后支持
支持
-



常见索引模型

哈希表

比如拉链法解决哈希冲突，追加新数据的速度很快，但是如果需要区间查找，就很慢。所以哈希表只适合等值查找


有序数组

可以解决范围查找问题，等值和范围查找都可以达到log(n)log(n)log(n)，但是插入删除元素需要移动数据，只适合静态搜索

 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/posts/504036dc.html" title="MySQL笔记_1">MySQL笔记_1</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-03-11T16:15:13.000Z" title="发表于 2024-03-12 00:15:13">2024-03-12</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/MySQL/">MySQL</a></span></div><div class="content">函数
字符串函数



函数
功能




CONCAT(S1, S2, …, Sn)
字符串拼接，将S1, S2, …, Sn拼接成一个字符串


LOWER(str)
将字符串转为小写


UPPER(str)
将字符串转为大写


LPAD(str, n, pad)
左填充，用字符串pad对str的左边进行填充，达到长度n


RPAD(str, n, pad)
右填充，用字符串pad对str的右边进行填充，达到长度n


TRIM(str)
去掉字符串头部和尾部的空格


SUBSTRING(str, start, len)
返回从字符串str的start位置起的len个长度的字符串




trim不能去除中间的空格
substring的start从1开始，不是0
substring()可以只输入两个参数，表示从start的位置截取到字符串末尾
start参数可以为负，如果是负数，则自动忽略len参数，表示截取最后几个字符
lpad和rpad如果输入的字符串过长，超过了第二个参数n，则自动变为从左往右的n个字符


数值函数



函数
功能




CEIL(x)
向上取整 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/posts/fae54f81.html" title="MySQL笔记_0">MySQL笔记_0</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-03-10T07:05:56.000Z" title="发表于 2024-03-10 15:05:56">2024-03-10</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/MySQL/">MySQL</a></span></div><div class="content">创建数据库
字符集选择: utf8mb4

Unicode编码，也称作统一码，万国码。如：utf8, utf16, utf32
utf8mb4兼容utf8，并且可以表示更多的字符。具体来说:  Unicode中的第1-126行是utf8的区域，utf8mb4同样兼容这一片区域，剩下126行以下的部分是utf8mb4扩充区域。


一般不选择utf8，因为其占用3B；而实际上很多内容，比如表情，就需要4B空间，所以一般使用utf8mb4

排序规则选择：

对于utf8mb4而言，常用的排序规则有utf8mb4_unicode_ci，utf8mb4_general_ci，utf8mb4_bin




utf8mb4_unicode_ci
utf8mb4_general_ci
utf8mb4_bin




基于标准的Unicode规则来排序和比较
没有实现Unicode排序规则
将字符串的每个字符用二进制数据编译存储


各语言精确排序
在某些特殊语言字符集，排序结果可能不一致



不区分大小写
不区分大小写
区分大小写


为了能够处理特殊字符，实现了略微复杂的排序算法
比较和排序 ...</div></div></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Sangs</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">56</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Sangs3112" target="_blank" title="Github"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-fill"></use></svg></a><a class="social-icon" href="mailto:Sangs3112@163.com" target="_blank" title="Email"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-002_youxiang"></use></svg></a></div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/f86b96e2.html" title="Go笔记_0">Go笔记_0</a><time datetime="2024-11-27T13:22:30.090Z" title="发表于 2024-11-27 21:22:30">2024-11-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/8f6ca674.html" title="Go笔记_1">Go笔记_1</a><time datetime="2024-11-27T13:22:30.090Z" title="发表于 2024-11-27 21:22:30">2024-11-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/ce24a37f.html" title="MySQL笔记_6">MySQL笔记_6</a><time datetime="2024-11-27T13:22:30.090Z" title="发表于 2024-11-27 21:22:30">2024-11-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/b92393e9.html" title="MySQL笔记_7">MySQL笔记_7</a><time datetime="2024-11-27T13:22:30.090Z" title="发表于 2024-11-27 21:22:30">2024-11-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/14a3e889.html" title="Java笔记_5">Java笔记_5</a><time datetime="2024-11-26T01:53:35.000Z" title="发表于 2024-11-26 09:53:35">2024-11-26</time></div></div></div></div><div class="card-widget card-categories"><div class="item-headline">
            <i class="fas fa-folder-open"></i>
            <span>分类</span>
            
            </div>
            <ul class="card-category-list" id="aside-cat-list">
            <li class="card-category-list-item "><a class="card-category-list-link" href="/categories/DesignPattern/"><span class="card-category-list-name">DesignPattern</span><span class="card-category-list-count">2</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Go/"><span class="card-category-list-name">Go</span><span class="card-category-list-count">2</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Java/"><span class="card-category-list-name">Java</span><span class="card-category-list-count">6</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Kafka/"><span class="card-category-list-name">Kafka</span><span class="card-category-list-count">2</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Kubernetes/"><span class="card-category-list-name">Kubernetes</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/MySQL/"><span class="card-category-list-name">MySQL</span><span class="card-category-list-count">8</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Redis/"><span class="card-category-list-name">Redis</span><span class="card-category-list-count">6</span></a></li>
            </ul></div><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84/" style="font-size: 1.1em; color: #999">索引结构</a> <a href="/tags/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/" style="font-size: 1.1em; color: #999">主从复制</a> <a href="/tags/MySQL/" style="font-size: 1.5em; color: #99a9bf">MySQL</a> <a href="/tags/%E4%B8%BB%E4%BB%8E%E5%BB%B6%E8%BF%9F%E8%A7%A3%E5%86%B3/" style="font-size: 1.1em; color: #999">主从延迟解决</a> <a href="/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/" style="font-size: 1.1em; color: #999">垃圾回收器</a> <a href="/tags/%E9%9B%86%E7%BE%A4%E8%84%91%E8%A3%82/" style="font-size: 1.1em; color: #999">集群脑裂</a> <a href="/tags/%E5%8A%A0%E9%94%81%E5%88%A4%E6%96%AD/" style="font-size: 1.1em; color: #999">加锁判断</a> <a href="/tags/join%E4%BC%98%E5%8C%96/" style="font-size: 1.1em; color: #999">join优化</a> <a href="/tags/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/" style="font-size: 1.1em; color: #999">运行时数据区</a> <a href="/tags/%E4%B8%BB%E5%A4%87%E5%88%87%E6%8D%A2/" style="font-size: 1.1em; color: #999">主备切换</a> <a href="/tags/%E4%BA%94%E7%A7%8D%E5%BC%95%E7%94%A8%E5%85%B3%E7%B3%BB/" style="font-size: 1.1em; color: #999">五种引用关系</a> <a href="/tags/%E8%A7%86%E5%9B%BE/" style="font-size: 1.1em; color: #999">视图</a> <a href="/tags/%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/" style="font-size: 1.1em; color: #999">读写分离</a> <a href="/tags/%E4%BA%8B%E5%8A%A1%E6%B5%81%E7%A8%8B/" style="font-size: 1.1em; color: #999">事务流程</a> <a href="/tags/Kubernetes/" style="font-size: 1.1em; color: #999">Kubernetes</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/" style="font-size: 1.1em; color: #999">设计原则</a> <a href="/tags/DesignPattern/" style="font-size: 1.23em; color: #999ea6">DesignPattern</a> <a href="/tags/%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E6%B3%95%E5%88%99/" style="font-size: 1.1em; color: #999">最左前缀法则</a> <a href="/tags/InnoDB%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84/" style="font-size: 1.1em; color: #999">InnoDB引擎架构</a> <a href="/tags/Go/" style="font-size: 1.23em; color: #999ea6">Go</a> <a href="/tags/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/" style="font-size: 1.1em; color: #999">存储过程</a> <a href="/tags/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/" style="font-size: 1.1em; color: #999">双亲委派机制</a> <a href="/tags/%E5%B9%BB%E8%AF%BB/" style="font-size: 1.1em; color: #999">幻读</a> <a href="/tags/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/" style="font-size: 1.1em; color: #999">分库分表</a> <a href="/tags/%E9%94%81/" style="font-size: 1.1em; color: #999">锁</a> <a href="/tags/JVM/" style="font-size: 1.1em; color: #999">JVM</a> <a href="/tags/%E6%97%A5%E5%BF%97/" style="font-size: 1.1em; color: #999">日志</a> <a href="/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/" style="font-size: 1.1em; color: #999">策略模式</a> <a href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E6%80%A7/" style="font-size: 1.1em; color: #999">面向对象的特性</a> <a href="/tags/MyCat/" style="font-size: 1.1em; color: #999">MyCat</a> <a href="/tags/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%8D%B7%E4%B8%80/" style="font-size: 1.1em; color: #999">Java核心技术(卷一)</a> <a href="/tags/%E5%BA%94%E7%AD%94%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/" style="font-size: 1.1em; color: #999">应答处理机制</a> <a href="/tags/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" style="font-size: 1.1em; color: #999">简单工厂模式</a> <a href="/tags/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" style="font-size: 1.1em; color: #999">类的生命周期</a> <a href="/tags/%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/" style="font-size: 1.1em; color: #999">多表查询</a> <a href="/tags/SQL%E5%88%86%E7%B1%BB/" style="font-size: 1.1em; color: #999">SQL分类</a> <a href="/tags/Java/" style="font-size: 1.37em; color: #99a4b2">Java</a> <a href="/tags/%E6%96%B9%E6%B3%95%E5%8C%BA-%E5%A0%86%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" style="font-size: 1.1em; color: #999">方法区 堆的垃圾回收</a> <a href="/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/" style="font-size: 1.1em; color: #999">垃圾回收算法</a> <a href="/tags/SQL%E4%BC%98%E5%8C%96/" style="font-size: 1.1em; color: #999">SQL优化</a></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.8/dist/lazyload.iife.min.js"></script><div class="js-pjax"></div><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="Hexo" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/Sangs3112" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="/js/ali_font.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('article-sort-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__slideInRight');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --></body></html>