<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Sangs Blog</title><meta name="author" content="Sangs"><meta name="copyright" content="Sangs"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta property="og:type" content="website">
<meta property="og:title" content="Sangs Blog">
<meta property="og:url" content="https://sangs3112.github.io/index.html">
<meta property="og:site_name" content="Sangs Blog">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://sangs3112.github.io/img/avatar.png">
<meta property="article:author" content="Sangs">
<meta property="article:tag" content="博客,Sangs">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://sangs3112.github.io/img/avatar.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://sangs3112.github.io/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><meta name="google-site-verification" content="https://github.com/Sangs3112/Sangs3112.github.io/blob/master/googlea12c1ab75804fd8f.html"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Sangs Blog',
  isPost: false,
  isHome: true,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2024-04-21 22:10:08'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><meta name="referrer" content="no-referrer" /><!-- hexo injector head_end start --><link rel="stylesheet" href="https://unpkg.zhimg.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.1.1"><link rel="alternate" href="/atom.xml" title="Sangs Blog" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">22</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw fas fa-home faa-tada"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><i class="fa-fw fas fa-folder-open faa-tada"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/tags/"><i class="fa-fw fas fa-tags faa-tada"></i><span> 标签</span></a></div></div></div></div><div class="page" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Sangs Blog"><span class="site-name">Sangs Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw fas fa-home faa-tada"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><i class="fa-fw fas fa-folder-open faa-tada"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/tags/"><i class="fa-fw fas fa-tags faa-tada"></i><span> 标签</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div class="recent-posts" id="recent-posts"><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/posts/63a4d81f.html" title="Java笔记_4">Java笔记_4</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-04-22T06:37:35.000Z" title="发表于 2024-04-22 14:37:35">2024-04-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/">Java</a></span></div><div class="content">垃圾回收算法

垃圾回收需要找到内存中存活的对象
还需要释放不再存活的对象，使程序可以再次利用这部分空间



标记-清除算法
复制算法
标记-整理算法
分代GC


垃圾回收会有单独的GC线程来完成，但是不管哪一种GC算法，都会有部分阶段需要停止所有用户线程，称之为Stop The World，简称STW，如果STW的时间过长，则会影响用户使用
评价标准


吞吐量：CPU用于执行用户代码的时间与CPU总执行时间的比值，吞吐量=执行用户代码的时间/(执行用户代码的时间+GC时间)，吞吐量越高表示垃圾回收效率越高
最大暂停时间：垃圾回收过程中STW时间的最大值，越小越好
堆使用效率：不同垃圾回收算法，堆内存使用效率不同。比如标记清除算法，可以完整的使用堆内存，复制算法会将堆内存一分为二，每次只能使用一半内存。从堆使用效率上来说，标记清除算法要优于复制算法。


三者不可兼得，堆内存越大，最大暂停时间就越大，减少最大暂停时间，就会降低吞吐量。


标记-清除算法

两个阶段

标记阶段，将所有存活对象标记，使用可达性算法，从GC Root开始通过引用链遍历出所有的存活对象
清除阶段，从内 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/posts/f86b96e2.html" title="Go笔记_0">Go笔记_0</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-04-21T14:09:52.157Z" title="发表于 2024-04-21 22:09:52">2024-04-21</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Go/">Go</a></span></div><div class="content">GOROOT VS GOPATH VS GOBIN VS GOPROXY

GOROOT: Go语言安装路径
GOPATH: 若干工作区目录的路径。是我们自己定义的工作空间  
GO1.8版本之后，开发包安装完成后会自动设置一个GOPATH目录，
GO1.14版本之后，推荐使用Go Module模式，不一定非要将代码写在GOPATH目录下，也不需要自己配置GOPATH



GOBIN: GO程序生成的可执行文件的路径
GOPROXY: 默认为GOPROXY=https://proxy.golang.org,direct，修改为GOPROXY=https://goproxy.cn,direct

跨平台编译
Windows 编译 LINUX或者OSX
1234SET CGO_ENABLED=0   // 禁用CGOSET GOOS=linux      // 目标平台, [windows, linux, darwin]SET GOARCH=amd64    // 目标处理器架构go build
LINUX 或者 OSX 编译其他环境
1CGO_ENABLED=0 GOOS=linux| ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/posts/8f6ca674.html" title="Go笔记_1">Go笔记_1</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-04-21T14:09:52.157Z" title="发表于 2024-04-21 22:09:52">2024-04-21</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Go/">Go</a></span></div><div class="content">方法

Go语言中只有不同的package中可以有相同函数名的函数，尽管参数不同，但是如果函数名相同就不能出现在相同的包中(函数重载Go语言没有)
方法需要通过一个特定的实例调用，比如t.Errorf()，这里的Errorf就是一个方法，通过实例t调用
函数可以随便调用，没有限制


接口

接口让函数接受不同类型的参数并创造类型安全并且高解耦的代码
Go语言中 interface resolution 是隐式的。如果传入的类型匹配接口需要的，则编译正确。
函数实现因此不需要关心参数是什么类型的，只需要声明一个接口，辅助函数就可以从具体类型解耦而只关心本身需要做的工作

表格驱动测试

如果需要测试一个接口的不同实现，或者传入的数据有很多不同的测试需求，则可以使用表格驱动测试

123456789101112131415161718func TestArea(t *testing.T)&#123;	areaTests := []struct&#123;		name string		shape Shape		want float64	&#125;&#123;		&#123;name: & ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/posts/fdc04dbc.html" title="Java笔记_3">Java笔记_3</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-04-21T06:37:35.000Z" title="发表于 2024-04-21 14:37:35">2024-04-21</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/">Java</a></span></div><div class="content">垃圾回收器

主要负责在堆上进行内存回收


自动垃圾回收可以降低实现难度，降低回收bug的可能性，但是程序员无法控制内存回收的及时性
但是无法完全避免内存溢出

应用场景

解决系统僵死，因为频繁的垃圾回收导致
性能优化
常见垃圾回收，四种引用等

方法区回收

线程不共享的程序计数器和Java虚拟机栈以及本地方法栈，都只需要等待线程销毁自己就销毁了，不需要垃圾回收
方法区中的类不再使用，即可被回收，需要满足三个条件


类的所有实例都已经被回收了，在堆中不存在任何该类的实例对象以及子类对象 123Class&lt;?&gt; clazz = loader.loadClass(&quot;类的全限定名&quot;);Object o = clazz.newInstance();o = null; // 此时对象o不再使用，就可以让gc自动回收clazz类

加载该类的类加载器已经被回收了 12URLClassLoader loader = new URLClassLoader(new URL[]&#123;new URL(spec:&quot;路径&quot;)&#125;);loa ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/posts/8ac77d2a.html" title="Java笔记_2">Java笔记_2</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-04-20T06:37:35.000Z" title="发表于 2024-04-20 14:37:35">2024-04-20</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/">Java</a></span></div><div class="content">运行时数据区
分类

线程不共享：程序计数器、Java虚拟机栈、本地方法栈
线程共享：方法区、堆区

程序计数器

Program Counter Register，也叫做PC寄存器，每个线程会通过程序计数器记录当前要执行的字节码指令的地址

作用

控制程序指令的执行，比如跳转，分支，异常
多线程情况下JVM通过程序计数器记录CPU切换前执行到哪一句，切换回来后执行并继续解释运行

程序计数器会产生内存溢出的问题吗

内存溢出指在使用某一块内存区域时，存放的数据需要占用的内存大小超过了虚拟机能够提供的内存上限
每个线程只存储一个固定长度的内存地址，PC不会产生内存溢出
PC不用程序员修改


Java虚拟机栈

先进后出(FILO)，每个方法调用一个栈帧来保存


Java虚拟机栈随着线程的创建而创建，线程销毁则栈回收，由于方法可能会在不同的线程中执行，所以每个线程都有自己的虚拟机栈

组成

局部变量表，操作数栈，帧数据


局部变量表：方法执行过程中存放所有的局部变量，与字节码局部变量表不太一样。


栈帧中的局部变量表是一个数组，每一个位置成为槽slot，long, doubl ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/posts/13ce2c90.html" title="Java笔记_1">Java笔记_1</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-04-19T06:37:35.000Z" title="发表于 2024-04-19 14:37:35">2024-04-19</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/">Java</a></span></div><div class="content">类加载器

类加载器(ClassLoader)是JVM给应用程序实现类和接口字节码数据的技术
本地接口JNI允许Java调用其他语言编写的方法，在hotspot类加载器中，主要用于调用JVM中使用CPP编写的方法

应用

SPI机制
类的热部署
Tomcat类的隔离
类的双亲委派机制，怎么打破双亲委派机制
自定义类加载器
使用Arthas不停机解决线上故障

分类

Java代码中实现的，JDK默认提供或者自定义的，所有实现的类加载器都需要继承抽象类ClassLoader
JVM底层源码实现的，跟虚拟机实现语言一致，比如Hotspot使用cpp实现。作用是加载运行时的基础类，保证运行中基础类可以被正确的加载，比如java.lang.String，确保可靠性

JDK8之前

JVM底层实现的类加载器，启动类加载器Bootstrap，加载Java中最核心的类，在jre/lib目录下的所有类文件，比如rt.jar, tools.jar, resources.jar


如果打印看到类加载器为null，则就是启动类加载器。因为为了安全性考虑，不允许在代码中获得启动类加载器。
用户自己如果写 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/posts/64c91c06.html" title="Java笔记_0">Java笔记_0</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-04-18T06:37:35.000Z" title="发表于 2024-04-18 14:37:35">2024-04-18</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/">Java</a></span></div><div class="content">面向对象的特性
封装
继承

实现了IS-A的关系，子类可以获得父类非private的属性和方法
应该要遵循里氏替换原则


里氏替换原则：子类必须能够替换掉所有的父类对象，父类引用指向子类对象称为向上转型


举例

Cat和Animal就是一种IS-A关系，所以Cat可以继承Animal，并且获得Animal的所有非private的属性和方法
Cat可以当做Animal使用，所以Animal可以引用Cat对象：Animal a = new Cat()，这就是向上转型

多态

分为编译时多态和运行时多态


编译时多态：指方法的重载
运行时多态：指对象引用的具体类型在运行期间才能确定

运行时多态具有三个条件：继承、覆盖(重写)、向上转型




JVM
功能

解释运行：javac编译源代码，得到class字节码，JVM将其实时解释成机器码，让计算机执行，这是为了实现跨平台
内存管理：自动为对象方法分配内存，自动垃圾回收不再使用的对象
即时编译JIT：对热点代码进行优化，提升执行效率

组成

类加载器
运行时数据区域(JVM管理的内存)
执行引擎(即编译器，解释器，垃圾回收等) ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/posts/64a0ba43.html" title="Kubernetes笔记_0">Kubernetes笔记_0</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-04-05T12:25:31.000Z" title="发表于 2024-04-05 20:25:31">2024-04-05</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Kubernetes/">Kubernetes</a></span></div><div class="content">架构
一个Kubernetes集群至少包含一个控制平面，以及一个或多个工作节点
控制平面


负责管理工作节点和维护集群状态，所有任务的分配都来自控制平面
为集群做出去全局决策，比如资源的调度、检测和响应集群事件

kube-apiserver

如果与Kubernetes集群进行交互，需要通过API
apiserver是Kubernetes控制平面的前端，用于处理内部和外部请求

kube-scheduler

集群状态是否良好，如果需要创建新的容器，需要将他们放在哪里，由调度程序关注
scheduler调度程序考虑容器集的资源需求，比如CPU或者内存，以及集群的运行状态，然后将容器集安排到适当的计算节点

kube-controller-manager

控制器负责实际运行集群，controller-manager控制器管理器将多个控制器功能合并，降低了程序的复杂性

controller-manager包含以下控制器:

节点控制器(Node Controller): 负责在节点出现故障时进行通知和响应
任务控制器(Job Controller): 检测代表一次性任务的Job对象 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/posts/afe3e258.html" title="Kafka笔记_1">Kafka笔记_1</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-04-05T09:05:56.000Z" title="发表于 2024-04-05 17:05:56">2024-04-05</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Kafka/">Kafka</a></span></div><div class="content">消费

watermark水位线以下的数据是消费者可以消费的数据

消费者组中的消费者和分区之间的分配关系

同一个消费者组中的消费者都订阅同一个主题，所以消费者组中的多个消费者可以共同消费同一个主题中的所有数据
为了避免数据被重复消费，所以主题一个分区的数据只能被组中的一个消费者消费，所以两个消费者不能同时消费一个分区的数据。但是一个消费者可以同时消费多个分区的数据。

消费者分区分配策略(4种)

具体的分配策略实际上是由消费者组中的Leader决定的，Leader就是群主，是第一个加入消费者组的消费者。
消费者加入群组时，发送一个JoinGroup，群主负责给每一个消费者分配一个分区。


轮询分配策略(RoundRobinAssignor)

每个消费者组中的消费者都含有一个自动生成的UUID作为memberid
轮询策略会将每个消费者按照memberid进行排序，所有member消费的主题分区根据主题名称进行排序
将主题分区轮询分配给对应的订阅用户，未订阅当前轮询主题的消费者会跳过。





范围范围分配策略(RangeAssignor)

每个Topic的partitio ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/posts/d8e4d2ce.html" title="Kafka笔记_0">Kafka笔记_0</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-04-04T07:05:56.000Z" title="发表于 2024-04-04 15:05:56">2024-04-04</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Kafka/">Kafka</a></span></div><div class="content">消费模式
点对点消费(P2P)

队列中只有一个消费者可以消费数据，用后即销毁，因此数据有且只有一次消费。
适合用于短信业务，发送一次，消费一次。  特点:

每个消息只有一个接收者
发送和接收之间没有依赖，发送者成功发送消息后，不管接收有没有运行，都可以再次发送消息
接收者在成功接收后需要像队列应答成功，以便消息队列删除当前消息




发布订阅模式(PS)

数据会在队列中存储7天，每个订阅都可以消费到相应的数据，可以重复进行消费数据。
大部分都是发布订阅模式。  特点:

每个消息有多个订阅者
发布者和订阅者之间有时间上的依赖性。针对某个Topic的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息
为了消费消息，订阅者需要提前订阅该角色主题，并保持在线运行




基础架构

Kafka不是主从集群，因此每一个节点都可以是主节点，如果一个节点宕机了，那么其他的节点可以被选举为主节点
Kafka中每一个节点都称为Broker，每个节点都存在一个Kafka_controller组件
但是只有一台节点的controller组件是活跃状态，其他都是standby状态
主节点宕机时， ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/posts/46b5b207.html" title="Redis笔记_5">Redis笔记_5</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-03-25T11:51:15.000Z" title="发表于 2024-03-25 19:51:15">2024-03-25</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Redis/">Redis</a></span></div><div class="content">QuickList

ZipList虽然节省内存，但是申请的是连续的空间，如果内存占用较多，内存申请效率很低；

这时候需要限制ZipList的长度或者entry大小；
也可以创建多个ZipList分片存储数据
但是拆分后比较分散，不方便管理和查找，所以引入了QuickList





QuickList本质上是一个双端链表，其中的每一个节点都是ZipList

为了避免QuickList中每个ZipList的entry过多，可以配置list-max-ziplist-size来进行限制

如果为正，表示ZipList的允许的entry最大个数
如果为负，表示ZipList的最大内存大小，共五种情况



情况
内存占用




-1
&lt;= 4KB


-2(默认)
&lt;= 8KB


-3
&lt;= 16KB


-4
&lt;= 32KB


-5
&lt;= 64KB






QuickList同时可以对节点ZipList进行压缩，通过配置list-compress-depth控制。因为链表一般都是首尾访问较多，所以首尾不压缩。



情况
含义




0
不压 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/posts/31b28291.html" title="Redis笔记_4">Redis笔记_4</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-03-23T16:11:10.000Z" title="发表于 2024-03-24 00:11:10">2024-03-24</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Redis/">Redis</a></span></div><div class="content">简单动态字符串SDS
传统的C语言字符串存在问题:
1. 获取字符串长度需要通过运算
2. 非二进制安全，如果中间有一个\0则字符串直接结束了
3. 不可修改

set name sangs: 这条命令会在底层创建两个SDS，分别是name 和 sangs的SDS
123456struct __attribute__ ((__packed__)) sdshdr8&#123;    uint8_t len;            // buf已保存的字符串字节数，不包含结束标识    uint8_t alloc;          // buf申请的总字节数，不包含结束标识，第一次触发时，申请内存一般和len一样    unsigned char flags;    // 不同的SDS头类型，用来控制SDS的头大小    char buf[];&#125;;

    
        
        len: 4alloc: 4flags: 1name\0
    


由于通过len判断需要读取多少位，所以是二进制安全的，不会读取到一半终止
之所以叫动态字符串，是因为具备动态扩容的 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/posts/afd61732.html" title="Redis笔记_3">Redis笔记_3</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-03-23T00:16:45.000Z" title="发表于 2024-03-23 08:16:45">2024-03-23</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Redis/">Redis</a></span></div><div class="content">传统缓存的问题
传统缓存策略是请求到达Tomcat后，先查询Redis，如果未命中则查询数据库:

请求经过Tomcat处理，性能成为整个系统的瓶颈
Redis缓存失效时，对数据库产生冲击

多级缓存就是充分利用请求处理每个缓环节，分别添加缓存，减轻Tomcat压力，提升服务性能。
缓存分类

分布式缓存比如Redis:

优点: 存储容量更大，可靠性更好，可以在集群间共享
缺点: 访问缓存有网络开销
场景: 缓存数据量较大，可靠性要求较高，需要在集群间共享


进程本地缓存，比如HashMap、GuavaCache:

优点: 读取本地内存，没有网络开销，速度更快
缺点: 存储容量有限，可靠性较低，无法共享
场景: 性能要求较高，缓存数据量较小




Caffeine
123456789Cache&lt;String, String&gt; cache = Caffeine.newBuilder().build();cache.put(&quot;key&quot;, &quot;value&quot;)// 取数据，如果没有则返回NULL，使用较少String key = cac ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/posts/d8d127a4.html" title="Redis笔记_2">Redis笔记_2</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-03-22T13:01:20.000Z" title="发表于 2024-03-22 21:01:20">2024-03-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Redis/">Redis</a></span></div><div class="content">数据持久化
RDB

Redis Database Backup file(Redis数据备份文件)，也叫做Redis数据快照。把内存中的所有数据都记录到磁盘中，故障重启后，从磁盘读取快照文件，恢复数据。
RDB文件称为快照文件，默认保存当前运行目录


1234redis-clisave # 使用save命令来进行快照保存，由Redis主进程执行RDB，阻塞所有命令# 所以一般不使用save，Redis在停机退出的时候会自动执行save，再次启动会读取RDB，实现默认的持久化bgsave # 开启子进程执行RDB，避免主进程受到影响

redis.conf配置RDB机制

12345678save 900 1 # 表示如果900s内至少有1个key被修改，则执行bgsavesave 300 10save 60 10000 # 如果是save &quot;&quot; 表示禁用RDBrdbcompression yes # 是否压缩，建议不开启，因为压缩也会消耗CPUdbfilename dump.rdb # RDB文件名称dir ./ # 文件保存路径目录

RDB的bgsave开始 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/posts/41d8761e.html" title="Redis笔记_1">Redis笔记_1</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-03-21T15:29:26.000Z" title="发表于 2024-03-21 23:29:26">2024-03-21</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Redis/">Redis</a></span></div><div class="content">全局唯一ID: 经常会需要全局唯一ID，比如订单表的生成。因为

如果ID自增，则规律性太明显
并且表中可能存在大量的数据，会受到表单数据量的限制


全局唯一ID生成器特性:

唯一性
高可用
高性能
递增性
安全性


超卖问题

原本库存为1，线程1查询后发现库存满足要求。要去扣除库存，但在此之前，线程2，线程3同时查询，发现库存充足。同样满足扣除库存的要求，此时产生了超卖问题


解决方法: 加锁


乐观锁: 认为线程安全问题不一定发生，因此不加锁，只是在更新数据时判断有没有其他线程对数据进行了修改

如果没有修改则认为自己安全，才能更新数据
如果已经被其他线程修改说明发生了安全问题，此时重试或返回异常



悲观锁: 认为线程安全问题一定会发生，因此操作数据之前先获取数据，确保线程串行执行。(性能差)

比如Synchronized、Lock都是悲观锁



乐观锁

版本号法

用版本标识数据更新，如果版本version更新了，则表示数据已经被更新了。


CAS法

用之前查询到的数据判断是否存在相同的数据，如果不存在，则表示数据已经更新。实际上就是简化了版本字段。

 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/posts/36df4688.html" title="Redis笔记_0">Redis笔记_0</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-03-16T15:29:26.000Z" title="发表于 2024-03-16 23:29:26">2024-03-16</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Redis/">Redis</a></span></div><div class="content">SQL VS NoSQL




SQL
NoSQL




数据结构
结构化
非结构化


数据关联
关联的
无关联


查询方式
SQL查询
非SQL


事务特性
ACID
BASE


存储方式
磁盘
内存


扩展性
垂直
水平


使用场景
数据结构固定且对安全性，一致性要求较高
数据结构不固定，对一致性安全性要求不高，对性能有一定要求



特征:

键值型，值支持多种不同的数据结构，功能丰富
单线程，每个命令具有原子性。现在多线程仅仅在网络连接请求方面，内部核心命令依然是单线程的
低延迟，速度快
支持数据持久化
支持主从集群，分片集群
支持多语言


为什么Redis单线程，但是速度快?

基于内存(最重要的原因)
IO多路复用
使用C语言，良好的编码


Redis安装
使用Docker安装:

在docker-data/redis/中执行命令wget http://download.redis.io/redis-stable/redis.conf下载config
修改权限
修改配置信息 1234567891011bind 127.0.0.1          # 注 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/posts/572df2c5.html" title="MySQL笔记_5">MySQL笔记_5</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-03-15T11:39:00.000Z" title="发表于 2024-03-15 19:39:00">2024-03-15</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/MySQL/">MySQL</a></span></div><div class="content">日志

MySQL中日志分为四类: 错误日志、二进制日志、查询日志、慢查询日志


错误日志

记录了当mysqld启动和停止时，以及服务器在运行过程中发生的任何严重错误时的相关信息。服务器出现故障无法使用就看这个日志
默认开启，存放在/var/log/中，日志文件名为mysqld.log
查看错误日志位置: show variables like '%log_error%';

二进制日志

binlog记录了所有的DDL, DML语句，不包含查询语句
binlog默认开启，查看二进制日志位置: show variables like '%log_bin%';

作用

灾难时数据恢复
MySQL主从复制

日志格式

查看二进制的日志格式: show variables like '%binlog_format%';




日志格式
含义




STATEMENT
基于SQL语句的日志记录，记录SQL语句，对数据进行修改的SQL都会记录在日志文件中


ROW
基于行的日志记录，记录的是每一行的数据变更(默认)


MIXED
混合了STATEMENT与ROW两种格式，默认采用 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/posts/202ac253.html" title="MySQL笔记_4">MySQL笔记_4</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-03-15T09:22:00.000Z" title="发表于 2024-03-15 17:22:00">2024-03-15</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/MySQL/">MySQL</a></span></div><div class="content">锁

全局锁

锁整个数据库的，加锁后数据库只读。后续的DML、DDL包括已经更新操作的事务提交都被阻塞
应用场景:数据库逻辑备份，获得一致性视图，保证完整性




加全局锁: flush tables with read lock;


数据库备份: musqldump -u用户名 -p密码 数据库名 &gt; 路径/数据库名.sql


解锁: unlock tables;
  
数据库备份的mysqldump命令只是一个工具，不是mysql内部的命令，因此不能在mysql界面中使用。在控制台使用即可，如果备份远程数据库，则需要使用-h 设置ip




缺点:

主库上备份，则备份期间业务停摆，无法更新
从库上备份，则备份期间主库可以更新，但是从库无法执行主库同步的二进制日志(binlog)，导致主从延迟

  
InnoDB引擎中为了解决这个问题，加上--single-transaction参数完成不加锁的一致性备份。
mysqldump --single-transaction -u用户 -p密码 数据库名 &gt; 路径/数据库名.sql
实际上通过快照读实现，这种方式不 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/posts/be4e57f0.html" title="MySQL笔记_3">MySQL笔记_3</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-03-14T05:38:14.000Z" title="发表于 2024-03-14 13:38:14">2024-03-14</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/MySQL/">MySQL</a></span></div><div class="content">SQL优化
insert优化

使用批量插入，一次性插入500~1000条数据，而不是一条一条插入，也不能一次性插入过多
使用手动事务提交
主键顺序插入
如果需要插入大批量的数据，可以使用MySQL提供的load指令，而不使用insert 12345678# 使用load需要修改# 客户端链接服务端 加上--local-infile参数mysql --local-infile -u root -p# 设置全局参数local-infile为1，开启本地加载文件到数据库的开关set global local-infile = 1;# 执行load指令 将准备好的数据加载到表结构中load data local infile &#x27;/root/sql1.log&#x27; into table &#x27;user&#x27; fields terminated by &#x27;,&#x27; lines terminated by &#x27;\n&#x27;;# 每个字段之间使用,分割，每行之间使用&#x27;\n&#x27;分割

对于load命令而言，同样顺序插入比乱序插入更 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/posts/c9496766.html" title="MySQL笔记_2">MySQL笔记_2</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-03-13T02:21:17.000Z" title="发表于 2024-03-13 10:21:17">2024-03-13</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/MySQL/">MySQL</a></span></div><div class="content">索引

高效获取数据的有序数据结构
提高检索效率，降低IO成本。
索引列对数据进行排序，降低排序成本，减少CPU的消耗
但是需要占用一些空间，提高查询效率有时候会降低更新表的速度，比如增删改。但是实际上增删改比例较少。





索引结构
描述
InnoDB
MyISAM
Memory




B+树索引
最常见的索引类型，大部分引擎都支持
支持
支持
支持


Hash索引
底层使用哈希表实现，只能精确匹配索引列的查询才有效，不支持范围查询
-
-
支持


R-tree(空间索引)
是MyISAM引擎的一个特殊索引类型，用于地理空间数据类型，使用较少
-
支持
-


Full-text(全文索引)
通过建立倒排索引，快速匹配文档的方式，类似于Lucene, Solr, ES
5.6版本后支持
支持
-



B+树


B+树的所有元素都在叶子节点处，非叶子节点只用于索引，存储都在叶子节点处，所有叶子节点形成了一个单向链表。



MySQL对B+树进行优化，在原来的B+树基础上，增加了一个指向相邻叶子节点的链表指针，形成了带顺序指针的B+树，提高区间访问性能。



InnoD ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/posts/504036dc.html" title="MySQL笔记_1">MySQL笔记_1</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-03-11T16:15:13.000Z" title="发表于 2024-03-12 00:15:13">2024-03-12</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/MySQL/">MySQL</a></span></div><div class="content">函数
字符串函数



函数
功能




CONCAT(S1, S2, …, Sn)
字符串拼接，将S1, S2, …, Sn拼接陈一个字符串


LOWER(str)
将字符串转为小写


UPPER(str)
将字符串转为大写


LPAD(str, n, pad)
左填充，用字符串pad对str的左边进行填充，达到长度n


RPAD(str, n, pad)
右填充，用字符串pad对str的右边进行填充，达到长度n


TRIM(str)
去掉字符串头部和尾部的空格


SUBSTRING(str, start, len)
返回从字符串str的start位置起的len个长度的字符串




trim不能去除中间的空格
substring的start从1开始，不是0
substring()可以只输入两个参数，表示从start的位置截取到字符串末尾
start参数可以为负，如果是负数，则自动忽略len参数，表示截取最后几个字符
lpad和rpad如果输入的字符串过长，超过了第二个参数n，则自动变为从左往右的n个字符


数值函数



函数
功能




CEIL(x)
向上取整 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/posts/fae54f81.html" title="MySQL笔记_0">MySQL笔记_0</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-03-10T07:05:56.000Z" title="发表于 2024-03-10 15:05:56">2024-03-10</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/MySQL/">MySQL</a></span></div><div class="content">创建数据库
字符集选择: utf8mb4

Unicode编码，也称作统一码，万国码。如：utf8, utf16, utf32
utf8mb4兼容utf8，并且可以表示更多的字符。具体来说:  Unicode中的第1-126行是utf8的区域，utf8mb4同样兼容这一片区域，剩下126行以下的部分是utf8mb4扩充区域。


一般不选择utf8，因为其占用三个字节；而实际上很多内容，比如表情，就需要四字节空间，所以一般使用utf8mb4

排序规则选择：

对于utf8mb4而言，常用的排序规则有utf8mb4_unicode_ci，utf8mb4_general_ci，utf8mb4_bin




utf8mb4_unicode_ci
utf8mb4_general_ci
utf8mb4_bin




基于标准的Unicode规则来排序和比较
没有实现Unicode排序规则
将字符串的每个字符用二进制数据编译存储


各语言精确排序
在某些特殊语言字符集，排序结果可能不一致



不区分大小写
不区分大小写
区分大小写


为了能够处理特殊字符，实现了略微复杂的排序算法
比较 ...</div></div></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Sangs</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">22</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Sangs3112" target="_blank" title="Github"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-fill"></use></svg></a><a class="social-icon" href="mailto:Sangs3112@163.com" target="_blank" title="Email"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-002_youxiang"></use></svg></a></div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/63a4d81f.html" title="Java笔记_4">Java笔记_4</a><time datetime="2024-04-22T06:37:35.000Z" title="发表于 2024-04-22 14:37:35">2024-04-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/f86b96e2.html" title="Go笔记_0">Go笔记_0</a><time datetime="2024-04-21T14:09:52.157Z" title="发表于 2024-04-21 22:09:52">2024-04-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/8f6ca674.html" title="Go笔记_1">Go笔记_1</a><time datetime="2024-04-21T14:09:52.157Z" title="发表于 2024-04-21 22:09:52">2024-04-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/fdc04dbc.html" title="Java笔记_3">Java笔记_3</a><time datetime="2024-04-21T06:37:35.000Z" title="发表于 2024-04-21 14:37:35">2024-04-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/8ac77d2a.html" title="Java笔记_2">Java笔记_2</a><time datetime="2024-04-20T06:37:35.000Z" title="发表于 2024-04-20 14:37:35">2024-04-20</time></div></div></div></div><div class="card-widget card-categories"><div class="item-headline">
            <i class="fas fa-folder-open"></i>
            <span>分类</span>
            
            </div>
            <ul class="card-category-list" id="aside-cat-list">
            <li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Go/"><span class="card-category-list-name">Go</span><span class="card-category-list-count">2</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Java/"><span class="card-category-list-name">Java</span><span class="card-category-list-count">5</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Kafka/"><span class="card-category-list-name">Kafka</span><span class="card-category-list-count">2</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Kubernetes/"><span class="card-category-list-name">Kubernetes</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/MySQL/"><span class="card-category-list-name">MySQL</span><span class="card-category-list-count">6</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Redis/"><span class="card-category-list-name">Redis</span><span class="card-category-list-count">6</span></a></li>
            </ul></div><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/Go/" style="font-size: 1.23em; color: #999ea6">Go</a> <a href="/tags/Redis/" style="font-size: 1.5em; color: #99a9bf">Redis</a> <a href="/tags/Kafka/" style="font-size: 1.23em; color: #999ea6">Kafka</a> <a href="/tags/Java/" style="font-size: 1.37em; color: #99a4b2">Java</a> <a href="/tags/Kubernetes/" style="font-size: 1.1em; color: #999">Kubernetes</a> <a href="/tags/MySQL/" style="font-size: 1.5em; color: #99a9bf">MySQL</a></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.8/dist/lazyload.iife.min.js"></script><div class="js-pjax"></div><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="Hexo" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/Sangs3112" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="/js/ali_font.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('article-sort-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__slideInRight');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --></body></html>